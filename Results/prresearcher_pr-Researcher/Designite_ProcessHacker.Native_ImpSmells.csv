Implementation smell,Namespace,Class,File,Method,Description
Long Method,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,VerifyFile,The method has 102 lines of code.
Long Method,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetHandleInfo,The method has 234 lines of code.
Long Method,ProcessHacker.Native,NativeTypeFactory,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\NativeTypeFactory.cs,GetAccessEntries,The method has 433 lines of code.
Complex Method,ProcessHacker.Native.Image,ImageImportDll,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Image\ImageImports.cs,ImageImportDll,Cyclomatic complexity of the method is 9
Complex Method,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetVolumeName,Cyclomatic complexity of the method is 11
Complex Method,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,VerifyFile,Cyclomatic complexity of the method is 18
Complex Method,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetObjectNameNt,Cyclomatic complexity of the method is 9
Complex Method,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetHandleInfo,Cyclomatic complexity of the method is 83
Complex Method,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,GetFileName,Cyclomatic complexity of the method is 9
Complex Method,ProcessHacker.Native,NativeTypeFactory,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\NativeTypeFactory.cs,GetAccessEntries,Cyclomatic complexity of the method is 108
Complex Method,ProcessHacker.Native,NativeTypeFactory,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\NativeTypeFactory.cs,GetAccessType,Cyclomatic complexity of the method is 39
Complex Method,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetNetworkConnections,Cyclomatic complexity of the method is 21
Complex Method,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetProcesses,Cyclomatic complexity of the method is 8
Complex Method,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetProcessThreads,Cyclomatic complexity of the method is 9
Complex Method,ProcessHacker.Native,OSVersion,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\OSVersion.cs,OSVersion,Cyclomatic complexity of the method is 11
Complex Method,ProcessHacker.Native.Mfs,MemoryFileSystem,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Mfs\MemoryFileSystem.cs,MemoryFileSystem,Cyclomatic complexity of the method is 24
Complex Method,ProcessHacker.Native.Mfs,MemoryFileSystem,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Mfs\MemoryFileSystem.cs,ValidateFsParameters,Cyclomatic complexity of the method is 9
Complex Method,ProcessHacker.Native.Objects,SamDomainHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\SamDomainHandle.cs,LookupNames,Cyclomatic complexity of the method is 9
Complex Method,ProcessHacker.Native.Objects,DirectoryHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\DirectoryHandle.cs,EnumObjects,Cyclomatic complexity of the method is 11
Complex Method,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,EnumFiles,Cyclomatic complexity of the method is 12
Complex Method,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,SetPosition,Cyclomatic complexity of the method is 9
Complex Method,ProcessHacker.Native.Objects,LsaPolicyHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\LsaPolicyHandle.cs,LookupName,Cyclomatic complexity of the method is 8
Complex Method,ProcessHacker.Native.Objects,LsaPolicyHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\LsaPolicyHandle.cs,LookupSid,Cyclomatic complexity of the method is 8
Complex Method,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,CreateExtended,Cyclomatic complexity of the method is 16
Complex Method,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetPebOffset,Cyclomatic complexity of the method is 10
Complex Method,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,EnumModulesNative,Cyclomatic complexity of the method is 9
Complex Method,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetEnvironmentVariables,Cyclomatic complexity of the method is 10
Complex Method,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetKnownProcessType,Cyclomatic complexity of the method is 8
Complex Method,ProcessHacker.Native.Objects,ThreadHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ThreadHandle.cs,WalkStack,Cyclomatic complexity of the method is 18
Complex Method,ProcessHacker.Native.Security.AccessControl,SecurityDescriptor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\AccessControl\SecurityDescriptor.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,ProcessHacker.Native.Security,Sid,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Sid.cs,GetWellKnownSidIdentifierAuthority,Cyclomatic complexity of the method is 22
Complex Method,ProcessHacker.Native.SsLogging,SsLogger,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\SsLogging\SsLogger.cs,ReadArgumentBlock,Cyclomatic complexity of the method is 27
Complex Method,ProcessHacker.Native.SsLogging,SsLogger,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\SsLogging\SsLogger.cs,BufferWorkerThreadStart,Cyclomatic complexity of the method is 10
Complex Method,ProcessHacker.Native.Symbols,SymbolProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Symbols\SymbolProvider.cs,GetSymbolFromAddress,Cyclomatic complexity of the method is 13
Complex Method,ProcessHacker.Native.Ui,ChooseProcessDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Ui\ChooseProcessDialog.cs,RefreshProcesses,Cyclomatic complexity of the method is 10
Long Parameter List,ProcessHacker.Native.Api,ISecurityInformation,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\ISecurityInformation.cs,GetAccessRights,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Api,ObjectAttributes,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\NativeStructs.cs,ObjectAttributes,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native,NativeUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\NativeUtils.cs,CopyProcessParameters,The method has 13 parameters.
Long Parameter List,ProcessHacker.Native,NProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\NProcessHacker.cs,PhQueryProcessWs,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native,NProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\NProcessHacker.cs,PhQueryProcessWs,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphCaptureStackBackTraceThread,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphDuplicateObject,The method has 7 parameters.
Long Parameter List,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphDuplicateObject,The method has 7 parameters.
Long Parameter List,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphQueryInformationDriver,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphQueryInformationProcess,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphQueryInformationThread,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphReadVirtualMemory,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphReadVirtualMemory,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphReadVirtualMemorySafe,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphReadVirtualMemoryUnsafe,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphReadVirtualMemoryUnsafe,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphWriteVirtualMemory,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphWriteVirtualMemory,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,SsCreateClientEntry,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,ZwQueryObject,The method has 7 parameters.
Long Parameter List,ProcessHacker.Native,NativeTypeFactory,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\NativeTypeFactory.cs,GetAccessString,The method has 7 parameters.
Long Parameter List,ProcessHacker.Native,KernelModule,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,KernelModule,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native,SystemLogonSession,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,SystemLogonSession,The method has 11 parameters.
Long Parameter List,ProcessHacker.Native.Debugging,HeapInformation,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Debugging\HeapInformation.cs,HeapInformation,The method has 6 parameters.
Long Parameter List,ProcessHacker.Native.Objects,LsaAuthHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\LsaAuthHandle.cs,LogonUser,The method has 7 parameters.
Long Parameter List,ProcessHacker.Native.Objects,SamUserInformation,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\SamUserHandle.cs,SamUserInformation,The method has 14 parameters.
Long Parameter List,ProcessHacker.Native.Objects,DomainPasswordPolicy,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\SamDomainHandle.cs,DomainPasswordPolicy,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Objects,KeyHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\KeyHandle.cs,Create,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Objects,KeyHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\KeyHandle.cs,Create,The method has 6 parameters.
Long Parameter List,ProcessHacker.Native.Objects,MailslotHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\MailslotHandle.cs,Create,The method has 8 parameters.
Long Parameter List,ProcessHacker.Native.Objects,MailslotHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\MailslotHandle.cs,MailslotHandle,The method has 6 parameters.
Long Parameter List,ProcessHacker.Native.Objects,EnlistmentHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\EnlistmentHandle.cs,Create,The method has 9 parameters.
Long Parameter List,ProcessHacker.Native.Objects,EnlistmentHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\EnlistmentHandle.cs,EnlistmentHandle,The method has 6 parameters.
Long Parameter List,ProcessHacker.Native.Objects,TransactionHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TransactionHandle.cs,Create,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Objects,TransactionHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TransactionHandle.cs,Create,The method has 9 parameters.
Long Parameter List,ProcessHacker.Native.Objects,TransactionHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TransactionHandle.cs,TransactionHandle,The method has 6 parameters.
Long Parameter List,ProcessHacker.Native.Objects,IoCompletionHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\IoCompletionHandle.cs,Create,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Objects,IoCompletionHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\IoCompletionHandle.cs,Remove,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Objects,ResourceManagerHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ResourceManagerHandle.cs,Create,The method has 8 parameters.
Long Parameter List,ProcessHacker.Native.Objects,ResourceManagerHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ResourceManagerHandle.cs,ResourceManagerHandle,The method has 6 parameters.
Long Parameter List,ProcessHacker.Native.Objects,TerminalServerSession,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TerminalServerHandle.cs,SendMessage,The method has 8 parameters.
Long Parameter List,ProcessHacker.Native.Objects,TmHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TmHandle.cs,Create,The method has 6 parameters.
Long Parameter List,ProcessHacker.Native.Objects,WindowHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\WindowHandle.cs,SendMessageTimeout,The method has 6 parameters.
Long Parameter List,ProcessHacker.Native.Objects,DebugObjectHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\DebugObjectHandle.cs,Create,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Objects,EventHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\EventHandle.cs,Create,The method has 6 parameters.
Long Parameter List,ProcessHacker.Native.Objects,MutantHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\MutantHandle.cs,Create,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Objects,PortHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\PortHandle.cs,Create,The method has 6 parameters.
Long Parameter List,ProcessHacker.Native.Objects,PortHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\PortHandle.cs,CreateWaitable,The method has 6 parameters.
Long Parameter List,ProcessHacker.Native.Objects,ProfileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProfileHandle.cs,Create,The method has 6 parameters.
Long Parameter List,ProcessHacker.Native.Objects,ProfileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProfileHandle.cs,ProfileHandle,The method has 6 parameters.
Long Parameter List,ProcessHacker.Native.Objects,SemaphoreHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\SemaphoreHandle.cs,Create,The method has 6 parameters.
Long Parameter List,ProcessHacker.Native.Objects,SymbolicLinkHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\SymbolicLinkHandle.cs,Create,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Objects,TimerHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TimerHandle.cs,Create,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Objects,TimerHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TimerHandle.cs,Set,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Objects,TimerHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TimerHandle.cs,Set,The method has 6 parameters.
Long Parameter List,ProcessHacker.Native.Objects,SectionHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\SectionHandle.cs,Create,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Objects,SectionHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\SectionHandle.cs,Create,The method has 6 parameters.
Long Parameter List,ProcessHacker.Native.Objects,SectionHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\SectionHandle.cs,Create,The method has 8 parameters.
Long Parameter List,ProcessHacker.Native.Objects,SectionHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\SectionHandle.cs,MapView,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Objects,SectionHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\SectionHandle.cs,MapView,The method has 8 parameters.
Long Parameter List,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,Create,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,Create,The method has 6 parameters.
Long Parameter List,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,Create,The method has 10 parameters.
Long Parameter List,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,FileHandle,The method has 6 parameters.
Long Parameter List,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,BeginFsControl,The method has 8 parameters.
Long Parameter List,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,BeginFsControl,The method has 6 parameters.
Long Parameter List,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,BeginIoControl,The method has 8 parameters.
Long Parameter List,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,BeginIoControl,The method has 6 parameters.
Long Parameter List,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,BeginLock,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,BeginRead,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,BeginWrite,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,FsControl,The method has 7 parameters.
Long Parameter List,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,FsControl,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,FsControl,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,FsControl,The method has 6 parameters.
Long Parameter List,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,IoControl,The method has 7 parameters.
Long Parameter List,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,IoControl,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,IoControl,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,IoControl,The method has 6 parameters.
Long Parameter List,ProcessHacker.Native.Objects,FileEntry,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,FileEntry,The method has 9 parameters.
Long Parameter List,ProcessHacker.Native.Objects,NamedPipeHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\NamedPipeHandle.cs,Create,The method has 8 parameters.
Long Parameter List,ProcessHacker.Native.Objects,NamedPipeHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\NamedPipeHandle.cs,Create,The method has 14 parameters.
Long Parameter List,ProcessHacker.Native.Objects,NamedPipeHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\NamedPipeHandle.cs,NamedPipeHandle,The method has 6 parameters.
Long Parameter List,ProcessHacker.Native.Objects,NamedPipeHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\NamedPipeHandle.cs,BeginTransceive,The method has 7 parameters.
Long Parameter List,ProcessHacker.Native.Objects,NamedPipeHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\NamedPipeHandle.cs,Peek,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,Create,The method has 8 parameters.
Long Parameter List,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,CreateExtended,The method has 8 parameters.
Long Parameter List,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,CreateExtended,The method has 10 parameters.
Long Parameter List,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,CreateWin32,The method has 9 parameters.
Long Parameter List,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,CreateWin32,The method has 10 parameters.
Long Parameter List,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,ProcessHandle,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Objects,ProcessModule,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,ProcessModule,The method has 6 parameters.
Long Parameter List,ProcessHacker.Native.Objects,ServiceManagerHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ServiceManagerHandle.cs,CreateService,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Objects,ServiceManagerHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ServiceManagerHandle.cs,CreateService,The method has 9 parameters.
Long Parameter List,ProcessHacker.Native.Objects,ThreadHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ThreadHandle.cs,Create,The method has 9 parameters.
Long Parameter List,ProcessHacker.Native.Objects,ThreadHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ThreadHandle.cs,CreateUserThread,The method has 7 parameters.
Long Parameter List,ProcessHacker.Native.Objects,ThreadHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ThreadHandle.cs,ThreadHandle,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Objects,ThreadHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ThreadHandle.cs,WalkStack,The method has 8 parameters.
Long Parameter List,ProcessHacker.Native.Objects,TokenHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TokenHandle.cs,Create,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Objects,TokenHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TokenHandle.cs,Create,The method has 9 parameters.
Long Parameter List,ProcessHacker.Native.Objects,TokenHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TokenHandle.cs,Create,The method has 14 parameters.
Long Parameter List,ProcessHacker.Native.Objects,TokenHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TokenHandle.cs,Logon,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Objects,NativeHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\NativeHandle.cs,WaitForMultipleObjects,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Security.AccessControl,Acl,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\AccessControl\Acl.cs,AddAuditAccess,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Security.AccessControl,SecurityEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\AccessControl\SecurityEditor.cs,GetAccessRights,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,PromptForCredentials,The method has 9 parameters.
Long Parameter List,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,PromptForCredentials2,The method has 9 parameters.
Long Parameter List,ProcessHacker.Native.Security,Privilege,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Privilege.cs,Privilege,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Symbols,SymbolProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Symbols\SymbolProvider.cs,EnumSymbols,The method has 6 parameters.
Long Parameter List,ProcessHacker.Native.Symbols,SymbolProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Symbols\SymbolProvider.cs,GetSymbolFromAddress,The method has 7 parameters.
Long Parameter List,ProcessHacker.Native.Symbols,SymbolProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Symbols\SymbolProvider.cs,LoadModule,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Threading,NativeThreadPool,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Threading\NativeThreadPool.cs,RegisterWait,The method has 6 parameters.
Long Parameter List,ProcessHacker.Native.Threading,Timer,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Threading\Timer.cs,Set,The method has 7 parameters.
Long Parameter List,ProcessHacker.Native.Threading,Timer,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Threading\Timer.cs,Set,The method has 7 parameters.
Long Identifier,ProcessHacker.Native,NProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\NProcessHacker.cs,PhQueryNameFileObject,The length of the parameter FileObjectNameInformationLength is 31.
Long Statement,ProcessHacker.Native.Api,UnicodeString,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\NativeStructs.cs,Duplicate,The length of the statement  "	if ((status = Win32.RtlDuplicateUnicodeString (RtlDuplicateUnicodeStringFlags.AllocateNullString | RtlDuplicateUnicodeStringFlags.NullTerminate' ref this' out newString)) >= NtStatus.Error) " is 189.
Long Statement,ProcessHacker.Native.Api,NtStatusExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\NtStatus.cs,GetMessage,The length of the statement  "	message = NativeUtils.GetMessage (Loader.GetDllHandle ("ntdll.dll")' 0xb' System.Threading.Thread.CurrentThread.CurrentUICulture.LCID' (int)status); " is 148.
Long Statement,ProcessHacker.Native.Api,Win32ErrorExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Win32Error.cs,GetMessage,The length of the statement  "		if ((buffer.Length = (byte)Win32.FormatMessage (0x3200' IntPtr.Zero' (int)errorCode' 0' new IntPtr (buffer.Buffer)' String255.MaximumLength' IntPtr.Zero)) == 0) " is 160.
Long Statement,ProcessHacker.Native.Image,MappedImage,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Image\MappedImage.cs,MapAndLoad,The length of the statement  "	using (Section section = new Section (fileHandle' false' readOnly ? MemoryProtection.ExecuteRead : MemoryProtection.ExecuteReadWrite)) { " is 136.
Long Statement,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetDeviceName,The length of the statement  "	using (var fhandle = new FileHandle (fileName' FileShareMode.ReadWrite' FileCreateOptions.SynchronousIoNonAlert' FileAccess.ReadAttributes | (FileAccess)StandardRights.Synchronize)) " is 181.
Long Statement,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetReparsePointTarget,The length of the statement  "		return data.ReadUnicodeString (FileSystem.ReparseDataBuffer.MountPointPathBuffer + buffer.SubstituteNameOffset' buffer.SubstituteNameLength / 2); " is 145.
Long Statement,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetMountPointTarget,The length of the statement  "	if ((fileName.Length == 2 && fileName [1] == ':') || (fileName.Length == 3 && fileName [1] == ':' && fileName [2] == '\\')) { " is 125.
Long Statement,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetMountPointTarget,The length of the statement  "	if ((fileName.Length == 6 || fileName.Length == 7) && fileName [0] == '\\' && fileName [1] == '\\' && (fileName [2] == '.' || fileName [2] == '?') && fileName [3] == '\\' && fileName [5] == ':') { " is 196.
Long Statement,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetMountPointTarget,The length of the statement  "	if (fileName.Length == 6 && fileName [0] == '\\' && fileName [1] == '?' && fileName [2] == '?' && fileName [3] == '\\' && fileName [5] == ':') { " is 144.
Long Statement,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetMountPointTarget,The length of the statement  "	using (var fhandle = new FileHandle (fileName' FileShareMode.ReadWrite' FileCreateOptions.OpenReparsePoint | FileCreateOptions.SynchronousIoNonAlert' FileAccess.GenericRead)) { " is 176.
Long Statement,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetVolumeName,The length of the statement  "					symLinkName = Marshal.PtrToStringUni (outData.Memory.Increment (mp.SymbolicLinkNameOffset)' mp.SymbolicLinkNameLength / 2); " is 123.
Long Statement,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,IsVolumePath,The length of the statement  "	if ((path.Length == 48 || (path.Length == 49 && path [48] == '\\')) && (path.StartsWith (@"\??\Volume") || path.StartsWith (@"\\?\Volume")) && path [10] == '{' && path [19] == '-' && path [24] == '-' && path [29] == '-' && path [34] == '-' && path [47] == '}') " is 260.
Long Statement,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,Notify,The length of the statement  "	using (var data = new MemoryAlloc (MountMgrVolumeMountPoint.Size + sourceVolumeName.Length * 2 + targetVolumeName.Length * 2)) { " is 128.
Long Statement,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,Notify,The length of the statement  "			fhandle.IoControl (created ? IoCtlVolumeMountPointCreated : IoCtlVolumeMountPointDeleted' data.Memory' data.Size' IntPtr.Zero' 0); " is 130.
Long Statement,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,VerifyFile,The length of the statement  "	using (FileHandle sourceFile = FileHandle.CreateWin32 (fileName' FileAccess.GenericRead' FileShareMode.Read' FileCreationDispositionWin32.OpenExisting)) { " is 154.
Long Statement,ProcessHacker.Native,MemoryRegion,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Memory\MemoryRegion.cs,ReadMemory,The length of the statement  "	ProcessHacker.Native.Api.Win32.RtlMoveMemory (buffer.Increment (destOffset)' _memory.Increment (srcOffset)' length.ToIntPtr ()); " is 128.
Long Statement,ProcessHacker.Native,NativeUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\NativeUtils.cs,CopyProcessParameters,The length of the statement  "		status = Win32.RtlCreateProcessParameters (out processParameters' ref imagePathNameStr' ref dllPathStr' ref currentDirectoryStr' ref commandLineStr' environment' ref windowTitleStr' ref desktopInfoStr' ref shellInfoStr' ref runtimeInfoStr); " is 240.
Long Statement,ProcessHacker.Native,NativeUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\NativeUtils.cs,CopyProcessParameters,The length of the statement  "			newProcessParameters = processHandle.AllocateMemory (IntPtr.Zero' ref regionSize' MemoryFlags.Commit' MemoryProtection.ReadWrite); " is 130.
Long Statement,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetBasicInfo,The length of the statement  "		if ((status = Win32.NtDuplicateObject (process' handle' ProcessHandle.Current' out objectHandleI' 0' 0' 0)) >= NtStatus.Error) " is 126.
Long Statement,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetBasicInfo,The length of the statement  "				KProcessHacker.Instance.ZwQueryObject (process' handle' ObjectInformationClass.ObjectBasicInformation' data' data.Size' out retLength' out baseAddress); " is 152.
Long Statement,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetBasicInfo,The length of the statement  "				status = Win32.NtQueryObject (objectHandle' ObjectInformationClass.ObjectBasicInformation' data' data.Size' out retLength); " is 123.
Long Statement,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetObjectNameNt,The length of the statement  "		KProcessHacker.Instance.ZwQueryObject (process' handle' ObjectInformationClass.ObjectNameInformation' IntPtr.Zero' 0' out retLength' out baseAddress); " is 150.
Long Statement,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetObjectNameNt,The length of the statement  "				if (KProcessHacker.Instance.ZwQueryObject (process' handle' ObjectInformationClass.ObjectNameInformation' oniMem' oniMem.Size' out retLength' out baseAddress) >= NtStatus.Error) " is 177.
Long Statement,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetObjectNameNt,The length of the statement  "				if (Win32.NtQueryObject (dupHandle' ObjectInformationClass.ObjectNameInformation' oniMem' oniMem.Size' out retLength) >= NtStatus.Error) " is 136.
Long Statement,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetHandleInfo,The length of the statement  "	using (ProcessHandle process = new ProcessHandle (thisHandle.ProcessId' KProcessHacker.Instance != null ? OSVersion.MinProcessQueryInfoAccess : ProcessAccess.DupHandle)) { " is 171.
Long Statement,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetHandleInfo,The length of the statement  "		if ((status = Win32.NtDuplicateObject (process' handle' ProcessHandle.Current' out objectHandleI' 0' 0' 0)) >= NtStatus.Error) " is 126.
Long Statement,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetHandleInfo,The length of the statement  "			KProcessHacker.Instance.ZwQueryObject (process' handle' ObjectInformationClass.ObjectTypeInformation' IntPtr.Zero' 0' out retLength' out baseAddress); " is 150.
Long Statement,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetHandleInfo,The length of the statement  "					if (KProcessHacker.Instance.ZwQueryObject (process' handle' ObjectInformationClass.ObjectTypeInformation' otiMem' otiMem.Size' out retLength' out baseAddress) >= NtStatus.Error) " is 177.
Long Statement,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetHandleInfo,The length of the statement  "					if (Win32.NtQueryObject (objectHandle' ObjectInformationClass.ObjectTypeInformation' otiMem' otiMem.Size' out retLength) >= NtStatus.Error) " is 139.
Long Statement,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetHandleInfo,The length of the statement  "				using (var rmHandleDup = new NativeHandle<ResourceManagerAccess> (process' handle' ResourceManagerAccess.QueryInformation)) { " is 125.
Long Statement,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetHandleInfo,The length of the statement  "				using (var transactionHandleDup = new NativeHandle<TransactionAccess> (process' handle' TransactionAccess.QueryInformation)) { " is 126.
Long Statement,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,GetFileIcon,The length of the statement  "		if (Win32.SHGetFileInfo (fileName' 0' out shinfo' (uint)Marshal.SizeOf (shinfo)' Win32.ShgFiIcon | (large ? Win32.ShgFiLargeIcon : Win32.ShgFiSmallIcon)) == 0) { " is 161.
Long Statement,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphDuplicateObject,The length of the statement  "	KphDuplicateObject (sourceProcessHandle' sourceHandle' targetProcessHandle' (int)&handle' desiredAccess' handleAttributes' options); " is 132.
Long Statement,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphReadVirtualMemorySafe,The length of the statement  "	status = _fileHandle.IoControl (CtlCode (Control.KphReadVirtualMemory)' (IntPtr)inData' 0x14' IntPtr.Zero' 0' out returnLength); " is 128.
Long Statement,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphReadVirtualMemoryUnsafe,The length of the statement  "	status = _fileHandle.IoControl (CtlCode (Control.KphUnsafeReadVirtualMemory)' (IntPtr)inData' 0x14' IntPtr.Zero' 0' out returnLength); " is 134.
Long Statement,ProcessHacker.Native,NativeTypeFactory,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\NativeTypeFactory.cs,GetAccessEntries,The length of the statement  "			new AccessEntry ("Full control"' OSVersion.HasQueryLimitedInformation ? (ProcessAccess.All | ProcessAccess.QueryLimitedInformation) : ProcessAccess.All' true' true)' " is 165.
Long Statement,ProcessHacker.Native,NativeTypeFactory,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\NativeTypeFactory.cs,GetAccessEntries,The length of the statement  "			OSVersion.HasQueryLimitedInformation ? new AccessEntry ("Query limited information"' ProcessAccess.QueryLimitedInformation' true' true) : new AccessEntry (null' 0' false' false)' " is 178.
Long Statement,ProcessHacker.Native,NativeTypeFactory,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\NativeTypeFactory.cs,GetAccessEntries,The length of the statement  "			new AccessEntry ("Query information"' OSVersion.HasQueryLimitedInformation ? (ProcessAccess.QueryInformation | ProcessAccess.QueryLimitedInformation) : ProcessAccess.QueryInformation' true' true)' " is 196.
Long Statement,ProcessHacker.Native,NativeTypeFactory,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\NativeTypeFactory.cs,GetAccessEntries,The length of the statement  "			new AccessEntry ("Full control"' OSVersion.HasQueryLimitedInformation ? (ThreadAccess.All | ThreadAccess.QueryLimitedInformation | ThreadAccess.SetLimitedInformation) : ThreadAccess.All' true' true)' " is 199.
Long Statement,ProcessHacker.Native,NativeTypeFactory,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\NativeTypeFactory.cs,GetAccessEntries,The length of the statement  "			OSVersion.HasQueryLimitedInformation ? new AccessEntry ("Query limited information"' ThreadAccess.QueryLimitedInformation' true' true) : new AccessEntry (null' 0' false' false)' " is 177.
Long Statement,ProcessHacker.Native,NativeTypeFactory,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\NativeTypeFactory.cs,GetAccessEntries,The length of the statement  "			OSVersion.HasQueryLimitedInformation ? new AccessEntry ("Set limited information"' ThreadAccess.SetLimitedInformation' true' true) : new AccessEntry (null' 0' false' false)' " is 173.
Long Statement,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,EnumKernelModules,The length of the statement  "	status = Win32.NtQuerySystemInformation (SystemInformationClass.SystemModuleInformation' _kernelModulesBuffer' _kernelModulesBuffer.Size' out retLength); " is 153.
Long Statement,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,EnumKernelModules,The length of the statement  "		status = Win32.NtQuerySystemInformation (SystemInformationClass.SystemModuleInformation' _kernelModulesBuffer' _kernelModulesBuffer.Size' out retLength); " is 153.
Long Statement,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,EnumKernelModules,The length of the statement  "		if (!enumCallback (new KernelModule (moduleInfo.BaseAddress' moduleInfo.Size' moduleInfo.Flags' moduleInfo.BaseName' FileUtils.GetFileName (moduleInfo.FileName)))) " is 163.
Long Statement,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetBasicInformation,The length of the statement  "	if ((status = Win32.NtQuerySystemInformation (SystemInformationClass.SystemBasicInformation' out sbi' Marshal.SizeOf (typeof(SystemBasicInformation))' out retLength)) >= NtStatus.Error) " is 185.
Long Statement,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetHandles,The length of the statement  "	while ((status = Win32.NtQuerySystemInformation (SystemInformationClass.SystemHandleInformation' data' data.Size' out retLength)) == NtStatus.InfoLengthMismatch) { " is 163.
Long Statement,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetLogonSession,The length of the statement  "		return new SystemLogonSession (info.AuthenticationPackage.Read ()' info.DnsDomainName.Read ()' info.LogonDomain.Read ()' info.LogonId' info.LogonServer.Read ()' DateTime.FromFileTime (info.LogonTime)' info.LogonType' info.Session' new Sid (info.Sid)' info.Upn.Read ()' info.UserName.Read ()); " is 292.
Long Statement,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetNetworkConnections,The length of the statement  "					Remote = new IPEndPoint (new IPAddress (struc.RemoteAddress' struc.RemoteScopeId)' ((ushort)struc.RemotePort).Reverse ())' " is 122.
Long Statement,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetPagefiles,The length of the statement  "		while ((status = Win32.NtQuerySystemInformation (SystemInformationClass.SystemPageFileInformation' data' data.Size' out retLength)) == NtStatus.InfoLengthMismatch) { " is 165.
Long Statement,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetPagefiles,The length of the statement  "			pagefiles.Add (new SystemPagefile (currentPagefile.TotalSize' currentPagefile.TotalInUse' currentPagefile.PeakUsage' FileUtils.GetFileName (currentPagefile.PageFileName.Read ()))); " is 180.
Long Statement,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetProcesses,The length of the statement  "		if ((status = Win32.NtQuerySystemInformation (SystemInformationClass.SystemProcessInformation' data' data.Size' out retLength)) >= NtStatus.Error) { " is 148.
Long Statement,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetProcessThreads,The length of the statement  "		if ((status = Win32.NtQuerySystemInformation (SystemInformationClass.SystemProcessInformation' data.Memory' data.Size' out retLength)) >= NtStatus.Error) { " is 155.
Long Statement,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetServices,The length of the statement  "		if (!Win32.EnumServicesStatusEx (manager' IntPtr.Zero' ServiceQueryType.Win32 | ServiceQueryType.Driver' ServiceQueryState.All' data' data.Size' out requiredSize' out servicesReturned' ref resume' null)) { " is 205.
Long Statement,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetServices,The length of the statement  "			if (!Win32.EnumServicesStatusEx (manager' IntPtr.Zero' ServiceQueryType.Win32 | ServiceQueryType.Driver' ServiceQueryState.All' data' data.Size' out requiredSize' out servicesReturned' ref resume' null)) " is 203.
Long Statement,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetTickCount,The length of the statement  "	int tickCountMultiplier = Marshal.ReadInt32 (Win32.UserSharedData.Increment (KUserSharedData.TickCountMultiplierOffset)); " is 121.
Long Statement,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetTickCount,The length of the statement  "	return (((long)tickCount.LowPart * tickCountMultiplier) >> (int)24) + (((long)tickCount.HighPart * tickCountMultiplier) << (int)8); " is 131.
Long Statement,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetTimeOfDay,The length of the statement  "	status = Win32.NtQuerySystemInformation (SystemInformationClass.SystemTimeOfDayInformation' out timeOfDay' Marshal.SizeOf (typeof(SystemTimeOfDayInformation))' out retLength); " is 175.
Long Statement,ProcessHacker.Native.Ipc,IpcCircularBuffer,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Ipc\IpcCircularBuffer.cs,Create,The length of the statement  "	return new IpcCircularBuffer (section' name' new Semaphore (name + "_" + readSemaphoreId.ToString ("x")' 0' numberOfBlocks)' new Semaphore (name + "_" + writeSemaphoreId.ToString ("x")' numberOfBlocks' numberOfBlocks)); " is 219.
Long Statement,ProcessHacker.Native.Ipc,IpcCircularBuffer,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Ipc\IpcCircularBuffer.cs,Read,The length of the statement  "		if (System.Threading.Interlocked.CompareExchange (ref _header->ReadPosition' (readPosition + 1) % _header->NumberOfBlocks' readPosition) == readPosition) " is 153.
Long Statement,ProcessHacker.Native.Ipc,IpcCircularBuffer,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Ipc\IpcCircularBuffer.cs,Read,The length of the statement  "	Win32.RtlMoveMemory (new IntPtr (buffer)' (new IntPtr (_data)).Increment (readPosition * _header->BlockSize)' _header->BlockSize.ToIntPtr ()); " is 142.
Long Statement,ProcessHacker.Native.Ipc,IpcCircularBuffer,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Ipc\IpcCircularBuffer.cs,Write,The length of the statement  "		if (System.Threading.Interlocked.CompareExchange (ref _header->WritePosition' (writePosition + 1) % _header->NumberOfBlocks' writePosition) == writePosition) " is 157.
Long Statement,ProcessHacker.Native.Ipc,IpcCircularBuffer,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Ipc\IpcCircularBuffer.cs,Write,The length of the statement  "	Win32.RtlMoveMemory ((new IntPtr (_data)).Increment (writePosition * _header->BlockSize)' new IntPtr (buffer)' _header->BlockSize.ToIntPtr ()); " is 143.
Long Statement,ProcessHacker.Native.Memory,PhysicalPages,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Memory\PhysicalPages.cs,Map,The length of the statement  "	IntPtr allocAddress = ProcessHandle.Current.AllocateMemory (address' _count * Windows.PageSize' MemoryFlags.Reserve | MemoryFlags.Physical' protection); " is 152.
Long Statement,ProcessHacker.Native.Objects,LsaAuthHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\LsaAuthHandle.cs,LogonUser,The length of the statement  "	return this.LogonUser (originName' logonType' package' TokenHandle.PhTokenSource' out profileData' out logonId' out subStatus); " is 127.
Long Statement,ProcessHacker.Native.Objects,LsaAuthHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\LsaAuthHandle.cs,LogonUser,The length of the statement  "			if ((status = Win32.LsaLogonUser (this' ref originNameStr' logonType' this.LookupAuthenticationPackage (package.PackageName)' logonData' logonData.Size' IntPtr.Zero' ref source' out profileBuffer' out profileBufferLength' out logonId' out token' out quotas' out subStatus)) >= NtStatus.Error) " is 292.
Long Statement,ProcessHacker.Native.Objects,LsaAuthHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\LsaAuthHandle.cs,LookupAuthenticationPackage,The length of the statement  "		if ((status = Win32.LsaLookupAuthenticationPackage (this' ref packageNameStr' out authenticationPackage)) >= NtStatus.Error) " is 124.
Long Statement,ProcessHacker.Native.Objects,SamAliasHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\SamAliasHandle.cs,Create,The length of the statement  "		if ((status = Win32.SamCreateAliasInDomain (domainHandle' ref nameStr' access' out handle' out aliasId)) >= NtStatus.Error) " is 123.
Long Statement,ProcessHacker.Native.Objects,SamUserHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\SamUserHandle.cs,Create,The length of the statement  "		if ((status = Win32.SamCreateUserInDomain (domainHandle' ref nameStr' access' out handle' out userId)) >= NtStatus.Error) " is 121.
Long Statement,ProcessHacker.Native.Objects,SamUserHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\SamUserHandle.cs,GetInformation,The length of the statement  "		return new SamUserInformation (SamDomainHandle.ToDateTime (info.LastLogon)' SamDomainHandle.ToDateTime (info.LastLogoff)' SamDomainHandle.ToDateTime (info.PasswordLastSet)' SamDomainHandle.ToDateTime (info.AccountExpires)' SamDomainHandle.ToDateTime (info.PasswordCanChange)' SamDomainHandle.ToDateTime (info.PasswordMustChange)' info.UserName.Read ()' info.FullName.Read ()' info.AdminComment.Read ()' info.UserComment.Read ()' info.UserId' info.PrimaryGroupId' info.UserAccountControl' info.PasswordExpired); " is 510.
Long Statement,ProcessHacker.Native.Objects,SamGroupHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\SamGroupHandle.cs,Create,The length of the statement  "		if ((status = Win32.SamCreateGroupInDomain (domainHandle' ref nameStr' access' out handle' out groupId)) >= NtStatus.Error) " is 123.
Long Statement,ProcessHacker.Native.Objects,SamDomainHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\SamDomainHandle.cs,GetPasswordPolicy,The length of the statement  "		return new DomainPasswordPolicy (info.MinPasswordLength' info.PasswordHistoryLength' info.PasswordProperties' new TimeSpan (-info.MaxPasswordAge)' new TimeSpan (-info.MinPasswordAge)); " is 184.
Long Statement,ProcessHacker.Native.Objects,SamDomainHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\SamDomainHandle.cs,LookupIds,The length of the statement  "	if ((status = Win32.SamLookupIdsInDomain (this' relativeIds.Length' relativeIds' out names' out use)) >= NtStatus.Error) " is 120.
Long Statement,ProcessHacker.Native.Objects,KeyHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\KeyHandle.cs,Create,The length of the statement  "		if ((status = Win32.NtCreateKey (out handle' access' ref oa' 0' IntPtr.Zero' createOptions' out creationDisposition)) >= NtStatus.Error) " is 136.
Long Statement,ProcessHacker.Native.Objects,LsaSecretHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\LsaSecretHandle.cs,Query,The length of the statement  "	if ((status = Win32.LsaQuerySecret (this' out currentValueStr' out currentValueSetTimeLong' out oldValueStr' out oldValueSetTimeLong)) >= NtStatus.Error) " is 153.
Long Statement,ProcessHacker.Native.Objects,MailslotHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\MailslotHandle.cs,Create,The length of the statement  "		if ((status = Win32.NtCreateMailslotFile (out handle' access' ref oa' out isb' createOptions' quota' maxMessageSize' ref readTimeout)) >= NtStatus.Error) " is 153.
Long Statement,ProcessHacker.Native.Objects,EnlistmentHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\EnlistmentHandle.cs,Create,The length of the statement  "		if ((status = Win32.NtCreateEnlistment (out handle' access' resourceManagerHandle' transactionHandle' ref oa' createOptions' notificationMask' enlistmentKey)) >= NtStatus.Error) " is 177.
Long Statement,ProcessHacker.Native.Objects,EnlistmentHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\EnlistmentHandle.cs,GetBasicInformation,The length of the statement  "	if ((status = Win32.NtQueryInformationEnlistment (this' EnlistmentInformationClass.EnlistmentBasicInformation' out basicInfo' Marshal.SizeOf (typeof(EnlistmentBasicInformation))' out retLength)) >= NtStatus.Error) " is 213.
Long Statement,ProcessHacker.Native.Objects,TransactionHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TransactionHandle.cs,Create,The length of the statement  "			if ((status = Win32.NtCreateTransaction (out handle' access' ref oa' ref unitOfWorkGuid' tmHandle ?? IntPtr.Zero' createOptions' 0' 0' ref timeout' ref descriptionStr)) >= NtStatus.Error) " is 187.
Long Statement,ProcessHacker.Native.Objects,TransactionHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TransactionHandle.cs,GetBasicInformation,The length of the statement  "	if ((status = Win32.NtQueryInformationTransaction (this' TransactionInformationClass.TransactionBasicInformation' out basicInfo' Marshal.SizeOf (typeof(TransactionBasicInformation))' out retLength)) >= NtStatus.Error) " is 217.
Long Statement,ProcessHacker.Native.Objects,TransactionHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TransactionHandle.cs,GetDescription,The length of the statement  "		return data.ReadUnicodeString (TransactionPropertiesInformation.DescriptionOffset' propertiesInfo.DescriptionLength / 2); " is 121.
Long Statement,ProcessHacker.Native.Objects,TransactionHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TransactionHandle.cs,GetPropertiesInformation,The length of the statement  "	status = Win32.NtQueryInformationTransaction (this' TransactionInformationClass.TransactionPropertiesInformation' data' data.Size' out retLength); " is 146.
Long Statement,ProcessHacker.Native.Objects,TransactionHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TransactionHandle.cs,GetPropertiesInformation,The length of the statement  "		status = Win32.NtQueryInformationTransaction (this' TransactionInformationClass.TransactionPropertiesInformation' data' data.Size' out retLength); " is 146.
Long Statement,ProcessHacker.Native.Objects,DriverHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\DriverHandle.cs,GetBasicInformation,The length of the statement  "		KProcessHacker.Instance.KphQueryInformationDriver (this' DriverInformationClass.DriverBasicInformation' new IntPtr (&basicInfo)' Marshal.SizeOf (typeof(DriverBasicInformation))' out retLength); " is 193.
Long Statement,ProcessHacker.Native.Objects,PortComHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\PortComHandle.cs,Connect,The length of the statement  "	SecurityQualityOfService securityQos = new SecurityQualityOfService (SecurityImpersonationLevel.SecurityImpersonation' true' false); " is 132.
Long Statement,ProcessHacker.Native.Objects,PortComHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\PortComHandle.cs,Connect,The length of the statement  "		if ((status = Win32.NtConnectPort (out handle' ref portNameStr' ref securityQos' IntPtr.Zero' IntPtr.Zero' IntPtr.Zero' IntPtr.Zero' IntPtr.Zero)) >= NtStatus.Error) " is 165.
Long Statement,ProcessHacker.Native.Objects,PortComHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\PortComHandle.cs,ReplyWaitReceive,The length of the statement  "			if ((status = Win32.NtReplyWaitReceivePort (this' out context' messageMemory ?? IntPtr.Zero' buffer)) >= NtStatus.Error) " is 120.
Long Statement,ProcessHacker.Native.Objects,IoCompletionHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\IoCompletionHandle.cs,Remove,The length of the statement  "	if ((status = Win32.NtRemoveIoCompletion (this' out keyContext' out apcContext' out isb' ref realTimeout)) >= NtStatus.Error) " is 125.
Long Statement,ProcessHacker.Native.Objects,ResourceManagerHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ResourceManagerHandle.cs,Create,The length of the statement  "			if ((status = Win32.NtCreateResourceManager (out handle' access' tmHandle' ref guid' ref oa' createOptions' ref descriptionStr)) >= NtStatus.Error) " is 147.
Long Statement,ProcessHacker.Native.Objects,ResourceManagerHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ResourceManagerHandle.cs,GetBasicInformation,The length of the statement  "	status = Win32.NtQueryInformationResourceManager (this' ResourceManagerInformationClass.ResourceManagerBasicInformation' data' data.Size' out retLength); " is 153.
Long Statement,ProcessHacker.Native.Objects,ResourceManagerHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ResourceManagerHandle.cs,GetBasicInformation,The length of the statement  "		status = Win32.NtQueryInformationResourceManager (this' ResourceManagerInformationClass.ResourceManagerBasicInformation' data' data.Size' out retLength); " is 153.
Long Statement,ProcessHacker.Native.Objects,TerminalServerHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TerminalServerHandle.cs,RegisterNotificationsCurrent,The length of the statement  "	if (!Win32.WTSRegisterSessionNotification (window.Handle' allSessions ? WtsNotificationFlags.AllSessions : WtsNotificationFlags.ThisSession)) " is 141.
Long Statement,ProcessHacker.Native.Objects,TerminalServerHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TerminalServerHandle.cs,GetProcesses,The length of the statement  "			processes [i] = new TerminalServerProcess (process.ProcessId' process.SessionId' Marshal.PtrToStringUni (process.ProcessName)' process.Sid != IntPtr.Zero ? new Sid (process.Sid' _systemName) : null); " is 199.
Long Statement,ProcessHacker.Native.Objects,TerminalServerHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TerminalServerHandle.cs,RegisterNotifications,The length of the statement  "	if (!Win32.WTSRegisterSessionNotificationEx (this' window.Handle' allSessions ? WtsNotificationFlags.AllSessions : WtsNotificationFlags.ThisSession)) " is 149.
Long Statement,ProcessHacker.Native.Objects,TerminalServerSession,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TerminalServerHandle.cs,SendMessage,The length of the statement  "	if (!Win32.WTSSendMessage (_serverHandle' _sessionId' title' title.Length * 2' message' message.Length * 2' (int)buttons | (int)icon | (int)defaultButton | (int)options' secondsTimeout' out response' synchronous)) " is 213.
Long Statement,ProcessHacker.Native.Objects,TmHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TmHandle.cs,Create,The length of the statement  "			if ((status = Win32.NtCreateTransactionManager (out handle' access' ref oa' ref logFileNameStr' createOptions' 0)) >= NtStatus.Error) " is 133.
Long Statement,ProcessHacker.Native.Objects,TmHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TmHandle.cs,GetBasicInformation,The length of the statement  "	if ((status = Win32.NtQueryInformationTransactionManager (this' TmInformationClass.TransactionManagerBasicInformation' out basicInfo' Marshal.SizeOf (typeof(TmBasicInformation))' out retLength)) >= NtStatus.Error) " is 213.
Long Statement,ProcessHacker.Native.Objects,TmHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TmHandle.cs,GetLastRecoveredLsn,The length of the statement  "	if ((status = Win32.NtQueryInformationTransactionManager (this' TmInformationClass.TransactionManagerRecoveryInformation' out recoveryInfo' Marshal.SizeOf (typeof(TmRecoveryInformation))' out retLength)) >= NtStatus.Error) " is 222.
Long Statement,ProcessHacker.Native.Objects,TmHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TmHandle.cs,GetLogFileName,The length of the statement  "		status = Win32.NtQueryInformationTransactionManager (this' TmInformationClass.TransactionManagerLogPathInformation' data' data.Size' out retLength); " is 148.
Long Statement,ProcessHacker.Native.Objects,TmHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TmHandle.cs,GetLogFileName,The length of the statement  "			status = Win32.NtQueryInformationTransactionManager (this' TmInformationClass.TransactionManagerLogPathInformation' data' data.Size' out retLength); " is 148.
Long Statement,ProcessHacker.Native.Objects,TmHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TmHandle.cs,GetLogIdentity,The length of the statement  "	if ((status = Win32.NtQueryInformationTransactionManager (this' TmInformationClass.TransactionManagerLogInformation' out logInfo' Marshal.SizeOf (typeof(TmLogInformation))' out retLength)) >= NtStatus.Error) " is 207.
Long Statement,ProcessHacker.Native.Objects,DebugObjectHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\DebugObjectHandle.cs,SetFlags,The length of the statement  "		if ((status = Win32.NtSetInformationDebugObject (this' DebugObjectInformationClass.DebugObjectFlags' new IntPtr (&flags)' sizeof(DebugObjectFlags)' out retLength)) >= NtStatus.Error) " is 182.
Long Statement,ProcessHacker.Native.Objects,DirectoryHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\DirectoryHandle.cs,EnumObjects,The length of the statement  "			while ((status = Win32.NtQueryDirectoryObject (this' data' data.Size' false' firstTime' ref context' out retLength)) == NtStatus.MoreEntries) { " is 143.
Long Statement,ProcessHacker.Native.Objects,EventHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\EventHandle.cs,GetBasicInformation,The length of the statement  "	if ((status = Win32.NtQueryEvent (this' EventInformationClass.EventBasicInformation' out ebi' Marshal.SizeOf (typeof(EventBasicInformation))' out retLength)) >= NtStatus.Error) " is 176.
Long Statement,ProcessHacker.Native.Objects,MutantHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\MutantHandle.cs,GetBasicInformation,The length of the statement  "	if ((status = Win32.NtQueryMutant (this' MutantInformationClass.MutantBasicInformation' out mbi' Marshal.SizeOf (typeof(MutantBasicInformation))' out retLength)) >= NtStatus.Error) " is 180.
Long Statement,ProcessHacker.Native.Objects,MutantHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\MutantHandle.cs,GetOwnerInformation,The length of the statement  "	if ((status = Win32.NtQueryMutant (this' MutantInformationClass.MutantOwnerInformation' out moi' Marshal.SizeOf (typeof(MutantOwnerInformation))' out retLength)) >= NtStatus.Error) " is 180.
Long Statement,ProcessHacker.Native.Objects,PortHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\PortHandle.cs,Create,The length of the statement  "		if ((status = Win32.NtCreatePort (out handle' ref oa' maxConnectionInfoLength' maxMessageLength' maxPoolUsage)) >= NtStatus.Error) " is 130.
Long Statement,ProcessHacker.Native.Objects,PortHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\PortHandle.cs,CreateWaitable,The length of the statement  "	return CreateWaitable (name' objectFlags' rootDirectory' Win32.PortMessageMaxDataLength' Win32.PortMessageMaxLength' 0); " is 120.
Long Statement,ProcessHacker.Native.Objects,PortHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\PortHandle.cs,CreateWaitable,The length of the statement  "		if ((status = Win32.NtCreateWaitablePort (out handle' ref oa' maxConnectionInfoLength' maxMessageLength' maxPoolUsage)) >= NtStatus.Error) " is 138.
Long Statement,ProcessHacker.Native.Objects,PortHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\PortHandle.cs,AcceptConnect,The length of the statement  "		if ((status = Win32.NtAcceptConnectPort (out portHandle' IntPtr.Zero' messageMemory' accept' IntPtr.Zero' IntPtr.Zero)) >= NtStatus.Error) " is 138.
Long Statement,ProcessHacker.Native.Objects,ProfileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProfileHandle.cs,Create,The length of the statement  "		if ((status = Win32.NtCreateProfile (out handle' processHandle ?? IntPtr.Zero' rangeBase' new IntPtr (rangeSize)' bucketSize' buffer' buffer.Size' profileSource' affinity)) >= NtStatus.Error) " is 191.
Long Statement,ProcessHacker.Native.Objects,SemaphoreHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\SemaphoreHandle.cs,GetBasicInformation,The length of the statement  "	if ((status = Win32.NtQuerySemaphore (this' SemaphoreInformationClass.SemaphoreBasicInformation' out sbi' Marshal.SizeOf (typeof(SemaphoreBasicInformation))' out retLength)) >= NtStatus.Error) " is 192.
Long Statement,ProcessHacker.Native.Objects,TimerHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TimerHandle.cs,GetBasicInformation,The length of the statement  "	if ((status = Win32.NtQueryTimer (this' TimerInformationClass.TimerBasicInformation' out tbi' Marshal.SizeOf (typeof(TimerBasicInformation))' out retLength)) >= NtStatus.Error) " is 176.
Long Statement,ProcessHacker.Native.Objects,TimerHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TimerHandle.cs,Set,The length of the statement  "	if ((status = Win32.NtSetTimer (this' ref realDueTime' routine' context' resume' period' out previousState)) >= NtStatus.Error) " is 127.
Long Statement,ProcessHacker.Native.Objects,SectionHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\SectionHandle.cs,Create,The length of the statement  "			if ((status = Win32.NtCreateSection (out handle' access' ref oa' ref maximumSize' pageAttributes' sectionAttributes' fileHandle ?? IntPtr.Zero)) >= NtStatus.Error) " is 163.
Long Statement,ProcessHacker.Native.Objects,SectionHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\SectionHandle.cs,Create,The length of the statement  "			if ((status = Win32.NtCreateSection (out handle' access' ref oa' IntPtr.Zero' pageAttributes' sectionAttributes' fileHandle ?? IntPtr.Zero)) >= NtStatus.Error) " is 159.
Long Statement,ProcessHacker.Native.Objects,SectionHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\SectionHandle.cs,GetBasicInformation,The length of the statement  "	if ((status = Win32.NtQuerySection (this' SectionInformationClass.SectionBasicInformation' out sbi' new IntPtr (Marshal.SizeOf (typeof(SectionBasicInformation)))' out retLength)) >= NtStatus.Error) " is 197.
Long Statement,ProcessHacker.Native.Objects,SectionHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\SectionHandle.cs,GetImageInformation,The length of the statement  "	if ((status = Win32.NtQuerySection (this' SectionInformationClass.SectionImageInformation' out sii' new IntPtr (Marshal.SizeOf (typeof(SectionImageInformation)))' out retLength)) >= NtStatus.Error) " is 197.
Long Statement,ProcessHacker.Native.Objects,SectionHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\SectionHandle.cs,MapView,The length of the statement  "	if ((status = Win32.NtMapViewOfSection (this' processHandle' ref baseAddress' IntPtr.Zero' commitSize' ref sectionOffset' ref viewSize' inheritDisposition' allocationType' protection)) >= NtStatus.Error) " is 203.
Long Statement,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,Create,The length of the statement  "	return Create (access' fileName' ObjectFlags.CaseInsensitive' rootDirectory' shareMode' creationDisposition' 0' FileAttributes.Normal' createOptions' out status); " is 162.
Long Statement,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,Create,The length of the statement  "		if ((status = Win32.NtCreateFile (out handle' access' ref oa' out isb' ref allocationSize' attributes' shareMode' creationDisposition' createOptions' IntPtr.Zero' 0)) >= NtStatus.Error) " is 185.
Long Statement,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,BeginFsControl,The length of the statement  "	this.BeginFsControl (asyncContext' controlCode' pinnedInBuffer != null ? pinnedInBuffer.Address.Increment (inBufferOffset) : IntPtr.Zero' inBufferLength' pinnedOutBuffer != null ? pinnedOutBuffer.Address.Increment (outBufferOffset) : IntPtr.Zero' outBufferLength); " is 264.
Long Statement,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,BeginFsControl,The length of the statement  "	this.BeginFsControl (asyncContext' controlCode' inBuffer ?? IntPtr.Zero' inBuffer != null ? inBuffer.Size : 0' outBuffer ?? IntPtr.Zero' outBuffer != null ? outBuffer.Size : 0); " is 177.
Long Statement,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,BeginFsControl,The length of the statement  "	status = Win32.NtFsControlFile (this' asyncContext.EventHandle ?? IntPtr.Zero' null' asyncContext.Context' asyncContext.StatusMemory' controlCode' inBuffer' inBufferLength' outBuffer' outBufferLength); " is 201.
Long Statement,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,BeginIoControl,The length of the statement  "	this.BeginIoControl (asyncContext' controlCode' pinnedInBuffer != null ? pinnedInBuffer.Address.Increment (inBufferOffset) : IntPtr.Zero' inBufferLength' pinnedOutBuffer != null ? pinnedOutBuffer.Address.Increment (outBufferOffset) : IntPtr.Zero' outBufferLength); " is 264.
Long Statement,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,BeginIoControl,The length of the statement  "	this.BeginIoControl (asyncContext' controlCode' inBuffer ?? IntPtr.Zero' inBuffer != null ? inBuffer.Size : 0' outBuffer ?? IntPtr.Zero' outBuffer != null ? outBuffer.Size : 0); " is 177.
Long Statement,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,BeginIoControl,The length of the statement  "	status = Win32.NtDeviceIoControlFile (this' asyncContext.EventHandle ?? IntPtr.Zero' null' asyncContext.Context' asyncContext.StatusMemory' controlCode' inBuffer' inBufferLength' outBuffer' outBufferLength); " is 207.
Long Statement,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,BeginLock,The length of the statement  "	status = Win32.NtLockFile (this' asyncContext.EventHandle ?? IntPtr.Zero' null' asyncContext.Context' asyncContext.StatusMemory' ref offset' ref length' 0' !wait' exclusive); " is 174.
Long Statement,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,BeginRead,The length of the statement  "		status = Win32.NtReadFile (this' asyncContext.EventHandle ?? IntPtr.Zero' null' asyncContext.Context' asyncContext.StatusMemory' buffer' length' fileOffset != -1 ? new IntPtr (&fileOffset) : IntPtr.Zero' IntPtr.Zero); " is 217.
Long Statement,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,BeginWrite,The length of the statement  "		status = Win32.NtWriteFile (this' asyncContext.EventHandle ?? IntPtr.Zero' null' asyncContext.Context' asyncContext.StatusMemory' buffer' length' fileOffset != -1 ? new IntPtr (&fileOffset) : IntPtr.Zero' IntPtr.Zero); " is 218.
Long Statement,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,Delete,The length of the statement  "	this.SetStruct<FileDispositionInformation> (FileInformationClass.FileDispositionInformation' new FileDispositionInformation () { " is 128.
Long Statement,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,EnumFiles,The length of the statement  "						status = Win32.NtQueryDirectoryFile (this' IntPtr.Zero' null' IntPtr.Zero' out isb' data' data.Size' FileInformationClass.FileDirectoryInformation' false' searchPattern == null ? IntPtr.Zero : new IntPtr (&searchPatternStr)' firstTime); " is 236.
Long Statement,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,EnumFiles,The length of the statement  "					if (!callback (new FileEntry (name' info.FileIndex' DateTime.FromFileTime (info.CreationTime)' DateTime.FromFileTime (info.LastAccessTime)' DateTime.FromFileTime (info.LastWriteTime)' DateTime.FromFileTime (info.ChangeTime)' info.EndOfFile' info.AllocationSize' info.FileAttributes))) " is 284.
Long Statement,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,FsControl,The length of the statement  "	return this.FsControl (controlCode' inBuffer' 0' inBuffer != null ? inBuffer.Length : 0' outBuffer' 0' outBuffer != null ? outBuffer.Length : 0); " is 145.
Long Statement,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,FsControl,The length of the statement  "				return this.FsControl (controlCode' &inBufferPtr [inBufferOffset]' inBuffer != null ? inBuffer.Length : 0' &outBufferPtr [outBufferOffset]' outBuffer != null ? outBuffer.Length : 0); " is 182.
Long Statement,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,FsControl,The length of the statement  "	status = Win32.NtFsControlFile (this' IntPtr.Zero' null' IntPtr.Zero' out isb' controlCode' inBuffer' inBufferLength' outBuffer' outBufferLength); " is 146.
Long Statement,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,GetVolumeFsName,The length of the statement  "		if ((status = Win32.NtQueryVolumeInformationFile (this' out isb' data' data.Size' FsInformationClass.FileFsAttributeInformation)) >= NtStatus.Error) " is 148.
Long Statement,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,GetVolumeFsName,The length of the statement  "		return Marshal.PtrToStringUni (data.Memory.Increment (Marshal.OffsetOf (typeof(FileFsAttributeInformation)' "FileSystemName"))' info.FileSystemNameLength / 2); " is 159.
Long Statement,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,GetVolumeLabel,The length of the statement  "		if ((status = Win32.NtQueryVolumeInformationFile (this' out isb' data' data.Size' FsInformationClass.FileFsVolumeInformation)) >= NtStatus.Error) " is 145.
Long Statement,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,GetVolumeLabel,The length of the statement  "		return Marshal.PtrToStringUni (data.Memory.Increment (Marshal.OffsetOf (typeof(FileFsVolumeInformation)' "VolumeLabel"))' info.VolumeLabelLength / 2); " is 150.
Long Statement,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,IoControl,The length of the statement  "	return this.IoControl (controlCode' inBuffer' 0' inBuffer != null ? inBuffer.Length : 0' outBuffer' 0' outBuffer != null ? outBuffer.Length : 0); " is 145.
Long Statement,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,IoControl,The length of the statement  "				return this.IoControl (controlCode' &inBufferPtr [inBufferOffset]' inBuffer != null ? inBuffer.Length : 0' &outBufferPtr [outBufferOffset]' outBuffer != null ? outBuffer.Length : 0); " is 182.
Long Statement,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,IoControl,The length of the statement  "	status = Win32.NtDeviceIoControlFile (this' IntPtr.Zero' null' IntPtr.Zero' out isb' controlCode' inBuffer' inBufferLength' outBuffer' outBufferLength); " is 152.
Long Statement,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,Read,The length of the statement  "		status = Win32.NtReadFile (this' IntPtr.Zero' null' IntPtr.Zero' out isb' buffer' length' fileOffset != -1 ? new IntPtr (&fileOffset) : IntPtr.Zero' IntPtr.Zero); " is 162.
Long Statement,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,SetEnd,The length of the statement  "	this.SetStruct<FileEndOfFileInformation> (FileInformationClass.FileEndOfFileInformation' new FileEndOfFileInformation () { " is 122.
Long Statement,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,Write,The length of the statement  "		status = Win32.NtWriteFile (this' IntPtr.Zero' null' IntPtr.Zero' out isb' buffer' length' fileOffset != -1 ? new IntPtr (&fileOffset) : IntPtr.Zero' IntPtr.Zero); " is 163.
Long Statement,ProcessHacker.Native.Objects,AsyncIoContext,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,DisposeObject,The length of the statement  "		throw new InvalidOperationException ("An attempt was made to dispose an asynchronous I/O context object " + "before the I/O operation has finished."); " is 150.
Long Statement,ProcessHacker.Native.Objects,JobObjectHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\JobObjectHandle.cs,Open,The length of the statement  "		handle = new IntPtr (KProcessHacker.Instance.KphOpenProcessJob (processHandle' (JobObjectAccess)StandardRights.Synchronize)); " is 125.
Long Statement,ProcessHacker.Native.Objects,JobObjectHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\JobObjectHandle.cs,GetBasicAccountingInformation,The length of the statement  "	return this.QueryStruct<JobObjectBasicAccountingInformation> (JobObjectInformationClass.JobObjectBasicAccountingInformation); " is 125.
Long Statement,ProcessHacker.Native.Objects,JobObjectHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\JobObjectHandle.cs,GetBasicAndIoAccountingInformation,The length of the statement  "	return this.QueryStruct<JobObjectBasicAndIoAccountingInformation> (JobObjectInformationClass.JobObjectBasicAndIoAccountingInformation); " is 135.
Long Statement,ProcessHacker.Native.Objects,JobObjectHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\JobObjectHandle.cs,GetProcessIdList,The length of the statement  "		if (!Win32.QueryInformationJobObject (this' JobObjectInformationClass.JobObjectBasicProcessIdList' data' data.Size' out retLength)) " is 131.
Long Statement,ProcessHacker.Native.Objects,JobObjectHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\JobObjectHandle.cs,GetBasicUiRestrictions,The length of the statement  "	if (!Win32.QueryInformationJobObject (this' JobObjectInformationClass.JobObjectBasicUIRestrictions' out uiRestrictions' 4' out retLength)) " is 138.
Long Statement,ProcessHacker.Native.Objects,JobObjectHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\JobObjectHandle.cs,GetExtendedLimitInformation,The length of the statement  "	return this.QueryStruct<JobObjectExtendedLimitInformation> (JobObjectInformationClass.JobObjectExtendedLimitInformation); " is 121.
Long Statement,ProcessHacker.Native.Objects,LsaPolicyHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\LsaPolicyHandle.cs,AddPrivileges,The length of the statement  "		if ((status = Win32.LsaAddAccountRights (this' accountSid' privilegeStrArray' privilegeStrArray.Length)) >= NtStatus.Error) " is 123.
Long Statement,ProcessHacker.Native.Objects,LsaPolicyHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\LsaPolicyHandle.cs,EnumAccountsWithPrivilege,The length of the statement  "		if ((status = Win32.LsaEnumerateAccountsWithUserRight (this' ref privilegeNameStr' out buffer' out count)) >= NtStatus.Error) " is 125.
Long Statement,ProcessHacker.Native.Objects,LsaPolicyHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\LsaPolicyHandle.cs,LookupPrivilegeDisplayName,The length of the statement  "		if ((status = Win32.LsaLookupPrivilegeDisplayName (this' ref nameStr' out displayName' out language)) >= NtStatus.Error) " is 120.
Long Statement,ProcessHacker.Native.Objects,LsaPolicyHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\LsaPolicyHandle.cs,RemovePrivileges,The length of the statement  "		if ((status = Win32.LsaRemoveAccountRights (this' accountSid' false' privilegeStrArray' privilegeStrArray.Length)) >= NtStatus.Error) " is 133.
Long Statement,ProcessHacker.Native.Objects,NamedPipeHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\NamedPipeHandle.cs,Create,The length of the statement  "	return Create (access' fileName' ObjectFlags.CaseInsensitive' null' FileShareMode.ReadWrite' FileCreationDisposition.OpenIf' createOptions' type' type' PipeCompletionMode.Queue' maximumInstances' inboundQuota' outboundQuota' defaultTimeout); " is 241.
Long Statement,ProcessHacker.Native.Objects,NamedPipeHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\NamedPipeHandle.cs,Create,The length of the statement  "		if ((status = Win32.NtCreateNamedPipeFile (out handle' access' ref oa' out isb' shareMode' creationDisposition' createOptions' type' readMode' completionMode' maximumInstances' inboundQuota' outboundQuota' ref defaultTimeout)) >= NtStatus.Error) " is 245.
Long Statement,ProcessHacker.Native.Objects,NamedPipeHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\NamedPipeHandle.cs,Wait,The length of the statement  "	using (var npfsHandle = new FileHandle (Win32.NamedPipePath + "\\"' FileShareMode.ReadWrite' FileCreateOptions.SynchronousIoNonAlert' FileAccess.ReadAttributes | (FileAccess)StandardRights.Synchronize)) { " is 204.
Long Statement,ProcessHacker.Native.Objects,NamedPipeHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\NamedPipeHandle.cs,BeginTransceive,The length of the statement  "	this.BeginFsControl (asyncContext' FsCtlTransceive' inBuffer' inBufferOffset' inBufferLength' outBuffer' outBufferOffset' outBufferLength); " is 139.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,Create,The length of the statement  "		if ((status = Win32.NtCreateProcess (out handle' access' ref oa' parentProcess ?? IntPtr.Zero' inheritHandles' sectionHandle ?? IntPtr.Zero' debugPort ?? IntPtr.Zero' IntPtr.Zero)) >= NtStatus.Error) " is 199.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,CreateExtended,The length of the statement  "	return CreateExtended (fileName' parentProcess' creationFlags' true' inheritHandles' EnvironmentBlock.GetCurrent ()' currentDirectory' startupInfo' out clientId' out threadHandle); " is 180.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,CreateExtended,The length of the statement  "	using (var fhandle = new FileHandle (fileName' FileShareMode.Read | FileShareMode.Delete' FileAccess.Execute | (FileAccess)StandardRights.Synchronize)) { " is 153.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,CreateExtended,The length of the statement  "		using (var shandle = SectionHandle.Create (SectionAccess.All' SectionAttributes.Image' MemoryProtection.Execute' fhandle)) { " is 124.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,CreateExtended,The length of the statement  "	NativeUtils.CopyProcessParameters (phandle' peb' creationFlags' FileUtils.GetFileName (fileName)' ProcessHandle.Current.GetPebString (PebOffset.DllPath)' currentDirectory' fileName' environment' startupInfo.Title != null ? startupInfo.Title : fileName' startupInfo.Desktop != null ? startupInfo.Desktop : ""' startupInfo.Reserved != null ? startupInfo.Reserved : ""' ""' ref startupInfo); " is 388.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,CreateExtended,The length of the statement  "	thandle = ThreadHandle.CreateUserThread (phandle' true' imageInfo.StackCommit.Increment (imageInfo.StackReserved).ToInt32 ()' imageInfo.StackCommit.ToInt32 ()' imageInfo.TransferAddress' IntPtr.Zero' out clientId); " is 214.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,CreateExtended,The length of the statement  "			Win32.CsrClientCallServer (data' IntPtr.Zero' Win32.CsrMakeApiNumber (Win32.BaseSrvServerDllIndex' (int)BaseSrvApiNumber.BasepCreateProcess)' Marshal.SizeOf (typeof(BaseCreateProcessMsg))); " is 189.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,CreateUserProcess,The length of the statement  "		if ((status = Win32.RtlCreateUserProcess (ref fileNameStr' 0' ref processParams' IntPtr.Zero' IntPtr.Zero' IntPtr.Zero' false' IntPtr.Zero' IntPtr.Zero' out processInfo)) >= NtStatus.Error) " is 189.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,CreateWin32,The length of the statement  "	if (!Win32.CreateProcess (applicationName' commandLine' IntPtr.Zero' IntPtr.Zero' inheritHandles' creationFlags' environment' currentDirectory' ref startupInfo' out processInformation)) " is 185.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,CreateWin32,The length of the statement  "	if (!Win32.CreateProcessAsUser (tokenHandle' applicationName' commandLine' IntPtr.Zero' IntPtr.Zero' inheritHandles' creationFlags' environment' currentDirectory' ref startupInfo' out processInformation)) " is 204.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,AllocateMemory,The length of the statement  "	if ((status = Win32.NtAllocateVirtualMemory (this' ref baseAddress' IntPtr.Zero' ref size' type' protection)) >= NtStatus.Error) " is 128.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,CreateThreadWin32,The length of the statement  "	if ((threadHandle = Win32.CreateRemoteThread (this' IntPtr.Zero' IntPtr.Zero' startAddress' parameter' createSuspended ? ProcessCreationFlags.CreateSuspended : 0' out threadId)) == IntPtr.Zero) " is 193.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,DisableHandleTracing,The length of the statement  "	if ((status = Win32.NtSetInformationProcess (this' ProcessInformationClass.ProcessHandleTracing' IntPtr.Zero' 0)) >= NtStatus.Error) " is 132.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,EnableHandleTracing,The length of the statement  "	if ((status = Win32.NtSetInformationProcess (this' ProcessInformationClass.ProcessHandleTracing' ref phte' Marshal.SizeOf (phte))) >= NtStatus.Error) " is 149.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,EnumModulesApi,The length of the statement  "		if (!enumModulesCallback (new ProcessModule (moduleInfo.BaseOfDll' moduleInfo.SizeOfImage' moduleInfo.EntryPoint' 0' baseName.ToString ()' FileUtils.GetFileName (fileName.ToString ())))) " is 186.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,EnumModulesNative,The length of the statement  "			if (!enumModulesCallback (new ProcessModule (currentEntry.DllBase' currentEntry.SizeOfImage' currentEntry.EntryPoint' currentEntry.Flags' baseDllName' fullDllName))) " is 165.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,FreeMemory,The length of the statement  "	if ((status = Win32.NtFreeVirtualMemory (this' ref baseAddress' ref sizeIntPtr' reserveOnly ? MemoryFlags.Decommit : MemoryFlags.Release)) >= NtStatus.Error) " is 157.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetBasicInformation,The length of the statement  "	if ((status = Win32.NtQueryInformationProcess (this' ProcessInformationClass.ProcessBasicInformation' out pbi' Marshal.SizeOf (typeof(ProcessBasicInformation))' out retLen)) >= NtStatus.Error) " is 192.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetHandleTraces,The length of the statement  "			status = Win32.NtQueryInformationProcess (this' ProcessInformationClass.ProcessHandleTracing' data' data.Size' out retLength); " is 126.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetInformationInt32,The length of the statement  "		if ((status = Win32.NtQueryInformationProcess (this' infoClass' out value' sizeof(int)' out retLength)) >= NtStatus.Error) " is 122.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetInformationIntPtr,The length of the statement  "	if ((status = Win32.NtQueryInformationProcess (this' infoClass' out value' IntPtr.Size' out retLength)) >= NtStatus.Error) " is 122.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetIoStatistics,The length of the statement  "	if ((status = Win32.NtQueryInformationProcess (this' ProcessInformationClass.ProcessIoCounters' out counters' Marshal.SizeOf (typeof(IoCounters))' out retLength)) >= NtStatus.Error) " is 181.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetMappedFileName,The length of the statement  "		if ((status = Win32.NtQueryVirtualMemory (this' address' MemoryInformationClass.MemoryMappedFilenameInformation' data' data.Size.ToIntPtr ()' out retLength)) == NtStatus.BufferOverflow) { " is 187.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetMappedFileName,The length of the statement  "			status = Win32.NtQueryVirtualMemory (this' address' MemoryInformationClass.MemoryMappedFilenameInformation' data' data.Size.ToIntPtr ()' out retLength); " is 152.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetMemoryStatistics,The length of the statement  "	if ((status = Win32.NtQueryInformationProcess (this' ProcessInformationClass.ProcessVmCounters' out counters' Marshal.SizeOf (typeof(VmCounters))' out retLength)) >= NtStatus.Error) " is 181.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetNextThread,The length of the statement  "	if ((status = Win32.NtGetNextThread (this' threadHandle != null ? threadHandle : IntPtr.Zero' access' 0' 0' out handle)) >= NtStatus.Error) " is 139.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetPosixCommandLine,The length of the statement  "	this.ReadMemory (processParameters.Increment (GetPebOffset (PebOffset.CommandLine))' &commandLineUs' Marshal.SizeOf (typeof(UnicodeString))); " is 141.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetPriorityClass,The length of the statement  "	if ((status = Win32.NtQueryInformationProcess (this' ProcessInformationClass.ProcessPriorityClass' out priorityClass' Marshal.SizeOf (typeof(ProcessPriorityClassStruct))' out retLength)) != NtStatus.Success) " is 207.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,ProtectMemory,The length of the statement  "	if ((status = Win32.NtProtectVirtualMemory (this' ref baseAddress' ref sizeIntPtr' protection' out oldProtection)) >= NtStatus.Error) " is 133.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,QueryMemory,The length of the statement  "	if ((status = Win32.NtQueryVirtualMemory (this' baseAddress' MemoryInformationClass.MemoryBasicInformation' out mbi' Marshal.SizeOf (typeof(MemoryBasicInformation)).ToIntPtr ()' out retLength)) >= NtStatus.Error) " is 212.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,ReadMemory,The length of the statement  "		if ((status = Win32.NtReadVirtualMemory (this' baseAddress' buffer' length.ToIntPtr ()' out retLengthIntPtr)) >= NtStatus.Error) " is 128.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,SetPriorityClass,The length of the statement  "	if ((status = Win32.NtSetInformationProcess (this' ProcessInformationClass.ProcessPriorityClass' ref processPriority' Marshal.SizeOf (typeof(ProcessPriorityClassStruct)))) != NtStatus.Success) " is 192.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,WriteDump,The length of the statement  "	this.WriteDump (fileName' MinidumpType.WithFullMemory | MinidumpType.WithHandleData | MinidumpType.WithUnloadedModules | MinidumpType.WithFullMemoryInfo | MinidumpType.WithThreadInfo); " is 184.
Long Statement,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,WriteMemory,The length of the statement  "		if ((status = Win32.NtWriteVirtualMemory (this' baseAddress' buffer' length.ToIntPtr ()' out retLengthIntPtr)) >= NtStatus.Error) " is 129.
Long Statement,ProcessHacker.Native.Objects,ServiceManagerHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ServiceManagerHandle.cs,CreateService,The length of the statement  "	return this.CreateService (name' displayName' type' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' binaryPath' null' null' null); " is 140.
Long Statement,ProcessHacker.Native.Objects,ServiceManagerHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ServiceManagerHandle.cs,CreateService,The length of the statement  "	return this.CreateService (name' displayName' type' startType' ServiceErrorControl.Ignore' binaryPath' null' null' null); " is 121.
Long Statement,ProcessHacker.Native.Objects,ServiceManagerHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ServiceManagerHandle.cs,CreateService,The length of the statement  "	if ((service = Win32.CreateService (this' name' displayName' ServiceAccess.All' type' startType' errorControl' binaryPath' group' IntPtr.Zero' IntPtr.Zero' accountName' password)) == IntPtr.Zero) " is 195.
Long Statement,ProcessHacker.Native.Objects,ThreadHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ThreadHandle.cs,Create,The length of the statement  "		if ((status = Win32.NtCreateThread (out handle' access' ref oa' processHandle' out clientId' ref threadContext' ref initialTeb' createSuspended)) >= NtStatus.Error) " is 164.
Long Statement,ProcessHacker.Native.Objects,ThreadHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ThreadHandle.cs,CreateUserThread,The length of the statement  "	if ((status = Win32.RtlCreateUserThread (processHandle' IntPtr.Zero' createSuspended' 0' maximumStackSize.ToIntPtr ()' initialStackSize.ToIntPtr ()' startAddress' parameter' out threadHandle' out clientId)) >= NtStatus.Error) " is 225.
Long Statement,ProcessHacker.Native.Objects,ThreadHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ThreadHandle.cs,GetBasicInformation,The length of the statement  "	if ((status = Win32.NtQueryInformationThread (this' ThreadInformationClass.ThreadBasicInformation' ref basicInfo' Marshal.SizeOf (basicInfo)' out retLen)) >= NtStatus.Error) " is 173.
Long Statement,ProcessHacker.Native.Objects,ThreadHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ThreadHandle.cs,GetInformationInt32,The length of the statement  "		if ((status = Win32.NtQueryInformationThread (this' infoClass' out value' sizeof(int)' out retLength)) >= NtStatus.Error) " is 121.
Long Statement,ProcessHacker.Native.Objects,ThreadHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ThreadHandle.cs,GetInformationIntPtr,The length of the statement  "	if ((status = Win32.NtQueryInformationThread (this' infoClass' out value' IntPtr.Size' out retLength)) >= NtStatus.Error) " is 121.
Long Statement,ProcessHacker.Native.Objects,ThreadHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ThreadHandle.cs,GetLastSystemCall,The length of the statement  "	if ((status = Win32.NtQueryInformationThread (this' ThreadInformationClass.ThreadLastSystemCall' data' sizeof(int) * 2' out retLength)) >= NtStatus.Error) " is 154.
Long Statement,ProcessHacker.Native.Objects,ThreadHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ThreadHandle.cs,RemoteCall,The length of the statement  "	if ((status = Win32.RtlRemoteCall (processHandle' this' address' arguments.Length' arguments' false' alreadySuspended)) >= NtStatus.Error) " is 138.
Long Statement,ProcessHacker.Native.Objects,ThreadHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ThreadHandle.cs,WalkStack,The length of the statement  "			using (var phandle = new ProcessHandle (ThreadHandle.FromHandle (dupThreadHandle).GetBasicInformation ().ClientId.ProcessId' ProcessAccess.QueryInformation | ProcessAccess.VmRead)) { " is 182.
Long Statement,ProcessHacker.Native.Objects,ThreadHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ThreadHandle.cs,WalkStack,The length of the statement  "		readMemoryProc = new ReadProcessMemoryProc64 (delegate (IntPtr processHandle' ulong baseAddress' IntPtr buffer' int size' out int bytesRead) { " is 142.
Long Statement,ProcessHacker.Native.Objects,ThreadHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ThreadHandle.cs,WalkStack,The length of the statement  "			return KProcessHacker.Instance.KphReadVirtualMemorySafe (ProcessHandle.FromHandle (processHandle)' (int)baseAddress' buffer' size' out bytesRead).IsSuccess (); " is 159.
Long Statement,ProcessHacker.Native.Objects,ThreadHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ThreadHandle.cs,WalkStack,The length of the statement  "					if (!Win32.StackWalk64 (MachineType.I386' parentProcess' this' ref stackFrame' ref context' readMemoryProc' Win32.SymFunctionTableAccess64' Win32.SymGetModuleBase64' IntPtr.Zero)) " is 179.
Long Statement,ProcessHacker.Native.Objects,ThreadHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ThreadHandle.cs,WalkStack,The length of the statement  "					if (!Win32.StackWalk64 (MachineType.Amd64' parentProcess' this' ref stackFrame' ref context' readMemoryProc' Win32.SymFunctionTableAccess64' Win32.SymGetModuleBase64' IntPtr.Zero)) " is 180.
Long Statement,ProcessHacker.Native.Objects,TokenHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TokenHandle.cs,Create,The length of the statement  "	return Create (access' null' objectFlags' null' tokenType' statistics.AuthenticationId' statistics.ExpirationTime' user' groups' privileges' owner' primaryGroup' null' _phTokenSource); " is 184.
Long Statement,ProcessHacker.Native.Objects,TokenHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TokenHandle.cs,Create,The length of the statement  "		if ((status = Win32.NtCreateToken (out handle' access' ref oa' tokenType' ref authenticationId' ref expirationTime' ref tokenUser' ref tokenGroups' ref tokenPrivileges' ref tokenOwner' ref tokenPrimaryGroup' ref tokenDefaultDacl' ref source)) >= NtStatus.Error) " is 261.
Long Statement,ProcessHacker.Native.Objects,TokenHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TokenHandle.cs,GetSource,The length of the statement  "	if (!Win32.GetTokenInformation (this' TokenInformationClass.TokenSource' out source' Marshal.SizeOf (typeof(TokenSource))' out retLen)) " is 135.
Long Statement,ProcessHacker.Native.Objects,TokenHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TokenHandle.cs,GetStatistics,The length of the statement  "	if (!Win32.GetTokenInformation (this' TokenInformationClass.TokenStatistics' out statistics' Marshal.SizeOf (typeof(TokenStatistics))' out retLen)) " is 147.
Long Statement,ProcessHacker.Native.Objects,NativeHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\NativeHandle.cs,WaitForMultipleObjects,The length of the statement  "	if ((status = Win32.NtWaitForMultipleObjects (handles.Length' handles' waitType' alertable' ref realTimeout)) >= NtStatus.Error) " is 128.
Long Statement,ProcessHacker.Native.Objects,NativeHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\NativeHandle.cs,GetObjectName,The length of the statement  "			if ((status = Win32.NtQueryObject (this' ObjectInformationClass.ObjectNameInformation' oniMem' oniMem.Size' out retLength)) >= NtStatus.Error) " is 142.
Long Statement,ProcessHacker.Native.Objects,NativeHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\NativeHandle.cs,GetObjectTypeName,The length of the statement  "			if ((status = Win32.NtQueryObject (this' ObjectInformationClass.ObjectTypeInformation' otiMem' otiMem.Size' out retLength)) >= NtStatus.Error) " is 142.
Long Statement,ProcessHacker.Native.Objects,NativeHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\NativeHandle.cs,SignalAndWait,The length of the statement  "	if ((status = Win32.NtSignalAndWaitForSingleObject (this' waitObject.Handle' alertable' ref timeout)) >= NtStatus.Error) " is 120.
Long Statement,ProcessHacker.Native.Security.AccessControl,Acl,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\AccessControl\Acl.cs,AddAuditAccess,The length of the statement  "	if ((status = Win32.RtlAddAuditAccessAce (this' Win32.AclRevision' accessMask' sid' auditSuccess' auditFailure)) >= NtStatus.Error) " is 131.
Long Statement,ProcessHacker.Native.Security.AccessControl,Acl,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\AccessControl\Acl.cs,AddAuditAccess,The length of the statement  "	if ((status = Win32.RtlAddAuditAccessAceEx (this' Win32.AclRevision' flags' accessMask' sid' auditSuccess' auditFailure)) >= NtStatus.Error) " is 140.
Long Statement,ProcessHacker.Native.Security.AccessControl,Acl,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\AccessControl\Acl.cs,AddCompound,The length of the statement  "	if ((status = Win32.RtlAddCompoundAce (this' Win32.AclRevision' type' accessMask' serverSid' clientSid)) >= NtStatus.Error) " is 123.
Long Statement,ProcessHacker.Native.Security.AccessControl,Acl,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\AccessControl\Acl.cs,GetSizeInformation,The length of the statement  "	if ((status = Win32.RtlQueryInformationAcl (this' out sizeInfo' Marshal.SizeOf (typeof(AclSizeInformation))' AclInformationClass.AclSizeInformation)) >= NtStatus.Error) " is 168.
Long Statement,ProcessHacker.Native.Security.AccessControl,SecurityEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\AccessControl\SecurityEditor.cs,GetObjectInformation,The length of the statement  "	soi.Flags = SiObjectInfoFlags.EditAudits | SiObjectInfoFlags.EditOwner | SiObjectInfoFlags.EditPerms | SiObjectInfoFlags.Advanced | SiObjectInfoFlags.NoAclProtect | SiObjectInfoFlags.NoTreeApply; " is 195.
Long Statement,ProcessHacker.Native.Security.AccessControl,SecurityDescriptor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\AccessControl\SecurityDescriptor.cs,GetSecurity,The length of the statement  "	if ((result = Win32.GetSecurityInfo (handle' objectType' securityInformation' out dummy' out dummy' out dummy' out dummy' out securityDescriptor)) != 0) " is 152.
Long Statement,ProcessHacker.Native.Security.AccessControl,SecurityDescriptor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\AccessControl\SecurityDescriptor.cs,CheckAccess,The length of the statement  "	if ((status = Win32.NtAccessCheck (this' tokenHandle' desiredAccess' ref genericMapping' IntPtr.Zero' ref privilegeSetLength' out grantedAccess' out accessStatus)) >= NtStatus.Error) " is 182.
Long Statement,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The length of the statement  "				if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) { " is 179.
Long Statement,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The length of the statement  "					if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) " is 177.
Long Statement,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,PromptForCredentials,The length of the statement  "			result = Win32.CredUIPromptForCredentials (ref info' targetName' IntPtr.Zero' errorCode' userNameAlloc' maxBytes / 2' passwordAlloc' maxBytes / 2' ref save' flags); " is 164.
Long Statement,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,PromptForCredentials2,The length of the statement  "		result = Win32.CredUIPromptForWindowsCredentials (ref info' errorCode' ref authenticationPackage' inAuthBuffer' inAuthBuffer.Size' out outAuthBuffer' out outAuthBufferSize' ref save' flags); " is 190.
Long Statement,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,PromptForCredentials2,The length of the statement  "			UnpackCredentials (new MemoryRegion (outAuthBuffer' 0' outAuthBufferSize)' CredPackFlags.ProtectedCredentials' out domainName' out userName' out password); " is 155.
Long Statement,ProcessHacker.Native.Security,Privilege,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Privilege.cs,Disable,The length of the statement  "		throw new InvalidOperationException ("Cannot disable the privilege because there is no token associated with the instance."); " is 125.
Long Statement,ProcessHacker.Native.Security,Privilege,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Privilege.cs,Enable,The length of the statement  "		throw new InvalidOperationException ("Cannot enable the privilege because there is no token associated with the instance."); " is 124.
Long Statement,ProcessHacker.Native.Security,Privilege,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Privilege.cs,Remove,The length of the statement  "		throw new InvalidOperationException ("Cannot remove the privilege because there is no token associated with the instance."); " is 124.
Long Statement,ProcessHacker.Native.SsLogging,SsLogger,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\SsLogging\SsLogger.cs,ReadEventBlock,The length of the statement  "	ssEvent.ArgumentsCopyFailed = (eventBlock.Flags & KphSsEventFlags.CopyArgumentsFailed) == KphSsEventFlags.CopyArgumentsFailed; " is 126.
Long Statement,ProcessHacker.Native.SsLogging,SsLogger,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\SsLogging\SsLogger.cs,ReadEventBlock,The length of the statement  "	ssEvent.ArgumentsProbeFailed = (eventBlock.Flags & KphSsEventFlags.ProbeArgumentsFailed) == KphSsEventFlags.ProbeArgumentsFailed; " is 129.
Long Statement,ProcessHacker.Native.SsLogging,SsLogger,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\SsLogging\SsLogger.cs,GetStatistics,The length of the statement  "	KProcessHacker.Instance.SsQueryClientEntry (_clientEntryHandle' out info' Marshal.SizeOf (typeof(KphSsClientInformation))' out retLength); " is 138.
Long Statement,ProcessHacker.Native.Symbols,SymbolProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Symbols\SymbolProvider.cs,EnumSymbols,The length of the statement  "		if (!Win32.SymEnumSymbols (_handle' moduleBase' mask' (symbolInfo' symbolSize' userContext) => enumDelegate (new SymbolInformation (symbolInfo' symbolSize))' IntPtr.Zero)) " is 171.
Long Statement,ProcessHacker.Native.Threading,NativeThreadPool,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Threading\NativeThreadPool.cs,RegisterWait,The length of the statement  "	Win32.RtlRegisterWait (out waitHandle' handle' (context' timeout) => callback (argument' timeout)' IntPtr.Zero' timeoutMilliseconds' WtFlags.ExecuteDefault).ThrowIf (); " is 168.
Long Statement,ProcessHacker.Native.Ui,HandlePropertiesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Ui\HandlePropertiesWindow.cs,buttonPermissions_Click,The length of the statement  "			SecurityEditor.EditSecurity (this' SecurityEditor.GetSecurableWrapper (_objectHandle)' _name' NativeTypeFactory.GetAccessEntries (NativeTypeFactory.GetObjectType (_typeName))); " is 176.
Long Statement,ProcessHacker.Native.Ui,HandlePropertiesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Ui\HandlePropertiesWindow.cs,buttonPermissions_Click,The length of the statement  "			MessageBox.Show ("Unable to edit security: " + ex.Message' "Security Editor"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 122.
Complex Conditional,ProcessHacker.Native.Api,Win32ErrorExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Win32Error.cs,GetMessage,The conditional expression  "!char.IsLetterOrDigit (c) && !char.IsPunctuation (c) && !char.IsSymbol (c) && !char.IsWhiteSpace (c)"  is complex.
Complex Conditional,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetMountPointTarget,The conditional expression  "(fileName.Length == 2 && fileName [1] == ':') || (fileName.Length == 3 && fileName [1] == ':' && fileName [2] == '\\')"  is complex.
Complex Conditional,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetMountPointTarget,The conditional expression  "(fileName.Length == 6 || fileName.Length == 7) && fileName [0] == '\\' && fileName [1] == '\\' && (fileName [2] == '.' || fileName [2] == '?') && fileName [3] == '\\' && fileName [5] == ':'"  is complex.
Complex Conditional,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetMountPointTarget,The conditional expression  "fileName.Length == 6 && fileName [0] == '\\' && fileName [1] == '?' && fileName [2] == '?' && fileName [3] == '\\' && fileName [5] == ':'"  is complex.
Complex Conditional,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,IsDriveLetterPath,The conditional expression  "path.Length == 14 && path.StartsWith (@"\DosDevices\") && path [12] >= 'A' && path [12] <= 'Z' && path [13] == ':'"  is complex.
Complex Conditional,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,IsVolumePath,The conditional expression  "(path.Length == 48 || (path.Length == 49 && path [48] == '\\')) && (path.StartsWith (@"\??\Volume") || path.StartsWith (@"\\?\Volume")) && path [10] == '{' && path [19] == '-' && path [24] == '-' && path [29] == '-' && path [34] == '-' && path [47] == '}'"  is complex.
Complex Conditional,ProcessHacker.Native.Security.AccessControl,KnownAce,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\AccessControl\KnownAce.cs,KnownAce,The conditional expression  "type != AceType.AccessAllowed && type != AceType.AccessDenied && type != AceType.SystemAlarm && type != AceType.SystemAudit"  is complex.
Empty Catch Block,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KProcessHacker,The method has an empty catch block.
Empty Catch Block,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,GetHandleObjectName,The method has an empty catch block.
Empty Catch Block,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,OpenByName,The method has an empty catch block.
Empty Catch Block,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,EnumModulesNative,The method has an empty catch block.
Empty Catch Block,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,EnumModulesNative,The method has an empty catch block.
Empty Catch Block,ProcessHacker.Native.Objects,ThreadHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ThreadHandle.cs,WalkStack,The method has an empty catch block.
Empty Catch Block,ProcessHacker.Native.Symbols,SymbolProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Symbols\SymbolProvider.cs,GetSymbolFromAddress,The method has an empty catch block.
Empty Catch Block,ProcessHacker.Native.Ui,ChooseProcessDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Ui\ChooseProcessDialog.cs,RefreshProcesses,The method has an empty catch block.
Empty Catch Block,ProcessHacker.Native.Ui,HandlePropertiesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Ui\HandlePropertiesWindow.cs,HandlePropertiesWindow,The method has an empty catch block.
Empty Catch Block,ProcessHacker.Native.Ui,HandlePropertiesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Ui\HandlePropertiesWindow.cs,HandlePropertiesWindow_Load,The method has an empty catch block.
Magic Number,ProcessHacker.Native.Api,TokenSource,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\NativeStructs.cs,TokenSource,The following statement contains a magic number: if (sourceName.Length > 8)  	throw new ArgumentException ("Source name must be equal to or less than 8 characters long.");  
Magic Number,ProcessHacker.Native.Api,UnicodeString,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\NativeStructs.cs,Read,The following statement contains a magic number: return Marshal.PtrToStringUni (this.Buffer' this.Length / 2);  
Magic Number,ProcessHacker.Native.Api,UnicodeString,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\NativeStructs.cs,Read,The following statement contains a magic number: try {  	return Marshal.PtrToStringUni (strDataHandle.AddrOfPinnedObject ()' this.Length / 2);  }  finally {  	strDataHandle.Free ();  }  
Magic Number,ProcessHacker.Native.Api,UnicodeString,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\NativeStructs.cs,Read,The following statement contains a magic number: return Marshal.PtrToStringUni (strDataHandle.AddrOfPinnedObject ()' this.Length / 2);  
Magic Number,ProcessHacker.Native.Image,ImageExports,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Image\ImageExports.cs,LookupName,The following statement contains a magic number: while (low <= high) {  	int i;  	string n;  	i = (low + high) / 2;  	n = new string ((sbyte*)_mappedImage.RvaToVa (_namePointerTable [i]));  	if (name == n) {  		return i;  	}  	else if (name.CompareTo (n) > 0) {  		low = i + 1;  	}  	else {  		high = i - 1;  	}  }  
Magic Number,ProcessHacker.Native.Image,ImageExports,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Image\ImageExports.cs,LookupName,The following statement contains a magic number: i = (low + high) / 2;  
Magic Number,ProcessHacker.Native.Image,MappedImage,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Image\MappedImage.cs,GetSectionName,The following statement contains a magic number: return new string ((sbyte*)section->Name' 0' 8).TrimEnd ('\0');  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,DeleteSymbolicLink,The following statement contains a magic number: using (var data = new MemoryAlloc (MountMgrMountPoint.Size + path.Length * 2))  	using (var outData = new MemoryAlloc (1600)) {  		MountMgrMountPoint mountPoint = new MountMgrMountPoint ();  		mountPoint.SymbolicLinkNameLength = (ushort)(path.Length * 2);  		mountPoint.SymbolicLinkNameOffset = MountMgrMountPoint.Size;  		data.WriteStruct<MountMgrMountPoint> (mountPoint);  		data.WriteUnicodeString (mountPoint.SymbolicLinkNameOffset' path);  		using (var fhandle = OpenMountManager (FileAccess.GenericRead | FileAccess.GenericWrite)) {  			fhandle.IoControl (IoCtlDeletePoints' data.Memory' data.Size' outData.Memory' outData.Size);  		}  	}  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,DeleteSymbolicLink,The following statement contains a magic number: using (var data = new MemoryAlloc (MountMgrMountPoint.Size + path.Length * 2))  	using (var outData = new MemoryAlloc (1600)) {  		MountMgrMountPoint mountPoint = new MountMgrMountPoint ();  		mountPoint.SymbolicLinkNameLength = (ushort)(path.Length * 2);  		mountPoint.SymbolicLinkNameOffset = MountMgrMountPoint.Size;  		data.WriteStruct<MountMgrMountPoint> (mountPoint);  		data.WriteUnicodeString (mountPoint.SymbolicLinkNameOffset' path);  		using (var fhandle = OpenMountManager (FileAccess.GenericRead | FileAccess.GenericWrite)) {  			fhandle.IoControl (IoCtlDeletePoints' data.Memory' data.Size' outData.Memory' outData.Size);  		}  	}  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,DeleteSymbolicLink,The following statement contains a magic number: using (var data = new MemoryAlloc (MountMgrMountPoint.Size + path.Length * 2))  	using (var outData = new MemoryAlloc (1600)) {  		MountMgrMountPoint mountPoint = new MountMgrMountPoint ();  		mountPoint.SymbolicLinkNameLength = (ushort)(path.Length * 2);  		mountPoint.SymbolicLinkNameOffset = MountMgrMountPoint.Size;  		data.WriteStruct<MountMgrMountPoint> (mountPoint);  		data.WriteUnicodeString (mountPoint.SymbolicLinkNameOffset' path);  		using (var fhandle = OpenMountManager (FileAccess.GenericRead | FileAccess.GenericWrite)) {  			fhandle.IoControl (IoCtlDeletePoints' data.Memory' data.Size' outData.Memory' outData.Size);  		}  	}  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,DeleteSymbolicLink,The following statement contains a magic number: using (var outData = new MemoryAlloc (1600)) {  	MountMgrMountPoint mountPoint = new MountMgrMountPoint ();  	mountPoint.SymbolicLinkNameLength = (ushort)(path.Length * 2);  	mountPoint.SymbolicLinkNameOffset = MountMgrMountPoint.Size;  	data.WriteStruct<MountMgrMountPoint> (mountPoint);  	data.WriteUnicodeString (mountPoint.SymbolicLinkNameOffset' path);  	using (var fhandle = OpenMountManager (FileAccess.GenericRead | FileAccess.GenericWrite)) {  		fhandle.IoControl (IoCtlDeletePoints' data.Memory' data.Size' outData.Memory' outData.Size);  	}  }  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,DeleteSymbolicLink,The following statement contains a magic number: using (var outData = new MemoryAlloc (1600)) {  	MountMgrMountPoint mountPoint = new MountMgrMountPoint ();  	mountPoint.SymbolicLinkNameLength = (ushort)(path.Length * 2);  	mountPoint.SymbolicLinkNameOffset = MountMgrMountPoint.Size;  	data.WriteStruct<MountMgrMountPoint> (mountPoint);  	data.WriteUnicodeString (mountPoint.SymbolicLinkNameOffset' path);  	using (var fhandle = OpenMountManager (FileAccess.GenericRead | FileAccess.GenericWrite)) {  		fhandle.IoControl (IoCtlDeletePoints' data.Memory' data.Size' outData.Memory' outData.Size);  	}  }  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,DeleteSymbolicLink,The following statement contains a magic number: mountPoint.SymbolicLinkNameLength = (ushort)(path.Length * 2);  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetDeviceName,The following statement contains a magic number: using (var data = new MemoryAlloc (600)) {  	fhandle.IoControl (IoCtlQueryDeviceName' IntPtr.Zero' 0' data' data.Size);  	MountDevName name = data.ReadStruct<MountDevName> ();  	return data.ReadUnicodeString (MountDevName.NameOffset' name.NameLength / 2);  }  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetDeviceName,The following statement contains a magic number: using (var data = new MemoryAlloc (600)) {  	fhandle.IoControl (IoCtlQueryDeviceName' IntPtr.Zero' 0' data' data.Size);  	MountDevName name = data.ReadStruct<MountDevName> ();  	return data.ReadUnicodeString (MountDevName.NameOffset' name.NameLength / 2);  }  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetDeviceName,The following statement contains a magic number: return data.ReadUnicodeString (MountDevName.NameOffset' name.NameLength / 2);  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetReparsePointTarget,The following statement contains a magic number: using (var data = new MemoryAlloc (FileSystem.MaximumReparseDataBufferSize)) {  	fhandle.IoControl (FileSystem.FsCtlGetReparsePoint' IntPtr.Zero' 0' data' data.Size);  	FileSystem.ReparseDataBuffer buffer = data.ReadStruct<FileSystem.ReparseDataBuffer> ();  	// Make sure it is in fact a mount point.  	if (buffer.ReparseTag != (uint)IoReparseTag.MountPoint)  		Win32.Throw (NtStatus.InvalidParameter);  	return data.ReadUnicodeString (FileSystem.ReparseDataBuffer.MountPointPathBuffer + buffer.SubstituteNameOffset' buffer.SubstituteNameLength / 2);  }  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetReparsePointTarget,The following statement contains a magic number: return data.ReadUnicodeString (FileSystem.ReparseDataBuffer.MountPointPathBuffer + buffer.SubstituteNameOffset' buffer.SubstituteNameLength / 2);  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetMountPointTarget,The following statement contains a magic number: if ((fileName.Length == 2 && fileName [1] == ':') || (fileName.Length == 3 && fileName [1] == ':' && fileName [2] == '\\')) {  	return GetVolumeName (fileName [0]);  }  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetMountPointTarget,The following statement contains a magic number: if ((fileName.Length == 2 && fileName [1] == ':') || (fileName.Length == 3 && fileName [1] == ':' && fileName [2] == '\\')) {  	return GetVolumeName (fileName [0]);  }  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetMountPointTarget,The following statement contains a magic number: if ((fileName.Length == 2 && fileName [1] == ':') || (fileName.Length == 3 && fileName [1] == ':' && fileName [2] == '\\')) {  	return GetVolumeName (fileName [0]);  }  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetMountPointTarget,The following statement contains a magic number: if ((fileName.Length == 6 || fileName.Length == 7) && fileName [0] == '\\' && fileName [1] == '\\' && (fileName [2] == '.' || fileName [2] == '?') && fileName [3] == '\\' && fileName [5] == ':') {  	return GetVolumeName (fileName [4]);  }  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetMountPointTarget,The following statement contains a magic number: if ((fileName.Length == 6 || fileName.Length == 7) && fileName [0] == '\\' && fileName [1] == '\\' && (fileName [2] == '.' || fileName [2] == '?') && fileName [3] == '\\' && fileName [5] == ':') {  	return GetVolumeName (fileName [4]);  }  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetMountPointTarget,The following statement contains a magic number: if ((fileName.Length == 6 || fileName.Length == 7) && fileName [0] == '\\' && fileName [1] == '\\' && (fileName [2] == '.' || fileName [2] == '?') && fileName [3] == '\\' && fileName [5] == ':') {  	return GetVolumeName (fileName [4]);  }  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetMountPointTarget,The following statement contains a magic number: if ((fileName.Length == 6 || fileName.Length == 7) && fileName [0] == '\\' && fileName [1] == '\\' && (fileName [2] == '.' || fileName [2] == '?') && fileName [3] == '\\' && fileName [5] == ':') {  	return GetVolumeName (fileName [4]);  }  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetMountPointTarget,The following statement contains a magic number: if ((fileName.Length == 6 || fileName.Length == 7) && fileName [0] == '\\' && fileName [1] == '\\' && (fileName [2] == '.' || fileName [2] == '?') && fileName [3] == '\\' && fileName [5] == ':') {  	return GetVolumeName (fileName [4]);  }  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetMountPointTarget,The following statement contains a magic number: if ((fileName.Length == 6 || fileName.Length == 7) && fileName [0] == '\\' && fileName [1] == '\\' && (fileName [2] == '.' || fileName [2] == '?') && fileName [3] == '\\' && fileName [5] == ':') {  	return GetVolumeName (fileName [4]);  }  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetMountPointTarget,The following statement contains a magic number: if ((fileName.Length == 6 || fileName.Length == 7) && fileName [0] == '\\' && fileName [1] == '\\' && (fileName [2] == '.' || fileName [2] == '?') && fileName [3] == '\\' && fileName [5] == ':') {  	return GetVolumeName (fileName [4]);  }  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetMountPointTarget,The following statement contains a magic number: return GetVolumeName (fileName [4]);  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetMountPointTarget,The following statement contains a magic number: if (fileName.Length == 6 && fileName [0] == '\\' && fileName [1] == '?' && fileName [2] == '?' && fileName [3] == '\\' && fileName [5] == ':') {  	return GetVolumeName (fileName [4]);  }  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetMountPointTarget,The following statement contains a magic number: if (fileName.Length == 6 && fileName [0] == '\\' && fileName [1] == '?' && fileName [2] == '?' && fileName [3] == '\\' && fileName [5] == ':') {  	return GetVolumeName (fileName [4]);  }  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetMountPointTarget,The following statement contains a magic number: if (fileName.Length == 6 && fileName [0] == '\\' && fileName [1] == '?' && fileName [2] == '?' && fileName [3] == '\\' && fileName [5] == ':') {  	return GetVolumeName (fileName [4]);  }  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetMountPointTarget,The following statement contains a magic number: if (fileName.Length == 6 && fileName [0] == '\\' && fileName [1] == '?' && fileName [2] == '?' && fileName [3] == '\\' && fileName [5] == ':') {  	return GetVolumeName (fileName [4]);  }  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetMountPointTarget,The following statement contains a magic number: if (fileName.Length == 6 && fileName [0] == '\\' && fileName [1] == '?' && fileName [2] == '?' && fileName [3] == '\\' && fileName [5] == ':') {  	return GetVolumeName (fileName [4]);  }  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetMountPointTarget,The following statement contains a magic number: return GetVolumeName (fileName [4]);  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetVolumeName,The following statement contains a magic number: using (var data = new MemoryAlloc (MountMgrMountPoint.Size + deviceName.Length * 2)) {  	MountMgrMountPoint mountPoint = new MountMgrMountPoint ();  	mountPoint.DeviceNameLength = (ushort)(deviceName.Length * 2);  	mountPoint.DeviceNameOffset = MountMgrMountPoint.Size;  	data.WriteStruct<MountMgrMountPoint> (mountPoint);  	data.WriteUnicodeString (mountPoint.DeviceNameOffset' deviceName);  	using (var fhandle = OpenMountManager ((FileAccess)StandardRights.Synchronize)) {  		NtStatus status;  		int retLength;  		using (var outData = new MemoryAlloc (0x100)) {  			while (true) {  				status = fhandle.IoControl (IoCtlQueryPoints' data.Memory' data.Size' outData.Memory' outData.Size' out retLength);  				if (status == NtStatus.BufferOverflow) {  					outData.ResizeNew (Marshal.ReadInt32 (outData.Memory));  					// read Size field  					continue;  				}  				else {  					break;  				}  			}  			if (status >= NtStatus.Error)  				Win32.Throw (status);  			MountMgrMountPoints mountPoints = outData.ReadStruct<MountMgrMountPoints> ();  			// Go through the mount points given and return the first symbolic link that seems   			// to be a volume name.  			for (int i = 0; i < mountPoints.NumberOfMountPoints; i++) {  				MountMgrMountPoint mp = outData.ReadStruct<MountMgrMountPoint> (MountMgrMountPoints.MountPointsOffset' i);  				string symLinkName;  				symLinkName = Marshal.PtrToStringUni (outData.Memory.Increment (mp.SymbolicLinkNameOffset)' mp.SymbolicLinkNameLength / 2);  				if (IsVolumePath (symLinkName))  					return symLinkName;  			}  			return null;  		}  	}  }  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetVolumeName,The following statement contains a magic number: using (var data = new MemoryAlloc (MountMgrMountPoint.Size + deviceName.Length * 2)) {  	MountMgrMountPoint mountPoint = new MountMgrMountPoint ();  	mountPoint.DeviceNameLength = (ushort)(deviceName.Length * 2);  	mountPoint.DeviceNameOffset = MountMgrMountPoint.Size;  	data.WriteStruct<MountMgrMountPoint> (mountPoint);  	data.WriteUnicodeString (mountPoint.DeviceNameOffset' deviceName);  	using (var fhandle = OpenMountManager ((FileAccess)StandardRights.Synchronize)) {  		NtStatus status;  		int retLength;  		using (var outData = new MemoryAlloc (0x100)) {  			while (true) {  				status = fhandle.IoControl (IoCtlQueryPoints' data.Memory' data.Size' outData.Memory' outData.Size' out retLength);  				if (status == NtStatus.BufferOverflow) {  					outData.ResizeNew (Marshal.ReadInt32 (outData.Memory));  					// read Size field  					continue;  				}  				else {  					break;  				}  			}  			if (status >= NtStatus.Error)  				Win32.Throw (status);  			MountMgrMountPoints mountPoints = outData.ReadStruct<MountMgrMountPoints> ();  			// Go through the mount points given and return the first symbolic link that seems   			// to be a volume name.  			for (int i = 0; i < mountPoints.NumberOfMountPoints; i++) {  				MountMgrMountPoint mp = outData.ReadStruct<MountMgrMountPoint> (MountMgrMountPoints.MountPointsOffset' i);  				string symLinkName;  				symLinkName = Marshal.PtrToStringUni (outData.Memory.Increment (mp.SymbolicLinkNameOffset)' mp.SymbolicLinkNameLength / 2);  				if (IsVolumePath (symLinkName))  					return symLinkName;  			}  			return null;  		}  	}  }  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetVolumeName,The following statement contains a magic number: using (var data = new MemoryAlloc (MountMgrMountPoint.Size + deviceName.Length * 2)) {  	MountMgrMountPoint mountPoint = new MountMgrMountPoint ();  	mountPoint.DeviceNameLength = (ushort)(deviceName.Length * 2);  	mountPoint.DeviceNameOffset = MountMgrMountPoint.Size;  	data.WriteStruct<MountMgrMountPoint> (mountPoint);  	data.WriteUnicodeString (mountPoint.DeviceNameOffset' deviceName);  	using (var fhandle = OpenMountManager ((FileAccess)StandardRights.Synchronize)) {  		NtStatus status;  		int retLength;  		using (var outData = new MemoryAlloc (0x100)) {  			while (true) {  				status = fhandle.IoControl (IoCtlQueryPoints' data.Memory' data.Size' outData.Memory' outData.Size' out retLength);  				if (status == NtStatus.BufferOverflow) {  					outData.ResizeNew (Marshal.ReadInt32 (outData.Memory));  					// read Size field  					continue;  				}  				else {  					break;  				}  			}  			if (status >= NtStatus.Error)  				Win32.Throw (status);  			MountMgrMountPoints mountPoints = outData.ReadStruct<MountMgrMountPoints> ();  			// Go through the mount points given and return the first symbolic link that seems   			// to be a volume name.  			for (int i = 0; i < mountPoints.NumberOfMountPoints; i++) {  				MountMgrMountPoint mp = outData.ReadStruct<MountMgrMountPoint> (MountMgrMountPoints.MountPointsOffset' i);  				string symLinkName;  				symLinkName = Marshal.PtrToStringUni (outData.Memory.Increment (mp.SymbolicLinkNameOffset)' mp.SymbolicLinkNameLength / 2);  				if (IsVolumePath (symLinkName))  					return symLinkName;  			}  			return null;  		}  	}  }  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetVolumeName,The following statement contains a magic number: mountPoint.DeviceNameLength = (ushort)(deviceName.Length * 2);  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetVolumeName,The following statement contains a magic number: using (var fhandle = OpenMountManager ((FileAccess)StandardRights.Synchronize)) {  	NtStatus status;  	int retLength;  	using (var outData = new MemoryAlloc (0x100)) {  		while (true) {  			status = fhandle.IoControl (IoCtlQueryPoints' data.Memory' data.Size' outData.Memory' outData.Size' out retLength);  			if (status == NtStatus.BufferOverflow) {  				outData.ResizeNew (Marshal.ReadInt32 (outData.Memory));  				// read Size field  				continue;  			}  			else {  				break;  			}  		}  		if (status >= NtStatus.Error)  			Win32.Throw (status);  		MountMgrMountPoints mountPoints = outData.ReadStruct<MountMgrMountPoints> ();  		// Go through the mount points given and return the first symbolic link that seems   		// to be a volume name.  		for (int i = 0; i < mountPoints.NumberOfMountPoints; i++) {  			MountMgrMountPoint mp = outData.ReadStruct<MountMgrMountPoint> (MountMgrMountPoints.MountPointsOffset' i);  			string symLinkName;  			symLinkName = Marshal.PtrToStringUni (outData.Memory.Increment (mp.SymbolicLinkNameOffset)' mp.SymbolicLinkNameLength / 2);  			if (IsVolumePath (symLinkName))  				return symLinkName;  		}  		return null;  	}  }  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetVolumeName,The following statement contains a magic number: using (var outData = new MemoryAlloc (0x100)) {  	while (true) {  		status = fhandle.IoControl (IoCtlQueryPoints' data.Memory' data.Size' outData.Memory' outData.Size' out retLength);  		if (status == NtStatus.BufferOverflow) {  			outData.ResizeNew (Marshal.ReadInt32 (outData.Memory));  			// read Size field  			continue;  		}  		else {  			break;  		}  	}  	if (status >= NtStatus.Error)  		Win32.Throw (status);  	MountMgrMountPoints mountPoints = outData.ReadStruct<MountMgrMountPoints> ();  	// Go through the mount points given and return the first symbolic link that seems   	// to be a volume name.  	for (int i = 0; i < mountPoints.NumberOfMountPoints; i++) {  		MountMgrMountPoint mp = outData.ReadStruct<MountMgrMountPoint> (MountMgrMountPoints.MountPointsOffset' i);  		string symLinkName;  		symLinkName = Marshal.PtrToStringUni (outData.Memory.Increment (mp.SymbolicLinkNameOffset)' mp.SymbolicLinkNameLength / 2);  		if (IsVolumePath (symLinkName))  			return symLinkName;  	}  	return null;  }  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetVolumeName,The following statement contains a magic number: for (int i = 0; i < mountPoints.NumberOfMountPoints; i++) {  	MountMgrMountPoint mp = outData.ReadStruct<MountMgrMountPoint> (MountMgrMountPoints.MountPointsOffset' i);  	string symLinkName;  	symLinkName = Marshal.PtrToStringUni (outData.Memory.Increment (mp.SymbolicLinkNameOffset)' mp.SymbolicLinkNameLength / 2);  	if (IsVolumePath (symLinkName))  		return symLinkName;  }  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,GetVolumeName,The following statement contains a magic number: symLinkName = Marshal.PtrToStringUni (outData.Memory.Increment (mp.SymbolicLinkNameOffset)' mp.SymbolicLinkNameLength / 2);  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,IsDriveLetterPath,The following statement contains a magic number: if (path.Length == 14 && path.StartsWith (@"\DosDevices\") && path [12] >= 'A' && path [12] <= 'Z' && path [13] == ':')  	return true;  else  	return false;  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,IsDriveLetterPath,The following statement contains a magic number: if (path.Length == 14 && path.StartsWith (@"\DosDevices\") && path [12] >= 'A' && path [12] <= 'Z' && path [13] == ':')  	return true;  else  	return false;  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,IsDriveLetterPath,The following statement contains a magic number: if (path.Length == 14 && path.StartsWith (@"\DosDevices\") && path [12] >= 'A' && path [12] <= 'Z' && path [13] == ':')  	return true;  else  	return false;  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,IsDriveLetterPath,The following statement contains a magic number: if (path.Length == 14 && path.StartsWith (@"\DosDevices\") && path [12] >= 'A' && path [12] <= 'Z' && path [13] == ':')  	return true;  else  	return false;  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,IsVolumePath,The following statement contains a magic number: if ((path.Length == 48 || (path.Length == 49 && path [48] == '\\')) && (path.StartsWith (@"\??\Volume") || path.StartsWith (@"\\?\Volume")) && path [10] == '{' && path [19] == '-' && path [24] == '-' && path [29] == '-' && path [34] == '-' && path [47] == '}')  	return true;  else  	return false;  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,IsVolumePath,The following statement contains a magic number: if ((path.Length == 48 || (path.Length == 49 && path [48] == '\\')) && (path.StartsWith (@"\??\Volume") || path.StartsWith (@"\\?\Volume")) && path [10] == '{' && path [19] == '-' && path [24] == '-' && path [29] == '-' && path [34] == '-' && path [47] == '}')  	return true;  else  	return false;  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,IsVolumePath,The following statement contains a magic number: if ((path.Length == 48 || (path.Length == 49 && path [48] == '\\')) && (path.StartsWith (@"\??\Volume") || path.StartsWith (@"\\?\Volume")) && path [10] == '{' && path [19] == '-' && path [24] == '-' && path [29] == '-' && path [34] == '-' && path [47] == '}')  	return true;  else  	return false;  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,IsVolumePath,The following statement contains a magic number: if ((path.Length == 48 || (path.Length == 49 && path [48] == '\\')) && (path.StartsWith (@"\??\Volume") || path.StartsWith (@"\\?\Volume")) && path [10] == '{' && path [19] == '-' && path [24] == '-' && path [29] == '-' && path [34] == '-' && path [47] == '}')  	return true;  else  	return false;  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,IsVolumePath,The following statement contains a magic number: if ((path.Length == 48 || (path.Length == 49 && path [48] == '\\')) && (path.StartsWith (@"\??\Volume") || path.StartsWith (@"\\?\Volume")) && path [10] == '{' && path [19] == '-' && path [24] == '-' && path [29] == '-' && path [34] == '-' && path [47] == '}')  	return true;  else  	return false;  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,IsVolumePath,The following statement contains a magic number: if ((path.Length == 48 || (path.Length == 49 && path [48] == '\\')) && (path.StartsWith (@"\??\Volume") || path.StartsWith (@"\\?\Volume")) && path [10] == '{' && path [19] == '-' && path [24] == '-' && path [29] == '-' && path [34] == '-' && path [47] == '}')  	return true;  else  	return false;  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,IsVolumePath,The following statement contains a magic number: if ((path.Length == 48 || (path.Length == 49 && path [48] == '\\')) && (path.StartsWith (@"\??\Volume") || path.StartsWith (@"\\?\Volume")) && path [10] == '{' && path [19] == '-' && path [24] == '-' && path [29] == '-' && path [34] == '-' && path [47] == '}')  	return true;  else  	return false;  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,IsVolumePath,The following statement contains a magic number: if ((path.Length == 48 || (path.Length == 49 && path [48] == '\\')) && (path.StartsWith (@"\??\Volume") || path.StartsWith (@"\\?\Volume")) && path [10] == '{' && path [19] == '-' && path [24] == '-' && path [29] == '-' && path [34] == '-' && path [47] == '}')  	return true;  else  	return false;  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,IsVolumePath,The following statement contains a magic number: if ((path.Length == 48 || (path.Length == 49 && path [48] == '\\')) && (path.StartsWith (@"\??\Volume") || path.StartsWith (@"\\?\Volume")) && path [10] == '{' && path [19] == '-' && path [24] == '-' && path [29] == '-' && path [34] == '-' && path [47] == '}')  	return true;  else  	return false;  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,Notify,The following statement contains a magic number: using (var data = new MemoryAlloc (MountMgrVolumeMountPoint.Size + sourceVolumeName.Length * 2 + targetVolumeName.Length * 2)) {  	MountMgrVolumeMountPoint mountPoint = new MountMgrVolumeMountPoint ();  	mountPoint.SourceVolumeNameLength = (ushort)(sourceVolumeName.Length * 2);  	mountPoint.SourceVolumeNameOffset = (ushort)MountMgrVolumeMountPoint.Size;  	mountPoint.TargetVolumeNameLength = (ushort)(targetVolumeName.Length * 2);  	mountPoint.TargetVolumeNameOffset = (ushort)(mountPoint.SourceVolumeNameOffset + mountPoint.SourceVolumeNameLength);  	data.WriteStruct<MountMgrVolumeMountPoint> (mountPoint);  	data.WriteUnicodeString (mountPoint.SourceVolumeNameOffset' sourceVolumeName);  	data.WriteUnicodeString (mountPoint.TargetVolumeNameOffset' targetVolumeName);  	using (var fhandle = OpenMountManager (FileAccess.GenericRead | FileAccess.GenericWrite)) {  		fhandle.IoControl (created ? IoCtlVolumeMountPointCreated : IoCtlVolumeMountPointDeleted' data.Memory' data.Size' IntPtr.Zero' 0);  	}  }  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,Notify,The following statement contains a magic number: using (var data = new MemoryAlloc (MountMgrVolumeMountPoint.Size + sourceVolumeName.Length * 2 + targetVolumeName.Length * 2)) {  	MountMgrVolumeMountPoint mountPoint = new MountMgrVolumeMountPoint ();  	mountPoint.SourceVolumeNameLength = (ushort)(sourceVolumeName.Length * 2);  	mountPoint.SourceVolumeNameOffset = (ushort)MountMgrVolumeMountPoint.Size;  	mountPoint.TargetVolumeNameLength = (ushort)(targetVolumeName.Length * 2);  	mountPoint.TargetVolumeNameOffset = (ushort)(mountPoint.SourceVolumeNameOffset + mountPoint.SourceVolumeNameLength);  	data.WriteStruct<MountMgrVolumeMountPoint> (mountPoint);  	data.WriteUnicodeString (mountPoint.SourceVolumeNameOffset' sourceVolumeName);  	data.WriteUnicodeString (mountPoint.TargetVolumeNameOffset' targetVolumeName);  	using (var fhandle = OpenMountManager (FileAccess.GenericRead | FileAccess.GenericWrite)) {  		fhandle.IoControl (created ? IoCtlVolumeMountPointCreated : IoCtlVolumeMountPointDeleted' data.Memory' data.Size' IntPtr.Zero' 0);  	}  }  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,Notify,The following statement contains a magic number: using (var data = new MemoryAlloc (MountMgrVolumeMountPoint.Size + sourceVolumeName.Length * 2 + targetVolumeName.Length * 2)) {  	MountMgrVolumeMountPoint mountPoint = new MountMgrVolumeMountPoint ();  	mountPoint.SourceVolumeNameLength = (ushort)(sourceVolumeName.Length * 2);  	mountPoint.SourceVolumeNameOffset = (ushort)MountMgrVolumeMountPoint.Size;  	mountPoint.TargetVolumeNameLength = (ushort)(targetVolumeName.Length * 2);  	mountPoint.TargetVolumeNameOffset = (ushort)(mountPoint.SourceVolumeNameOffset + mountPoint.SourceVolumeNameLength);  	data.WriteStruct<MountMgrVolumeMountPoint> (mountPoint);  	data.WriteUnicodeString (mountPoint.SourceVolumeNameOffset' sourceVolumeName);  	data.WriteUnicodeString (mountPoint.TargetVolumeNameOffset' targetVolumeName);  	using (var fhandle = OpenMountManager (FileAccess.GenericRead | FileAccess.GenericWrite)) {  		fhandle.IoControl (created ? IoCtlVolumeMountPointCreated : IoCtlVolumeMountPointDeleted' data.Memory' data.Size' IntPtr.Zero' 0);  	}  }  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,Notify,The following statement contains a magic number: using (var data = new MemoryAlloc (MountMgrVolumeMountPoint.Size + sourceVolumeName.Length * 2 + targetVolumeName.Length * 2)) {  	MountMgrVolumeMountPoint mountPoint = new MountMgrVolumeMountPoint ();  	mountPoint.SourceVolumeNameLength = (ushort)(sourceVolumeName.Length * 2);  	mountPoint.SourceVolumeNameOffset = (ushort)MountMgrVolumeMountPoint.Size;  	mountPoint.TargetVolumeNameLength = (ushort)(targetVolumeName.Length * 2);  	mountPoint.TargetVolumeNameOffset = (ushort)(mountPoint.SourceVolumeNameOffset + mountPoint.SourceVolumeNameLength);  	data.WriteStruct<MountMgrVolumeMountPoint> (mountPoint);  	data.WriteUnicodeString (mountPoint.SourceVolumeNameOffset' sourceVolumeName);  	data.WriteUnicodeString (mountPoint.TargetVolumeNameOffset' targetVolumeName);  	using (var fhandle = OpenMountManager (FileAccess.GenericRead | FileAccess.GenericWrite)) {  		fhandle.IoControl (created ? IoCtlVolumeMountPointCreated : IoCtlVolumeMountPointDeleted' data.Memory' data.Size' IntPtr.Zero' 0);  	}  }  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,Notify,The following statement contains a magic number: mountPoint.SourceVolumeNameLength = (ushort)(sourceVolumeName.Length * 2);  
Magic Number,ProcessHacker.Native.Io,MountManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Io\MountManager.cs,Notify,The following statement contains a magic number: mountPoint.TargetVolumeNameLength = (ushort)(targetVolumeName.Length * 2);  
Magic Number,ProcessHacker.Native,NativeBitmap,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\NativeBitmap.cs,NativeBitmap,The following statement contains a magic number: _buffer = new MemoryAlloc (Utils.DivideUp (bits' 32) * 4);  
Magic Number,ProcessHacker.Native,NativeBitmap,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\NativeBitmap.cs,NativeBitmap,The following statement contains a magic number: _buffer = new MemoryAlloc (Utils.DivideUp (bits' 32) * 4);  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,GetSignerNameFromStateData,The following statement contains a magic number: if (context.CertInfo != IntPtr.Zero) {  	// 5. Cert context -> Cert info  	CertInfo certInfo = (CertInfo)Marshal.PtrToStructure (context.CertInfo' typeof(CertInfo));  	unsafe {  		using (var buffer = new MemoryAlloc (0x200)) {  			int length;  			// 6. Cert info subject -> Subject X.500 string  			length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  			if (length > buffer.Size / 2) {  				buffer.ResizeNew (length * 2);  				length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  			}  			string name = buffer.ReadUnicodeString (0);  			string value;  			// 7. Subject X.500 string -> CN or OU value  			value = GetX500Value (name' "CN");  			if (value == null)  				value = GetX500Value (name' "OU");  			return value;  		}  	}  }  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,GetSignerNameFromStateData,The following statement contains a magic number: if (context.CertInfo != IntPtr.Zero) {  	// 5. Cert context -> Cert info  	CertInfo certInfo = (CertInfo)Marshal.PtrToStructure (context.CertInfo' typeof(CertInfo));  	unsafe {  		using (var buffer = new MemoryAlloc (0x200)) {  			int length;  			// 6. Cert info subject -> Subject X.500 string  			length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  			if (length > buffer.Size / 2) {  				buffer.ResizeNew (length * 2);  				length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  			}  			string name = buffer.ReadUnicodeString (0);  			string value;  			// 7. Subject X.500 string -> CN or OU value  			value = GetX500Value (name' "CN");  			if (value == null)  				value = GetX500Value (name' "OU");  			return value;  		}  	}  }  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,GetSignerNameFromStateData,The following statement contains a magic number: if (context.CertInfo != IntPtr.Zero) {  	// 5. Cert context -> Cert info  	CertInfo certInfo = (CertInfo)Marshal.PtrToStructure (context.CertInfo' typeof(CertInfo));  	unsafe {  		using (var buffer = new MemoryAlloc (0x200)) {  			int length;  			// 6. Cert info subject -> Subject X.500 string  			length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  			if (length > buffer.Size / 2) {  				buffer.ResizeNew (length * 2);  				length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  			}  			string name = buffer.ReadUnicodeString (0);  			string value;  			// 7. Subject X.500 string -> CN or OU value  			value = GetX500Value (name' "CN");  			if (value == null)  				value = GetX500Value (name' "OU");  			return value;  		}  	}  }  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,GetSignerNameFromStateData,The following statement contains a magic number: if (context.CertInfo != IntPtr.Zero) {  	// 5. Cert context -> Cert info  	CertInfo certInfo = (CertInfo)Marshal.PtrToStructure (context.CertInfo' typeof(CertInfo));  	unsafe {  		using (var buffer = new MemoryAlloc (0x200)) {  			int length;  			// 6. Cert info subject -> Subject X.500 string  			length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  			if (length > buffer.Size / 2) {  				buffer.ResizeNew (length * 2);  				length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  			}  			string name = buffer.ReadUnicodeString (0);  			string value;  			// 7. Subject X.500 string -> CN or OU value  			value = GetX500Value (name' "CN");  			if (value == null)  				value = GetX500Value (name' "OU");  			return value;  		}  	}  }  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,GetSignerNameFromStateData,The following statement contains a magic number: if (context.CertInfo != IntPtr.Zero) {  	// 5. Cert context -> Cert info  	CertInfo certInfo = (CertInfo)Marshal.PtrToStructure (context.CertInfo' typeof(CertInfo));  	unsafe {  		using (var buffer = new MemoryAlloc (0x200)) {  			int length;  			// 6. Cert info subject -> Subject X.500 string  			length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  			if (length > buffer.Size / 2) {  				buffer.ResizeNew (length * 2);  				length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  			}  			string name = buffer.ReadUnicodeString (0);  			string value;  			// 7. Subject X.500 string -> CN or OU value  			value = GetX500Value (name' "CN");  			if (value == null)  				value = GetX500Value (name' "OU");  			return value;  		}  	}  }  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,GetSignerNameFromStateData,The following statement contains a magic number: if (context.CertInfo != IntPtr.Zero) {  	// 5. Cert context -> Cert info  	CertInfo certInfo = (CertInfo)Marshal.PtrToStructure (context.CertInfo' typeof(CertInfo));  	unsafe {  		using (var buffer = new MemoryAlloc (0x200)) {  			int length;  			// 6. Cert info subject -> Subject X.500 string  			length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  			if (length > buffer.Size / 2) {  				buffer.ResizeNew (length * 2);  				length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  			}  			string name = buffer.ReadUnicodeString (0);  			string value;  			// 7. Subject X.500 string -> CN or OU value  			value = GetX500Value (name' "CN");  			if (value == null)  				value = GetX500Value (name' "OU");  			return value;  		}  	}  }  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,GetSignerNameFromStateData,The following statement contains a magic number: unsafe {  	using (var buffer = new MemoryAlloc (0x200)) {  		int length;  		// 6. Cert info subject -> Subject X.500 string  		length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  		if (length > buffer.Size / 2) {  			buffer.ResizeNew (length * 2);  			length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  		}  		string name = buffer.ReadUnicodeString (0);  		string value;  		// 7. Subject X.500 string -> CN or OU value  		value = GetX500Value (name' "CN");  		if (value == null)  			value = GetX500Value (name' "OU");  		return value;  	}  }  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,GetSignerNameFromStateData,The following statement contains a magic number: unsafe {  	using (var buffer = new MemoryAlloc (0x200)) {  		int length;  		// 6. Cert info subject -> Subject X.500 string  		length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  		if (length > buffer.Size / 2) {  			buffer.ResizeNew (length * 2);  			length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  		}  		string name = buffer.ReadUnicodeString (0);  		string value;  		// 7. Subject X.500 string -> CN or OU value  		value = GetX500Value (name' "CN");  		if (value == null)  			value = GetX500Value (name' "OU");  		return value;  	}  }  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,GetSignerNameFromStateData,The following statement contains a magic number: unsafe {  	using (var buffer = new MemoryAlloc (0x200)) {  		int length;  		// 6. Cert info subject -> Subject X.500 string  		length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  		if (length > buffer.Size / 2) {  			buffer.ResizeNew (length * 2);  			length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  		}  		string name = buffer.ReadUnicodeString (0);  		string value;  		// 7. Subject X.500 string -> CN or OU value  		value = GetX500Value (name' "CN");  		if (value == null)  			value = GetX500Value (name' "OU");  		return value;  	}  }  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,GetSignerNameFromStateData,The following statement contains a magic number: unsafe {  	using (var buffer = new MemoryAlloc (0x200)) {  		int length;  		// 6. Cert info subject -> Subject X.500 string  		length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  		if (length > buffer.Size / 2) {  			buffer.ResizeNew (length * 2);  			length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  		}  		string name = buffer.ReadUnicodeString (0);  		string value;  		// 7. Subject X.500 string -> CN or OU value  		value = GetX500Value (name' "CN");  		if (value == null)  			value = GetX500Value (name' "OU");  		return value;  	}  }  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,GetSignerNameFromStateData,The following statement contains a magic number: unsafe {  	using (var buffer = new MemoryAlloc (0x200)) {  		int length;  		// 6. Cert info subject -> Subject X.500 string  		length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  		if (length > buffer.Size / 2) {  			buffer.ResizeNew (length * 2);  			length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  		}  		string name = buffer.ReadUnicodeString (0);  		string value;  		// 7. Subject X.500 string -> CN or OU value  		value = GetX500Value (name' "CN");  		if (value == null)  			value = GetX500Value (name' "OU");  		return value;  	}  }  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,GetSignerNameFromStateData,The following statement contains a magic number: unsafe {  	using (var buffer = new MemoryAlloc (0x200)) {  		int length;  		// 6. Cert info subject -> Subject X.500 string  		length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  		if (length > buffer.Size / 2) {  			buffer.ResizeNew (length * 2);  			length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  		}  		string name = buffer.ReadUnicodeString (0);  		string value;  		// 7. Subject X.500 string -> CN or OU value  		value = GetX500Value (name' "CN");  		if (value == null)  			value = GetX500Value (name' "OU");  		return value;  	}  }  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,GetSignerNameFromStateData,The following statement contains a magic number: using (var buffer = new MemoryAlloc (0x200)) {  	int length;  	// 6. Cert info subject -> Subject X.500 string  	length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  	if (length > buffer.Size / 2) {  		buffer.ResizeNew (length * 2);  		length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  	}  	string name = buffer.ReadUnicodeString (0);  	string value;  	// 7. Subject X.500 string -> CN or OU value  	value = GetX500Value (name' "CN");  	if (value == null)  		value = GetX500Value (name' "OU");  	return value;  }  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,GetSignerNameFromStateData,The following statement contains a magic number: using (var buffer = new MemoryAlloc (0x200)) {  	int length;  	// 6. Cert info subject -> Subject X.500 string  	length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  	if (length > buffer.Size / 2) {  		buffer.ResizeNew (length * 2);  		length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  	}  	string name = buffer.ReadUnicodeString (0);  	string value;  	// 7. Subject X.500 string -> CN or OU value  	value = GetX500Value (name' "CN");  	if (value == null)  		value = GetX500Value (name' "OU");  	return value;  }  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,GetSignerNameFromStateData,The following statement contains a magic number: using (var buffer = new MemoryAlloc (0x200)) {  	int length;  	// 6. Cert info subject -> Subject X.500 string  	length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  	if (length > buffer.Size / 2) {  		buffer.ResizeNew (length * 2);  		length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  	}  	string name = buffer.ReadUnicodeString (0);  	string value;  	// 7. Subject X.500 string -> CN or OU value  	value = GetX500Value (name' "CN");  	if (value == null)  		value = GetX500Value (name' "OU");  	return value;  }  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,GetSignerNameFromStateData,The following statement contains a magic number: using (var buffer = new MemoryAlloc (0x200)) {  	int length;  	// 6. Cert info subject -> Subject X.500 string  	length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  	if (length > buffer.Size / 2) {  		buffer.ResizeNew (length * 2);  		length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  	}  	string name = buffer.ReadUnicodeString (0);  	string value;  	// 7. Subject X.500 string -> CN or OU value  	value = GetX500Value (name' "CN");  	if (value == null)  		value = GetX500Value (name' "OU");  	return value;  }  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,GetSignerNameFromStateData,The following statement contains a magic number: using (var buffer = new MemoryAlloc (0x200)) {  	int length;  	// 6. Cert info subject -> Subject X.500 string  	length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  	if (length > buffer.Size / 2) {  		buffer.ResizeNew (length * 2);  		length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  	}  	string name = buffer.ReadUnicodeString (0);  	string value;  	// 7. Subject X.500 string -> CN or OU value  	value = GetX500Value (name' "CN");  	if (value == null)  		value = GetX500Value (name' "OU");  	return value;  }  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,GetSignerNameFromStateData,The following statement contains a magic number: using (var buffer = new MemoryAlloc (0x200)) {  	int length;  	// 6. Cert info subject -> Subject X.500 string  	length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  	if (length > buffer.Size / 2) {  		buffer.ResizeNew (length * 2);  		length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  	}  	string name = buffer.ReadUnicodeString (0);  	string value;  	// 7. Subject X.500 string -> CN or OU value  	value = GetX500Value (name' "CN");  	if (value == null)  		value = GetX500Value (name' "OU");  	return value;  }  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,GetSignerNameFromStateData,The following statement contains a magic number: length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,GetSignerNameFromStateData,The following statement contains a magic number: length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,GetSignerNameFromStateData,The following statement contains a magic number: if (length > buffer.Size / 2) {  	buffer.ResizeNew (length * 2);  	length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  }  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,GetSignerNameFromStateData,The following statement contains a magic number: if (length > buffer.Size / 2) {  	buffer.ResizeNew (length * 2);  	length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  }  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,GetSignerNameFromStateData,The following statement contains a magic number: if (length > buffer.Size / 2) {  	buffer.ResizeNew (length * 2);  	length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  }  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,GetSignerNameFromStateData,The following statement contains a magic number: if (length > buffer.Size / 2) {  	buffer.ResizeNew (length * 2);  	length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  }  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,GetSignerNameFromStateData,The following statement contains a magic number: buffer.ResizeNew (length * 2);  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,GetSignerNameFromStateData,The following statement contains a magic number: length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,GetSignerNameFromStateData,The following statement contains a magic number: length = Win32.CertNameToStr (1' new IntPtr (&certInfo.Subject)' 3' buffer' buffer.Size / 2);  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,VerifyFile,The following statement contains a magic number: using (MemoryAlloc strMem = new MemoryAlloc (fileName.Length * 2 + 2)) {  	WintrustFileInfo fileInfo = new WintrustFileInfo ();  	strMem.WriteUnicodeString (0' fileName);  	strMem.WriteInt16 (fileName.Length * 2' 0);  	fileInfo.Size = Marshal.SizeOf (fileInfo);  	fileInfo.FilePath = strMem;  	WintrustData trustData = new WintrustData ();  	trustData.Size = Marshal.SizeOf (typeof(WintrustData));  	trustData.UIChoice = 2;  	// WTD_UI_NONE  	trustData.UnionChoice = 1;  	// WTD_CHOICE_FILE  	trustData.RevocationChecks = WtdRevocationChecks.None;  	trustData.ProvFlags = WtdProvFlags.Safer;  	trustData.StateAction = WtdStateAction.Verify;  	if (OSVersion.IsAboveOrEqual (WindowsVersion.Vista))  		trustData.ProvFlags |= WtdProvFlags.CacheOnlyUrlRetrieval;  	using (MemoryAlloc mem = new MemoryAlloc (fileInfo.Size)) {  		mem.WriteStruct<WintrustFileInfo> (fileInfo);  		trustData.UnionData = mem;  		uint winTrustResult = Win32.WinVerifyTrust (IntPtr.Zero' WintrustActionGenericVerifyV2' ref trustData);  		result = StatusToVerifyResult (winTrustResult);  		try {  			if (result != VerifyResult.NoSignature) {  				signerName = GetSignerNameFromStateData (trustData.StateData);  				return result;  			}  		}  		finally {  			// Close the state data.  			trustData.StateAction = WtdStateAction.Close;  			Win32.WinVerifyTrust (IntPtr.Zero' WintrustActionGenericVerifyV2' ref trustData);  		}  	}  }  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,VerifyFile,The following statement contains a magic number: using (MemoryAlloc strMem = new MemoryAlloc (fileName.Length * 2 + 2)) {  	WintrustFileInfo fileInfo = new WintrustFileInfo ();  	strMem.WriteUnicodeString (0' fileName);  	strMem.WriteInt16 (fileName.Length * 2' 0);  	fileInfo.Size = Marshal.SizeOf (fileInfo);  	fileInfo.FilePath = strMem;  	WintrustData trustData = new WintrustData ();  	trustData.Size = Marshal.SizeOf (typeof(WintrustData));  	trustData.UIChoice = 2;  	// WTD_UI_NONE  	trustData.UnionChoice = 1;  	// WTD_CHOICE_FILE  	trustData.RevocationChecks = WtdRevocationChecks.None;  	trustData.ProvFlags = WtdProvFlags.Safer;  	trustData.StateAction = WtdStateAction.Verify;  	if (OSVersion.IsAboveOrEqual (WindowsVersion.Vista))  		trustData.ProvFlags |= WtdProvFlags.CacheOnlyUrlRetrieval;  	using (MemoryAlloc mem = new MemoryAlloc (fileInfo.Size)) {  		mem.WriteStruct<WintrustFileInfo> (fileInfo);  		trustData.UnionData = mem;  		uint winTrustResult = Win32.WinVerifyTrust (IntPtr.Zero' WintrustActionGenericVerifyV2' ref trustData);  		result = StatusToVerifyResult (winTrustResult);  		try {  			if (result != VerifyResult.NoSignature) {  				signerName = GetSignerNameFromStateData (trustData.StateData);  				return result;  			}  		}  		finally {  			// Close the state data.  			trustData.StateAction = WtdStateAction.Close;  			Win32.WinVerifyTrust (IntPtr.Zero' WintrustActionGenericVerifyV2' ref trustData);  		}  	}  }  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,VerifyFile,The following statement contains a magic number: using (MemoryAlloc strMem = new MemoryAlloc (fileName.Length * 2 + 2)) {  	WintrustFileInfo fileInfo = new WintrustFileInfo ();  	strMem.WriteUnicodeString (0' fileName);  	strMem.WriteInt16 (fileName.Length * 2' 0);  	fileInfo.Size = Marshal.SizeOf (fileInfo);  	fileInfo.FilePath = strMem;  	WintrustData trustData = new WintrustData ();  	trustData.Size = Marshal.SizeOf (typeof(WintrustData));  	trustData.UIChoice = 2;  	// WTD_UI_NONE  	trustData.UnionChoice = 1;  	// WTD_CHOICE_FILE  	trustData.RevocationChecks = WtdRevocationChecks.None;  	trustData.ProvFlags = WtdProvFlags.Safer;  	trustData.StateAction = WtdStateAction.Verify;  	if (OSVersion.IsAboveOrEqual (WindowsVersion.Vista))  		trustData.ProvFlags |= WtdProvFlags.CacheOnlyUrlRetrieval;  	using (MemoryAlloc mem = new MemoryAlloc (fileInfo.Size)) {  		mem.WriteStruct<WintrustFileInfo> (fileInfo);  		trustData.UnionData = mem;  		uint winTrustResult = Win32.WinVerifyTrust (IntPtr.Zero' WintrustActionGenericVerifyV2' ref trustData);  		result = StatusToVerifyResult (winTrustResult);  		try {  			if (result != VerifyResult.NoSignature) {  				signerName = GetSignerNameFromStateData (trustData.StateData);  				return result;  			}  		}  		finally {  			// Close the state data.  			trustData.StateAction = WtdStateAction.Close;  			Win32.WinVerifyTrust (IntPtr.Zero' WintrustActionGenericVerifyV2' ref trustData);  		}  	}  }  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,VerifyFile,The following statement contains a magic number: using (MemoryAlloc strMem = new MemoryAlloc (fileName.Length * 2 + 2)) {  	WintrustFileInfo fileInfo = new WintrustFileInfo ();  	strMem.WriteUnicodeString (0' fileName);  	strMem.WriteInt16 (fileName.Length * 2' 0);  	fileInfo.Size = Marshal.SizeOf (fileInfo);  	fileInfo.FilePath = strMem;  	WintrustData trustData = new WintrustData ();  	trustData.Size = Marshal.SizeOf (typeof(WintrustData));  	trustData.UIChoice = 2;  	// WTD_UI_NONE  	trustData.UnionChoice = 1;  	// WTD_CHOICE_FILE  	trustData.RevocationChecks = WtdRevocationChecks.None;  	trustData.ProvFlags = WtdProvFlags.Safer;  	trustData.StateAction = WtdStateAction.Verify;  	if (OSVersion.IsAboveOrEqual (WindowsVersion.Vista))  		trustData.ProvFlags |= WtdProvFlags.CacheOnlyUrlRetrieval;  	using (MemoryAlloc mem = new MemoryAlloc (fileInfo.Size)) {  		mem.WriteStruct<WintrustFileInfo> (fileInfo);  		trustData.UnionData = mem;  		uint winTrustResult = Win32.WinVerifyTrust (IntPtr.Zero' WintrustActionGenericVerifyV2' ref trustData);  		result = StatusToVerifyResult (winTrustResult);  		try {  			if (result != VerifyResult.NoSignature) {  				signerName = GetSignerNameFromStateData (trustData.StateData);  				return result;  			}  		}  		finally {  			// Close the state data.  			trustData.StateAction = WtdStateAction.Close;  			Win32.WinVerifyTrust (IntPtr.Zero' WintrustActionGenericVerifyV2' ref trustData);  		}  	}  }  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,VerifyFile,The following statement contains a magic number: strMem.WriteInt16 (fileName.Length * 2' 0);  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,VerifyFile,The following statement contains a magic number: trustData.UIChoice = 2;  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,VerifyFile,The following statement contains a magic number: using (FileHandle sourceFile = FileHandle.CreateWin32 (fileName' FileAccess.GenericRead' FileShareMode.Read' FileCreationDispositionWin32.OpenExisting)) {  	byte[] hash = new byte[256];  	int hashLength = 256;  	if (!Win32.CryptCATAdminCalcHashFromFileHandle (sourceFile' ref hashLength' hash' 0)) {  		hash = new byte[hashLength];  		if (!Win32.CryptCATAdminCalcHashFromFileHandle (sourceFile' ref hashLength' hash' 0))  			return VerifyResult.NoSignature;  	}  	StringBuilder memberTag = new StringBuilder (hashLength * 2);  	for (int i = 0; i < hashLength; i++)  		memberTag.Append (hash [i].ToString ("X2"));  	IntPtr catAdmin;  	if (!Win32.CryptCATAdminAcquireContext (out catAdmin' DriverActionVerify' 0))  		return VerifyResult.NoSignature;  	IntPtr catInfo = Win32.CryptCATAdminEnumCatalogFromHash (catAdmin' hash' hashLength' 0' IntPtr.Zero);  	if (catInfo == IntPtr.Zero) {  		Win32.CryptCATAdminReleaseContext (catAdmin' 0);  		return VerifyResult.NoSignature;  	}  	CatalogInfo ci;  	if (!Win32.CryptCATCatalogInfoFromContext (catInfo' out ci' 0)) {  		Win32.CryptCATAdminReleaseCatalogContext (catAdmin' catInfo' 0);  		Win32.CryptCATAdminReleaseContext (catAdmin' 0);  		return VerifyResult.NoSignature;  	}  	WintrustCatalogInfo wci = new WintrustCatalogInfo ();  	wci.Size = Marshal.SizeOf (wci);  	wci.CatalogFilePath = ci.CatalogFile;  	wci.MemberFilePath = fileName;  	wci.MemberTag = memberTag.ToString ();  	WintrustData trustData = new WintrustData ();  	trustData.Size = Marshal.SizeOf (typeof(WintrustData));  	trustData.UIChoice = 1;  	trustData.UnionChoice = 2;  	trustData.RevocationChecks = WtdRevocationChecks.None;  	trustData.StateAction = WtdStateAction.Verify;  	if (OSVersion.IsAboveOrEqual (WindowsVersion.Vista))  		trustData.ProvFlags = WtdProvFlags.CacheOnlyUrlRetrieval;  	using (MemoryAlloc mem = new MemoryAlloc (wci.Size)) {  		mem.WriteStruct<WintrustCatalogInfo> (wci);  		try {  			trustData.UnionData = mem;  			uint winTrustResult = Win32.WinVerifyTrust (IntPtr.Zero' DriverActionVerify' ref trustData);  			result = StatusToVerifyResult (winTrustResult);  			if (result != VerifyResult.NoSignature) {  				signerName = GetSignerNameFromStateData (trustData.StateData);  			}  		}  		finally {  			try {  				// Close the state data.  				trustData.StateAction = WtdStateAction.Close;  				Win32.WinVerifyTrust (IntPtr.Zero' DriverActionVerify' ref trustData);  			}  			finally {  				Win32.CryptCATAdminReleaseCatalogContext (catAdmin' catInfo' 0);  				Win32.CryptCATAdminReleaseContext (catAdmin' 0);  				mem.DestroyStruct<WintrustCatalogInfo> ();  			}  		}  	}  }  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,VerifyFile,The following statement contains a magic number: using (FileHandle sourceFile = FileHandle.CreateWin32 (fileName' FileAccess.GenericRead' FileShareMode.Read' FileCreationDispositionWin32.OpenExisting)) {  	byte[] hash = new byte[256];  	int hashLength = 256;  	if (!Win32.CryptCATAdminCalcHashFromFileHandle (sourceFile' ref hashLength' hash' 0)) {  		hash = new byte[hashLength];  		if (!Win32.CryptCATAdminCalcHashFromFileHandle (sourceFile' ref hashLength' hash' 0))  			return VerifyResult.NoSignature;  	}  	StringBuilder memberTag = new StringBuilder (hashLength * 2);  	for (int i = 0; i < hashLength; i++)  		memberTag.Append (hash [i].ToString ("X2"));  	IntPtr catAdmin;  	if (!Win32.CryptCATAdminAcquireContext (out catAdmin' DriverActionVerify' 0))  		return VerifyResult.NoSignature;  	IntPtr catInfo = Win32.CryptCATAdminEnumCatalogFromHash (catAdmin' hash' hashLength' 0' IntPtr.Zero);  	if (catInfo == IntPtr.Zero) {  		Win32.CryptCATAdminReleaseContext (catAdmin' 0);  		return VerifyResult.NoSignature;  	}  	CatalogInfo ci;  	if (!Win32.CryptCATCatalogInfoFromContext (catInfo' out ci' 0)) {  		Win32.CryptCATAdminReleaseCatalogContext (catAdmin' catInfo' 0);  		Win32.CryptCATAdminReleaseContext (catAdmin' 0);  		return VerifyResult.NoSignature;  	}  	WintrustCatalogInfo wci = new WintrustCatalogInfo ();  	wci.Size = Marshal.SizeOf (wci);  	wci.CatalogFilePath = ci.CatalogFile;  	wci.MemberFilePath = fileName;  	wci.MemberTag = memberTag.ToString ();  	WintrustData trustData = new WintrustData ();  	trustData.Size = Marshal.SizeOf (typeof(WintrustData));  	trustData.UIChoice = 1;  	trustData.UnionChoice = 2;  	trustData.RevocationChecks = WtdRevocationChecks.None;  	trustData.StateAction = WtdStateAction.Verify;  	if (OSVersion.IsAboveOrEqual (WindowsVersion.Vista))  		trustData.ProvFlags = WtdProvFlags.CacheOnlyUrlRetrieval;  	using (MemoryAlloc mem = new MemoryAlloc (wci.Size)) {  		mem.WriteStruct<WintrustCatalogInfo> (wci);  		try {  			trustData.UnionData = mem;  			uint winTrustResult = Win32.WinVerifyTrust (IntPtr.Zero' DriverActionVerify' ref trustData);  			result = StatusToVerifyResult (winTrustResult);  			if (result != VerifyResult.NoSignature) {  				signerName = GetSignerNameFromStateData (trustData.StateData);  			}  		}  		finally {  			try {  				// Close the state data.  				trustData.StateAction = WtdStateAction.Close;  				Win32.WinVerifyTrust (IntPtr.Zero' DriverActionVerify' ref trustData);  			}  			finally {  				Win32.CryptCATAdminReleaseCatalogContext (catAdmin' catInfo' 0);  				Win32.CryptCATAdminReleaseContext (catAdmin' 0);  				mem.DestroyStruct<WintrustCatalogInfo> ();  			}  		}  	}  }  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,VerifyFile,The following statement contains a magic number: using (FileHandle sourceFile = FileHandle.CreateWin32 (fileName' FileAccess.GenericRead' FileShareMode.Read' FileCreationDispositionWin32.OpenExisting)) {  	byte[] hash = new byte[256];  	int hashLength = 256;  	if (!Win32.CryptCATAdminCalcHashFromFileHandle (sourceFile' ref hashLength' hash' 0)) {  		hash = new byte[hashLength];  		if (!Win32.CryptCATAdminCalcHashFromFileHandle (sourceFile' ref hashLength' hash' 0))  			return VerifyResult.NoSignature;  	}  	StringBuilder memberTag = new StringBuilder (hashLength * 2);  	for (int i = 0; i < hashLength; i++)  		memberTag.Append (hash [i].ToString ("X2"));  	IntPtr catAdmin;  	if (!Win32.CryptCATAdminAcquireContext (out catAdmin' DriverActionVerify' 0))  		return VerifyResult.NoSignature;  	IntPtr catInfo = Win32.CryptCATAdminEnumCatalogFromHash (catAdmin' hash' hashLength' 0' IntPtr.Zero);  	if (catInfo == IntPtr.Zero) {  		Win32.CryptCATAdminReleaseContext (catAdmin' 0);  		return VerifyResult.NoSignature;  	}  	CatalogInfo ci;  	if (!Win32.CryptCATCatalogInfoFromContext (catInfo' out ci' 0)) {  		Win32.CryptCATAdminReleaseCatalogContext (catAdmin' catInfo' 0);  		Win32.CryptCATAdminReleaseContext (catAdmin' 0);  		return VerifyResult.NoSignature;  	}  	WintrustCatalogInfo wci = new WintrustCatalogInfo ();  	wci.Size = Marshal.SizeOf (wci);  	wci.CatalogFilePath = ci.CatalogFile;  	wci.MemberFilePath = fileName;  	wci.MemberTag = memberTag.ToString ();  	WintrustData trustData = new WintrustData ();  	trustData.Size = Marshal.SizeOf (typeof(WintrustData));  	trustData.UIChoice = 1;  	trustData.UnionChoice = 2;  	trustData.RevocationChecks = WtdRevocationChecks.None;  	trustData.StateAction = WtdStateAction.Verify;  	if (OSVersion.IsAboveOrEqual (WindowsVersion.Vista))  		trustData.ProvFlags = WtdProvFlags.CacheOnlyUrlRetrieval;  	using (MemoryAlloc mem = new MemoryAlloc (wci.Size)) {  		mem.WriteStruct<WintrustCatalogInfo> (wci);  		try {  			trustData.UnionData = mem;  			uint winTrustResult = Win32.WinVerifyTrust (IntPtr.Zero' DriverActionVerify' ref trustData);  			result = StatusToVerifyResult (winTrustResult);  			if (result != VerifyResult.NoSignature) {  				signerName = GetSignerNameFromStateData (trustData.StateData);  			}  		}  		finally {  			try {  				// Close the state data.  				trustData.StateAction = WtdStateAction.Close;  				Win32.WinVerifyTrust (IntPtr.Zero' DriverActionVerify' ref trustData);  			}  			finally {  				Win32.CryptCATAdminReleaseCatalogContext (catAdmin' catInfo' 0);  				Win32.CryptCATAdminReleaseContext (catAdmin' 0);  				mem.DestroyStruct<WintrustCatalogInfo> ();  			}  		}  	}  }  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,VerifyFile,The following statement contains a magic number: using (FileHandle sourceFile = FileHandle.CreateWin32 (fileName' FileAccess.GenericRead' FileShareMode.Read' FileCreationDispositionWin32.OpenExisting)) {  	byte[] hash = new byte[256];  	int hashLength = 256;  	if (!Win32.CryptCATAdminCalcHashFromFileHandle (sourceFile' ref hashLength' hash' 0)) {  		hash = new byte[hashLength];  		if (!Win32.CryptCATAdminCalcHashFromFileHandle (sourceFile' ref hashLength' hash' 0))  			return VerifyResult.NoSignature;  	}  	StringBuilder memberTag = new StringBuilder (hashLength * 2);  	for (int i = 0; i < hashLength; i++)  		memberTag.Append (hash [i].ToString ("X2"));  	IntPtr catAdmin;  	if (!Win32.CryptCATAdminAcquireContext (out catAdmin' DriverActionVerify' 0))  		return VerifyResult.NoSignature;  	IntPtr catInfo = Win32.CryptCATAdminEnumCatalogFromHash (catAdmin' hash' hashLength' 0' IntPtr.Zero);  	if (catInfo == IntPtr.Zero) {  		Win32.CryptCATAdminReleaseContext (catAdmin' 0);  		return VerifyResult.NoSignature;  	}  	CatalogInfo ci;  	if (!Win32.CryptCATCatalogInfoFromContext (catInfo' out ci' 0)) {  		Win32.CryptCATAdminReleaseCatalogContext (catAdmin' catInfo' 0);  		Win32.CryptCATAdminReleaseContext (catAdmin' 0);  		return VerifyResult.NoSignature;  	}  	WintrustCatalogInfo wci = new WintrustCatalogInfo ();  	wci.Size = Marshal.SizeOf (wci);  	wci.CatalogFilePath = ci.CatalogFile;  	wci.MemberFilePath = fileName;  	wci.MemberTag = memberTag.ToString ();  	WintrustData trustData = new WintrustData ();  	trustData.Size = Marshal.SizeOf (typeof(WintrustData));  	trustData.UIChoice = 1;  	trustData.UnionChoice = 2;  	trustData.RevocationChecks = WtdRevocationChecks.None;  	trustData.StateAction = WtdStateAction.Verify;  	if (OSVersion.IsAboveOrEqual (WindowsVersion.Vista))  		trustData.ProvFlags = WtdProvFlags.CacheOnlyUrlRetrieval;  	using (MemoryAlloc mem = new MemoryAlloc (wci.Size)) {  		mem.WriteStruct<WintrustCatalogInfo> (wci);  		try {  			trustData.UnionData = mem;  			uint winTrustResult = Win32.WinVerifyTrust (IntPtr.Zero' DriverActionVerify' ref trustData);  			result = StatusToVerifyResult (winTrustResult);  			if (result != VerifyResult.NoSignature) {  				signerName = GetSignerNameFromStateData (trustData.StateData);  			}  		}  		finally {  			try {  				// Close the state data.  				trustData.StateAction = WtdStateAction.Close;  				Win32.WinVerifyTrust (IntPtr.Zero' DriverActionVerify' ref trustData);  			}  			finally {  				Win32.CryptCATAdminReleaseCatalogContext (catAdmin' catInfo' 0);  				Win32.CryptCATAdminReleaseContext (catAdmin' 0);  				mem.DestroyStruct<WintrustCatalogInfo> ();  			}  		}  	}  }  
Magic Number,ProcessHacker.Native,Cryptography,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Cryptography.cs,VerifyFile,The following statement contains a magic number: trustData.UnionChoice = 2;  
Magic Number,ProcessHacker.Native,MemoryRegion,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Memory\MemoryRegion.cs,WriteUnicodeString,The following statement contains a magic number: unsafe {  	fixed (char* ptr = s) {  		this.WriteMemory (offset' (IntPtr)ptr' s.Length * 2);  	}  }  
Magic Number,ProcessHacker.Native,MemoryRegion,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Memory\MemoryRegion.cs,WriteUnicodeString,The following statement contains a magic number: fixed (char* ptr = s) {  	this.WriteMemory (offset' (IntPtr)ptr' s.Length * 2);  }  
Magic Number,ProcessHacker.Native,MemoryRegion,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Memory\MemoryRegion.cs,WriteUnicodeString,The following statement contains a magic number: this.WriteMemory (offset' (IntPtr)ptr' s.Length * 2);  
Magic Number,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetHandleInfo,The following statement contains a magic number: if (thisHandle.Handle == 0 || thisHandle.Handle == -1 || thisHandle.Handle == -2)  	throw new WindowsException (NtStatus.InvalidHandle);  
Magic Number,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetHandleInfo,The following statement contains a magic number: if (info.TypeName == "File") {  	if (KProcessHacker.Instance != null) {  		// Use KProcessHacker for files to avoid hangs.  		info.OrigName = KProcessHacker.Instance.GetHandleObjectName (process' handle);  	}  	else {  		// 0: No hack' query the thing normally.  		// 1: No hack' use NProcessHacker.  		// 2: Hack.  		int hackLevel = 1;  		// If we already tried to use NPH but it wasn't present'   		// skip to level 2.  		if (NphNotAvailable)  			hackLevel = 2;  		// Can't use NPH because XP had a bug where a thread hanging   		// on NtQueryObject couldn't be terminated.  		if (OSVersion.IsBelowOrEqual (WindowsVersion.XP))  			hackLevel = 2;  		// On Windows 7 and above the hanging bug appears to have   		// been fixed. Query the object normally.  		// UPDATE: Not so. It still happens.  		//if (OSVersion.IsAboveOrEqual(WindowsVersion.Seven))  		//    hackLevel = 0;  		if (hackLevel == 1) {  			try {  				// Use NProcessHacker.  				using (MemoryAlloc oniMem = new MemoryAlloc (0x4000)) {  					if (NProcessHacker.PhQueryNameFileObject (objectHandle' oniMem' oniMem.Size' out retLength) >= NtStatus.Error)  						throw new Exception ("PhQueryNameFileObject failed.");  					var oni = oniMem.ReadStruct<ObjectNameInformation> ();  					info.OrigName = oni.Name.Read ();  				}  			}  			catch (DllNotFoundException) {  				hackLevel = 2;  				NphNotAvailable = true;  			}  		}  		if (hackLevel == 0) {  			info.OrigName = GetObjectNameNt (process' handle' objectHandle);  		}  		else if (hackLevel == 2) {  			// KProcessHacker and NProcessHacker not available. Fall back to using hack  			// (i.e. not querying the name at all if the access is 0x0012019f).  			if ((int)thisHandle.GrantedAccess != 0x0012019f)  				info.OrigName = GetObjectNameNt (process' handle' objectHandle);  		}  	}  }  else {  	// Not a file. Query the object normally.  	info.OrigName = GetObjectNameNt (process' handle' objectHandle);  }  
Magic Number,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetHandleInfo,The following statement contains a magic number: if (info.TypeName == "File") {  	if (KProcessHacker.Instance != null) {  		// Use KProcessHacker for files to avoid hangs.  		info.OrigName = KProcessHacker.Instance.GetHandleObjectName (process' handle);  	}  	else {  		// 0: No hack' query the thing normally.  		// 1: No hack' use NProcessHacker.  		// 2: Hack.  		int hackLevel = 1;  		// If we already tried to use NPH but it wasn't present'   		// skip to level 2.  		if (NphNotAvailable)  			hackLevel = 2;  		// Can't use NPH because XP had a bug where a thread hanging   		// on NtQueryObject couldn't be terminated.  		if (OSVersion.IsBelowOrEqual (WindowsVersion.XP))  			hackLevel = 2;  		// On Windows 7 and above the hanging bug appears to have   		// been fixed. Query the object normally.  		// UPDATE: Not so. It still happens.  		//if (OSVersion.IsAboveOrEqual(WindowsVersion.Seven))  		//    hackLevel = 0;  		if (hackLevel == 1) {  			try {  				// Use NProcessHacker.  				using (MemoryAlloc oniMem = new MemoryAlloc (0x4000)) {  					if (NProcessHacker.PhQueryNameFileObject (objectHandle' oniMem' oniMem.Size' out retLength) >= NtStatus.Error)  						throw new Exception ("PhQueryNameFileObject failed.");  					var oni = oniMem.ReadStruct<ObjectNameInformation> ();  					info.OrigName = oni.Name.Read ();  				}  			}  			catch (DllNotFoundException) {  				hackLevel = 2;  				NphNotAvailable = true;  			}  		}  		if (hackLevel == 0) {  			info.OrigName = GetObjectNameNt (process' handle' objectHandle);  		}  		else if (hackLevel == 2) {  			// KProcessHacker and NProcessHacker not available. Fall back to using hack  			// (i.e. not querying the name at all if the access is 0x0012019f).  			if ((int)thisHandle.GrantedAccess != 0x0012019f)  				info.OrigName = GetObjectNameNt (process' handle' objectHandle);  		}  	}  }  else {  	// Not a file. Query the object normally.  	info.OrigName = GetObjectNameNt (process' handle' objectHandle);  }  
Magic Number,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetHandleInfo,The following statement contains a magic number: if (info.TypeName == "File") {  	if (KProcessHacker.Instance != null) {  		// Use KProcessHacker for files to avoid hangs.  		info.OrigName = KProcessHacker.Instance.GetHandleObjectName (process' handle);  	}  	else {  		// 0: No hack' query the thing normally.  		// 1: No hack' use NProcessHacker.  		// 2: Hack.  		int hackLevel = 1;  		// If we already tried to use NPH but it wasn't present'   		// skip to level 2.  		if (NphNotAvailable)  			hackLevel = 2;  		// Can't use NPH because XP had a bug where a thread hanging   		// on NtQueryObject couldn't be terminated.  		if (OSVersion.IsBelowOrEqual (WindowsVersion.XP))  			hackLevel = 2;  		// On Windows 7 and above the hanging bug appears to have   		// been fixed. Query the object normally.  		// UPDATE: Not so. It still happens.  		//if (OSVersion.IsAboveOrEqual(WindowsVersion.Seven))  		//    hackLevel = 0;  		if (hackLevel == 1) {  			try {  				// Use NProcessHacker.  				using (MemoryAlloc oniMem = new MemoryAlloc (0x4000)) {  					if (NProcessHacker.PhQueryNameFileObject (objectHandle' oniMem' oniMem.Size' out retLength) >= NtStatus.Error)  						throw new Exception ("PhQueryNameFileObject failed.");  					var oni = oniMem.ReadStruct<ObjectNameInformation> ();  					info.OrigName = oni.Name.Read ();  				}  			}  			catch (DllNotFoundException) {  				hackLevel = 2;  				NphNotAvailable = true;  			}  		}  		if (hackLevel == 0) {  			info.OrigName = GetObjectNameNt (process' handle' objectHandle);  		}  		else if (hackLevel == 2) {  			// KProcessHacker and NProcessHacker not available. Fall back to using hack  			// (i.e. not querying the name at all if the access is 0x0012019f).  			if ((int)thisHandle.GrantedAccess != 0x0012019f)  				info.OrigName = GetObjectNameNt (process' handle' objectHandle);  		}  	}  }  else {  	// Not a file. Query the object normally.  	info.OrigName = GetObjectNameNt (process' handle' objectHandle);  }  
Magic Number,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetHandleInfo,The following statement contains a magic number: if (info.TypeName == "File") {  	if (KProcessHacker.Instance != null) {  		// Use KProcessHacker for files to avoid hangs.  		info.OrigName = KProcessHacker.Instance.GetHandleObjectName (process' handle);  	}  	else {  		// 0: No hack' query the thing normally.  		// 1: No hack' use NProcessHacker.  		// 2: Hack.  		int hackLevel = 1;  		// If we already tried to use NPH but it wasn't present'   		// skip to level 2.  		if (NphNotAvailable)  			hackLevel = 2;  		// Can't use NPH because XP had a bug where a thread hanging   		// on NtQueryObject couldn't be terminated.  		if (OSVersion.IsBelowOrEqual (WindowsVersion.XP))  			hackLevel = 2;  		// On Windows 7 and above the hanging bug appears to have   		// been fixed. Query the object normally.  		// UPDATE: Not so. It still happens.  		//if (OSVersion.IsAboveOrEqual(WindowsVersion.Seven))  		//    hackLevel = 0;  		if (hackLevel == 1) {  			try {  				// Use NProcessHacker.  				using (MemoryAlloc oniMem = new MemoryAlloc (0x4000)) {  					if (NProcessHacker.PhQueryNameFileObject (objectHandle' oniMem' oniMem.Size' out retLength) >= NtStatus.Error)  						throw new Exception ("PhQueryNameFileObject failed.");  					var oni = oniMem.ReadStruct<ObjectNameInformation> ();  					info.OrigName = oni.Name.Read ();  				}  			}  			catch (DllNotFoundException) {  				hackLevel = 2;  				NphNotAvailable = true;  			}  		}  		if (hackLevel == 0) {  			info.OrigName = GetObjectNameNt (process' handle' objectHandle);  		}  		else if (hackLevel == 2) {  			// KProcessHacker and NProcessHacker not available. Fall back to using hack  			// (i.e. not querying the name at all if the access is 0x0012019f).  			if ((int)thisHandle.GrantedAccess != 0x0012019f)  				info.OrigName = GetObjectNameNt (process' handle' objectHandle);  		}  	}  }  else {  	// Not a file. Query the object normally.  	info.OrigName = GetObjectNameNt (process' handle' objectHandle);  }  
Magic Number,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetHandleInfo,The following statement contains a magic number: if (KProcessHacker.Instance != null) {  	// Use KProcessHacker for files to avoid hangs.  	info.OrigName = KProcessHacker.Instance.GetHandleObjectName (process' handle);  }  else {  	// 0: No hack' query the thing normally.  	// 1: No hack' use NProcessHacker.  	// 2: Hack.  	int hackLevel = 1;  	// If we already tried to use NPH but it wasn't present'   	// skip to level 2.  	if (NphNotAvailable)  		hackLevel = 2;  	// Can't use NPH because XP had a bug where a thread hanging   	// on NtQueryObject couldn't be terminated.  	if (OSVersion.IsBelowOrEqual (WindowsVersion.XP))  		hackLevel = 2;  	// On Windows 7 and above the hanging bug appears to have   	// been fixed. Query the object normally.  	// UPDATE: Not so. It still happens.  	//if (OSVersion.IsAboveOrEqual(WindowsVersion.Seven))  	//    hackLevel = 0;  	if (hackLevel == 1) {  		try {  			// Use NProcessHacker.  			using (MemoryAlloc oniMem = new MemoryAlloc (0x4000)) {  				if (NProcessHacker.PhQueryNameFileObject (objectHandle' oniMem' oniMem.Size' out retLength) >= NtStatus.Error)  					throw new Exception ("PhQueryNameFileObject failed.");  				var oni = oniMem.ReadStruct<ObjectNameInformation> ();  				info.OrigName = oni.Name.Read ();  			}  		}  		catch (DllNotFoundException) {  			hackLevel = 2;  			NphNotAvailable = true;  		}  	}  	if (hackLevel == 0) {  		info.OrigName = GetObjectNameNt (process' handle' objectHandle);  	}  	else if (hackLevel == 2) {  		// KProcessHacker and NProcessHacker not available. Fall back to using hack  		// (i.e. not querying the name at all if the access is 0x0012019f).  		if ((int)thisHandle.GrantedAccess != 0x0012019f)  			info.OrigName = GetObjectNameNt (process' handle' objectHandle);  	}  }  
Magic Number,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetHandleInfo,The following statement contains a magic number: if (KProcessHacker.Instance != null) {  	// Use KProcessHacker for files to avoid hangs.  	info.OrigName = KProcessHacker.Instance.GetHandleObjectName (process' handle);  }  else {  	// 0: No hack' query the thing normally.  	// 1: No hack' use NProcessHacker.  	// 2: Hack.  	int hackLevel = 1;  	// If we already tried to use NPH but it wasn't present'   	// skip to level 2.  	if (NphNotAvailable)  		hackLevel = 2;  	// Can't use NPH because XP had a bug where a thread hanging   	// on NtQueryObject couldn't be terminated.  	if (OSVersion.IsBelowOrEqual (WindowsVersion.XP))  		hackLevel = 2;  	// On Windows 7 and above the hanging bug appears to have   	// been fixed. Query the object normally.  	// UPDATE: Not so. It still happens.  	//if (OSVersion.IsAboveOrEqual(WindowsVersion.Seven))  	//    hackLevel = 0;  	if (hackLevel == 1) {  		try {  			// Use NProcessHacker.  			using (MemoryAlloc oniMem = new MemoryAlloc (0x4000)) {  				if (NProcessHacker.PhQueryNameFileObject (objectHandle' oniMem' oniMem.Size' out retLength) >= NtStatus.Error)  					throw new Exception ("PhQueryNameFileObject failed.");  				var oni = oniMem.ReadStruct<ObjectNameInformation> ();  				info.OrigName = oni.Name.Read ();  			}  		}  		catch (DllNotFoundException) {  			hackLevel = 2;  			NphNotAvailable = true;  		}  	}  	if (hackLevel == 0) {  		info.OrigName = GetObjectNameNt (process' handle' objectHandle);  	}  	else if (hackLevel == 2) {  		// KProcessHacker and NProcessHacker not available. Fall back to using hack  		// (i.e. not querying the name at all if the access is 0x0012019f).  		if ((int)thisHandle.GrantedAccess != 0x0012019f)  			info.OrigName = GetObjectNameNt (process' handle' objectHandle);  	}  }  
Magic Number,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetHandleInfo,The following statement contains a magic number: if (KProcessHacker.Instance != null) {  	// Use KProcessHacker for files to avoid hangs.  	info.OrigName = KProcessHacker.Instance.GetHandleObjectName (process' handle);  }  else {  	// 0: No hack' query the thing normally.  	// 1: No hack' use NProcessHacker.  	// 2: Hack.  	int hackLevel = 1;  	// If we already tried to use NPH but it wasn't present'   	// skip to level 2.  	if (NphNotAvailable)  		hackLevel = 2;  	// Can't use NPH because XP had a bug where a thread hanging   	// on NtQueryObject couldn't be terminated.  	if (OSVersion.IsBelowOrEqual (WindowsVersion.XP))  		hackLevel = 2;  	// On Windows 7 and above the hanging bug appears to have   	// been fixed. Query the object normally.  	// UPDATE: Not so. It still happens.  	//if (OSVersion.IsAboveOrEqual(WindowsVersion.Seven))  	//    hackLevel = 0;  	if (hackLevel == 1) {  		try {  			// Use NProcessHacker.  			using (MemoryAlloc oniMem = new MemoryAlloc (0x4000)) {  				if (NProcessHacker.PhQueryNameFileObject (objectHandle' oniMem' oniMem.Size' out retLength) >= NtStatus.Error)  					throw new Exception ("PhQueryNameFileObject failed.");  				var oni = oniMem.ReadStruct<ObjectNameInformation> ();  				info.OrigName = oni.Name.Read ();  			}  		}  		catch (DllNotFoundException) {  			hackLevel = 2;  			NphNotAvailable = true;  		}  	}  	if (hackLevel == 0) {  		info.OrigName = GetObjectNameNt (process' handle' objectHandle);  	}  	else if (hackLevel == 2) {  		// KProcessHacker and NProcessHacker not available. Fall back to using hack  		// (i.e. not querying the name at all if the access is 0x0012019f).  		if ((int)thisHandle.GrantedAccess != 0x0012019f)  			info.OrigName = GetObjectNameNt (process' handle' objectHandle);  	}  }  
Magic Number,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetHandleInfo,The following statement contains a magic number: if (KProcessHacker.Instance != null) {  	// Use KProcessHacker for files to avoid hangs.  	info.OrigName = KProcessHacker.Instance.GetHandleObjectName (process' handle);  }  else {  	// 0: No hack' query the thing normally.  	// 1: No hack' use NProcessHacker.  	// 2: Hack.  	int hackLevel = 1;  	// If we already tried to use NPH but it wasn't present'   	// skip to level 2.  	if (NphNotAvailable)  		hackLevel = 2;  	// Can't use NPH because XP had a bug where a thread hanging   	// on NtQueryObject couldn't be terminated.  	if (OSVersion.IsBelowOrEqual (WindowsVersion.XP))  		hackLevel = 2;  	// On Windows 7 and above the hanging bug appears to have   	// been fixed. Query the object normally.  	// UPDATE: Not so. It still happens.  	//if (OSVersion.IsAboveOrEqual(WindowsVersion.Seven))  	//    hackLevel = 0;  	if (hackLevel == 1) {  		try {  			// Use NProcessHacker.  			using (MemoryAlloc oniMem = new MemoryAlloc (0x4000)) {  				if (NProcessHacker.PhQueryNameFileObject (objectHandle' oniMem' oniMem.Size' out retLength) >= NtStatus.Error)  					throw new Exception ("PhQueryNameFileObject failed.");  				var oni = oniMem.ReadStruct<ObjectNameInformation> ();  				info.OrigName = oni.Name.Read ();  			}  		}  		catch (DllNotFoundException) {  			hackLevel = 2;  			NphNotAvailable = true;  		}  	}  	if (hackLevel == 0) {  		info.OrigName = GetObjectNameNt (process' handle' objectHandle);  	}  	else if (hackLevel == 2) {  		// KProcessHacker and NProcessHacker not available. Fall back to using hack  		// (i.e. not querying the name at all if the access is 0x0012019f).  		if ((int)thisHandle.GrantedAccess != 0x0012019f)  			info.OrigName = GetObjectNameNt (process' handle' objectHandle);  	}  }  
Magic Number,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetHandleInfo,The following statement contains a magic number: if (NphNotAvailable)  	hackLevel = 2;  
Magic Number,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetHandleInfo,The following statement contains a magic number: hackLevel = 2;  
Magic Number,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetHandleInfo,The following statement contains a magic number: if (OSVersion.IsBelowOrEqual (WindowsVersion.XP))  	hackLevel = 2;  
Magic Number,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetHandleInfo,The following statement contains a magic number: hackLevel = 2;  
Magic Number,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetHandleInfo,The following statement contains a magic number: if (hackLevel == 1) {  	try {  		// Use NProcessHacker.  		using (MemoryAlloc oniMem = new MemoryAlloc (0x4000)) {  			if (NProcessHacker.PhQueryNameFileObject (objectHandle' oniMem' oniMem.Size' out retLength) >= NtStatus.Error)  				throw new Exception ("PhQueryNameFileObject failed.");  			var oni = oniMem.ReadStruct<ObjectNameInformation> ();  			info.OrigName = oni.Name.Read ();  		}  	}  	catch (DllNotFoundException) {  		hackLevel = 2;  		NphNotAvailable = true;  	}  }  
Magic Number,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetHandleInfo,The following statement contains a magic number: try {  	// Use NProcessHacker.  	using (MemoryAlloc oniMem = new MemoryAlloc (0x4000)) {  		if (NProcessHacker.PhQueryNameFileObject (objectHandle' oniMem' oniMem.Size' out retLength) >= NtStatus.Error)  			throw new Exception ("PhQueryNameFileObject failed.");  		var oni = oniMem.ReadStruct<ObjectNameInformation> ();  		info.OrigName = oni.Name.Read ();  	}  }  catch (DllNotFoundException) {  	hackLevel = 2;  	NphNotAvailable = true;  }  
Magic Number,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetHandleInfo,The following statement contains a magic number: hackLevel = 2;  
Magic Number,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetHandleInfo,The following statement contains a magic number: if (hackLevel == 0) {  	info.OrigName = GetObjectNameNt (process' handle' objectHandle);  }  else if (hackLevel == 2) {  	// KProcessHacker and NProcessHacker not available. Fall back to using hack  	// (i.e. not querying the name at all if the access is 0x0012019f).  	if ((int)thisHandle.GrantedAccess != 0x0012019f)  		info.OrigName = GetObjectNameNt (process' handle' objectHandle);  }  
Magic Number,ProcessHacker.Native,NativeExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Api\Extensions.cs,GetHandleInfo,The following statement contains a magic number: if (hackLevel == 2) {  	// KProcessHacker and NProcessHacker not available. Fall back to using hack  	// (i.e. not querying the name at all if the access is 0x0012019f).  	if ((int)thisHandle.GrantedAccess != 0x0012019f)  		info.OrigName = GetObjectNameNt (process' handle' objectHandle);  }  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,FindFileWin32,The following statement contains a magic number: using (var data = new MemoryAlloc (0x400)) {  	int retLength;  	IntPtr filePart;  	retLength = Win32.SearchPath (null' fileName' null' data.Size / 2' data' out filePart);  	if (retLength * 2 > data.Size) {  		data.ResizeNew (retLength * 2);  		retLength = Win32.SearchPath (null' fileName' null' data.Size / 2' data' out filePart);  	}  	if (retLength == 0)  		return null;  	return data.ReadUnicodeString (0' retLength);  }  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,FindFileWin32,The following statement contains a magic number: using (var data = new MemoryAlloc (0x400)) {  	int retLength;  	IntPtr filePart;  	retLength = Win32.SearchPath (null' fileName' null' data.Size / 2' data' out filePart);  	if (retLength * 2 > data.Size) {  		data.ResizeNew (retLength * 2);  		retLength = Win32.SearchPath (null' fileName' null' data.Size / 2' data' out filePart);  	}  	if (retLength == 0)  		return null;  	return data.ReadUnicodeString (0' retLength);  }  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,FindFileWin32,The following statement contains a magic number: using (var data = new MemoryAlloc (0x400)) {  	int retLength;  	IntPtr filePart;  	retLength = Win32.SearchPath (null' fileName' null' data.Size / 2' data' out filePart);  	if (retLength * 2 > data.Size) {  		data.ResizeNew (retLength * 2);  		retLength = Win32.SearchPath (null' fileName' null' data.Size / 2' data' out filePart);  	}  	if (retLength == 0)  		return null;  	return data.ReadUnicodeString (0' retLength);  }  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,FindFileWin32,The following statement contains a magic number: using (var data = new MemoryAlloc (0x400)) {  	int retLength;  	IntPtr filePart;  	retLength = Win32.SearchPath (null' fileName' null' data.Size / 2' data' out filePart);  	if (retLength * 2 > data.Size) {  		data.ResizeNew (retLength * 2);  		retLength = Win32.SearchPath (null' fileName' null' data.Size / 2' data' out filePart);  	}  	if (retLength == 0)  		return null;  	return data.ReadUnicodeString (0' retLength);  }  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,FindFileWin32,The following statement contains a magic number: retLength = Win32.SearchPath (null' fileName' null' data.Size / 2' data' out filePart);  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,FindFileWin32,The following statement contains a magic number: if (retLength * 2 > data.Size) {  	data.ResizeNew (retLength * 2);  	retLength = Win32.SearchPath (null' fileName' null' data.Size / 2' data' out filePart);  }  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,FindFileWin32,The following statement contains a magic number: if (retLength * 2 > data.Size) {  	data.ResizeNew (retLength * 2);  	retLength = Win32.SearchPath (null' fileName' null' data.Size / 2' data' out filePart);  }  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,FindFileWin32,The following statement contains a magic number: if (retLength * 2 > data.Size) {  	data.ResizeNew (retLength * 2);  	retLength = Win32.SearchPath (null' fileName' null' data.Size / 2' data' out filePart);  }  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,FindFileWin32,The following statement contains a magic number: data.ResizeNew (retLength * 2);  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,FindFileWin32,The following statement contains a magic number: retLength = Win32.SearchPath (null' fileName' null' data.Size / 2' data' out filePart);  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,GetFileName,The following statement contains a magic number: if (fileName.StartsWith ("\\systemroot"' StringComparison.OrdinalIgnoreCase)) {  	fileName = System.IO.Path.GetFullPath (Environment.SystemDirectory + "\\.." + fileName.Substring (11));  	alreadyCanonicalized = true;  }  // If the path starts with "\WINDOWS"' we can replace it with C:\WINDOWS.  else if (fileName.StartsWith ("\\windows"' StringComparison.OrdinalIgnoreCase)) {  	fileName = System.IO.Path.GetFullPath (Environment.SystemDirectory + "\\.." + fileName.Substring (8));  	alreadyCanonicalized = true;  }  // If the path starts with "\??\"' we can remove it and we will have the path.  else if (fileName.StartsWith ("\\??\\")) {  	fileName = fileName.Substring (4);  }  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,GetFileName,The following statement contains a magic number: if (fileName.StartsWith ("\\systemroot"' StringComparison.OrdinalIgnoreCase)) {  	fileName = System.IO.Path.GetFullPath (Environment.SystemDirectory + "\\.." + fileName.Substring (11));  	alreadyCanonicalized = true;  }  // If the path starts with "\WINDOWS"' we can replace it with C:\WINDOWS.  else if (fileName.StartsWith ("\\windows"' StringComparison.OrdinalIgnoreCase)) {  	fileName = System.IO.Path.GetFullPath (Environment.SystemDirectory + "\\.." + fileName.Substring (8));  	alreadyCanonicalized = true;  }  // If the path starts with "\??\"' we can remove it and we will have the path.  else if (fileName.StartsWith ("\\??\\")) {  	fileName = fileName.Substring (4);  }  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,GetFileName,The following statement contains a magic number: if (fileName.StartsWith ("\\systemroot"' StringComparison.OrdinalIgnoreCase)) {  	fileName = System.IO.Path.GetFullPath (Environment.SystemDirectory + "\\.." + fileName.Substring (11));  	alreadyCanonicalized = true;  }  // If the path starts with "\WINDOWS"' we can replace it with C:\WINDOWS.  else if (fileName.StartsWith ("\\windows"' StringComparison.OrdinalIgnoreCase)) {  	fileName = System.IO.Path.GetFullPath (Environment.SystemDirectory + "\\.." + fileName.Substring (8));  	alreadyCanonicalized = true;  }  // If the path starts with "\??\"' we can remove it and we will have the path.  else if (fileName.StartsWith ("\\??\\")) {  	fileName = fileName.Substring (4);  }  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,GetFileName,The following statement contains a magic number: fileName = System.IO.Path.GetFullPath (Environment.SystemDirectory + "\\.." + fileName.Substring (11));  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,GetFileName,The following statement contains a magic number: if (fileName.StartsWith ("\\windows"' StringComparison.OrdinalIgnoreCase)) {  	fileName = System.IO.Path.GetFullPath (Environment.SystemDirectory + "\\.." + fileName.Substring (8));  	alreadyCanonicalized = true;  }  // If the path starts with "\??\"' we can remove it and we will have the path.  else if (fileName.StartsWith ("\\??\\")) {  	fileName = fileName.Substring (4);  }  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,GetFileName,The following statement contains a magic number: if (fileName.StartsWith ("\\windows"' StringComparison.OrdinalIgnoreCase)) {  	fileName = System.IO.Path.GetFullPath (Environment.SystemDirectory + "\\.." + fileName.Substring (8));  	alreadyCanonicalized = true;  }  // If the path starts with "\??\"' we can remove it and we will have the path.  else if (fileName.StartsWith ("\\??\\")) {  	fileName = fileName.Substring (4);  }  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,GetFileName,The following statement contains a magic number: fileName = System.IO.Path.GetFullPath (Environment.SystemDirectory + "\\.." + fileName.Substring (8));  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,GetFileName,The following statement contains a magic number: if (fileName.StartsWith ("\\??\\")) {  	fileName = fileName.Substring (4);  }  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,GetFileName,The following statement contains a magic number: fileName = fileName.Substring (4);  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,RefreshFileNamePrefixes,The following statement contains a magic number: for (char c = 'A'; c <= 'Z'; c++) {  	using (var data = new MemoryAlloc (1024)) {  		int length;  		if ((length = Win32.QueryDosDevice (c.ToString () + ":"' data' data.Size / 2)) > 2) {  			newPrefixes.Add (data.ReadUnicodeString (0' length - 2)' c.ToString () + ":");  		}  	}  }  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,RefreshFileNamePrefixes,The following statement contains a magic number: for (char c = 'A'; c <= 'Z'; c++) {  	using (var data = new MemoryAlloc (1024)) {  		int length;  		if ((length = Win32.QueryDosDevice (c.ToString () + ":"' data' data.Size / 2)) > 2) {  			newPrefixes.Add (data.ReadUnicodeString (0' length - 2)' c.ToString () + ":");  		}  	}  }  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,RefreshFileNamePrefixes,The following statement contains a magic number: for (char c = 'A'; c <= 'Z'; c++) {  	using (var data = new MemoryAlloc (1024)) {  		int length;  		if ((length = Win32.QueryDosDevice (c.ToString () + ":"' data' data.Size / 2)) > 2) {  			newPrefixes.Add (data.ReadUnicodeString (0' length - 2)' c.ToString () + ":");  		}  	}  }  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,RefreshFileNamePrefixes,The following statement contains a magic number: for (char c = 'A'; c <= 'Z'; c++) {  	using (var data = new MemoryAlloc (1024)) {  		int length;  		if ((length = Win32.QueryDosDevice (c.ToString () + ":"' data' data.Size / 2)) > 2) {  			newPrefixes.Add (data.ReadUnicodeString (0' length - 2)' c.ToString () + ":");  		}  	}  }  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,RefreshFileNamePrefixes,The following statement contains a magic number: using (var data = new MemoryAlloc (1024)) {  	int length;  	if ((length = Win32.QueryDosDevice (c.ToString () + ":"' data' data.Size / 2)) > 2) {  		newPrefixes.Add (data.ReadUnicodeString (0' length - 2)' c.ToString () + ":");  	}  }  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,RefreshFileNamePrefixes,The following statement contains a magic number: using (var data = new MemoryAlloc (1024)) {  	int length;  	if ((length = Win32.QueryDosDevice (c.ToString () + ":"' data' data.Size / 2)) > 2) {  		newPrefixes.Add (data.ReadUnicodeString (0' length - 2)' c.ToString () + ":");  	}  }  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,RefreshFileNamePrefixes,The following statement contains a magic number: using (var data = new MemoryAlloc (1024)) {  	int length;  	if ((length = Win32.QueryDosDevice (c.ToString () + ":"' data' data.Size / 2)) > 2) {  		newPrefixes.Add (data.ReadUnicodeString (0' length - 2)' c.ToString () + ":");  	}  }  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,RefreshFileNamePrefixes,The following statement contains a magic number: using (var data = new MemoryAlloc (1024)) {  	int length;  	if ((length = Win32.QueryDosDevice (c.ToString () + ":"' data' data.Size / 2)) > 2) {  		newPrefixes.Add (data.ReadUnicodeString (0' length - 2)' c.ToString () + ":");  	}  }  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,RefreshFileNamePrefixes,The following statement contains a magic number: if ((length = Win32.QueryDosDevice (c.ToString () + ":"' data' data.Size / 2)) > 2) {  	newPrefixes.Add (data.ReadUnicodeString (0' length - 2)' c.ToString () + ":");  }  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,RefreshFileNamePrefixes,The following statement contains a magic number: if ((length = Win32.QueryDosDevice (c.ToString () + ":"' data' data.Size / 2)) > 2) {  	newPrefixes.Add (data.ReadUnicodeString (0' length - 2)' c.ToString () + ":");  }  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,RefreshFileNamePrefixes,The following statement contains a magic number: if ((length = Win32.QueryDosDevice (c.ToString () + ":"' data' data.Size / 2)) > 2) {  	newPrefixes.Add (data.ReadUnicodeString (0' length - 2)' c.ToString () + ":");  }  
Magic Number,ProcessHacker.Native,FileUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\FileUtils.cs,RefreshFileNamePrefixes,The following statement contains a magic number: newPrefixes.Add (data.ReadUnicodeString (0' length - 2)' c.ToString () + ":");  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,CtlCode,The following statement contains a magic number: return (int)(_baseControlNumber + ((uint)ctl * 4));  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,ClientCloseHandle,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.ClientCloseHandle)' inData' 4' null' 0);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,GetFeatures,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.GetFeatures)' null' 0' outData' 4);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,GetHandleObjectName,The following statement contains a magic number: *(int*)(inData + 4) = handle.ToInt32 ();  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,GetHandleObjectName,The following statement contains a magic number: try {  	int len = _fileHandle.IoControl (CtlCode (Control.GetHandleObjectName)' inData' 8' outData);  	return Encoding.Unicode.GetString (outData' 8' len - 8).TrimEnd ('\0');  }  catch {  }  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,GetHandleObjectName,The following statement contains a magic number: try {  	int len = _fileHandle.IoControl (CtlCode (Control.GetHandleObjectName)' inData' 8' outData);  	return Encoding.Unicode.GetString (outData' 8' len - 8).TrimEnd ('\0');  }  catch {  }  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,GetHandleObjectName,The following statement contains a magic number: try {  	int len = _fileHandle.IoControl (CtlCode (Control.GetHandleObjectName)' inData' 8' outData);  	return Encoding.Unicode.GetString (outData' 8' len - 8).TrimEnd ('\0');  }  catch {  }  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,GetHandleObjectName,The following statement contains a magic number: return Encoding.Unicode.GetString (outData' 8' len - 8).TrimEnd ('\0');  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,GetHandleObjectName,The following statement contains a magic number: return Encoding.Unicode.GetString (outData' 8' len - 8).TrimEnd ('\0');  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,GetProcessProtected,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.GetProcessProtected)' (byte*)&pid' 4' result);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,GetThreadStartAddress,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.GetThreadStartAddress)' (byte*)&threadHandleInt' 4' outData' 4);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,GetThreadStartAddress,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.GetThreadStartAddress)' (byte*)&threadHandleInt' 4' outData' 4);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphAssignImpersonationToken,The following statement contains a magic number: *(int*)(inData + 4) = tokenHandle;  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphAssignImpersonationToken,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.KphAssignImpersonationToken)' inData' 8' null' 0);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphCaptureStackBackTraceThread,The following statement contains a magic number: fixed (IntPtr* backTracePtr = backTrace) {  	*(int*)inData = threadHandle;  	*(int*)(inData + 0x4) = framesToSkip;  	*(int*)(inData + 0x8) = framesToCapture;  	*(int*)(inData + 0xc) = (int)backTracePtr;  	*(int*)(inData + 0x10) = (int)&capturedFramesLocal;  	*(int*)(inData + 0x14) = (int)&backTraceHashLocal;  	_fileHandle.IoControl (CtlCode (Control.KphCaptureStackBackTraceThread)' inData' 6 * sizeof(int)' null' 0);  	backTraceHash = backTraceHashLocal;  	return capturedFramesLocal;  }  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphCaptureStackBackTraceThread,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.KphCaptureStackBackTraceThread)' inData' 6 * sizeof(int)' null' 0);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphDangerousTerminateThread,The following statement contains a magic number: *(int*)(inData + 4) = (int)exitStatus;  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphDangerousTerminateThread,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.KphDangerousTerminateThread)' inData' 8' null' 0);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphGetContextThread,The following statement contains a magic number: *(int*)(inData + 4) = (int)context;  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphGetContextThread,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.KphGetContextThread)' inData' 8' null' 0);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphGetProcessId,The following statement contains a magic number: *(int*)(inData + 4) = handle.ToInt32 ();  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphGetProcessId,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.KphGetProcessId)' inData' 8' outData' 4);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphGetProcessId,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.KphGetProcessId)' inData' 8' outData' 4);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphGetThreadId,The following statement contains a magic number: *(int*)(inData + 4) = handle.ToInt32 ();  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphGetThreadId,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.KphGetThreadId)' inData' 8' outData' 8);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphGetThreadId,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.KphGetThreadId)' inData' 8' outData' 8);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphGetThreadId,The following statement contains a magic number: processId = *(int*)(outData + 4);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphGetThreadWin32Thread,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.KphGetThreadWin32Thread)' (byte*)&threadHandleInt' 4' outData' 4);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphGetThreadWin32Thread,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.KphGetThreadWin32Thread)' (byte*)&threadHandleInt' 4' outData' 4);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphOpenDriver,The following statement contains a magic number: *(int*)(inData + 4) = (int)&objectAttributes;  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphOpenDriver,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.KphOpenDriver)' inData' 8' null' 0);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphOpenNamedObject,The following statement contains a magic number: *(int*)(inData + 4) = access;  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphOpenNamedObject,The following statement contains a magic number: *(int*)(inData + 8) = (int)&objectAttributes;  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphOpenProcess,The following statement contains a magic number: *(uint*)(inData + 4) = (uint)desiredAccess;  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphOpenProcess,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.KphOpenProcess)' inData' 8' outData' 4);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphOpenProcess,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.KphOpenProcess)' inData' 8' outData' 4);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphOpenProcessJob,The following statement contains a magic number: *(uint*)(inData + 4) = (uint)desiredAccess;  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphOpenProcessJob,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.KphOpenProcessJob)' inData' 8' outData' 4);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphOpenProcessJob,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.KphOpenProcessJob)' inData' 8' outData' 4);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphOpenProcessToken,The following statement contains a magic number: *(uint*)(inData + 4) = (uint)desiredAccess;  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphOpenProcessToken,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.KphOpenProcessToken)' inData' 8' outData' 4);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphOpenProcessToken,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.KphOpenProcessToken)' inData' 8' outData' 4);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphOpenThread,The following statement contains a magic number: *(uint*)(inData + 4) = (uint)desiredAccess;  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphOpenThread,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.KphOpenThread)' inData' 8' outData' 4);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphOpenThread,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.KphOpenThread)' inData' 8' outData' 4);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphOpenThreadProcess,The following statement contains a magic number: *(uint*)(inData + 4) = (uint)desiredAccess;  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphOpenThreadProcess,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.KphOpenThreadProcess)' inData' 8' outData' 4);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphOpenThreadProcess,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.KphOpenThreadProcess)' inData' 8' outData' 4);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphOpenType,The following statement contains a magic number: *(int*)(inData + 4) = (int)&objectAttributes;  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphOpenType,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.KphOpenType)' inData' 8' null' 0);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphResumeProcess,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.KphResumeProcess)' (byte*)&processHandleInt' 4' null' 0);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphSetContextThread,The following statement contains a magic number: *(int*)(inData + 4) = (int)context;  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphSetContextThread,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.KphSetContextThread)' inData' 8' null' 0);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphSetHandleGrantedAccess,The following statement contains a magic number: *(int*)(inData + 4) = grantedAccess;  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphSetHandleGrantedAccess,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.KphSetHandleGrantedAccess)' inData' 8' null' 0);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphSuspendProcess,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.KphSuspendProcess)' (byte*)&processHandleInt' 4' null' 0);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphTerminateProcess,The following statement contains a magic number: *(int*)(inData + 4) = (int)exitStatus;  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphTerminateProcess,The following statement contains a magic number: try {  	_fileHandle.IoControl (CtlCode (Control.KphTerminateProcess)' inData' 8' null' 0);  }  catch (WindowsException ex) {  	// STATUS_CANT_TERMINATE_SELF means we tried to terminate ourself. Kernel-mode can't do it'   	// so we do it now.  	if (ex.Status == NtStatus.CantTerminateSelf)  		Win32.TerminateProcess (new IntPtr (-1)' (int)exitStatus);  	else  		throw ex;  }  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphTerminateProcess,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.KphTerminateProcess)' inData' 8' null' 0);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphTerminateThread,The following statement contains a magic number: *(int*)(inData + 4) = (int)exitStatus;  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphTerminateThread,The following statement contains a magic number: try {  	_fileHandle.IoControl (CtlCode (Control.KphTerminateThread)' inData' 8' null' 0);  }  catch (WindowsException ex) {  	if (ex.Status == NtStatus.CantTerminateSelf)  		Win32.TerminateThread (new IntPtr (-2)' (int)exitStatus);  	else  		throw ex;  }  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphTerminateThread,The following statement contains a magic number: try {  	_fileHandle.IoControl (CtlCode (Control.KphTerminateThread)' inData' 8' null' 0);  }  catch (WindowsException ex) {  	if (ex.Status == NtStatus.CantTerminateSelf)  		Win32.TerminateThread (new IntPtr (-2)' (int)exitStatus);  	else  		throw ex;  }  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphTerminateThread,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.KphTerminateThread)' inData' 8' null' 0);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphTerminateThread,The following statement contains a magic number: if (ex.Status == NtStatus.CantTerminateSelf)  	Win32.TerminateThread (new IntPtr (-2)' (int)exitStatus);  else  	throw ex;  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,KphTerminateThread,The following statement contains a magic number: Win32.TerminateThread (new IntPtr (-2)' (int)exitStatus);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,ProtectAdd,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.ProtectAdd)' inData' 16' null' 0);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,ProtectQuery,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.ProtectQuery)' inData' 16' null' 0);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,ProtectRemove,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.ProtectRemove)' (byte*)&processHandleInt' 4' null' 0);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,SetExecuteOptions,The following statement contains a magic number: *(int*)(inData + 4) = (int)executeOptions;  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,SetExecuteOptions,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.SetExecuteOptions)' inData' 8' null' 0);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,SetHandleAttributes,The following statement contains a magic number: *(int*)(inData + 4) = handle.ToInt32 ();  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,SetHandleAttributes,The following statement contains a magic number: *(int*)(inData + 8) = (int)flags;  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,SetHandleAttributes,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.SetHandleAttributes)' inData' 12' null' 0);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,SetProcessProtected,The following statement contains a magic number: inData [4] = (byte)(protecte ? 1 : 0);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,SetProcessProtected,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.SetProcessProtected)' inData' 5' null' 0);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,SetProcessToken,The following statement contains a magic number: *(int*)(inData + 4) = targetPid;  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,SetProcessToken,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.SetProcessToken)' inData' 8' null' 0);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,SsAddProcessIdRule,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.SsAddProcessIdRule)' inData' 0xc' outData' 4);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,SsAddThreadIdRule,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.SsAddThreadIdRule)' inData' 0xc' outData' 4);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,SsAddPreviousModeRule,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.SsAddPreviousModeRule)' inData' 0x9' outData' 4);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,SsAddNumberRule,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.SsAddNumberRule)' inData' 0xc' outData' 4);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,SsCreateClientEntry,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.SsCreateClientEntry)' inData' 0x14' outData' 4);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,SsCreateRuleSetEntry,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.SsCreateRuleSetEntry)' inData' 0xc' outData' 4);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,SsEnableClientEntry,The following statement contains a magic number: *(byte*)(inData + 4) = (byte)(enable ? 1 : 0);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,SsEnableClientEntry,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.SsEnableClientEntry)' inData' 5' null' 0);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,SsRemoveRule,The following statement contains a magic number: *(int*)(inData + 4) = ruleEntryHandle.ToInt32 ();  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,SsRemoveRule,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.SsRemoveRule)' inData' 8' null' 0);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,ZwQueryObject,The following statement contains a magic number: *(int*)(inData + 4) = handle.ToInt32 ();  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,ZwQueryObject,The following statement contains a magic number: *(int*)(inData + 8) = (int)objectInformationClass;  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,ZwQueryObject,The following statement contains a magic number: _fileHandle.IoControl (CtlCode (Control.ZwQueryObject)' inData' 12' outData);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,ZwQueryObject,The following statement contains a magic number: fixed (byte* outDataPtr = outData) {  	status = *(NtStatus*)outDataPtr;  	returnLength = *(int*)(outDataPtr + 4);  	baseAddress = *(int*)(outDataPtr + 8);  }  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,ZwQueryObject,The following statement contains a magic number: fixed (byte* outDataPtr = outData) {  	status = *(NtStatus*)outDataPtr;  	returnLength = *(int*)(outDataPtr + 4);  	baseAddress = *(int*)(outDataPtr + 8);  }  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,ZwQueryObject,The following statement contains a magic number: returnLength = *(int*)(outDataPtr + 4);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,ZwQueryObject,The following statement contains a magic number: baseAddress = *(int*)(outDataPtr + 8);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,ZwQueryObject,The following statement contains a magic number: if (buffer != IntPtr.Zero)  	Marshal.Copy (outData' 12' buffer' bufferLength);  
Magic Number,ProcessHacker.Native,KProcessHacker,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\KProcessHacker.cs,ZwQueryObject,The following statement contains a magic number: Marshal.Copy (outData' 12' buffer' bufferLength);  
Magic Number,ProcessHacker.Native,NativeTypeFactory,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\NativeTypeFactory.cs,GetAccessString,The following statement contains a magic number: if (accessString.EndsWith ("' "))  	return accessString.Remove (accessString.Length - 2' 2);  else  	return accessString;  
Magic Number,ProcessHacker.Native,NativeTypeFactory,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\NativeTypeFactory.cs,GetAccessString,The following statement contains a magic number: if (accessString.EndsWith ("' "))  	return accessString.Remove (accessString.Length - 2' 2);  else  	return accessString;  
Magic Number,ProcessHacker.Native,NativeTypeFactory,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\NativeTypeFactory.cs,GetAccessString,The following statement contains a magic number: return accessString.Remove (accessString.Length - 2' 2);  
Magic Number,ProcessHacker.Native,NativeTypeFactory,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\NativeTypeFactory.cs,GetAccessString,The following statement contains a magic number: return accessString.Remove (accessString.Length - 2' 2);  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetHandles,The following statement contains a magic number: while ((status = Win32.NtQuerySystemInformation (SystemInformationClass.SystemHandleInformation' data' data.Size' out retLength)) == NtStatus.InfoLengthMismatch) {  	data.ResizeNew (data.Size * 2);  	// Fail if we've resized it to over 16MB - protect from infinite resizing  	if (data.Size > 16 * 1024 * 1024)  		throw new OutOfMemoryException ();  }  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetHandles,The following statement contains a magic number: while ((status = Win32.NtQuerySystemInformation (SystemInformationClass.SystemHandleInformation' data' data.Size' out retLength)) == NtStatus.InfoLengthMismatch) {  	data.ResizeNew (data.Size * 2);  	// Fail if we've resized it to over 16MB - protect from infinite resizing  	if (data.Size > 16 * 1024 * 1024)  		throw new OutOfMemoryException ();  }  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetHandles,The following statement contains a magic number: while ((status = Win32.NtQuerySystemInformation (SystemInformationClass.SystemHandleInformation' data' data.Size' out retLength)) == NtStatus.InfoLengthMismatch) {  	data.ResizeNew (data.Size * 2);  	// Fail if we've resized it to over 16MB - protect from infinite resizing  	if (data.Size > 16 * 1024 * 1024)  		throw new OutOfMemoryException ();  }  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetHandles,The following statement contains a magic number: while ((status = Win32.NtQuerySystemInformation (SystemInformationClass.SystemHandleInformation' data' data.Size' out retLength)) == NtStatus.InfoLengthMismatch) {  	data.ResizeNew (data.Size * 2);  	// Fail if we've resized it to over 16MB - protect from infinite resizing  	if (data.Size > 16 * 1024 * 1024)  		throw new OutOfMemoryException ();  }  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetHandles,The following statement contains a magic number: data.ResizeNew (data.Size * 2);  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetHandles,The following statement contains a magic number: if (data.Size > 16 * 1024 * 1024)  	throw new OutOfMemoryException ();  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetHandles,The following statement contains a magic number: if (data.Size > 16 * 1024 * 1024)  	throw new OutOfMemoryException ();  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetHandles,The following statement contains a magic number: if (data.Size > 16 * 1024 * 1024)  	throw new OutOfMemoryException ();  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetPagefiles,The following statement contains a magic number: using (MemoryAlloc data = new MemoryAlloc (0x200)) {  	NtStatus status;  	while ((status = Win32.NtQuerySystemInformation (SystemInformationClass.SystemPageFileInformation' data' data.Size' out retLength)) == NtStatus.InfoLengthMismatch) {  		data.ResizeNew (data.Size * 2);  		// Fail if we've resized it to over 16MB - protect from infinite resizing  		if (data.Size > 16 * 1024 * 1024)  			throw new OutOfMemoryException ();  	}  	if (status >= NtStatus.Error)  		Win32.Throw (status);  	pagefiles = new List<SystemPagefile> (2);  	int i = 0;  	SystemPagefileInformation currentPagefile;  	do {  		currentPagefile = data.ReadStruct<SystemPagefileInformation> (i' 0);  		pagefiles.Add (new SystemPagefile (currentPagefile.TotalSize' currentPagefile.TotalInUse' currentPagefile.PeakUsage' FileUtils.GetFileName (currentPagefile.PageFileName.Read ())));  		i += currentPagefile.NextEntryOffset;  	}  	while (currentPagefile.NextEntryOffset != 0);  	return pagefiles.ToArray ();  }  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetPagefiles,The following statement contains a magic number: using (MemoryAlloc data = new MemoryAlloc (0x200)) {  	NtStatus status;  	while ((status = Win32.NtQuerySystemInformation (SystemInformationClass.SystemPageFileInformation' data' data.Size' out retLength)) == NtStatus.InfoLengthMismatch) {  		data.ResizeNew (data.Size * 2);  		// Fail if we've resized it to over 16MB - protect from infinite resizing  		if (data.Size > 16 * 1024 * 1024)  			throw new OutOfMemoryException ();  	}  	if (status >= NtStatus.Error)  		Win32.Throw (status);  	pagefiles = new List<SystemPagefile> (2);  	int i = 0;  	SystemPagefileInformation currentPagefile;  	do {  		currentPagefile = data.ReadStruct<SystemPagefileInformation> (i' 0);  		pagefiles.Add (new SystemPagefile (currentPagefile.TotalSize' currentPagefile.TotalInUse' currentPagefile.PeakUsage' FileUtils.GetFileName (currentPagefile.PageFileName.Read ())));  		i += currentPagefile.NextEntryOffset;  	}  	while (currentPagefile.NextEntryOffset != 0);  	return pagefiles.ToArray ();  }  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetPagefiles,The following statement contains a magic number: using (MemoryAlloc data = new MemoryAlloc (0x200)) {  	NtStatus status;  	while ((status = Win32.NtQuerySystemInformation (SystemInformationClass.SystemPageFileInformation' data' data.Size' out retLength)) == NtStatus.InfoLengthMismatch) {  		data.ResizeNew (data.Size * 2);  		// Fail if we've resized it to over 16MB - protect from infinite resizing  		if (data.Size > 16 * 1024 * 1024)  			throw new OutOfMemoryException ();  	}  	if (status >= NtStatus.Error)  		Win32.Throw (status);  	pagefiles = new List<SystemPagefile> (2);  	int i = 0;  	SystemPagefileInformation currentPagefile;  	do {  		currentPagefile = data.ReadStruct<SystemPagefileInformation> (i' 0);  		pagefiles.Add (new SystemPagefile (currentPagefile.TotalSize' currentPagefile.TotalInUse' currentPagefile.PeakUsage' FileUtils.GetFileName (currentPagefile.PageFileName.Read ())));  		i += currentPagefile.NextEntryOffset;  	}  	while (currentPagefile.NextEntryOffset != 0);  	return pagefiles.ToArray ();  }  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetPagefiles,The following statement contains a magic number: using (MemoryAlloc data = new MemoryAlloc (0x200)) {  	NtStatus status;  	while ((status = Win32.NtQuerySystemInformation (SystemInformationClass.SystemPageFileInformation' data' data.Size' out retLength)) == NtStatus.InfoLengthMismatch) {  		data.ResizeNew (data.Size * 2);  		// Fail if we've resized it to over 16MB - protect from infinite resizing  		if (data.Size > 16 * 1024 * 1024)  			throw new OutOfMemoryException ();  	}  	if (status >= NtStatus.Error)  		Win32.Throw (status);  	pagefiles = new List<SystemPagefile> (2);  	int i = 0;  	SystemPagefileInformation currentPagefile;  	do {  		currentPagefile = data.ReadStruct<SystemPagefileInformation> (i' 0);  		pagefiles.Add (new SystemPagefile (currentPagefile.TotalSize' currentPagefile.TotalInUse' currentPagefile.PeakUsage' FileUtils.GetFileName (currentPagefile.PageFileName.Read ())));  		i += currentPagefile.NextEntryOffset;  	}  	while (currentPagefile.NextEntryOffset != 0);  	return pagefiles.ToArray ();  }  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetPagefiles,The following statement contains a magic number: using (MemoryAlloc data = new MemoryAlloc (0x200)) {  	NtStatus status;  	while ((status = Win32.NtQuerySystemInformation (SystemInformationClass.SystemPageFileInformation' data' data.Size' out retLength)) == NtStatus.InfoLengthMismatch) {  		data.ResizeNew (data.Size * 2);  		// Fail if we've resized it to over 16MB - protect from infinite resizing  		if (data.Size > 16 * 1024 * 1024)  			throw new OutOfMemoryException ();  	}  	if (status >= NtStatus.Error)  		Win32.Throw (status);  	pagefiles = new List<SystemPagefile> (2);  	int i = 0;  	SystemPagefileInformation currentPagefile;  	do {  		currentPagefile = data.ReadStruct<SystemPagefileInformation> (i' 0);  		pagefiles.Add (new SystemPagefile (currentPagefile.TotalSize' currentPagefile.TotalInUse' currentPagefile.PeakUsage' FileUtils.GetFileName (currentPagefile.PageFileName.Read ())));  		i += currentPagefile.NextEntryOffset;  	}  	while (currentPagefile.NextEntryOffset != 0);  	return pagefiles.ToArray ();  }  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetPagefiles,The following statement contains a magic number: while ((status = Win32.NtQuerySystemInformation (SystemInformationClass.SystemPageFileInformation' data' data.Size' out retLength)) == NtStatus.InfoLengthMismatch) {  	data.ResizeNew (data.Size * 2);  	// Fail if we've resized it to over 16MB - protect from infinite resizing  	if (data.Size > 16 * 1024 * 1024)  		throw new OutOfMemoryException ();  }  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetPagefiles,The following statement contains a magic number: while ((status = Win32.NtQuerySystemInformation (SystemInformationClass.SystemPageFileInformation' data' data.Size' out retLength)) == NtStatus.InfoLengthMismatch) {  	data.ResizeNew (data.Size * 2);  	// Fail if we've resized it to over 16MB - protect from infinite resizing  	if (data.Size > 16 * 1024 * 1024)  		throw new OutOfMemoryException ();  }  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetPagefiles,The following statement contains a magic number: while ((status = Win32.NtQuerySystemInformation (SystemInformationClass.SystemPageFileInformation' data' data.Size' out retLength)) == NtStatus.InfoLengthMismatch) {  	data.ResizeNew (data.Size * 2);  	// Fail if we've resized it to over 16MB - protect from infinite resizing  	if (data.Size > 16 * 1024 * 1024)  		throw new OutOfMemoryException ();  }  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetPagefiles,The following statement contains a magic number: while ((status = Win32.NtQuerySystemInformation (SystemInformationClass.SystemPageFileInformation' data' data.Size' out retLength)) == NtStatus.InfoLengthMismatch) {  	data.ResizeNew (data.Size * 2);  	// Fail if we've resized it to over 16MB - protect from infinite resizing  	if (data.Size > 16 * 1024 * 1024)  		throw new OutOfMemoryException ();  }  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetPagefiles,The following statement contains a magic number: data.ResizeNew (data.Size * 2);  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetPagefiles,The following statement contains a magic number: if (data.Size > 16 * 1024 * 1024)  	throw new OutOfMemoryException ();  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetPagefiles,The following statement contains a magic number: if (data.Size > 16 * 1024 * 1024)  	throw new OutOfMemoryException ();  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetPagefiles,The following statement contains a magic number: if (data.Size > 16 * 1024 * 1024)  	throw new OutOfMemoryException ();  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetPagefiles,The following statement contains a magic number: pagefiles = new List<SystemPagefile> (2);  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetProcesses,The following statement contains a magic number: while (true) {  	attempts++;  	if ((status = Win32.NtQuerySystemInformation (SystemInformationClass.SystemProcessInformation' data' data.Size' out retLength)) >= NtStatus.Error) {  		if (attempts > 3)  			Win32.Throw (status);  		data.ResizeNew (retLength);  	}  	else {  		break;  	}  }  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetProcesses,The following statement contains a magic number: if ((status = Win32.NtQuerySystemInformation (SystemInformationClass.SystemProcessInformation' data' data.Size' out retLength)) >= NtStatus.Error) {  	if (attempts > 3)  		Win32.Throw (status);  	data.ResizeNew (retLength);  }  else {  	break;  }  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetProcesses,The following statement contains a magic number: if (attempts > 3)  	Win32.Throw (status);  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetProcesses,The following statement contains a magic number: returnProcesses = new Dictionary<int' SystemProcess> (32);  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetProcessThreads,The following statement contains a magic number: while (true) {  	attempts++;  	if ((status = Win32.NtQuerySystemInformation (SystemInformationClass.SystemProcessInformation' data.Memory' data.Size' out retLength)) >= NtStatus.Error) {  		if (attempts > 3)  			Win32.Throw (status);  		data.ResizeNew (retLength);  	}  	else {  		break;  	}  }  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetProcessThreads,The following statement contains a magic number: if ((status = Win32.NtQuerySystemInformation (SystemInformationClass.SystemProcessInformation' data.Memory' data.Size' out retLength)) >= NtStatus.Error) {  	if (attempts > 3)  		Win32.Throw (status);  	data.ResizeNew (retLength);  }  else {  	break;  }  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetProcessThreads,The following statement contains a magic number: if (attempts > 3)  	Win32.Throw (status);  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetTickCount,The following statement contains a magic number: return (((long)tickCount.LowPart * tickCountMultiplier) >> (int)24) + (((long)tickCount.HighPart * tickCountMultiplier) << (int)8);  
Magic Number,ProcessHacker.Native,Windows,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Windows.cs,GetTickCount,The following statement contains a magic number: return (((long)tickCount.LowPart * tickCountMultiplier) >> (int)24) + (((long)tickCount.HighPart * tickCountMultiplier) << (int)8);  
Magic Number,ProcessHacker.Native,OSVersion,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\OSVersion.cs,OSVersion,The following statement contains a magic number: if (version.Major == 5 && version.Minor == 0)  	_windowsVersion = WindowsVersion.TwoThousand;  else if (version.Major == 5 && version.Minor == 1)  	_windowsVersion = WindowsVersion.XP;  else if (version.Major == 5 && version.Minor == 2)  	_windowsVersion = WindowsVersion.Server2003;  else if (version.Major == 6 && version.Minor == 0)  	_windowsVersion = WindowsVersion.Vista;  else if (version.Major == 6 && version.Minor == 1)  	_windowsVersion = WindowsVersion.Seven;  else  	_windowsVersion = WindowsVersion.Unknown;  
Magic Number,ProcessHacker.Native,OSVersion,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\OSVersion.cs,OSVersion,The following statement contains a magic number: if (version.Major == 5 && version.Minor == 0)  	_windowsVersion = WindowsVersion.TwoThousand;  else if (version.Major == 5 && version.Minor == 1)  	_windowsVersion = WindowsVersion.XP;  else if (version.Major == 5 && version.Minor == 2)  	_windowsVersion = WindowsVersion.Server2003;  else if (version.Major == 6 && version.Minor == 0)  	_windowsVersion = WindowsVersion.Vista;  else if (version.Major == 6 && version.Minor == 1)  	_windowsVersion = WindowsVersion.Seven;  else  	_windowsVersion = WindowsVersion.Unknown;  
Magic Number,ProcessHacker.Native,OSVersion,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\OSVersion.cs,OSVersion,The following statement contains a magic number: if (version.Major == 5 && version.Minor == 0)  	_windowsVersion = WindowsVersion.TwoThousand;  else if (version.Major == 5 && version.Minor == 1)  	_windowsVersion = WindowsVersion.XP;  else if (version.Major == 5 && version.Minor == 2)  	_windowsVersion = WindowsVersion.Server2003;  else if (version.Major == 6 && version.Minor == 0)  	_windowsVersion = WindowsVersion.Vista;  else if (version.Major == 6 && version.Minor == 1)  	_windowsVersion = WindowsVersion.Seven;  else  	_windowsVersion = WindowsVersion.Unknown;  
Magic Number,ProcessHacker.Native,OSVersion,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\OSVersion.cs,OSVersion,The following statement contains a magic number: if (version.Major == 5 && version.Minor == 0)  	_windowsVersion = WindowsVersion.TwoThousand;  else if (version.Major == 5 && version.Minor == 1)  	_windowsVersion = WindowsVersion.XP;  else if (version.Major == 5 && version.Minor == 2)  	_windowsVersion = WindowsVersion.Server2003;  else if (version.Major == 6 && version.Minor == 0)  	_windowsVersion = WindowsVersion.Vista;  else if (version.Major == 6 && version.Minor == 1)  	_windowsVersion = WindowsVersion.Seven;  else  	_windowsVersion = WindowsVersion.Unknown;  
Magic Number,ProcessHacker.Native,OSVersion,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\OSVersion.cs,OSVersion,The following statement contains a magic number: if (version.Major == 5 && version.Minor == 0)  	_windowsVersion = WindowsVersion.TwoThousand;  else if (version.Major == 5 && version.Minor == 1)  	_windowsVersion = WindowsVersion.XP;  else if (version.Major == 5 && version.Minor == 2)  	_windowsVersion = WindowsVersion.Server2003;  else if (version.Major == 6 && version.Minor == 0)  	_windowsVersion = WindowsVersion.Vista;  else if (version.Major == 6 && version.Minor == 1)  	_windowsVersion = WindowsVersion.Seven;  else  	_windowsVersion = WindowsVersion.Unknown;  
Magic Number,ProcessHacker.Native,OSVersion,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\OSVersion.cs,OSVersion,The following statement contains a magic number: if (version.Major == 5 && version.Minor == 0)  	_windowsVersion = WindowsVersion.TwoThousand;  else if (version.Major == 5 && version.Minor == 1)  	_windowsVersion = WindowsVersion.XP;  else if (version.Major == 5 && version.Minor == 2)  	_windowsVersion = WindowsVersion.Server2003;  else if (version.Major == 6 && version.Minor == 0)  	_windowsVersion = WindowsVersion.Vista;  else if (version.Major == 6 && version.Minor == 1)  	_windowsVersion = WindowsVersion.Seven;  else  	_windowsVersion = WindowsVersion.Unknown;  
Magic Number,ProcessHacker.Native,OSVersion,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\OSVersion.cs,OSVersion,The following statement contains a magic number: if (version.Major == 5 && version.Minor == 1)  	_windowsVersion = WindowsVersion.XP;  else if (version.Major == 5 && version.Minor == 2)  	_windowsVersion = WindowsVersion.Server2003;  else if (version.Major == 6 && version.Minor == 0)  	_windowsVersion = WindowsVersion.Vista;  else if (version.Major == 6 && version.Minor == 1)  	_windowsVersion = WindowsVersion.Seven;  else  	_windowsVersion = WindowsVersion.Unknown;  
Magic Number,ProcessHacker.Native,OSVersion,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\OSVersion.cs,OSVersion,The following statement contains a magic number: if (version.Major == 5 && version.Minor == 1)  	_windowsVersion = WindowsVersion.XP;  else if (version.Major == 5 && version.Minor == 2)  	_windowsVersion = WindowsVersion.Server2003;  else if (version.Major == 6 && version.Minor == 0)  	_windowsVersion = WindowsVersion.Vista;  else if (version.Major == 6 && version.Minor == 1)  	_windowsVersion = WindowsVersion.Seven;  else  	_windowsVersion = WindowsVersion.Unknown;  
Magic Number,ProcessHacker.Native,OSVersion,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\OSVersion.cs,OSVersion,The following statement contains a magic number: if (version.Major == 5 && version.Minor == 1)  	_windowsVersion = WindowsVersion.XP;  else if (version.Major == 5 && version.Minor == 2)  	_windowsVersion = WindowsVersion.Server2003;  else if (version.Major == 6 && version.Minor == 0)  	_windowsVersion = WindowsVersion.Vista;  else if (version.Major == 6 && version.Minor == 1)  	_windowsVersion = WindowsVersion.Seven;  else  	_windowsVersion = WindowsVersion.Unknown;  
Magic Number,ProcessHacker.Native,OSVersion,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\OSVersion.cs,OSVersion,The following statement contains a magic number: if (version.Major == 5 && version.Minor == 1)  	_windowsVersion = WindowsVersion.XP;  else if (version.Major == 5 && version.Minor == 2)  	_windowsVersion = WindowsVersion.Server2003;  else if (version.Major == 6 && version.Minor == 0)  	_windowsVersion = WindowsVersion.Vista;  else if (version.Major == 6 && version.Minor == 1)  	_windowsVersion = WindowsVersion.Seven;  else  	_windowsVersion = WindowsVersion.Unknown;  
Magic Number,ProcessHacker.Native,OSVersion,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\OSVersion.cs,OSVersion,The following statement contains a magic number: if (version.Major == 5 && version.Minor == 1)  	_windowsVersion = WindowsVersion.XP;  else if (version.Major == 5 && version.Minor == 2)  	_windowsVersion = WindowsVersion.Server2003;  else if (version.Major == 6 && version.Minor == 0)  	_windowsVersion = WindowsVersion.Vista;  else if (version.Major == 6 && version.Minor == 1)  	_windowsVersion = WindowsVersion.Seven;  else  	_windowsVersion = WindowsVersion.Unknown;  
Magic Number,ProcessHacker.Native,OSVersion,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\OSVersion.cs,OSVersion,The following statement contains a magic number: if (version.Major == 5 && version.Minor == 2)  	_windowsVersion = WindowsVersion.Server2003;  else if (version.Major == 6 && version.Minor == 0)  	_windowsVersion = WindowsVersion.Vista;  else if (version.Major == 6 && version.Minor == 1)  	_windowsVersion = WindowsVersion.Seven;  else  	_windowsVersion = WindowsVersion.Unknown;  
Magic Number,ProcessHacker.Native,OSVersion,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\OSVersion.cs,OSVersion,The following statement contains a magic number: if (version.Major == 5 && version.Minor == 2)  	_windowsVersion = WindowsVersion.Server2003;  else if (version.Major == 6 && version.Minor == 0)  	_windowsVersion = WindowsVersion.Vista;  else if (version.Major == 6 && version.Minor == 1)  	_windowsVersion = WindowsVersion.Seven;  else  	_windowsVersion = WindowsVersion.Unknown;  
Magic Number,ProcessHacker.Native,OSVersion,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\OSVersion.cs,OSVersion,The following statement contains a magic number: if (version.Major == 5 && version.Minor == 2)  	_windowsVersion = WindowsVersion.Server2003;  else if (version.Major == 6 && version.Minor == 0)  	_windowsVersion = WindowsVersion.Vista;  else if (version.Major == 6 && version.Minor == 1)  	_windowsVersion = WindowsVersion.Seven;  else  	_windowsVersion = WindowsVersion.Unknown;  
Magic Number,ProcessHacker.Native,OSVersion,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\OSVersion.cs,OSVersion,The following statement contains a magic number: if (version.Major == 5 && version.Minor == 2)  	_windowsVersion = WindowsVersion.Server2003;  else if (version.Major == 6 && version.Minor == 0)  	_windowsVersion = WindowsVersion.Vista;  else if (version.Major == 6 && version.Minor == 1)  	_windowsVersion = WindowsVersion.Seven;  else  	_windowsVersion = WindowsVersion.Unknown;  
Magic Number,ProcessHacker.Native,OSVersion,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\OSVersion.cs,OSVersion,The following statement contains a magic number: if (version.Major == 6 && version.Minor == 0)  	_windowsVersion = WindowsVersion.Vista;  else if (version.Major == 6 && version.Minor == 1)  	_windowsVersion = WindowsVersion.Seven;  else  	_windowsVersion = WindowsVersion.Unknown;  
Magic Number,ProcessHacker.Native,OSVersion,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\OSVersion.cs,OSVersion,The following statement contains a magic number: if (version.Major == 6 && version.Minor == 0)  	_windowsVersion = WindowsVersion.Vista;  else if (version.Major == 6 && version.Minor == 1)  	_windowsVersion = WindowsVersion.Seven;  else  	_windowsVersion = WindowsVersion.Unknown;  
Magic Number,ProcessHacker.Native,OSVersion,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\OSVersion.cs,OSVersion,The following statement contains a magic number: if (version.Major == 6 && version.Minor == 1)  	_windowsVersion = WindowsVersion.Seven;  else  	_windowsVersion = WindowsVersion.Unknown;  
Magic Number,ProcessHacker.Native.Mfs,MemoryFileSystem,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Mfs\MemoryFileSystem.cs,SetObjectName,The following statement contains a magic number: Utils.StrCpy (obj->Name' name' 32);  
Magic Number,ProcessHacker.Native.Mfs,MemoryFileSystem,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Mfs\MemoryFileSystem.cs,ValidateFsParameters,The following statement contains a magic number: if ((blockSize / cellSize) < 2)  	throw new ArgumentException ("There must be a least 2 cells in each block.");  
Magic Number,ProcessHacker.Native.Mfs,MfsCellId,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Mfs\Internal.cs,GetHashCode,The following statement contains a magic number: return ((Block << 16) | Cell).GetHashCode ();  
Magic Number,ProcessHacker.Native.Objects,EnvironmentBlock,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\EnvironmentBlock.cs,GetVariable,The following statement contains a magic number: try {  	using (var data = new MemoryAlloc (100)) {  		valueStr = new UnicodeString ();  		valueStr.Buffer = data;  		valueStr.MaximumLength = (ushort)data.Size;  		status = Win32.RtlQueryEnvironmentVariable_U (this' ref nameStr' ref valueStr);  		if (status == NtStatus.BufferTooSmall) {  			// Resize and try again (+2 for the null terminator).  			data.ResizeNew (valueStr.Length + 2);  			valueStr.Buffer = data;  			valueStr.MaximumLength = (ushort)(valueStr.Length + 2);  			status = Win32.RtlQueryEnvironmentVariable_U (this' ref nameStr' ref valueStr);  		}  		if (status >= NtStatus.Error)  			Win32.Throw (status);  		return valueStr.Read ();  	}  }  finally {  	nameStr.Dispose ();  }  
Magic Number,ProcessHacker.Native.Objects,EnvironmentBlock,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\EnvironmentBlock.cs,GetVariable,The following statement contains a magic number: try {  	using (var data = new MemoryAlloc (100)) {  		valueStr = new UnicodeString ();  		valueStr.Buffer = data;  		valueStr.MaximumLength = (ushort)data.Size;  		status = Win32.RtlQueryEnvironmentVariable_U (this' ref nameStr' ref valueStr);  		if (status == NtStatus.BufferTooSmall) {  			// Resize and try again (+2 for the null terminator).  			data.ResizeNew (valueStr.Length + 2);  			valueStr.Buffer = data;  			valueStr.MaximumLength = (ushort)(valueStr.Length + 2);  			status = Win32.RtlQueryEnvironmentVariable_U (this' ref nameStr' ref valueStr);  		}  		if (status >= NtStatus.Error)  			Win32.Throw (status);  		return valueStr.Read ();  	}  }  finally {  	nameStr.Dispose ();  }  
Magic Number,ProcessHacker.Native.Objects,EnvironmentBlock,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\EnvironmentBlock.cs,GetVariable,The following statement contains a magic number: try {  	using (var data = new MemoryAlloc (100)) {  		valueStr = new UnicodeString ();  		valueStr.Buffer = data;  		valueStr.MaximumLength = (ushort)data.Size;  		status = Win32.RtlQueryEnvironmentVariable_U (this' ref nameStr' ref valueStr);  		if (status == NtStatus.BufferTooSmall) {  			// Resize and try again (+2 for the null terminator).  			data.ResizeNew (valueStr.Length + 2);  			valueStr.Buffer = data;  			valueStr.MaximumLength = (ushort)(valueStr.Length + 2);  			status = Win32.RtlQueryEnvironmentVariable_U (this' ref nameStr' ref valueStr);  		}  		if (status >= NtStatus.Error)  			Win32.Throw (status);  		return valueStr.Read ();  	}  }  finally {  	nameStr.Dispose ();  }  
Magic Number,ProcessHacker.Native.Objects,EnvironmentBlock,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\EnvironmentBlock.cs,GetVariable,The following statement contains a magic number: using (var data = new MemoryAlloc (100)) {  	valueStr = new UnicodeString ();  	valueStr.Buffer = data;  	valueStr.MaximumLength = (ushort)data.Size;  	status = Win32.RtlQueryEnvironmentVariable_U (this' ref nameStr' ref valueStr);  	if (status == NtStatus.BufferTooSmall) {  		// Resize and try again (+2 for the null terminator).  		data.ResizeNew (valueStr.Length + 2);  		valueStr.Buffer = data;  		valueStr.MaximumLength = (ushort)(valueStr.Length + 2);  		status = Win32.RtlQueryEnvironmentVariable_U (this' ref nameStr' ref valueStr);  	}  	if (status >= NtStatus.Error)  		Win32.Throw (status);  	return valueStr.Read ();  }  
Magic Number,ProcessHacker.Native.Objects,EnvironmentBlock,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\EnvironmentBlock.cs,GetVariable,The following statement contains a magic number: using (var data = new MemoryAlloc (100)) {  	valueStr = new UnicodeString ();  	valueStr.Buffer = data;  	valueStr.MaximumLength = (ushort)data.Size;  	status = Win32.RtlQueryEnvironmentVariable_U (this' ref nameStr' ref valueStr);  	if (status == NtStatus.BufferTooSmall) {  		// Resize and try again (+2 for the null terminator).  		data.ResizeNew (valueStr.Length + 2);  		valueStr.Buffer = data;  		valueStr.MaximumLength = (ushort)(valueStr.Length + 2);  		status = Win32.RtlQueryEnvironmentVariable_U (this' ref nameStr' ref valueStr);  	}  	if (status >= NtStatus.Error)  		Win32.Throw (status);  	return valueStr.Read ();  }  
Magic Number,ProcessHacker.Native.Objects,EnvironmentBlock,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\EnvironmentBlock.cs,GetVariable,The following statement contains a magic number: using (var data = new MemoryAlloc (100)) {  	valueStr = new UnicodeString ();  	valueStr.Buffer = data;  	valueStr.MaximumLength = (ushort)data.Size;  	status = Win32.RtlQueryEnvironmentVariable_U (this' ref nameStr' ref valueStr);  	if (status == NtStatus.BufferTooSmall) {  		// Resize and try again (+2 for the null terminator).  		data.ResizeNew (valueStr.Length + 2);  		valueStr.Buffer = data;  		valueStr.MaximumLength = (ushort)(valueStr.Length + 2);  		status = Win32.RtlQueryEnvironmentVariable_U (this' ref nameStr' ref valueStr);  	}  	if (status >= NtStatus.Error)  		Win32.Throw (status);  	return valueStr.Read ();  }  
Magic Number,ProcessHacker.Native.Objects,EnvironmentBlock,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\EnvironmentBlock.cs,GetVariable,The following statement contains a magic number: if (status == NtStatus.BufferTooSmall) {  	// Resize and try again (+2 for the null terminator).  	data.ResizeNew (valueStr.Length + 2);  	valueStr.Buffer = data;  	valueStr.MaximumLength = (ushort)(valueStr.Length + 2);  	status = Win32.RtlQueryEnvironmentVariable_U (this' ref nameStr' ref valueStr);  }  
Magic Number,ProcessHacker.Native.Objects,EnvironmentBlock,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\EnvironmentBlock.cs,GetVariable,The following statement contains a magic number: if (status == NtStatus.BufferTooSmall) {  	// Resize and try again (+2 for the null terminator).  	data.ResizeNew (valueStr.Length + 2);  	valueStr.Buffer = data;  	valueStr.MaximumLength = (ushort)(valueStr.Length + 2);  	status = Win32.RtlQueryEnvironmentVariable_U (this' ref nameStr' ref valueStr);  }  
Magic Number,ProcessHacker.Native.Objects,EnvironmentBlock,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\EnvironmentBlock.cs,GetVariable,The following statement contains a magic number: data.ResizeNew (valueStr.Length + 2);  
Magic Number,ProcessHacker.Native.Objects,EnvironmentBlock,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\EnvironmentBlock.cs,GetVariable,The following statement contains a magic number: valueStr.MaximumLength = (ushort)(valueStr.Length + 2);  
Magic Number,ProcessHacker.Native.Objects,TransactionHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TransactionHandle.cs,GetDescription,The following statement contains a magic number: using (var data = this.GetPropertiesInformation ()) {  	var propertiesInfo = data.ReadStruct<TransactionPropertiesInformation> ();  	return data.ReadUnicodeString (TransactionPropertiesInformation.DescriptionOffset' propertiesInfo.DescriptionLength / 2);  }  
Magic Number,ProcessHacker.Native.Objects,TransactionHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TransactionHandle.cs,GetDescription,The following statement contains a magic number: return data.ReadUnicodeString (TransactionPropertiesInformation.DescriptionOffset' propertiesInfo.DescriptionLength / 2);  
Magic Number,ProcessHacker.Native.Objects,ResourceManagerHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ResourceManagerHandle.cs,GetDescription,The following statement contains a magic number: using (var data = this.GetBasicInformation ()) {  	var basicInfo = data.ReadStruct<ResourceManagerBasicInformation> ();  	return data.ReadUnicodeString (ResourceManagerBasicInformation.DescriptionOffset' basicInfo.DescriptionLength / 2);  }  
Magic Number,ProcessHacker.Native.Objects,ResourceManagerHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ResourceManagerHandle.cs,GetDescription,The following statement contains a magic number: return data.ReadUnicodeString (ResourceManagerBasicInformation.DescriptionOffset' basicInfo.DescriptionLength / 2);  
Magic Number,ProcessHacker.Native.Objects,TerminalServerSession,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TerminalServerHandle.cs,SendMessage,The following statement contains a magic number: if (!Win32.WTSSendMessage (_serverHandle' _sessionId' title' title.Length * 2' message' message.Length * 2' (int)buttons | (int)icon | (int)defaultButton | (int)options' secondsTimeout' out response' synchronous))  	Win32.Throw ();  
Magic Number,ProcessHacker.Native.Objects,TerminalServerSession,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TerminalServerHandle.cs,SendMessage,The following statement contains a magic number: if (!Win32.WTSSendMessage (_serverHandle' _sessionId' title' title.Length * 2' message' message.Length * 2' (int)buttons | (int)icon | (int)defaultButton | (int)options' secondsTimeout' out response' synchronous))  	Win32.Throw ();  
Magic Number,ProcessHacker.Native.Objects,WindowHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\WindowHandle.cs,GetText,The following statement contains a magic number: using (var data = new MemoryAlloc (0x200)) {  	retChars = Win32.InternalGetWindowText (this' data' data.Size / 2);  	return data.ReadUnicodeString (0' retChars);  }  
Magic Number,ProcessHacker.Native.Objects,WindowHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\WindowHandle.cs,GetText,The following statement contains a magic number: retChars = Win32.InternalGetWindowText (this' data' data.Size / 2);  
Magic Number,ProcessHacker.Native.Objects,DirectoryHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\DirectoryHandle.cs,EnumObjects,The following statement contains a magic number: using (var data = new MemoryAlloc (0x200)) {  	while (true) {  		while ((status = Win32.NtQueryDirectoryObject (this' data' data.Size' false' firstTime' ref context' out retLength)) == NtStatus.MoreEntries) {  			// Check if we have at least one entry. If not'   			// we need to double the buffer size and try again.  			if (data.ReadStruct<ObjectDirectoryInformation> (0).Name.Buffer != IntPtr.Zero)  				break;  			if (data.Size > 16 * 1024 * 1024)  				Win32.Throw (status);  			data.ResizeNew (data.Size * 2);  		}  		if (status >= NtStatus.Error)  			Win32.Throw (status);  		int i = 0;  		while (true) {  			ObjectDirectoryInformation info = data.ReadStruct<ObjectDirectoryInformation> (i);  			if (info.Name.Buffer == IntPtr.Zero)  				break;  			if (!callback (new ObjectEntry (info.Name.Read ()' info.TypeName.Read ())))  				return;  			i++;  		}  		if (status != NtStatus.MoreEntries)  			break;  		firstTime = false;  	}  }  
Magic Number,ProcessHacker.Native.Objects,DirectoryHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\DirectoryHandle.cs,EnumObjects,The following statement contains a magic number: using (var data = new MemoryAlloc (0x200)) {  	while (true) {  		while ((status = Win32.NtQueryDirectoryObject (this' data' data.Size' false' firstTime' ref context' out retLength)) == NtStatus.MoreEntries) {  			// Check if we have at least one entry. If not'   			// we need to double the buffer size and try again.  			if (data.ReadStruct<ObjectDirectoryInformation> (0).Name.Buffer != IntPtr.Zero)  				break;  			if (data.Size > 16 * 1024 * 1024)  				Win32.Throw (status);  			data.ResizeNew (data.Size * 2);  		}  		if (status >= NtStatus.Error)  			Win32.Throw (status);  		int i = 0;  		while (true) {  			ObjectDirectoryInformation info = data.ReadStruct<ObjectDirectoryInformation> (i);  			if (info.Name.Buffer == IntPtr.Zero)  				break;  			if (!callback (new ObjectEntry (info.Name.Read ()' info.TypeName.Read ())))  				return;  			i++;  		}  		if (status != NtStatus.MoreEntries)  			break;  		firstTime = false;  	}  }  
Magic Number,ProcessHacker.Native.Objects,DirectoryHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\DirectoryHandle.cs,EnumObjects,The following statement contains a magic number: using (var data = new MemoryAlloc (0x200)) {  	while (true) {  		while ((status = Win32.NtQueryDirectoryObject (this' data' data.Size' false' firstTime' ref context' out retLength)) == NtStatus.MoreEntries) {  			// Check if we have at least one entry. If not'   			// we need to double the buffer size and try again.  			if (data.ReadStruct<ObjectDirectoryInformation> (0).Name.Buffer != IntPtr.Zero)  				break;  			if (data.Size > 16 * 1024 * 1024)  				Win32.Throw (status);  			data.ResizeNew (data.Size * 2);  		}  		if (status >= NtStatus.Error)  			Win32.Throw (status);  		int i = 0;  		while (true) {  			ObjectDirectoryInformation info = data.ReadStruct<ObjectDirectoryInformation> (i);  			if (info.Name.Buffer == IntPtr.Zero)  				break;  			if (!callback (new ObjectEntry (info.Name.Read ()' info.TypeName.Read ())))  				return;  			i++;  		}  		if (status != NtStatus.MoreEntries)  			break;  		firstTime = false;  	}  }  
Magic Number,ProcessHacker.Native.Objects,DirectoryHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\DirectoryHandle.cs,EnumObjects,The following statement contains a magic number: using (var data = new MemoryAlloc (0x200)) {  	while (true) {  		while ((status = Win32.NtQueryDirectoryObject (this' data' data.Size' false' firstTime' ref context' out retLength)) == NtStatus.MoreEntries) {  			// Check if we have at least one entry. If not'   			// we need to double the buffer size and try again.  			if (data.ReadStruct<ObjectDirectoryInformation> (0).Name.Buffer != IntPtr.Zero)  				break;  			if (data.Size > 16 * 1024 * 1024)  				Win32.Throw (status);  			data.ResizeNew (data.Size * 2);  		}  		if (status >= NtStatus.Error)  			Win32.Throw (status);  		int i = 0;  		while (true) {  			ObjectDirectoryInformation info = data.ReadStruct<ObjectDirectoryInformation> (i);  			if (info.Name.Buffer == IntPtr.Zero)  				break;  			if (!callback (new ObjectEntry (info.Name.Read ()' info.TypeName.Read ())))  				return;  			i++;  		}  		if (status != NtStatus.MoreEntries)  			break;  		firstTime = false;  	}  }  
Magic Number,ProcessHacker.Native.Objects,DirectoryHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\DirectoryHandle.cs,EnumObjects,The following statement contains a magic number: while (true) {  	while ((status = Win32.NtQueryDirectoryObject (this' data' data.Size' false' firstTime' ref context' out retLength)) == NtStatus.MoreEntries) {  		// Check if we have at least one entry. If not'   		// we need to double the buffer size and try again.  		if (data.ReadStruct<ObjectDirectoryInformation> (0).Name.Buffer != IntPtr.Zero)  			break;  		if (data.Size > 16 * 1024 * 1024)  			Win32.Throw (status);  		data.ResizeNew (data.Size * 2);  	}  	if (status >= NtStatus.Error)  		Win32.Throw (status);  	int i = 0;  	while (true) {  		ObjectDirectoryInformation info = data.ReadStruct<ObjectDirectoryInformation> (i);  		if (info.Name.Buffer == IntPtr.Zero)  			break;  		if (!callback (new ObjectEntry (info.Name.Read ()' info.TypeName.Read ())))  			return;  		i++;  	}  	if (status != NtStatus.MoreEntries)  		break;  	firstTime = false;  }  
Magic Number,ProcessHacker.Native.Objects,DirectoryHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\DirectoryHandle.cs,EnumObjects,The following statement contains a magic number: while (true) {  	while ((status = Win32.NtQueryDirectoryObject (this' data' data.Size' false' firstTime' ref context' out retLength)) == NtStatus.MoreEntries) {  		// Check if we have at least one entry. If not'   		// we need to double the buffer size and try again.  		if (data.ReadStruct<ObjectDirectoryInformation> (0).Name.Buffer != IntPtr.Zero)  			break;  		if (data.Size > 16 * 1024 * 1024)  			Win32.Throw (status);  		data.ResizeNew (data.Size * 2);  	}  	if (status >= NtStatus.Error)  		Win32.Throw (status);  	int i = 0;  	while (true) {  		ObjectDirectoryInformation info = data.ReadStruct<ObjectDirectoryInformation> (i);  		if (info.Name.Buffer == IntPtr.Zero)  			break;  		if (!callback (new ObjectEntry (info.Name.Read ()' info.TypeName.Read ())))  			return;  		i++;  	}  	if (status != NtStatus.MoreEntries)  		break;  	firstTime = false;  }  
Magic Number,ProcessHacker.Native.Objects,DirectoryHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\DirectoryHandle.cs,EnumObjects,The following statement contains a magic number: while (true) {  	while ((status = Win32.NtQueryDirectoryObject (this' data' data.Size' false' firstTime' ref context' out retLength)) == NtStatus.MoreEntries) {  		// Check if we have at least one entry. If not'   		// we need to double the buffer size and try again.  		if (data.ReadStruct<ObjectDirectoryInformation> (0).Name.Buffer != IntPtr.Zero)  			break;  		if (data.Size > 16 * 1024 * 1024)  			Win32.Throw (status);  		data.ResizeNew (data.Size * 2);  	}  	if (status >= NtStatus.Error)  		Win32.Throw (status);  	int i = 0;  	while (true) {  		ObjectDirectoryInformation info = data.ReadStruct<ObjectDirectoryInformation> (i);  		if (info.Name.Buffer == IntPtr.Zero)  			break;  		if (!callback (new ObjectEntry (info.Name.Read ()' info.TypeName.Read ())))  			return;  		i++;  	}  	if (status != NtStatus.MoreEntries)  		break;  	firstTime = false;  }  
Magic Number,ProcessHacker.Native.Objects,DirectoryHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\DirectoryHandle.cs,EnumObjects,The following statement contains a magic number: while (true) {  	while ((status = Win32.NtQueryDirectoryObject (this' data' data.Size' false' firstTime' ref context' out retLength)) == NtStatus.MoreEntries) {  		// Check if we have at least one entry. If not'   		// we need to double the buffer size and try again.  		if (data.ReadStruct<ObjectDirectoryInformation> (0).Name.Buffer != IntPtr.Zero)  			break;  		if (data.Size > 16 * 1024 * 1024)  			Win32.Throw (status);  		data.ResizeNew (data.Size * 2);  	}  	if (status >= NtStatus.Error)  		Win32.Throw (status);  	int i = 0;  	while (true) {  		ObjectDirectoryInformation info = data.ReadStruct<ObjectDirectoryInformation> (i);  		if (info.Name.Buffer == IntPtr.Zero)  			break;  		if (!callback (new ObjectEntry (info.Name.Read ()' info.TypeName.Read ())))  			return;  		i++;  	}  	if (status != NtStatus.MoreEntries)  		break;  	firstTime = false;  }  
Magic Number,ProcessHacker.Native.Objects,DirectoryHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\DirectoryHandle.cs,EnumObjects,The following statement contains a magic number: while ((status = Win32.NtQueryDirectoryObject (this' data' data.Size' false' firstTime' ref context' out retLength)) == NtStatus.MoreEntries) {  	// Check if we have at least one entry. If not'   	// we need to double the buffer size and try again.  	if (data.ReadStruct<ObjectDirectoryInformation> (0).Name.Buffer != IntPtr.Zero)  		break;  	if (data.Size > 16 * 1024 * 1024)  		Win32.Throw (status);  	data.ResizeNew (data.Size * 2);  }  
Magic Number,ProcessHacker.Native.Objects,DirectoryHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\DirectoryHandle.cs,EnumObjects,The following statement contains a magic number: while ((status = Win32.NtQueryDirectoryObject (this' data' data.Size' false' firstTime' ref context' out retLength)) == NtStatus.MoreEntries) {  	// Check if we have at least one entry. If not'   	// we need to double the buffer size and try again.  	if (data.ReadStruct<ObjectDirectoryInformation> (0).Name.Buffer != IntPtr.Zero)  		break;  	if (data.Size > 16 * 1024 * 1024)  		Win32.Throw (status);  	data.ResizeNew (data.Size * 2);  }  
Magic Number,ProcessHacker.Native.Objects,DirectoryHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\DirectoryHandle.cs,EnumObjects,The following statement contains a magic number: while ((status = Win32.NtQueryDirectoryObject (this' data' data.Size' false' firstTime' ref context' out retLength)) == NtStatus.MoreEntries) {  	// Check if we have at least one entry. If not'   	// we need to double the buffer size and try again.  	if (data.ReadStruct<ObjectDirectoryInformation> (0).Name.Buffer != IntPtr.Zero)  		break;  	if (data.Size > 16 * 1024 * 1024)  		Win32.Throw (status);  	data.ResizeNew (data.Size * 2);  }  
Magic Number,ProcessHacker.Native.Objects,DirectoryHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\DirectoryHandle.cs,EnumObjects,The following statement contains a magic number: while ((status = Win32.NtQueryDirectoryObject (this' data' data.Size' false' firstTime' ref context' out retLength)) == NtStatus.MoreEntries) {  	// Check if we have at least one entry. If not'   	// we need to double the buffer size and try again.  	if (data.ReadStruct<ObjectDirectoryInformation> (0).Name.Buffer != IntPtr.Zero)  		break;  	if (data.Size > 16 * 1024 * 1024)  		Win32.Throw (status);  	data.ResizeNew (data.Size * 2);  }  
Magic Number,ProcessHacker.Native.Objects,DirectoryHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\DirectoryHandle.cs,EnumObjects,The following statement contains a magic number: if (data.Size > 16 * 1024 * 1024)  	Win32.Throw (status);  
Magic Number,ProcessHacker.Native.Objects,DirectoryHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\DirectoryHandle.cs,EnumObjects,The following statement contains a magic number: if (data.Size > 16 * 1024 * 1024)  	Win32.Throw (status);  
Magic Number,ProcessHacker.Native.Objects,DirectoryHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\DirectoryHandle.cs,EnumObjects,The following statement contains a magic number: if (data.Size > 16 * 1024 * 1024)  	Win32.Throw (status);  
Magic Number,ProcessHacker.Native.Objects,DirectoryHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\DirectoryHandle.cs,EnumObjects,The following statement contains a magic number: data.ResizeNew (data.Size * 2);  
Magic Number,ProcessHacker.Native.Objects,KeyedEventHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\KeyedEventHandle.cs,ReleaseKey,The following statement contains a magic number: if (key.ToInt64 () % 2 != 0)  	throw new ArgumentException ("Key must be divisible by 2.");  
Magic Number,ProcessHacker.Native.Objects,KeyedEventHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\KeyedEventHandle.cs,WaitKey,The following statement contains a magic number: if (key.ToInt64 () % 2 != 0)  	throw new ArgumentException ("Key must be divisible by 2.");  
Magic Number,ProcessHacker.Native.Objects,ProfileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProfileHandle.cs,Create,The following statement contains a magic number: if (bucketSize < 2 || bucketSize > 30)  	throw new ArgumentException ("Bucket size must be between 2 and 30' inclusive.");  
Magic Number,ProcessHacker.Native.Objects,ProfileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProfileHandle.cs,Create,The following statement contains a magic number: if (bucketSize < 2 || bucketSize > 30)  	throw new ArgumentException ("Bucket size must be between 2 and 30' inclusive.");  
Magic Number,ProcessHacker.Native.Objects,ProfileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProfileHandle.cs,Create,The following statement contains a magic number: unchecked {  	uint realBucketSize = (uint)(2 << (bucketSize - 1));  	MemoryAlloc buffer = new MemoryAlloc ((int)((rangeSize - 1) / realBucketSize + 1) * sizeof(int));  	// divide' round up  	if ((status = Win32.NtCreateProfile (out handle' processHandle ?? IntPtr.Zero' rangeBase' new IntPtr (rangeSize)' bucketSize' buffer' buffer.Size' profileSource' affinity)) >= NtStatus.Error)  		Win32.Throw (status);  	return new ProfileHandle (handle' true' rangeBase' rangeSize' realBucketSize' buffer);  }  
Magic Number,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,EnumFiles,The following statement contains a magic number: try {  	using (var data = new MemoryAlloc (0x400)) {  		while (true) {  			// Query the directory' doubling the buffer size each   			// time NtQueryDirectoryFile fails. We will also handle   			// any pending status.  			while (true) {  				unsafe {  					status = Win32.NtQueryDirectoryFile (this' IntPtr.Zero' null' IntPtr.Zero' out isb' data' data.Size' FileInformationClass.FileDirectoryInformation' false' searchPattern == null ? IntPtr.Zero : new IntPtr (&searchPatternStr)' firstTime);  				}  				// Our ISB is on the stack' so we have to wait for the operation to complete   				// before continuing.  				if (status == NtStatus.Pending) {  					this.Wait ();  					status = isb.Status;  				}  				if (status == NtStatus.BufferOverflow || status == NtStatus.InfoLengthMismatch)  					data.ResizeNew (data.Size * 2);  				else  					break;  			}  			// If we don't have any entries to read' exit.  			if (status == NtStatus.NoMoreFiles)  				break;  			// Handle any errors.  			if (status >= NtStatus.Error)  				Win32.Throw (status);  			// Read the list of files we got in this batch.  			int i = 0;  			while (true) {  				FileDirectoryInformation info = data.ReadStruct<FileDirectoryInformation> (i' 0);  				string name = data.ReadUnicodeString (i + FileDirectoryInformation.FileNameOffset' info.FileNameLength / 2);  				if (!callback (new FileEntry (name' info.FileIndex' DateTime.FromFileTime (info.CreationTime)' DateTime.FromFileTime (info.LastAccessTime)' DateTime.FromFileTime (info.LastWriteTime)' DateTime.FromFileTime (info.ChangeTime)' info.EndOfFile' info.AllocationSize' info.FileAttributes)))  					return;  				if (info.NextEntryOffset == 0)  					break;  				else  					i += info.NextEntryOffset;  			}  			firstTime = false;  			// Go back and get another batch of file entries.  		}  	}  }  finally {  	if (searchPattern != null)  		searchPatternStr.Dispose ();  }  
Magic Number,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,EnumFiles,The following statement contains a magic number: try {  	using (var data = new MemoryAlloc (0x400)) {  		while (true) {  			// Query the directory' doubling the buffer size each   			// time NtQueryDirectoryFile fails. We will also handle   			// any pending status.  			while (true) {  				unsafe {  					status = Win32.NtQueryDirectoryFile (this' IntPtr.Zero' null' IntPtr.Zero' out isb' data' data.Size' FileInformationClass.FileDirectoryInformation' false' searchPattern == null ? IntPtr.Zero : new IntPtr (&searchPatternStr)' firstTime);  				}  				// Our ISB is on the stack' so we have to wait for the operation to complete   				// before continuing.  				if (status == NtStatus.Pending) {  					this.Wait ();  					status = isb.Status;  				}  				if (status == NtStatus.BufferOverflow || status == NtStatus.InfoLengthMismatch)  					data.ResizeNew (data.Size * 2);  				else  					break;  			}  			// If we don't have any entries to read' exit.  			if (status == NtStatus.NoMoreFiles)  				break;  			// Handle any errors.  			if (status >= NtStatus.Error)  				Win32.Throw (status);  			// Read the list of files we got in this batch.  			int i = 0;  			while (true) {  				FileDirectoryInformation info = data.ReadStruct<FileDirectoryInformation> (i' 0);  				string name = data.ReadUnicodeString (i + FileDirectoryInformation.FileNameOffset' info.FileNameLength / 2);  				if (!callback (new FileEntry (name' info.FileIndex' DateTime.FromFileTime (info.CreationTime)' DateTime.FromFileTime (info.LastAccessTime)' DateTime.FromFileTime (info.LastWriteTime)' DateTime.FromFileTime (info.ChangeTime)' info.EndOfFile' info.AllocationSize' info.FileAttributes)))  					return;  				if (info.NextEntryOffset == 0)  					break;  				else  					i += info.NextEntryOffset;  			}  			firstTime = false;  			// Go back and get another batch of file entries.  		}  	}  }  finally {  	if (searchPattern != null)  		searchPatternStr.Dispose ();  }  
Magic Number,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,EnumFiles,The following statement contains a magic number: using (var data = new MemoryAlloc (0x400)) {  	while (true) {  		// Query the directory' doubling the buffer size each   		// time NtQueryDirectoryFile fails. We will also handle   		// any pending status.  		while (true) {  			unsafe {  				status = Win32.NtQueryDirectoryFile (this' IntPtr.Zero' null' IntPtr.Zero' out isb' data' data.Size' FileInformationClass.FileDirectoryInformation' false' searchPattern == null ? IntPtr.Zero : new IntPtr (&searchPatternStr)' firstTime);  			}  			// Our ISB is on the stack' so we have to wait for the operation to complete   			// before continuing.  			if (status == NtStatus.Pending) {  				this.Wait ();  				status = isb.Status;  			}  			if (status == NtStatus.BufferOverflow || status == NtStatus.InfoLengthMismatch)  				data.ResizeNew (data.Size * 2);  			else  				break;  		}  		// If we don't have any entries to read' exit.  		if (status == NtStatus.NoMoreFiles)  			break;  		// Handle any errors.  		if (status >= NtStatus.Error)  			Win32.Throw (status);  		// Read the list of files we got in this batch.  		int i = 0;  		while (true) {  			FileDirectoryInformation info = data.ReadStruct<FileDirectoryInformation> (i' 0);  			string name = data.ReadUnicodeString (i + FileDirectoryInformation.FileNameOffset' info.FileNameLength / 2);  			if (!callback (new FileEntry (name' info.FileIndex' DateTime.FromFileTime (info.CreationTime)' DateTime.FromFileTime (info.LastAccessTime)' DateTime.FromFileTime (info.LastWriteTime)' DateTime.FromFileTime (info.ChangeTime)' info.EndOfFile' info.AllocationSize' info.FileAttributes)))  				return;  			if (info.NextEntryOffset == 0)  				break;  			else  				i += info.NextEntryOffset;  		}  		firstTime = false;  		// Go back and get another batch of file entries.  	}  }  
Magic Number,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,EnumFiles,The following statement contains a magic number: using (var data = new MemoryAlloc (0x400)) {  	while (true) {  		// Query the directory' doubling the buffer size each   		// time NtQueryDirectoryFile fails. We will also handle   		// any pending status.  		while (true) {  			unsafe {  				status = Win32.NtQueryDirectoryFile (this' IntPtr.Zero' null' IntPtr.Zero' out isb' data' data.Size' FileInformationClass.FileDirectoryInformation' false' searchPattern == null ? IntPtr.Zero : new IntPtr (&searchPatternStr)' firstTime);  			}  			// Our ISB is on the stack' so we have to wait for the operation to complete   			// before continuing.  			if (status == NtStatus.Pending) {  				this.Wait ();  				status = isb.Status;  			}  			if (status == NtStatus.BufferOverflow || status == NtStatus.InfoLengthMismatch)  				data.ResizeNew (data.Size * 2);  			else  				break;  		}  		// If we don't have any entries to read' exit.  		if (status == NtStatus.NoMoreFiles)  			break;  		// Handle any errors.  		if (status >= NtStatus.Error)  			Win32.Throw (status);  		// Read the list of files we got in this batch.  		int i = 0;  		while (true) {  			FileDirectoryInformation info = data.ReadStruct<FileDirectoryInformation> (i' 0);  			string name = data.ReadUnicodeString (i + FileDirectoryInformation.FileNameOffset' info.FileNameLength / 2);  			if (!callback (new FileEntry (name' info.FileIndex' DateTime.FromFileTime (info.CreationTime)' DateTime.FromFileTime (info.LastAccessTime)' DateTime.FromFileTime (info.LastWriteTime)' DateTime.FromFileTime (info.ChangeTime)' info.EndOfFile' info.AllocationSize' info.FileAttributes)))  				return;  			if (info.NextEntryOffset == 0)  				break;  			else  				i += info.NextEntryOffset;  		}  		firstTime = false;  		// Go back and get another batch of file entries.  	}  }  
Magic Number,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,EnumFiles,The following statement contains a magic number: while (true) {  	// Query the directory' doubling the buffer size each   	// time NtQueryDirectoryFile fails. We will also handle   	// any pending status.  	while (true) {  		unsafe {  			status = Win32.NtQueryDirectoryFile (this' IntPtr.Zero' null' IntPtr.Zero' out isb' data' data.Size' FileInformationClass.FileDirectoryInformation' false' searchPattern == null ? IntPtr.Zero : new IntPtr (&searchPatternStr)' firstTime);  		}  		// Our ISB is on the stack' so we have to wait for the operation to complete   		// before continuing.  		if (status == NtStatus.Pending) {  			this.Wait ();  			status = isb.Status;  		}  		if (status == NtStatus.BufferOverflow || status == NtStatus.InfoLengthMismatch)  			data.ResizeNew (data.Size * 2);  		else  			break;  	}  	// If we don't have any entries to read' exit.  	if (status == NtStatus.NoMoreFiles)  		break;  	// Handle any errors.  	if (status >= NtStatus.Error)  		Win32.Throw (status);  	// Read the list of files we got in this batch.  	int i = 0;  	while (true) {  		FileDirectoryInformation info = data.ReadStruct<FileDirectoryInformation> (i' 0);  		string name = data.ReadUnicodeString (i + FileDirectoryInformation.FileNameOffset' info.FileNameLength / 2);  		if (!callback (new FileEntry (name' info.FileIndex' DateTime.FromFileTime (info.CreationTime)' DateTime.FromFileTime (info.LastAccessTime)' DateTime.FromFileTime (info.LastWriteTime)' DateTime.FromFileTime (info.ChangeTime)' info.EndOfFile' info.AllocationSize' info.FileAttributes)))  			return;  		if (info.NextEntryOffset == 0)  			break;  		else  			i += info.NextEntryOffset;  	}  	firstTime = false;  	// Go back and get another batch of file entries.  }  
Magic Number,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,EnumFiles,The following statement contains a magic number: while (true) {  	// Query the directory' doubling the buffer size each   	// time NtQueryDirectoryFile fails. We will also handle   	// any pending status.  	while (true) {  		unsafe {  			status = Win32.NtQueryDirectoryFile (this' IntPtr.Zero' null' IntPtr.Zero' out isb' data' data.Size' FileInformationClass.FileDirectoryInformation' false' searchPattern == null ? IntPtr.Zero : new IntPtr (&searchPatternStr)' firstTime);  		}  		// Our ISB is on the stack' so we have to wait for the operation to complete   		// before continuing.  		if (status == NtStatus.Pending) {  			this.Wait ();  			status = isb.Status;  		}  		if (status == NtStatus.BufferOverflow || status == NtStatus.InfoLengthMismatch)  			data.ResizeNew (data.Size * 2);  		else  			break;  	}  	// If we don't have any entries to read' exit.  	if (status == NtStatus.NoMoreFiles)  		break;  	// Handle any errors.  	if (status >= NtStatus.Error)  		Win32.Throw (status);  	// Read the list of files we got in this batch.  	int i = 0;  	while (true) {  		FileDirectoryInformation info = data.ReadStruct<FileDirectoryInformation> (i' 0);  		string name = data.ReadUnicodeString (i + FileDirectoryInformation.FileNameOffset' info.FileNameLength / 2);  		if (!callback (new FileEntry (name' info.FileIndex' DateTime.FromFileTime (info.CreationTime)' DateTime.FromFileTime (info.LastAccessTime)' DateTime.FromFileTime (info.LastWriteTime)' DateTime.FromFileTime (info.ChangeTime)' info.EndOfFile' info.AllocationSize' info.FileAttributes)))  			return;  		if (info.NextEntryOffset == 0)  			break;  		else  			i += info.NextEntryOffset;  	}  	firstTime = false;  	// Go back and get another batch of file entries.  }  
Magic Number,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,EnumFiles,The following statement contains a magic number: while (true) {  	unsafe {  		status = Win32.NtQueryDirectoryFile (this' IntPtr.Zero' null' IntPtr.Zero' out isb' data' data.Size' FileInformationClass.FileDirectoryInformation' false' searchPattern == null ? IntPtr.Zero : new IntPtr (&searchPatternStr)' firstTime);  	}  	// Our ISB is on the stack' so we have to wait for the operation to complete   	// before continuing.  	if (status == NtStatus.Pending) {  		this.Wait ();  		status = isb.Status;  	}  	if (status == NtStatus.BufferOverflow || status == NtStatus.InfoLengthMismatch)  		data.ResizeNew (data.Size * 2);  	else  		break;  }  
Magic Number,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,EnumFiles,The following statement contains a magic number: if (status == NtStatus.BufferOverflow || status == NtStatus.InfoLengthMismatch)  	data.ResizeNew (data.Size * 2);  else  	break;  
Magic Number,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,EnumFiles,The following statement contains a magic number: data.ResizeNew (data.Size * 2);  
Magic Number,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,EnumFiles,The following statement contains a magic number: while (true) {  	FileDirectoryInformation info = data.ReadStruct<FileDirectoryInformation> (i' 0);  	string name = data.ReadUnicodeString (i + FileDirectoryInformation.FileNameOffset' info.FileNameLength / 2);  	if (!callback (new FileEntry (name' info.FileIndex' DateTime.FromFileTime (info.CreationTime)' DateTime.FromFileTime (info.LastAccessTime)' DateTime.FromFileTime (info.LastWriteTime)' DateTime.FromFileTime (info.ChangeTime)' info.EndOfFile' info.AllocationSize' info.FileAttributes)))  		return;  	if (info.NextEntryOffset == 0)  		break;  	else  		i += info.NextEntryOffset;  }  
Magic Number,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,EnumStreams,The following statement contains a magic number: using (var data = this.QueryVariableSize (FileInformationClass.FileStreamInformation)) {  	int i = 0;  	while (true) {  		FileStreamInformation info = data.ReadStruct<FileStreamInformation> (i' 0);  		string name = data.ReadUnicodeString (i + FileStreamInformation.StreamNameOffset' info.StreamNameLength / 2);  		if (!callback (new FileStreamEntry (name' info.StreamSize' info.StreamAllocationSize)))  			return;  		if (info.NextEntryOffset == 0)  			break;  		else  			i += info.NextEntryOffset;  	}  }  
Magic Number,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,EnumStreams,The following statement contains a magic number: while (true) {  	FileStreamInformation info = data.ReadStruct<FileStreamInformation> (i' 0);  	string name = data.ReadUnicodeString (i + FileStreamInformation.StreamNameOffset' info.StreamNameLength / 2);  	if (!callback (new FileStreamEntry (name' info.StreamSize' info.StreamAllocationSize)))  		return;  	if (info.NextEntryOffset == 0)  		break;  	else  		i += info.NextEntryOffset;  }  
Magic Number,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,GetFileName,The following statement contains a magic number: using (var data = this.QueryVariableSize (FileInformationClass.FileNameInformation)) {  	FileNameInformation info = data.ReadStruct<FileNameInformation> ();  	return data.ReadUnicodeString (FileNameInformation.FileNameOffset' info.FileNameLength / 2);  }  
Magic Number,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,GetFileName,The following statement contains a magic number: return data.ReadUnicodeString (FileNameInformation.FileNameOffset' info.FileNameLength / 2);  
Magic Number,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,GetVolumeFsName,The following statement contains a magic number: using (var data = new MemoryAlloc (0x200)) {  	if ((status = Win32.NtQueryVolumeInformationFile (this' out isb' data' data.Size' FsInformationClass.FileFsAttributeInformation)) >= NtStatus.Error)  		Win32.Throw (status);  	FileFsAttributeInformation info = data.ReadStruct<FileFsAttributeInformation> ();  	return Marshal.PtrToStringUni (data.Memory.Increment (Marshal.OffsetOf (typeof(FileFsAttributeInformation)' "FileSystemName"))' info.FileSystemNameLength / 2);  }  
Magic Number,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,GetVolumeFsName,The following statement contains a magic number: return Marshal.PtrToStringUni (data.Memory.Increment (Marshal.OffsetOf (typeof(FileFsAttributeInformation)' "FileSystemName"))' info.FileSystemNameLength / 2);  
Magic Number,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,GetVolumeLabel,The following statement contains a magic number: using (var data = new MemoryAlloc (0x200)) {  	if ((status = Win32.NtQueryVolumeInformationFile (this' out isb' data' data.Size' FsInformationClass.FileFsVolumeInformation)) >= NtStatus.Error)  		Win32.Throw (status);  	FileFsVolumeInformation info = data.ReadStruct<FileFsVolumeInformation> ();  	return Marshal.PtrToStringUni (data.Memory.Increment (Marshal.OffsetOf (typeof(FileFsVolumeInformation)' "VolumeLabel"))' info.VolumeLabelLength / 2);  }  
Magic Number,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,GetVolumeLabel,The following statement contains a magic number: return Marshal.PtrToStringUni (data.Memory.Increment (Marshal.OffsetOf (typeof(FileFsVolumeInformation)' "VolumeLabel"))' info.VolumeLabelLength / 2);  
Magic Number,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,QueryVariableSize,The following statement contains a magic number: while (true) {  	status = Win32.NtQueryInformationFile (this' out isb' data' data.Size' infoClass);  	if (status == NtStatus.BufferOverflow || status == NtStatus.BufferTooSmall || status == NtStatus.InfoLengthMismatch)  		data.ResizeNew (data.Size * 2);  	else  		break;  }  
Magic Number,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,QueryVariableSize,The following statement contains a magic number: if (status == NtStatus.BufferOverflow || status == NtStatus.BufferTooSmall || status == NtStatus.InfoLengthMismatch)  	data.ResizeNew (data.Size * 2);  else  	break;  
Magic Number,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,QueryVariableSize,The following statement contains a magic number: data.ResizeNew (data.Size * 2);  
Magic Number,ProcessHacker.Native.Objects,JobObjectHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\JobObjectHandle.cs,GetProcessIdList,The following statement contains a magic number: using (MemoryAlloc data = new MemoryAlloc (0x1000)) {  	if (!Win32.QueryInformationJobObject (this' JobObjectInformationClass.JobObjectBasicProcessIdList' data' data.Size' out retLength))  		Win32.Throw ();  	JobObjectBasicProcessIdList listInfo = data.ReadStruct<JobObjectBasicProcessIdList> ();  	for (int i = 0; i < listInfo.NumberOfProcessIdsInList; i++) {  		processIds.Add (data.ReadInt32 (8' i));  	}  }  
Magic Number,ProcessHacker.Native.Objects,JobObjectHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\JobObjectHandle.cs,GetProcessIdList,The following statement contains a magic number: for (int i = 0; i < listInfo.NumberOfProcessIdsInList; i++) {  	processIds.Add (data.ReadInt32 (8' i));  }  
Magic Number,ProcessHacker.Native.Objects,JobObjectHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\JobObjectHandle.cs,GetProcessIdList,The following statement contains a magic number: processIds.Add (data.ReadInt32 (8' i));  
Magic Number,ProcessHacker.Native.Objects,JobObjectHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\JobObjectHandle.cs,GetBasicUiRestrictions,The following statement contains a magic number: if (!Win32.QueryInformationJobObject (this' JobObjectInformationClass.JobObjectBasicUIRestrictions' out uiRestrictions' 4' out retLength))  	Win32.Throw ();  
Magic Number,ProcessHacker.Native.Objects,NamedPipeHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\NamedPipeHandle.cs,Create,The following statement contains a magic number: if (defaultTimeout == 0)  	defaultTimeout = -50 * Win32.TimeMsTo100Ns;  
Magic Number,ProcessHacker.Native.Objects,NamedPipeHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\NamedPipeHandle.cs,Create,The following statement contains a magic number: defaultTimeout = -50 * Win32.TimeMsTo100Ns;  
Magic Number,ProcessHacker.Native.Objects,NamedPipeHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\NamedPipeHandle.cs,Wait,The following statement contains a magic number: using (var npfsHandle = new FileHandle (Win32.NamedPipePath + "\\"' FileShareMode.ReadWrite' FileCreateOptions.SynchronousIoNonAlert' FileAccess.ReadAttributes | (FileAccess)StandardRights.Synchronize)) {  	using (var data = new MemoryAlloc (FilePipeWaitForBuffer.NameOffset + name.Length * 2)) {  		FilePipeWaitForBuffer info = new FilePipeWaitForBuffer ();  		info.Timeout = timeout;  		info.TimeoutSpecified = true;  		info.NameLength = name.Length * 2;  		data.WriteStruct<FilePipeWaitForBuffer> (info);  		data.WriteUnicodeString (FilePipeWaitForBuffer.NameOffset' name);  		NtStatus status;  		int returnLength;  		status = npfsHandle.FsControl (FsCtlWait' data' data.Size' IntPtr.Zero' 0' out returnLength);  		if (status == NtStatus.IoTimeout)  			return false;  		if (status >= NtStatus.Error)  			Win32.Throw (status);  		return true;  	}  }  
Magic Number,ProcessHacker.Native.Objects,NamedPipeHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\NamedPipeHandle.cs,Wait,The following statement contains a magic number: using (var npfsHandle = new FileHandle (Win32.NamedPipePath + "\\"' FileShareMode.ReadWrite' FileCreateOptions.SynchronousIoNonAlert' FileAccess.ReadAttributes | (FileAccess)StandardRights.Synchronize)) {  	using (var data = new MemoryAlloc (FilePipeWaitForBuffer.NameOffset + name.Length * 2)) {  		FilePipeWaitForBuffer info = new FilePipeWaitForBuffer ();  		info.Timeout = timeout;  		info.TimeoutSpecified = true;  		info.NameLength = name.Length * 2;  		data.WriteStruct<FilePipeWaitForBuffer> (info);  		data.WriteUnicodeString (FilePipeWaitForBuffer.NameOffset' name);  		NtStatus status;  		int returnLength;  		status = npfsHandle.FsControl (FsCtlWait' data' data.Size' IntPtr.Zero' 0' out returnLength);  		if (status == NtStatus.IoTimeout)  			return false;  		if (status >= NtStatus.Error)  			Win32.Throw (status);  		return true;  	}  }  
Magic Number,ProcessHacker.Native.Objects,NamedPipeHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\NamedPipeHandle.cs,Wait,The following statement contains a magic number: using (var data = new MemoryAlloc (FilePipeWaitForBuffer.NameOffset + name.Length * 2)) {  	FilePipeWaitForBuffer info = new FilePipeWaitForBuffer ();  	info.Timeout = timeout;  	info.TimeoutSpecified = true;  	info.NameLength = name.Length * 2;  	data.WriteStruct<FilePipeWaitForBuffer> (info);  	data.WriteUnicodeString (FilePipeWaitForBuffer.NameOffset' name);  	NtStatus status;  	int returnLength;  	status = npfsHandle.FsControl (FsCtlWait' data' data.Size' IntPtr.Zero' 0' out returnLength);  	if (status == NtStatus.IoTimeout)  		return false;  	if (status >= NtStatus.Error)  		Win32.Throw (status);  	return true;  }  
Magic Number,ProcessHacker.Native.Objects,NamedPipeHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\NamedPipeHandle.cs,Wait,The following statement contains a magic number: using (var data = new MemoryAlloc (FilePipeWaitForBuffer.NameOffset + name.Length * 2)) {  	FilePipeWaitForBuffer info = new FilePipeWaitForBuffer ();  	info.Timeout = timeout;  	info.TimeoutSpecified = true;  	info.NameLength = name.Length * 2;  	data.WriteStruct<FilePipeWaitForBuffer> (info);  	data.WriteUnicodeString (FilePipeWaitForBuffer.NameOffset' name);  	NtStatus status;  	int returnLength;  	status = npfsHandle.FsControl (FsCtlWait' data' data.Size' IntPtr.Zero' 0' out returnLength);  	if (status == NtStatus.IoTimeout)  		return false;  	if (status >= NtStatus.Error)  		Win32.Throw (status);  	return true;  }  
Magic Number,ProcessHacker.Native.Objects,NamedPipeHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\NamedPipeHandle.cs,Wait,The following statement contains a magic number: info.NameLength = name.Length * 2;  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,CreateExtended,The following statement contains a magic number: if (notifyCsr) {  	BaseCreateProcessMsg processMsg = new BaseCreateProcessMsg ();  	processMsg.ProcessHandle = phandle;  	processMsg.ThreadHandle = thandle;  	processMsg.ClientId = clientId;  	processMsg.CreationFlags = creationFlags;  	if ((creationFlags & (ProcessCreationFlags.DebugProcess | ProcessCreationFlags.DebugOnlyThisProcess)) != 0) {  		NtStatus status;  		status = Win32.DbgUiConnectToDbg ();  		if (status >= NtStatus.Error) {  			phandle.Terminate (status);  			Win32.Throw (status);  		}  		processMsg.DebuggerClientId = ThreadHandle.GetCurrentCid ();  	}  	// If this is a GUI program' set the 1 and 2 bits to turn the   	// hourglass cursor on.  	if (imageInfo.ImageSubsystem == 2)  		processMsg.ProcessHandle = processMsg.ProcessHandle.Or ((1 | 2).ToIntPtr ());  	// We still have to honor the startup info settings' though.  	if ((startupInfo.Flags & StartupFlags.ForceOnFeedback) == StartupFlags.ForceOnFeedback)  		processMsg.ProcessHandle = processMsg.ProcessHandle.Or ((1).ToIntPtr ());  	if ((startupInfo.Flags & StartupFlags.ForceOffFeedback) == StartupFlags.ForceOffFeedback)  		processMsg.ProcessHandle = processMsg.ProcessHandle.And ((1).ToIntPtr ().Not ());  	using (var data = new MemoryAlloc (CsrApiMsg.ApiMessageDataOffset + Marshal.SizeOf (typeof(BaseCreateProcessMsg)))) {  		data.WriteStruct<BaseCreateProcessMsg> (CsrApiMsg.ApiMessageDataOffset' 0' processMsg);  		Win32.CsrClientCallServer (data' IntPtr.Zero' Win32.CsrMakeApiNumber (Win32.BaseSrvServerDllIndex' (int)BaseSrvApiNumber.BasepCreateProcess)' Marshal.SizeOf (typeof(BaseCreateProcessMsg)));  		NtStatus status = (NtStatus)data.ReadStruct<CsrApiMsg> ().ReturnValue;  		if (status >= NtStatus.Error) {  			phandle.Terminate (status);  			Win32.Throw (status);  		}  	}  }  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,CreateExtended,The following statement contains a magic number: if (notifyCsr) {  	BaseCreateProcessMsg processMsg = new BaseCreateProcessMsg ();  	processMsg.ProcessHandle = phandle;  	processMsg.ThreadHandle = thandle;  	processMsg.ClientId = clientId;  	processMsg.CreationFlags = creationFlags;  	if ((creationFlags & (ProcessCreationFlags.DebugProcess | ProcessCreationFlags.DebugOnlyThisProcess)) != 0) {  		NtStatus status;  		status = Win32.DbgUiConnectToDbg ();  		if (status >= NtStatus.Error) {  			phandle.Terminate (status);  			Win32.Throw (status);  		}  		processMsg.DebuggerClientId = ThreadHandle.GetCurrentCid ();  	}  	// If this is a GUI program' set the 1 and 2 bits to turn the   	// hourglass cursor on.  	if (imageInfo.ImageSubsystem == 2)  		processMsg.ProcessHandle = processMsg.ProcessHandle.Or ((1 | 2).ToIntPtr ());  	// We still have to honor the startup info settings' though.  	if ((startupInfo.Flags & StartupFlags.ForceOnFeedback) == StartupFlags.ForceOnFeedback)  		processMsg.ProcessHandle = processMsg.ProcessHandle.Or ((1).ToIntPtr ());  	if ((startupInfo.Flags & StartupFlags.ForceOffFeedback) == StartupFlags.ForceOffFeedback)  		processMsg.ProcessHandle = processMsg.ProcessHandle.And ((1).ToIntPtr ().Not ());  	using (var data = new MemoryAlloc (CsrApiMsg.ApiMessageDataOffset + Marshal.SizeOf (typeof(BaseCreateProcessMsg)))) {  		data.WriteStruct<BaseCreateProcessMsg> (CsrApiMsg.ApiMessageDataOffset' 0' processMsg);  		Win32.CsrClientCallServer (data' IntPtr.Zero' Win32.CsrMakeApiNumber (Win32.BaseSrvServerDllIndex' (int)BaseSrvApiNumber.BasepCreateProcess)' Marshal.SizeOf (typeof(BaseCreateProcessMsg)));  		NtStatus status = (NtStatus)data.ReadStruct<CsrApiMsg> ().ReturnValue;  		if (status >= NtStatus.Error) {  			phandle.Terminate (status);  			Win32.Throw (status);  		}  	}  }  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,CreateExtended,The following statement contains a magic number: if (imageInfo.ImageSubsystem == 2)  	processMsg.ProcessHandle = processMsg.ProcessHandle.Or ((1 | 2).ToIntPtr ());  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,CreateExtended,The following statement contains a magic number: if (imageInfo.ImageSubsystem == 2)  	processMsg.ProcessHandle = processMsg.ProcessHandle.Or ((1 | 2).ToIntPtr ());  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,CreateExtended,The following statement contains a magic number: processMsg.ProcessHandle = processMsg.ProcessHandle.Or ((1 | 2).ToIntPtr ());  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,EnumModulesApi,The following statement contains a magic number: moduleHandles = new IntPtr[requiredSize / 4];  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,EnumModulesApi,The following statement contains a magic number: for (int i = 0; i < moduleHandles.Length; i++) {  	ModuleInfo moduleInfo = new ModuleInfo ();  	StringBuilder baseName = new StringBuilder (0x400);  	StringBuilder fileName = new StringBuilder (0x400);  	if (!Win32.GetModuleInformation (this' moduleHandles [i]' moduleInfo' Marshal.SizeOf (moduleInfo)))  		Win32.Throw ();  	if (Win32.GetModuleBaseName (this' moduleHandles [i]' baseName' baseName.Capacity * 2) == 0)  		Win32.Throw ();  	if (Win32.GetModuleFileNameEx (this' moduleHandles [i]' fileName' fileName.Capacity * 2) == 0)  		Win32.Throw ();  	if (!enumModulesCallback (new ProcessModule (moduleInfo.BaseOfDll' moduleInfo.SizeOfImage' moduleInfo.EntryPoint' 0' baseName.ToString ()' FileUtils.GetFileName (fileName.ToString ()))))  		break;  }  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,EnumModulesApi,The following statement contains a magic number: for (int i = 0; i < moduleHandles.Length; i++) {  	ModuleInfo moduleInfo = new ModuleInfo ();  	StringBuilder baseName = new StringBuilder (0x400);  	StringBuilder fileName = new StringBuilder (0x400);  	if (!Win32.GetModuleInformation (this' moduleHandles [i]' moduleInfo' Marshal.SizeOf (moduleInfo)))  		Win32.Throw ();  	if (Win32.GetModuleBaseName (this' moduleHandles [i]' baseName' baseName.Capacity * 2) == 0)  		Win32.Throw ();  	if (Win32.GetModuleFileNameEx (this' moduleHandles [i]' fileName' fileName.Capacity * 2) == 0)  		Win32.Throw ();  	if (!enumModulesCallback (new ProcessModule (moduleInfo.BaseOfDll' moduleInfo.SizeOfImage' moduleInfo.EntryPoint' 0' baseName.ToString ()' FileUtils.GetFileName (fileName.ToString ()))))  		break;  }  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,EnumModulesApi,The following statement contains a magic number: if (Win32.GetModuleBaseName (this' moduleHandles [i]' baseName' baseName.Capacity * 2) == 0)  	Win32.Throw ();  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,EnumModulesApi,The following statement contains a magic number: if (Win32.GetModuleFileNameEx (this' moduleHandles [i]' fileName' fileName.Capacity * 2) == 0)  	Win32.Throw ();  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetEnvironmentVariables,The following statement contains a magic number: using (var memoryAlloc = new MemoryAlloc (length)) {  	byte* memory = (byte*)memoryAlloc.Memory;  	this.ReadMemory (envBase' memoryAlloc.Memory' length);  	/* The environment variables block is a series of Unicode strings separated by                   * two null bytes. The entire block is terminated by four null bytes.                  */Dictionary<string' string> vars = new Dictionary<string' string> ();  	StringBuilder currentVariable = new StringBuilder ();  	int i = 0;  	while (true) {  		if (i >= length)  			break;  		char currentChar;  		Encoding.Unicode.GetChars (&memory [i]' 2' &currentChar' 1);  		i += 2;  		if (currentChar == '\0') {  			// Two nulls in a row' the env. block is finished.  			if (currentVariable.Length == 0)  				break;  			string[] s = currentVariable.ToString ().Split (new char[] {  				'='  			}' 2);  			if (!vars.ContainsKey (s [0]) && s.Length > 1)  				vars.Add (s [0]' s [1]);  			currentVariable = new StringBuilder ();  		}  		else {  			currentVariable.Append (currentChar);  		}  	}  	return vars;  }  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetEnvironmentVariables,The following statement contains a magic number: using (var memoryAlloc = new MemoryAlloc (length)) {  	byte* memory = (byte*)memoryAlloc.Memory;  	this.ReadMemory (envBase' memoryAlloc.Memory' length);  	/* The environment variables block is a series of Unicode strings separated by                   * two null bytes. The entire block is terminated by four null bytes.                  */Dictionary<string' string> vars = new Dictionary<string' string> ();  	StringBuilder currentVariable = new StringBuilder ();  	int i = 0;  	while (true) {  		if (i >= length)  			break;  		char currentChar;  		Encoding.Unicode.GetChars (&memory [i]' 2' &currentChar' 1);  		i += 2;  		if (currentChar == '\0') {  			// Two nulls in a row' the env. block is finished.  			if (currentVariable.Length == 0)  				break;  			string[] s = currentVariable.ToString ().Split (new char[] {  				'='  			}' 2);  			if (!vars.ContainsKey (s [0]) && s.Length > 1)  				vars.Add (s [0]' s [1]);  			currentVariable = new StringBuilder ();  		}  		else {  			currentVariable.Append (currentChar);  		}  	}  	return vars;  }  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetEnvironmentVariables,The following statement contains a magic number: using (var memoryAlloc = new MemoryAlloc (length)) {  	byte* memory = (byte*)memoryAlloc.Memory;  	this.ReadMemory (envBase' memoryAlloc.Memory' length);  	/* The environment variables block is a series of Unicode strings separated by                   * two null bytes. The entire block is terminated by four null bytes.                  */Dictionary<string' string> vars = new Dictionary<string' string> ();  	StringBuilder currentVariable = new StringBuilder ();  	int i = 0;  	while (true) {  		if (i >= length)  			break;  		char currentChar;  		Encoding.Unicode.GetChars (&memory [i]' 2' &currentChar' 1);  		i += 2;  		if (currentChar == '\0') {  			// Two nulls in a row' the env. block is finished.  			if (currentVariable.Length == 0)  				break;  			string[] s = currentVariable.ToString ().Split (new char[] {  				'='  			}' 2);  			if (!vars.ContainsKey (s [0]) && s.Length > 1)  				vars.Add (s [0]' s [1]);  			currentVariable = new StringBuilder ();  		}  		else {  			currentVariable.Append (currentChar);  		}  	}  	return vars;  }  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetEnvironmentVariables,The following statement contains a magic number: while (true) {  	if (i >= length)  		break;  	char currentChar;  	Encoding.Unicode.GetChars (&memory [i]' 2' &currentChar' 1);  	i += 2;  	if (currentChar == '\0') {  		// Two nulls in a row' the env. block is finished.  		if (currentVariable.Length == 0)  			break;  		string[] s = currentVariable.ToString ().Split (new char[] {  			'='  		}' 2);  		if (!vars.ContainsKey (s [0]) && s.Length > 1)  			vars.Add (s [0]' s [1]);  		currentVariable = new StringBuilder ();  	}  	else {  		currentVariable.Append (currentChar);  	}  }  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetEnvironmentVariables,The following statement contains a magic number: while (true) {  	if (i >= length)  		break;  	char currentChar;  	Encoding.Unicode.GetChars (&memory [i]' 2' &currentChar' 1);  	i += 2;  	if (currentChar == '\0') {  		// Two nulls in a row' the env. block is finished.  		if (currentVariable.Length == 0)  			break;  		string[] s = currentVariable.ToString ().Split (new char[] {  			'='  		}' 2);  		if (!vars.ContainsKey (s [0]) && s.Length > 1)  			vars.Add (s [0]' s [1]);  		currentVariable = new StringBuilder ();  	}  	else {  		currentVariable.Append (currentChar);  	}  }  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetEnvironmentVariables,The following statement contains a magic number: while (true) {  	if (i >= length)  		break;  	char currentChar;  	Encoding.Unicode.GetChars (&memory [i]' 2' &currentChar' 1);  	i += 2;  	if (currentChar == '\0') {  		// Two nulls in a row' the env. block is finished.  		if (currentVariable.Length == 0)  			break;  		string[] s = currentVariable.ToString ().Split (new char[] {  			'='  		}' 2);  		if (!vars.ContainsKey (s [0]) && s.Length > 1)  			vars.Add (s [0]' s [1]);  		currentVariable = new StringBuilder ();  	}  	else {  		currentVariable.Append (currentChar);  	}  }  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetEnvironmentVariables,The following statement contains a magic number: Encoding.Unicode.GetChars (&memory [i]' 2' &currentChar' 1);  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetEnvironmentVariables,The following statement contains a magic number: i += 2;  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetEnvironmentVariables,The following statement contains a magic number: if (currentChar == '\0') {  	// Two nulls in a row' the env. block is finished.  	if (currentVariable.Length == 0)  		break;  	string[] s = currentVariable.ToString ().Split (new char[] {  		'='  	}' 2);  	if (!vars.ContainsKey (s [0]) && s.Length > 1)  		vars.Add (s [0]' s [1]);  	currentVariable = new StringBuilder ();  }  else {  	currentVariable.Append (currentChar);  }  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetHandles,The following statement contains a magic number: using (var data = new MemoryAlloc (0x1000)) {  	while (true) {  		try {  			KProcessHacker.Instance.KphQueryProcessHandles (this' data' data.Size' out returnLength);  		}  		catch (WindowsException ex) {  			if (attempts > 3)  				throw ex;  			if (ex.Status == NtStatus.BufferTooSmall && returnLength > data.Size)  				data.ResizeNew (returnLength);  			attempts++;  			continue;  		}  		int handleCount = data.ReadInt32 (0);  		ProcessHandleInformation[] handles = new ProcessHandleInformation[handleCount];  		for (int i = 0; i < handleCount; i++)  			handles [i] = data.ReadStruct<ProcessHandleInformation> (sizeof(int)' i);  		return handles;  	}  }  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetHandles,The following statement contains a magic number: while (true) {  	try {  		KProcessHacker.Instance.KphQueryProcessHandles (this' data' data.Size' out returnLength);  	}  	catch (WindowsException ex) {  		if (attempts > 3)  			throw ex;  		if (ex.Status == NtStatus.BufferTooSmall && returnLength > data.Size)  			data.ResizeNew (returnLength);  		attempts++;  		continue;  	}  	int handleCount = data.ReadInt32 (0);  	ProcessHandleInformation[] handles = new ProcessHandleInformation[handleCount];  	for (int i = 0; i < handleCount; i++)  		handles [i] = data.ReadStruct<ProcessHandleInformation> (sizeof(int)' i);  	return handles;  }  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetHandles,The following statement contains a magic number: try {  	KProcessHacker.Instance.KphQueryProcessHandles (this' data' data.Size' out returnLength);  }  catch (WindowsException ex) {  	if (attempts > 3)  		throw ex;  	if (ex.Status == NtStatus.BufferTooSmall && returnLength > data.Size)  		data.ResizeNew (returnLength);  	attempts++;  	continue;  }  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetHandles,The following statement contains a magic number: if (attempts > 3)  	throw ex;  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetHandleTraces,The following statement contains a magic number: using (var data = new MemoryAlloc (0x10000)) {  	var query = new ProcessHandleTracingQuery ();  	// If Handle is not NULL' NtQueryInformationProcess will   	// get a specific stack trace. Otherwise' it will get   	// all of the stack traces.  	query.Handle = handle;  	data.WriteStruct<ProcessHandleTracingQuery> (query);  	for (int i = 0; i < 8; i++) {  		status = Win32.NtQueryInformationProcess (this' ProcessInformationClass.ProcessHandleTracing' data' data.Size' out retLength);  		if (status == NtStatus.InfoLengthMismatch) {  			data.ResizeNew (data.Size * 4);  			continue;  		}  		if (status >= NtStatus.Error)  			Win32.Throw (status);  		return new ProcessHandleTraceCollection (data);  	}  	Win32.Throw (status);  	return null;  	// Silences the compiler.  }  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetHandleTraces,The following statement contains a magic number: using (var data = new MemoryAlloc (0x10000)) {  	var query = new ProcessHandleTracingQuery ();  	// If Handle is not NULL' NtQueryInformationProcess will   	// get a specific stack trace. Otherwise' it will get   	// all of the stack traces.  	query.Handle = handle;  	data.WriteStruct<ProcessHandleTracingQuery> (query);  	for (int i = 0; i < 8; i++) {  		status = Win32.NtQueryInformationProcess (this' ProcessInformationClass.ProcessHandleTracing' data' data.Size' out retLength);  		if (status == NtStatus.InfoLengthMismatch) {  			data.ResizeNew (data.Size * 4);  			continue;  		}  		if (status >= NtStatus.Error)  			Win32.Throw (status);  		return new ProcessHandleTraceCollection (data);  	}  	Win32.Throw (status);  	return null;  	// Silences the compiler.  }  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetHandleTraces,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	status = Win32.NtQueryInformationProcess (this' ProcessInformationClass.ProcessHandleTracing' data' data.Size' out retLength);  	if (status == NtStatus.InfoLengthMismatch) {  		data.ResizeNew (data.Size * 4);  		continue;  	}  	if (status >= NtStatus.Error)  		Win32.Throw (status);  	return new ProcessHandleTraceCollection (data);  }  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetHandleTraces,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	status = Win32.NtQueryInformationProcess (this' ProcessInformationClass.ProcessHandleTracing' data' data.Size' out retLength);  	if (status == NtStatus.InfoLengthMismatch) {  		data.ResizeNew (data.Size * 4);  		continue;  	}  	if (status >= NtStatus.Error)  		Win32.Throw (status);  	return new ProcessHandleTraceCollection (data);  }  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetHandleTraces,The following statement contains a magic number: if (status == NtStatus.InfoLengthMismatch) {  	data.ResizeNew (data.Size * 4);  	continue;  }  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetHandleTraces,The following statement contains a magic number: data.ResizeNew (data.Size * 4);  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetKnownProcessType,The following statement contains a magic number: if (this.GetBasicInformation ().UniqueProcessId.Equals (4))  	return KnownProcess.System;  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetMappedFileName,The following statement contains a magic number: using (var data = new MemoryAlloc (20)) {  	if ((status = Win32.NtQueryVirtualMemory (this' address' MemoryInformationClass.MemoryMappedFilenameInformation' data' data.Size.ToIntPtr ()' out retLength)) == NtStatus.BufferOverflow) {  		data.ResizeNew (retLength.ToInt32 ());  		status = Win32.NtQueryVirtualMemory (this' address' MemoryInformationClass.MemoryMappedFilenameInformation' data' data.Size.ToIntPtr ()' out retLength);  	}  	if (status >= NtStatus.Error)  		return null;  	return FileUtils.GetFileName (data.ReadStruct<UnicodeString> ().Read ());  }  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetTimes,The following statement contains a magic number: if (!Win32.GetProcessTimes (this' out times [0]' out times [1]' out times [2]' out times [3]))  	Win32.Throw ();  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,GetTimes,The following statement contains a magic number: if (!Win32.GetProcessTimes (this' out times [0]' out times [1]' out times [2]' out times [3]))  	Win32.Throw ();  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,InjectDll,The following statement contains a magic number: this.FreeMemory (stringPage' path.Length * 2 + 2' false);  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,InjectDll,The following statement contains a magic number: this.FreeMemory (stringPage' path.Length * 2 + 2' false);  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,IsPosix,The following statement contains a magic number: return subsystem == 7;  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,SetModuleReferenceCount,The following statement contains a magic number: while (currentLink != IntPtr.Zero) {  	if (modules.Count > 0 && currentLink == startLink)  		break;  	if (i > 0x800)  		break;  	this.ReadMemory (currentLink' &currentEntry' Marshal.SizeOf (typeof(LdrDataTableEntry)));  	if (currentEntry.DllBase == baseAddress) {  		this.WriteMemory (currentLink.Increment (LdrDataTableEntry.LoadCountOffset)' &count' 2);  		break;  	}  	currentLink = currentEntry.InLoadOrderLinks.Flink;  	i++;  }  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,SetModuleReferenceCount,The following statement contains a magic number: if (currentEntry.DllBase == baseAddress) {  	this.WriteMemory (currentLink.Increment (LdrDataTableEntry.LoadCountOffset)' &count' 2);  	break;  }  
Magic Number,ProcessHacker.Native.Objects,ProcessHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ProcessHandle.cs,SetModuleReferenceCount,The following statement contains a magic number: this.WriteMemory (currentLink.Increment (LdrDataTableEntry.LoadCountOffset)' &count' 2);  
Magic Number,ProcessHacker.Native.Objects,ThreadHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ThreadHandle.cs,GetContext,The following statement contains a magic number: using (var data = new AlignedMemoryAlloc (Utils.SizeOf<ContextAmd64> (16)' 16)) {  	data.WriteStruct<ContextAmd64> (context);  	if ((status = Win32.NtGetContextThread (this' data)) >= NtStatus.Error)  		Win32.Throw (status);  	context = data.ReadStruct<ContextAmd64> ();  }  
Magic Number,ProcessHacker.Native.Objects,ThreadHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ThreadHandle.cs,GetContext,The following statement contains a magic number: using (var data = new AlignedMemoryAlloc (Utils.SizeOf<ContextAmd64> (16)' 16)) {  	data.WriteStruct<ContextAmd64> (context);  	if ((status = Win32.NtGetContextThread (this' data)) >= NtStatus.Error)  		Win32.Throw (status);  	context = data.ReadStruct<ContextAmd64> ();  }  
Magic Number,ProcessHacker.Native.Objects,ThreadHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ThreadHandle.cs,GetLastSystemCall,The following statement contains a magic number: if ((status = Win32.NtQueryInformationThread (this' ThreadInformationClass.ThreadLastSystemCall' data' sizeof(int) * 2' out retLength)) >= NtStatus.Error)  	Win32.Throw (status);  
Magic Number,ProcessHacker.Native.Objects,ThreadHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ThreadHandle.cs,SetContext,The following statement contains a magic number: using (var data = new AlignedMemoryAlloc (Utils.SizeOf<ContextAmd64> (16)' 16)) {  	data.WriteStruct<ContextAmd64> (context);  	if ((status = Win32.NtSetContextThread (this' data)) >= NtStatus.Error)  		Win32.Throw (status);  }  
Magic Number,ProcessHacker.Native.Objects,ThreadHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ThreadHandle.cs,SetContext,The following statement contains a magic number: using (var data = new AlignedMemoryAlloc (Utils.SizeOf<ContextAmd64> (16)' 16)) {  	data.WriteStruct<ContextAmd64> (context);  	if ((status = Win32.NtSetContextThread (this' data)) >= NtStatus.Error)  		Win32.Throw (status);  }  
Magic Number,ProcessHacker.Native.Objects,ThreadStackFrame,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ThreadHandle.cs,ThreadStackFrame,The following statement contains a magic number: _params = new IntPtr[4];  
Magic Number,ProcessHacker.Native.Objects,ThreadStackFrame,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\ThreadHandle.cs,ThreadStackFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	_params [i] = new IntPtr (stackFrame.Params [i]);  
Magic Number,ProcessHacker.Native.Objects,TokenHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TokenHandle.cs,OpenSystemToken,The following statement contains a magic number: using (var phandle = new ProcessHandle (4' OSVersion.MinProcessQueryInfoAccess)) {  	return phandle.GetToken (access);  }  
Magic Number,ProcessHacker.Native.Objects,TokenHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TokenHandle.cs,OpenSystemToken,The following statement contains a magic number: using (var phandle = new ProcessHandle (4' OSVersion.MinProcessQueryInfoAccess)) {  	using (var thandle = phandle.GetToken (TokenAccess.Duplicate | access)) {  		return thandle.Duplicate (access' impersonationLevel' type);  	}  }  
Magic Number,ProcessHacker.Native.Objects,TokenHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\TokenHandle.cs,SetVirtualizationEnabled,The following statement contains a magic number: if (!Win32.SetTokenInformation (this' TokenInformationClass.TokenVirtualizationEnabled' ref value' 4)) {  	Win32.Throw ();  }  
Magic Number,ProcessHacker.Native.Objects,NativeHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\NativeHandle.cs,Close,The following statement contains a magic number: if (_handle != IntPtr.Zero && _handle.ToInt32 () != -1 && _handle.ToInt32 () != -2)  	Win32.NtClose (_handle);  
Magic Number,ProcessHacker.Native.Security.AccessControl,Acl,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\AccessControl\Acl.cs,Acl,The following statement contains a magic number: if (size < 8)  	throw new ArgumentException ("Size must be greater than or equal to 8 bytes.");  
Magic Number,ProcessHacker.Native.Security.AccessControl,SecurityEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\AccessControl\SecurityEditor.cs,AllocateString,The following statement contains a magic number: alloc.WriteInt16 (value.Length * 2' 0);  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: using (var domainNameBuffer = new MemoryAlloc (0x100))  	using (var userNameBuffer = new MemoryAlloc (0x100))  		using (var passwordBuffer = new MemoryAlloc (0x100)) {  			int domainNameSize = domainNameBuffer.Size / 2 - 1;  			int userNameSize = userNameBuffer.Size / 2 - 1;  			int passwordSize = passwordBuffer.Size / 2 - 1;  			if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  				domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  				userNameBuffer.ResizeNew (userNameSize * 2 + 2);  				passwordBuffer.ResizeNew (passwordSize * 2 + 2);  				if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  					Win32.Throw ();  			}  			domainName = domainNameBuffer.ReadUnicodeString (0);  			userName = userNameBuffer.ReadUnicodeString (0);  			password = passwordBuffer.ReadUnicodeString (0);  		}  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: using (var domainNameBuffer = new MemoryAlloc (0x100))  	using (var userNameBuffer = new MemoryAlloc (0x100))  		using (var passwordBuffer = new MemoryAlloc (0x100)) {  			int domainNameSize = domainNameBuffer.Size / 2 - 1;  			int userNameSize = userNameBuffer.Size / 2 - 1;  			int passwordSize = passwordBuffer.Size / 2 - 1;  			if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  				domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  				userNameBuffer.ResizeNew (userNameSize * 2 + 2);  				passwordBuffer.ResizeNew (passwordSize * 2 + 2);  				if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  					Win32.Throw ();  			}  			domainName = domainNameBuffer.ReadUnicodeString (0);  			userName = userNameBuffer.ReadUnicodeString (0);  			password = passwordBuffer.ReadUnicodeString (0);  		}  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: using (var domainNameBuffer = new MemoryAlloc (0x100))  	using (var userNameBuffer = new MemoryAlloc (0x100))  		using (var passwordBuffer = new MemoryAlloc (0x100)) {  			int domainNameSize = domainNameBuffer.Size / 2 - 1;  			int userNameSize = userNameBuffer.Size / 2 - 1;  			int passwordSize = passwordBuffer.Size / 2 - 1;  			if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  				domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  				userNameBuffer.ResizeNew (userNameSize * 2 + 2);  				passwordBuffer.ResizeNew (passwordSize * 2 + 2);  				if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  					Win32.Throw ();  			}  			domainName = domainNameBuffer.ReadUnicodeString (0);  			userName = userNameBuffer.ReadUnicodeString (0);  			password = passwordBuffer.ReadUnicodeString (0);  		}  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: using (var domainNameBuffer = new MemoryAlloc (0x100))  	using (var userNameBuffer = new MemoryAlloc (0x100))  		using (var passwordBuffer = new MemoryAlloc (0x100)) {  			int domainNameSize = domainNameBuffer.Size / 2 - 1;  			int userNameSize = userNameBuffer.Size / 2 - 1;  			int passwordSize = passwordBuffer.Size / 2 - 1;  			if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  				domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  				userNameBuffer.ResizeNew (userNameSize * 2 + 2);  				passwordBuffer.ResizeNew (passwordSize * 2 + 2);  				if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  					Win32.Throw ();  			}  			domainName = domainNameBuffer.ReadUnicodeString (0);  			userName = userNameBuffer.ReadUnicodeString (0);  			password = passwordBuffer.ReadUnicodeString (0);  		}  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: using (var domainNameBuffer = new MemoryAlloc (0x100))  	using (var userNameBuffer = new MemoryAlloc (0x100))  		using (var passwordBuffer = new MemoryAlloc (0x100)) {  			int domainNameSize = domainNameBuffer.Size / 2 - 1;  			int userNameSize = userNameBuffer.Size / 2 - 1;  			int passwordSize = passwordBuffer.Size / 2 - 1;  			if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  				domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  				userNameBuffer.ResizeNew (userNameSize * 2 + 2);  				passwordBuffer.ResizeNew (passwordSize * 2 + 2);  				if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  					Win32.Throw ();  			}  			domainName = domainNameBuffer.ReadUnicodeString (0);  			userName = userNameBuffer.ReadUnicodeString (0);  			password = passwordBuffer.ReadUnicodeString (0);  		}  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: using (var domainNameBuffer = new MemoryAlloc (0x100))  	using (var userNameBuffer = new MemoryAlloc (0x100))  		using (var passwordBuffer = new MemoryAlloc (0x100)) {  			int domainNameSize = domainNameBuffer.Size / 2 - 1;  			int userNameSize = userNameBuffer.Size / 2 - 1;  			int passwordSize = passwordBuffer.Size / 2 - 1;  			if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  				domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  				userNameBuffer.ResizeNew (userNameSize * 2 + 2);  				passwordBuffer.ResizeNew (passwordSize * 2 + 2);  				if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  					Win32.Throw ();  			}  			domainName = domainNameBuffer.ReadUnicodeString (0);  			userName = userNameBuffer.ReadUnicodeString (0);  			password = passwordBuffer.ReadUnicodeString (0);  		}  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: using (var domainNameBuffer = new MemoryAlloc (0x100))  	using (var userNameBuffer = new MemoryAlloc (0x100))  		using (var passwordBuffer = new MemoryAlloc (0x100)) {  			int domainNameSize = domainNameBuffer.Size / 2 - 1;  			int userNameSize = userNameBuffer.Size / 2 - 1;  			int passwordSize = passwordBuffer.Size / 2 - 1;  			if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  				domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  				userNameBuffer.ResizeNew (userNameSize * 2 + 2);  				passwordBuffer.ResizeNew (passwordSize * 2 + 2);  				if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  					Win32.Throw ();  			}  			domainName = domainNameBuffer.ReadUnicodeString (0);  			userName = userNameBuffer.ReadUnicodeString (0);  			password = passwordBuffer.ReadUnicodeString (0);  		}  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: using (var domainNameBuffer = new MemoryAlloc (0x100))  	using (var userNameBuffer = new MemoryAlloc (0x100))  		using (var passwordBuffer = new MemoryAlloc (0x100)) {  			int domainNameSize = domainNameBuffer.Size / 2 - 1;  			int userNameSize = userNameBuffer.Size / 2 - 1;  			int passwordSize = passwordBuffer.Size / 2 - 1;  			if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  				domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  				userNameBuffer.ResizeNew (userNameSize * 2 + 2);  				passwordBuffer.ResizeNew (passwordSize * 2 + 2);  				if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  					Win32.Throw ();  			}  			domainName = domainNameBuffer.ReadUnicodeString (0);  			userName = userNameBuffer.ReadUnicodeString (0);  			password = passwordBuffer.ReadUnicodeString (0);  		}  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: using (var domainNameBuffer = new MemoryAlloc (0x100))  	using (var userNameBuffer = new MemoryAlloc (0x100))  		using (var passwordBuffer = new MemoryAlloc (0x100)) {  			int domainNameSize = domainNameBuffer.Size / 2 - 1;  			int userNameSize = userNameBuffer.Size / 2 - 1;  			int passwordSize = passwordBuffer.Size / 2 - 1;  			if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  				domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  				userNameBuffer.ResizeNew (userNameSize * 2 + 2);  				passwordBuffer.ResizeNew (passwordSize * 2 + 2);  				if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  					Win32.Throw ();  			}  			domainName = domainNameBuffer.ReadUnicodeString (0);  			userName = userNameBuffer.ReadUnicodeString (0);  			password = passwordBuffer.ReadUnicodeString (0);  		}  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: using (var userNameBuffer = new MemoryAlloc (0x100))  	using (var passwordBuffer = new MemoryAlloc (0x100)) {  		int domainNameSize = domainNameBuffer.Size / 2 - 1;  		int userNameSize = userNameBuffer.Size / 2 - 1;  		int passwordSize = passwordBuffer.Size / 2 - 1;  		if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  			domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  			userNameBuffer.ResizeNew (userNameSize * 2 + 2);  			passwordBuffer.ResizeNew (passwordSize * 2 + 2);  			if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  				Win32.Throw ();  		}  		domainName = domainNameBuffer.ReadUnicodeString (0);  		userName = userNameBuffer.ReadUnicodeString (0);  		password = passwordBuffer.ReadUnicodeString (0);  	}  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: using (var userNameBuffer = new MemoryAlloc (0x100))  	using (var passwordBuffer = new MemoryAlloc (0x100)) {  		int domainNameSize = domainNameBuffer.Size / 2 - 1;  		int userNameSize = userNameBuffer.Size / 2 - 1;  		int passwordSize = passwordBuffer.Size / 2 - 1;  		if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  			domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  			userNameBuffer.ResizeNew (userNameSize * 2 + 2);  			passwordBuffer.ResizeNew (passwordSize * 2 + 2);  			if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  				Win32.Throw ();  		}  		domainName = domainNameBuffer.ReadUnicodeString (0);  		userName = userNameBuffer.ReadUnicodeString (0);  		password = passwordBuffer.ReadUnicodeString (0);  	}  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: using (var userNameBuffer = new MemoryAlloc (0x100))  	using (var passwordBuffer = new MemoryAlloc (0x100)) {  		int domainNameSize = domainNameBuffer.Size / 2 - 1;  		int userNameSize = userNameBuffer.Size / 2 - 1;  		int passwordSize = passwordBuffer.Size / 2 - 1;  		if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  			domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  			userNameBuffer.ResizeNew (userNameSize * 2 + 2);  			passwordBuffer.ResizeNew (passwordSize * 2 + 2);  			if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  				Win32.Throw ();  		}  		domainName = domainNameBuffer.ReadUnicodeString (0);  		userName = userNameBuffer.ReadUnicodeString (0);  		password = passwordBuffer.ReadUnicodeString (0);  	}  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: using (var userNameBuffer = new MemoryAlloc (0x100))  	using (var passwordBuffer = new MemoryAlloc (0x100)) {  		int domainNameSize = domainNameBuffer.Size / 2 - 1;  		int userNameSize = userNameBuffer.Size / 2 - 1;  		int passwordSize = passwordBuffer.Size / 2 - 1;  		if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  			domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  			userNameBuffer.ResizeNew (userNameSize * 2 + 2);  			passwordBuffer.ResizeNew (passwordSize * 2 + 2);  			if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  				Win32.Throw ();  		}  		domainName = domainNameBuffer.ReadUnicodeString (0);  		userName = userNameBuffer.ReadUnicodeString (0);  		password = passwordBuffer.ReadUnicodeString (0);  	}  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: using (var userNameBuffer = new MemoryAlloc (0x100))  	using (var passwordBuffer = new MemoryAlloc (0x100)) {  		int domainNameSize = domainNameBuffer.Size / 2 - 1;  		int userNameSize = userNameBuffer.Size / 2 - 1;  		int passwordSize = passwordBuffer.Size / 2 - 1;  		if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  			domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  			userNameBuffer.ResizeNew (userNameSize * 2 + 2);  			passwordBuffer.ResizeNew (passwordSize * 2 + 2);  			if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  				Win32.Throw ();  		}  		domainName = domainNameBuffer.ReadUnicodeString (0);  		userName = userNameBuffer.ReadUnicodeString (0);  		password = passwordBuffer.ReadUnicodeString (0);  	}  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: using (var userNameBuffer = new MemoryAlloc (0x100))  	using (var passwordBuffer = new MemoryAlloc (0x100)) {  		int domainNameSize = domainNameBuffer.Size / 2 - 1;  		int userNameSize = userNameBuffer.Size / 2 - 1;  		int passwordSize = passwordBuffer.Size / 2 - 1;  		if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  			domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  			userNameBuffer.ResizeNew (userNameSize * 2 + 2);  			passwordBuffer.ResizeNew (passwordSize * 2 + 2);  			if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  				Win32.Throw ();  		}  		domainName = domainNameBuffer.ReadUnicodeString (0);  		userName = userNameBuffer.ReadUnicodeString (0);  		password = passwordBuffer.ReadUnicodeString (0);  	}  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: using (var userNameBuffer = new MemoryAlloc (0x100))  	using (var passwordBuffer = new MemoryAlloc (0x100)) {  		int domainNameSize = domainNameBuffer.Size / 2 - 1;  		int userNameSize = userNameBuffer.Size / 2 - 1;  		int passwordSize = passwordBuffer.Size / 2 - 1;  		if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  			domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  			userNameBuffer.ResizeNew (userNameSize * 2 + 2);  			passwordBuffer.ResizeNew (passwordSize * 2 + 2);  			if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  				Win32.Throw ();  		}  		domainName = domainNameBuffer.ReadUnicodeString (0);  		userName = userNameBuffer.ReadUnicodeString (0);  		password = passwordBuffer.ReadUnicodeString (0);  	}  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: using (var userNameBuffer = new MemoryAlloc (0x100))  	using (var passwordBuffer = new MemoryAlloc (0x100)) {  		int domainNameSize = domainNameBuffer.Size / 2 - 1;  		int userNameSize = userNameBuffer.Size / 2 - 1;  		int passwordSize = passwordBuffer.Size / 2 - 1;  		if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  			domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  			userNameBuffer.ResizeNew (userNameSize * 2 + 2);  			passwordBuffer.ResizeNew (passwordSize * 2 + 2);  			if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  				Win32.Throw ();  		}  		domainName = domainNameBuffer.ReadUnicodeString (0);  		userName = userNameBuffer.ReadUnicodeString (0);  		password = passwordBuffer.ReadUnicodeString (0);  	}  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: using (var userNameBuffer = new MemoryAlloc (0x100))  	using (var passwordBuffer = new MemoryAlloc (0x100)) {  		int domainNameSize = domainNameBuffer.Size / 2 - 1;  		int userNameSize = userNameBuffer.Size / 2 - 1;  		int passwordSize = passwordBuffer.Size / 2 - 1;  		if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  			domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  			userNameBuffer.ResizeNew (userNameSize * 2 + 2);  			passwordBuffer.ResizeNew (passwordSize * 2 + 2);  			if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  				Win32.Throw ();  		}  		domainName = domainNameBuffer.ReadUnicodeString (0);  		userName = userNameBuffer.ReadUnicodeString (0);  		password = passwordBuffer.ReadUnicodeString (0);  	}  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: using (var passwordBuffer = new MemoryAlloc (0x100)) {  	int domainNameSize = domainNameBuffer.Size / 2 - 1;  	int userNameSize = userNameBuffer.Size / 2 - 1;  	int passwordSize = passwordBuffer.Size / 2 - 1;  	if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  		domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  		userNameBuffer.ResizeNew (userNameSize * 2 + 2);  		passwordBuffer.ResizeNew (passwordSize * 2 + 2);  		if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  			Win32.Throw ();  	}  	domainName = domainNameBuffer.ReadUnicodeString (0);  	userName = userNameBuffer.ReadUnicodeString (0);  	password = passwordBuffer.ReadUnicodeString (0);  }  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: using (var passwordBuffer = new MemoryAlloc (0x100)) {  	int domainNameSize = domainNameBuffer.Size / 2 - 1;  	int userNameSize = userNameBuffer.Size / 2 - 1;  	int passwordSize = passwordBuffer.Size / 2 - 1;  	if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  		domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  		userNameBuffer.ResizeNew (userNameSize * 2 + 2);  		passwordBuffer.ResizeNew (passwordSize * 2 + 2);  		if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  			Win32.Throw ();  	}  	domainName = domainNameBuffer.ReadUnicodeString (0);  	userName = userNameBuffer.ReadUnicodeString (0);  	password = passwordBuffer.ReadUnicodeString (0);  }  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: using (var passwordBuffer = new MemoryAlloc (0x100)) {  	int domainNameSize = domainNameBuffer.Size / 2 - 1;  	int userNameSize = userNameBuffer.Size / 2 - 1;  	int passwordSize = passwordBuffer.Size / 2 - 1;  	if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  		domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  		userNameBuffer.ResizeNew (userNameSize * 2 + 2);  		passwordBuffer.ResizeNew (passwordSize * 2 + 2);  		if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  			Win32.Throw ();  	}  	domainName = domainNameBuffer.ReadUnicodeString (0);  	userName = userNameBuffer.ReadUnicodeString (0);  	password = passwordBuffer.ReadUnicodeString (0);  }  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: using (var passwordBuffer = new MemoryAlloc (0x100)) {  	int domainNameSize = domainNameBuffer.Size / 2 - 1;  	int userNameSize = userNameBuffer.Size / 2 - 1;  	int passwordSize = passwordBuffer.Size / 2 - 1;  	if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  		domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  		userNameBuffer.ResizeNew (userNameSize * 2 + 2);  		passwordBuffer.ResizeNew (passwordSize * 2 + 2);  		if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  			Win32.Throw ();  	}  	domainName = domainNameBuffer.ReadUnicodeString (0);  	userName = userNameBuffer.ReadUnicodeString (0);  	password = passwordBuffer.ReadUnicodeString (0);  }  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: using (var passwordBuffer = new MemoryAlloc (0x100)) {  	int domainNameSize = domainNameBuffer.Size / 2 - 1;  	int userNameSize = userNameBuffer.Size / 2 - 1;  	int passwordSize = passwordBuffer.Size / 2 - 1;  	if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  		domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  		userNameBuffer.ResizeNew (userNameSize * 2 + 2);  		passwordBuffer.ResizeNew (passwordSize * 2 + 2);  		if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  			Win32.Throw ();  	}  	domainName = domainNameBuffer.ReadUnicodeString (0);  	userName = userNameBuffer.ReadUnicodeString (0);  	password = passwordBuffer.ReadUnicodeString (0);  }  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: using (var passwordBuffer = new MemoryAlloc (0x100)) {  	int domainNameSize = domainNameBuffer.Size / 2 - 1;  	int userNameSize = userNameBuffer.Size / 2 - 1;  	int passwordSize = passwordBuffer.Size / 2 - 1;  	if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  		domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  		userNameBuffer.ResizeNew (userNameSize * 2 + 2);  		passwordBuffer.ResizeNew (passwordSize * 2 + 2);  		if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  			Win32.Throw ();  	}  	domainName = domainNameBuffer.ReadUnicodeString (0);  	userName = userNameBuffer.ReadUnicodeString (0);  	password = passwordBuffer.ReadUnicodeString (0);  }  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: using (var passwordBuffer = new MemoryAlloc (0x100)) {  	int domainNameSize = domainNameBuffer.Size / 2 - 1;  	int userNameSize = userNameBuffer.Size / 2 - 1;  	int passwordSize = passwordBuffer.Size / 2 - 1;  	if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  		domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  		userNameBuffer.ResizeNew (userNameSize * 2 + 2);  		passwordBuffer.ResizeNew (passwordSize * 2 + 2);  		if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  			Win32.Throw ();  	}  	domainName = domainNameBuffer.ReadUnicodeString (0);  	userName = userNameBuffer.ReadUnicodeString (0);  	password = passwordBuffer.ReadUnicodeString (0);  }  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: using (var passwordBuffer = new MemoryAlloc (0x100)) {  	int domainNameSize = domainNameBuffer.Size / 2 - 1;  	int userNameSize = userNameBuffer.Size / 2 - 1;  	int passwordSize = passwordBuffer.Size / 2 - 1;  	if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  		domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  		userNameBuffer.ResizeNew (userNameSize * 2 + 2);  		passwordBuffer.ResizeNew (passwordSize * 2 + 2);  		if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  			Win32.Throw ();  	}  	domainName = domainNameBuffer.ReadUnicodeString (0);  	userName = userNameBuffer.ReadUnicodeString (0);  	password = passwordBuffer.ReadUnicodeString (0);  }  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: using (var passwordBuffer = new MemoryAlloc (0x100)) {  	int domainNameSize = domainNameBuffer.Size / 2 - 1;  	int userNameSize = userNameBuffer.Size / 2 - 1;  	int passwordSize = passwordBuffer.Size / 2 - 1;  	if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  		domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  		userNameBuffer.ResizeNew (userNameSize * 2 + 2);  		passwordBuffer.ResizeNew (passwordSize * 2 + 2);  		if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  			Win32.Throw ();  	}  	domainName = domainNameBuffer.ReadUnicodeString (0);  	userName = userNameBuffer.ReadUnicodeString (0);  	password = passwordBuffer.ReadUnicodeString (0);  }  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  	domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  	userNameBuffer.ResizeNew (userNameSize * 2 + 2);  	passwordBuffer.ResizeNew (passwordSize * 2 + 2);  	if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  		Win32.Throw ();  }  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  	domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  	userNameBuffer.ResizeNew (userNameSize * 2 + 2);  	passwordBuffer.ResizeNew (passwordSize * 2 + 2);  	if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  		Win32.Throw ();  }  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  	domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  	userNameBuffer.ResizeNew (userNameSize * 2 + 2);  	passwordBuffer.ResizeNew (passwordSize * 2 + 2);  	if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  		Win32.Throw ();  }  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  	domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  	userNameBuffer.ResizeNew (userNameSize * 2 + 2);  	passwordBuffer.ResizeNew (passwordSize * 2 + 2);  	if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  		Win32.Throw ();  }  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  	domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  	userNameBuffer.ResizeNew (userNameSize * 2 + 2);  	passwordBuffer.ResizeNew (passwordSize * 2 + 2);  	if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  		Win32.Throw ();  }  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize)) {  	domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  	userNameBuffer.ResizeNew (userNameSize * 2 + 2);  	passwordBuffer.ResizeNew (passwordSize * 2 + 2);  	if (!Win32.CredUnPackAuthenticationBuffer (flags' buffer' buffer.Size' userNameBuffer' ref userNameSize' domainNameBuffer' ref domainNameSize' passwordBuffer' ref passwordSize))  		Win32.Throw ();  }  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: domainNameBuffer.ResizeNew (domainNameSize * 2 + 2);  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: userNameBuffer.ResizeNew (userNameSize * 2 + 2);  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: userNameBuffer.ResizeNew (userNameSize * 2 + 2);  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: passwordBuffer.ResizeNew (passwordSize * 2 + 2);  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,UnpackCredentials,The following statement contains a magic number: passwordBuffer.ResizeNew (passwordSize * 2 + 2);  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,PromptForCredentials,The following statement contains a magic number: using (var userNameAlloc = new MemoryAlloc (maxBytes))  	using (var passwordAlloc = new MemoryAlloc (maxBytes)) {  		userNameAlloc.WriteUnicodeString (0' userName);  		userNameAlloc.WriteInt16 (userName.Length * 2' 0);  		passwordAlloc.WriteUnicodeString (0' password);  		passwordAlloc.WriteInt16 (password.Length * 2' 0);  		result = Win32.CredUIPromptForCredentials (ref info' targetName' IntPtr.Zero' errorCode' userNameAlloc' maxBytes / 2' passwordAlloc' maxBytes / 2' ref save' flags);  		if (result == Win32Error.Cancelled)  			return false;  		if (result != Win32Error.Success)  			Win32.Throw (result);  		userName = userNameAlloc.ReadUnicodeString (0);  		password = passwordAlloc.ReadUnicodeString (0);  		return true;  	}  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,PromptForCredentials,The following statement contains a magic number: using (var userNameAlloc = new MemoryAlloc (maxBytes))  	using (var passwordAlloc = new MemoryAlloc (maxBytes)) {  		userNameAlloc.WriteUnicodeString (0' userName);  		userNameAlloc.WriteInt16 (userName.Length * 2' 0);  		passwordAlloc.WriteUnicodeString (0' password);  		passwordAlloc.WriteInt16 (password.Length * 2' 0);  		result = Win32.CredUIPromptForCredentials (ref info' targetName' IntPtr.Zero' errorCode' userNameAlloc' maxBytes / 2' passwordAlloc' maxBytes / 2' ref save' flags);  		if (result == Win32Error.Cancelled)  			return false;  		if (result != Win32Error.Success)  			Win32.Throw (result);  		userName = userNameAlloc.ReadUnicodeString (0);  		password = passwordAlloc.ReadUnicodeString (0);  		return true;  	}  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,PromptForCredentials,The following statement contains a magic number: using (var userNameAlloc = new MemoryAlloc (maxBytes))  	using (var passwordAlloc = new MemoryAlloc (maxBytes)) {  		userNameAlloc.WriteUnicodeString (0' userName);  		userNameAlloc.WriteInt16 (userName.Length * 2' 0);  		passwordAlloc.WriteUnicodeString (0' password);  		passwordAlloc.WriteInt16 (password.Length * 2' 0);  		result = Win32.CredUIPromptForCredentials (ref info' targetName' IntPtr.Zero' errorCode' userNameAlloc' maxBytes / 2' passwordAlloc' maxBytes / 2' ref save' flags);  		if (result == Win32Error.Cancelled)  			return false;  		if (result != Win32Error.Success)  			Win32.Throw (result);  		userName = userNameAlloc.ReadUnicodeString (0);  		password = passwordAlloc.ReadUnicodeString (0);  		return true;  	}  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,PromptForCredentials,The following statement contains a magic number: using (var userNameAlloc = new MemoryAlloc (maxBytes))  	using (var passwordAlloc = new MemoryAlloc (maxBytes)) {  		userNameAlloc.WriteUnicodeString (0' userName);  		userNameAlloc.WriteInt16 (userName.Length * 2' 0);  		passwordAlloc.WriteUnicodeString (0' password);  		passwordAlloc.WriteInt16 (password.Length * 2' 0);  		result = Win32.CredUIPromptForCredentials (ref info' targetName' IntPtr.Zero' errorCode' userNameAlloc' maxBytes / 2' passwordAlloc' maxBytes / 2' ref save' flags);  		if (result == Win32Error.Cancelled)  			return false;  		if (result != Win32Error.Success)  			Win32.Throw (result);  		userName = userNameAlloc.ReadUnicodeString (0);  		password = passwordAlloc.ReadUnicodeString (0);  		return true;  	}  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,PromptForCredentials,The following statement contains a magic number: using (var passwordAlloc = new MemoryAlloc (maxBytes)) {  	userNameAlloc.WriteUnicodeString (0' userName);  	userNameAlloc.WriteInt16 (userName.Length * 2' 0);  	passwordAlloc.WriteUnicodeString (0' password);  	passwordAlloc.WriteInt16 (password.Length * 2' 0);  	result = Win32.CredUIPromptForCredentials (ref info' targetName' IntPtr.Zero' errorCode' userNameAlloc' maxBytes / 2' passwordAlloc' maxBytes / 2' ref save' flags);  	if (result == Win32Error.Cancelled)  		return false;  	if (result != Win32Error.Success)  		Win32.Throw (result);  	userName = userNameAlloc.ReadUnicodeString (0);  	password = passwordAlloc.ReadUnicodeString (0);  	return true;  }  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,PromptForCredentials,The following statement contains a magic number: using (var passwordAlloc = new MemoryAlloc (maxBytes)) {  	userNameAlloc.WriteUnicodeString (0' userName);  	userNameAlloc.WriteInt16 (userName.Length * 2' 0);  	passwordAlloc.WriteUnicodeString (0' password);  	passwordAlloc.WriteInt16 (password.Length * 2' 0);  	result = Win32.CredUIPromptForCredentials (ref info' targetName' IntPtr.Zero' errorCode' userNameAlloc' maxBytes / 2' passwordAlloc' maxBytes / 2' ref save' flags);  	if (result == Win32Error.Cancelled)  		return false;  	if (result != Win32Error.Success)  		Win32.Throw (result);  	userName = userNameAlloc.ReadUnicodeString (0);  	password = passwordAlloc.ReadUnicodeString (0);  	return true;  }  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,PromptForCredentials,The following statement contains a magic number: using (var passwordAlloc = new MemoryAlloc (maxBytes)) {  	userNameAlloc.WriteUnicodeString (0' userName);  	userNameAlloc.WriteInt16 (userName.Length * 2' 0);  	passwordAlloc.WriteUnicodeString (0' password);  	passwordAlloc.WriteInt16 (password.Length * 2' 0);  	result = Win32.CredUIPromptForCredentials (ref info' targetName' IntPtr.Zero' errorCode' userNameAlloc' maxBytes / 2' passwordAlloc' maxBytes / 2' ref save' flags);  	if (result == Win32Error.Cancelled)  		return false;  	if (result != Win32Error.Success)  		Win32.Throw (result);  	userName = userNameAlloc.ReadUnicodeString (0);  	password = passwordAlloc.ReadUnicodeString (0);  	return true;  }  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,PromptForCredentials,The following statement contains a magic number: using (var passwordAlloc = new MemoryAlloc (maxBytes)) {  	userNameAlloc.WriteUnicodeString (0' userName);  	userNameAlloc.WriteInt16 (userName.Length * 2' 0);  	passwordAlloc.WriteUnicodeString (0' password);  	passwordAlloc.WriteInt16 (password.Length * 2' 0);  	result = Win32.CredUIPromptForCredentials (ref info' targetName' IntPtr.Zero' errorCode' userNameAlloc' maxBytes / 2' passwordAlloc' maxBytes / 2' ref save' flags);  	if (result == Win32Error.Cancelled)  		return false;  	if (result != Win32Error.Success)  		Win32.Throw (result);  	userName = userNameAlloc.ReadUnicodeString (0);  	password = passwordAlloc.ReadUnicodeString (0);  	return true;  }  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,PromptForCredentials,The following statement contains a magic number: userNameAlloc.WriteInt16 (userName.Length * 2' 0);  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,PromptForCredentials,The following statement contains a magic number: passwordAlloc.WriteInt16 (password.Length * 2' 0);  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,PromptForCredentials,The following statement contains a magic number: result = Win32.CredUIPromptForCredentials (ref info' targetName' IntPtr.Zero' errorCode' userNameAlloc' maxBytes / 2' passwordAlloc' maxBytes / 2' ref save' flags);  
Magic Number,ProcessHacker.Native.Security.Authentication,Credentials,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Credentials.cs,PromptForCredentials,The following statement contains a magic number: result = Win32.CredUIPromptForCredentials (ref info' targetName' IntPtr.Zero' errorCode' userNameAlloc' maxBytes / 2' passwordAlloc' maxBytes / 2' ref save' flags);  
Magic Number,ProcessHacker.Native.Security.Authentication,Msv1_0_InteractivePackage,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Msv1_0_InteractivePackage.cs,GetAuthData,The following statement contains a magic number: userNameOffset = domainNameOffset + lDomainName.Length * 2;  
Magic Number,ProcessHacker.Native.Security.Authentication,Msv1_0_InteractivePackage,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Msv1_0_InteractivePackage.cs,GetAuthData,The following statement contains a magic number: passwordOffset = userNameOffset + lUserName.Length * 2;  
Magic Number,ProcessHacker.Native.Security.Authentication,Msv1_0_InteractivePackage,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Msv1_0_InteractivePackage.cs,GetAuthData,The following statement contains a magic number: dataSize = passwordOffset + lPassword.Length * 2;  
Magic Number,ProcessHacker.Native.Security.Authentication,Msv1_0_InteractivePackage,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Msv1_0_InteractivePackage.cs,GetAuthData,The following statement contains a magic number: info.LogonDomainName.MaximumLength = info.LogonDomainName.Length = (ushort)(lDomainName.Length * 2);  
Magic Number,ProcessHacker.Native.Security.Authentication,Msv1_0_InteractivePackage,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Msv1_0_InteractivePackage.cs,GetAuthData,The following statement contains a magic number: info.UserName.MaximumLength = info.UserName.Length = (ushort)(lUserName.Length * 2);  
Magic Number,ProcessHacker.Native.Security.Authentication,Msv1_0_InteractivePackage,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Authentication\Msv1_0_InteractivePackage.cs,GetAuthData,The following statement contains a magic number: info.Password.MaximumLength = info.Password.Length = (ushort)(lPassword.Length * 2);  
Magic Number,ProcessHacker.Native.Security,PrivilegeSet,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\PrivilegeSet.cs,ToMemory,The following statement contains a magic number: memory.WriteInt32 (4' (int)_flags);  
Magic Number,ProcessHacker.Native.Security,PrivilegeSet,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\PrivilegeSet.cs,ToMemory,The following statement contains a magic number: for (int i = 0; i < _privileges.Count; i++)  	memory.WriteStruct<LuidAndAttributes> (8' i' _privileges [i].ToLuidAndAttributes ());  
Magic Number,ProcessHacker.Native.Security,PrivilegeSet,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\PrivilegeSet.cs,ToMemory,The following statement contains a magic number: memory.WriteStruct<LuidAndAttributes> (8' i' _privileges [i].ToLuidAndAttributes ());  
Magic Number,ProcessHacker.Native.Security,Sid,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Sid.cs,GetHashCode,The following statement contains a magic number: for (int i = 0; i < subAuthorities.Length; i++) {  	hashCode ^= identifierAuthority [(uint)hashCode % identifierAuthority.Length];  	// Reverse and XOR.  	hashCode ^= (hashCode >> 24) | ((hashCode >> 16) << 8) | ((hashCode >> 24) << 16) | (hashCode << 24);  	hashCode ^= subAuthorities [(uint)hashCode % subAuthorities.Length];  }  
Magic Number,ProcessHacker.Native.Security,Sid,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Sid.cs,GetHashCode,The following statement contains a magic number: for (int i = 0; i < subAuthorities.Length; i++) {  	hashCode ^= identifierAuthority [(uint)hashCode % identifierAuthority.Length];  	// Reverse and XOR.  	hashCode ^= (hashCode >> 24) | ((hashCode >> 16) << 8) | ((hashCode >> 24) << 16) | (hashCode << 24);  	hashCode ^= subAuthorities [(uint)hashCode % subAuthorities.Length];  }  
Magic Number,ProcessHacker.Native.Security,Sid,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Sid.cs,GetHashCode,The following statement contains a magic number: for (int i = 0; i < subAuthorities.Length; i++) {  	hashCode ^= identifierAuthority [(uint)hashCode % identifierAuthority.Length];  	// Reverse and XOR.  	hashCode ^= (hashCode >> 24) | ((hashCode >> 16) << 8) | ((hashCode >> 24) << 16) | (hashCode << 24);  	hashCode ^= subAuthorities [(uint)hashCode % subAuthorities.Length];  }  
Magic Number,ProcessHacker.Native.Security,Sid,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Sid.cs,GetHashCode,The following statement contains a magic number: for (int i = 0; i < subAuthorities.Length; i++) {  	hashCode ^= identifierAuthority [(uint)hashCode % identifierAuthority.Length];  	// Reverse and XOR.  	hashCode ^= (hashCode >> 24) | ((hashCode >> 16) << 8) | ((hashCode >> 24) << 16) | (hashCode << 24);  	hashCode ^= subAuthorities [(uint)hashCode % subAuthorities.Length];  }  
Magic Number,ProcessHacker.Native.Security,Sid,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Sid.cs,GetHashCode,The following statement contains a magic number: for (int i = 0; i < subAuthorities.Length; i++) {  	hashCode ^= identifierAuthority [(uint)hashCode % identifierAuthority.Length];  	// Reverse and XOR.  	hashCode ^= (hashCode >> 24) | ((hashCode >> 16) << 8) | ((hashCode >> 24) << 16) | (hashCode << 24);  	hashCode ^= subAuthorities [(uint)hashCode % subAuthorities.Length];  }  
Magic Number,ProcessHacker.Native.Security,Sid,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Sid.cs,GetHashCode,The following statement contains a magic number: for (int i = 0; i < subAuthorities.Length; i++) {  	hashCode ^= identifierAuthority [(uint)hashCode % identifierAuthority.Length];  	// Reverse and XOR.  	hashCode ^= (hashCode >> 24) | ((hashCode >> 16) << 8) | ((hashCode >> 24) << 16) | (hashCode << 24);  	hashCode ^= subAuthorities [(uint)hashCode % subAuthorities.Length];  }  
Magic Number,ProcessHacker.Native.Security,Sid,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Sid.cs,GetHashCode,The following statement contains a magic number: hashCode ^= (hashCode >> 24) | ((hashCode >> 16) << 8) | ((hashCode >> 24) << 16) | (hashCode << 24);  
Magic Number,ProcessHacker.Native.Security,Sid,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Sid.cs,GetHashCode,The following statement contains a magic number: hashCode ^= (hashCode >> 24) | ((hashCode >> 16) << 8) | ((hashCode >> 24) << 16) | (hashCode << 24);  
Magic Number,ProcessHacker.Native.Security,Sid,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Sid.cs,GetHashCode,The following statement contains a magic number: hashCode ^= (hashCode >> 24) | ((hashCode >> 16) << 8) | ((hashCode >> 24) << 16) | (hashCode << 24);  
Magic Number,ProcessHacker.Native.Security,Sid,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Sid.cs,GetHashCode,The following statement contains a magic number: hashCode ^= (hashCode >> 24) | ((hashCode >> 16) << 8) | ((hashCode >> 24) << 16) | (hashCode << 24);  
Magic Number,ProcessHacker.Native.Security,Sid,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Sid.cs,GetHashCode,The following statement contains a magic number: hashCode ^= (hashCode >> 24) | ((hashCode >> 16) << 8) | ((hashCode >> 24) << 16) | (hashCode << 24);  
Magic Number,ProcessHacker.Native.Security,Sid,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Security\Sid.cs,GetHashCode,The following statement contains a magic number: hashCode ^= (hashCode >> 24) | ((hashCode >> 16) << 8) | ((hashCode >> 24) << 16) | (hashCode << 24);  
Magic Number,ProcessHacker.Native.SsLogging,SsLogger,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\SsLogging\SsLogger.cs,ReadWString,The following statement contains a magic number: return data.ReadUnicodeString (KphSsWString.BufferOffset' wString.Length / 2);  
Magic Number,ProcessHacker.Native.SsLogging,SsUnicodeString,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\SsLogging\SsUnicodeString.cs,SsUnicodeString,The following statement contains a magic number: this.String = data.ReadUnicodeString (KphSsUnicodeString.BufferOffset' unicodeStringInfo.Length / 2);  
Magic Number,ProcessHacker.Native.Ui,HandlePropertiesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Ui\HandlePropertiesWindow.cs,HandlePropertiesWindow_Load,The following statement contains a magic number: if (HandlePropertiesCallback != null) {  	try {  		HandlePropertiesCallback (groupObjectInfo' _name' _typeName);  	}  	catch {  	}  	if (groupObjectInfo.Controls.Count == 0) {  		groupObjectInfo.Visible = false;  	}  	else if (groupObjectInfo.Controls.Count == 1) {  		Control control = groupObjectInfo.Controls [0];  		// If it's a user control' dock it.  		if (control is UserControl) {  			control.Dock = DockStyle.Fill;  			control.Margin = new Padding (3);  		}  		else {  			control.Location = new System.Drawing.Point (10' 20);  		}  	}  }  
Magic Number,ProcessHacker.Native.Ui,HandlePropertiesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Ui\HandlePropertiesWindow.cs,HandlePropertiesWindow_Load,The following statement contains a magic number: if (HandlePropertiesCallback != null) {  	try {  		HandlePropertiesCallback (groupObjectInfo' _name' _typeName);  	}  	catch {  	}  	if (groupObjectInfo.Controls.Count == 0) {  		groupObjectInfo.Visible = false;  	}  	else if (groupObjectInfo.Controls.Count == 1) {  		Control control = groupObjectInfo.Controls [0];  		// If it's a user control' dock it.  		if (control is UserControl) {  			control.Dock = DockStyle.Fill;  			control.Margin = new Padding (3);  		}  		else {  			control.Location = new System.Drawing.Point (10' 20);  		}  	}  }  
Magic Number,ProcessHacker.Native.Ui,HandlePropertiesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Ui\HandlePropertiesWindow.cs,HandlePropertiesWindow_Load,The following statement contains a magic number: if (HandlePropertiesCallback != null) {  	try {  		HandlePropertiesCallback (groupObjectInfo' _name' _typeName);  	}  	catch {  	}  	if (groupObjectInfo.Controls.Count == 0) {  		groupObjectInfo.Visible = false;  	}  	else if (groupObjectInfo.Controls.Count == 1) {  		Control control = groupObjectInfo.Controls [0];  		// If it's a user control' dock it.  		if (control is UserControl) {  			control.Dock = DockStyle.Fill;  			control.Margin = new Padding (3);  		}  		else {  			control.Location = new System.Drawing.Point (10' 20);  		}  	}  }  
Magic Number,ProcessHacker.Native.Ui,HandlePropertiesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Ui\HandlePropertiesWindow.cs,HandlePropertiesWindow_Load,The following statement contains a magic number: if (groupObjectInfo.Controls.Count == 0) {  	groupObjectInfo.Visible = false;  }  else if (groupObjectInfo.Controls.Count == 1) {  	Control control = groupObjectInfo.Controls [0];  	// If it's a user control' dock it.  	if (control is UserControl) {  		control.Dock = DockStyle.Fill;  		control.Margin = new Padding (3);  	}  	else {  		control.Location = new System.Drawing.Point (10' 20);  	}  }  
Magic Number,ProcessHacker.Native.Ui,HandlePropertiesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Ui\HandlePropertiesWindow.cs,HandlePropertiesWindow_Load,The following statement contains a magic number: if (groupObjectInfo.Controls.Count == 0) {  	groupObjectInfo.Visible = false;  }  else if (groupObjectInfo.Controls.Count == 1) {  	Control control = groupObjectInfo.Controls [0];  	// If it's a user control' dock it.  	if (control is UserControl) {  		control.Dock = DockStyle.Fill;  		control.Margin = new Padding (3);  	}  	else {  		control.Location = new System.Drawing.Point (10' 20);  	}  }  
Magic Number,ProcessHacker.Native.Ui,HandlePropertiesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Ui\HandlePropertiesWindow.cs,HandlePropertiesWindow_Load,The following statement contains a magic number: if (groupObjectInfo.Controls.Count == 0) {  	groupObjectInfo.Visible = false;  }  else if (groupObjectInfo.Controls.Count == 1) {  	Control control = groupObjectInfo.Controls [0];  	// If it's a user control' dock it.  	if (control is UserControl) {  		control.Dock = DockStyle.Fill;  		control.Margin = new Padding (3);  	}  	else {  		control.Location = new System.Drawing.Point (10' 20);  	}  }  
Magic Number,ProcessHacker.Native.Ui,HandlePropertiesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Ui\HandlePropertiesWindow.cs,HandlePropertiesWindow_Load,The following statement contains a magic number: if (groupObjectInfo.Controls.Count == 1) {  	Control control = groupObjectInfo.Controls [0];  	// If it's a user control' dock it.  	if (control is UserControl) {  		control.Dock = DockStyle.Fill;  		control.Margin = new Padding (3);  	}  	else {  		control.Location = new System.Drawing.Point (10' 20);  	}  }  
Magic Number,ProcessHacker.Native.Ui,HandlePropertiesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Ui\HandlePropertiesWindow.cs,HandlePropertiesWindow_Load,The following statement contains a magic number: if (groupObjectInfo.Controls.Count == 1) {  	Control control = groupObjectInfo.Controls [0];  	// If it's a user control' dock it.  	if (control is UserControl) {  		control.Dock = DockStyle.Fill;  		control.Margin = new Padding (3);  	}  	else {  		control.Location = new System.Drawing.Point (10' 20);  	}  }  
Magic Number,ProcessHacker.Native.Ui,HandlePropertiesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Ui\HandlePropertiesWindow.cs,HandlePropertiesWindow_Load,The following statement contains a magic number: if (groupObjectInfo.Controls.Count == 1) {  	Control control = groupObjectInfo.Controls [0];  	// If it's a user control' dock it.  	if (control is UserControl) {  		control.Dock = DockStyle.Fill;  		control.Margin = new Padding (3);  	}  	else {  		control.Location = new System.Drawing.Point (10' 20);  	}  }  
Magic Number,ProcessHacker.Native.Ui,HandlePropertiesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Ui\HandlePropertiesWindow.cs,HandlePropertiesWindow_Load,The following statement contains a magic number: if (control is UserControl) {  	control.Dock = DockStyle.Fill;  	control.Margin = new Padding (3);  }  else {  	control.Location = new System.Drawing.Point (10' 20);  }  
Magic Number,ProcessHacker.Native.Ui,HandlePropertiesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Ui\HandlePropertiesWindow.cs,HandlePropertiesWindow_Load,The following statement contains a magic number: if (control is UserControl) {  	control.Dock = DockStyle.Fill;  	control.Margin = new Padding (3);  }  else {  	control.Location = new System.Drawing.Point (10' 20);  }  
Magic Number,ProcessHacker.Native.Ui,HandlePropertiesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Ui\HandlePropertiesWindow.cs,HandlePropertiesWindow_Load,The following statement contains a magic number: if (control is UserControl) {  	control.Dock = DockStyle.Fill;  	control.Margin = new Padding (3);  }  else {  	control.Location = new System.Drawing.Point (10' 20);  }  
Magic Number,ProcessHacker.Native.Ui,HandlePropertiesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Ui\HandlePropertiesWindow.cs,HandlePropertiesWindow_Load,The following statement contains a magic number: control.Margin = new Padding (3);  
Magic Number,ProcessHacker.Native.Ui,HandlePropertiesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Ui\HandlePropertiesWindow.cs,HandlePropertiesWindow_Load,The following statement contains a magic number: control.Location = new System.Drawing.Point (10' 20);  
Magic Number,ProcessHacker.Native.Ui,HandlePropertiesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Ui\HandlePropertiesWindow.cs,HandlePropertiesWindow_Load,The following statement contains a magic number: control.Location = new System.Drawing.Point (10' 20);  
Missing Default,ProcessHacker.Native.Objects,FileHandle,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\Objects\FileHandle.cs,SetPosition,The following switch statement is missing a default case: switch (origin) {  case PositionOrigin.Current:  	currentPosition += offset;  	break;  case PositionOrigin.Start:  	currentPosition = offset;  	break;  case PositionOrigin.End:  	currentPosition = this.GetSize () + offset;  	break;  }  
Missing Default,ProcessHacker.Native.SsLogging,SsLogger,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker.Native\SsLogging\SsLogger.cs,ReadArgumentBlock,The following switch statement is missing a default case: switch (argBlock.Type) {  case KphSsArgumentType.Int8:  	{  		SsSimple simpleArg = new SsSimple ();  		simpleArg.Argument = argBlock.Data.Int8;  		simpleArg.Type = typeof(Byte);  		ssArg = simpleArg;  	}  	break;  case KphSsArgumentType.Int16:  	{  		SsSimple simpleArg = new SsSimple ();  		simpleArg.Argument = argBlock.Data.Int16;  		simpleArg.Type = typeof(Int16);  		ssArg = simpleArg;  	}  	break;  case KphSsArgumentType.Int32:  	{  		SsSimple simpleArg = new SsSimple ();  		simpleArg.Argument = argBlock.Data.Int32;  		simpleArg.Type = typeof(Int32);  		ssArg = simpleArg;  	}  	break;  case KphSsArgumentType.Int64:  	{  		SsSimple simpleArg = new SsSimple ();  		simpleArg.Argument = argBlock.Data.Int64;  		simpleArg.Type = typeof(Int64);  		ssArg = simpleArg;  	}  	break;  case KphSsArgumentType.Handle:  	{  		ssArg = new SsHandle (dataRegion);  	}  	break;  case KphSsArgumentType.UnicodeString:  	{  		ssArg = new SsUnicodeString (dataRegion);  	}  	break;  case KphSsArgumentType.ObjectAttributes:  	{  		ssArg = new SsObjectAttributes (dataRegion);  	}  	break;  case KphSsArgumentType.ClientId:  	{  		ssArg = new SsClientId (dataRegion);  	}  	break;  case KphSsArgumentType.Bytes:  	{  		ssArg = new SsBytes (dataRegion);  	}  	break;  }  
