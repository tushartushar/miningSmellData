Implementation smell,Namespace,Class,File,Method,Description
Long Method,dnlib.DotNet,CustomAttributeReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\CustomAttributeReader.cs,ReadValue,The method has 109 lines of code.
Long Method,dnlib.DotNet,FrameworkRedirect,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\FrameworkRedirect.cs,InitFrameworkRedirectV4,The method has 207 lines of code.
Long Method,dnlib.DotNet,FullNameFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\FullNameFactory.cs,CreateTypeSigName,The method has 207 lines of code.
Long Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,Equals,The method has 113 lines of code.
Long Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,Equals,The method has 128 lines of code.
Long Method,dnlib.DotNet,SignatureReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SignatureReader.cs,ReadType,The method has 116 lines of code.
Long Method,dnlib.DotNet,ReflectionTypeNameParser,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TypeNameParser.cs,ReadTSpecs,The method has 101 lines of code.
Long Method,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The method has 160 lines of code.
Long Method,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The method has 162 lines of code.
Long Method,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The method has 280 lines of code.
Long Method,dnlib.DotNet.MD,ENCMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\ENCMetadata.cs,InitializeInternal,The method has 132 lines of code.
Long Method,dnlib.DotNet.Pdb,PdbState,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\PdbState.cs,CreateScope,The method has 140 lines of code.
Long Method,dnlib.DotNet.Pdb.Portable,LocalConstantSigBlobReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\LocalConstantSigBlobReader.cs,ReadCore,The method has 186 lines of code.
Long Method,dnlib.DotNet.Pdb.Portable,LocalConstantSigBlobWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\LocalConstantSigBlobWriter.cs,Write,The method has 151 lines of code.
Long Method,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoReader.cs,ReadRecord,The method has 154 lines of code.
Long Method,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoWriter.cs,Write,The method has 215 lines of code.
Long Method,dnlib.DotNet.Writer,CustomAttributeWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,WriteElem,The method has 162 lines of code.
Long Method,dnlib.DotNet.Writer,Metadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Metadata.cs,InitializeTypeDefsAndMemberDefs,The method has 105 lines of code.
Long Method,dnlib.DotNet.Writer,Metadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Metadata.cs,WriteMethodBodies,The method has 129 lines of code.
Long Method,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteFile,The method has 122 lines of code.
Long Method,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The method has 121 lines of code.
Long Method,dnlib.DotNet.Writer,PEHeaders,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PEHeaders.cs,WriteTo,The method has 111 lines of code.
Long Method,dnlib.DotNet.Writer,SignatureWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\SignatureWriter.cs,Write,The method has 104 lines of code.
Complex Method,dnlib.DotNet,AssemblyDef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyDef.cs,IsFriendAssemblyOf,Cyclomatic complexity of the method is 12
Complex Method,dnlib.DotNet,AssemblyDef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyDef.cs,IsValidAssemblySignatureKeyAttribute,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,AssemblyDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyDef.cs,InitializeTargetFrameworkAttribute,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet,AssemblyDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyDef.cs,TryCreateTargetFrameworkInfo,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyHashAlgorithm.cs,GetName,Cyclomatic complexity of the method is 13
Complex Method,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyHashAlgorithm.cs,ToTypeSig,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyHashAlgorithm.cs,GetCorLibTypeSig,Cyclomatic complexity of the method is 20
Complex Method,dnlib.DotNet,AssemblyNameComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyNameComparer.cs,CompareTo,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet,AssemblyNameComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyNameComparer.cs,CompareClosest,Cyclomatic complexity of the method is 25
Complex Method,dnlib.DotNet,AssemblyResolver,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyResolver.cs,AssemblyResolver,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet,AssemblyResolver,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyResolver.cs,Resolve,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet,ConstantUser,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Constant.cs,GetElementType,Cyclomatic complexity of the method is 15
Complex Method,dnlib.DotNet,ConstantMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Constant.cs,GetValue,Cyclomatic complexity of the method is 27
Complex Method,dnlib.DotNet,CustomAttributeReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\CustomAttributeReader.cs,ReadValue,Cyclomatic complexity of the method is 26
Complex Method,dnlib.DotNet,CustomAttributeReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\CustomAttributeReader.cs,ReadFieldOrPropType,Cyclomatic complexity of the method is 19
Complex Method,dnlib.DotNet,DeclSecurity,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\DeclSecurity.cs,GetNet1xXmlStringInternal,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet,FullNameFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\FullNameFactory.cs,CreateTypeSigName,Cyclomatic complexity of the method is 51
Complex Method,dnlib.DotNet,FullNameFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\FullNameFactory.cs,GetDefinitionAssembly,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,FullNameFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\FullNameFactory.cs,GetScope,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,FullNameFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\FullNameFactory.cs,CreateMethodFullName,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,Importer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Importer.cs,ImportAsTypeSig,Cyclomatic complexity of the method is 30
Complex Method,dnlib.DotNet,Importer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Importer.cs,ImportInternal,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet,Importer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Importer.cs,Import,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet,Importer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Importer.cs,Import,Cyclomatic complexity of the method is 38
Complex Method,dnlib.DotNet,Importer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Importer.cs,Import,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,MemberFinder,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MemberFinder.cs,ProcessAll,Cyclomatic complexity of the method is 15
Complex Method,dnlib.DotNet,MemberFinder,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MemberFinder.cs,GetObjectType2,Cyclomatic complexity of the method is 13
Complex Method,dnlib.DotNet,MemberFinder,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MemberFinder.cs,Add,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,MemberFinder,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MemberFinder.cs,Add,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,MethodExportInfoProvider,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MethodExportInfoProvider.cs,Initialize,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,ModuleDef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDef.cs,GetPointerSize,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,FindCorLibAssemblyRef,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,ResolveToken,Cyclomatic complexity of the method is 25
Complex Method,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,ResolveHasCustomAttribute,Cyclomatic complexity of the method is 23
Complex Method,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,CreateResource,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,TryCreateResourceStream,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,ReadBlob,Cyclomatic complexity of the method is 28
Complex Method,dnlib.DotNet,ModuleLoader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleLoader.cs,LoadObj,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet,ModuleLoader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleLoader.cs,Load,Cyclomatic complexity of the method is 30
Complex Method,dnlib.DotNet,ReflectionExtensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ReflectionExtensions.cs,GetElementType2,Cyclomatic complexity of the method is 25
Complex Method,dnlib.DotNet,Resolver,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Resolver.cs,Resolve,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet,Resolver,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Resolver.cs,GetDeclaringType,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,GetHashCode,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 29
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,GetHashCode,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 15
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,EqualsResolutionScope,Cyclomatic complexity of the method is 17
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,EqualsImplementation,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,EqualsScope,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 20
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,GetHashCode,Cyclomatic complexity of the method is 18
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 12
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 26
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 12
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,GetHashCode,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,DeclaringTypeEquals,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,SignatureReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SignatureReader.cs,ReadType,Cyclomatic complexity of the method is 55
Complex Method,dnlib.DotNet,StrongNameSigner,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet,TIAHelper,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TIAHelper.cs,GetInfo,Cyclomatic complexity of the method is 17
Complex Method,dnlib.DotNet,TIAHelper,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TIAHelper.cs,CheckEquivalent,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet,TIAHelper,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TIAHelper.cs,Equivalent,Cyclomatic complexity of the method is 18
Complex Method,dnlib.DotNet,Info,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TIAHelper.cs,stricmp,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,TypeDef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TypeDef.cs,Remove,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,TypeDef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TypeDef.cs,GetClassSize,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,TypeDef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TypeDef.cs,FindMethodImplMethod,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet,TypeDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TypeDef.cs,InitializeMethodSemanticsAttributes,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet,TypeDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TypeDef.cs,InitializeProperty,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet,TypeDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TypeDef.cs,InitializeEvent,Cyclomatic complexity of the method is 13
Complex Method,dnlib.DotNet,TypeHelper,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TypeHelper.cs,ContainsGenericParameterInternal,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet,ReflectionTypeNameParser,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TypeNameParser.cs,ReadTSpecs,Cyclomatic complexity of the method is 19
Complex Method,dnlib.DotNet,ReflectionTypeNameParser,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TypeNameParser.cs,ReadAssemblyRef,Cyclomatic complexity of the method is 17
Complex Method,dnlib.DotNet,WinMDHelpers,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\WinMDHelpers.cs,CreateAssembly,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet,WinMDHelpers,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\WinMDHelpers.cs,GetName,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,WinMDHelpers,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\WinMDHelpers.cs,GetPublicKeyToken,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,WinMDHelpers,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\WinMDHelpers.cs,ToCLR,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.Emit,DynamicMethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\DynamicMethodBodyReader.cs,DynamicMethodBodyReader,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet.Emit,DynamicMethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\DynamicMethodBodyReader.cs,CreateExceptionHandlers,Cyclomatic complexity of the method is 15
Complex Method,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,CreateLdcI4,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,CalculateStackUsageCall,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,CalculateStackUsageNonCall,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,Cyclomatic complexity of the method is 13
Complex Method,dnlib.DotNet.Emit,InstructionPrinter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\InstructionPrinter.cs,AddOperandString,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet.Emit,InstructionPrinter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\InstructionPrinter.cs,EscapeString,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet.Emit,MethodBodyReaderBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReaderBase.cs,ReadOperand,Cyclomatic complexity of the method is 19
Complex Method,dnlib.DotNet.Emit,MethodBodyReaderBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReaderBase.cs,Add,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,Cyclomatic complexity of the method is 44
Complex Method,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,Cyclomatic complexity of the method is 45
Complex Method,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyBranches,Cyclomatic complexity of the method is 15
Complex Method,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeBranches,Cyclomatic complexity of the method is 21
Complex Method,dnlib.DotNet.MD,CompressedMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\CompressedMetadata.cs,InitializeInternal,Cyclomatic complexity of the method is 15
Complex Method,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,Cyclomatic complexity of the method is 26
Complex Method,dnlib.DotNet.MD,ENCMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\ENCMetadata.cs,InitializeInternal,Cyclomatic complexity of the method is 28
Complex Method,dnlib.DotNet.MD,ENCMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\ENCMetadata.cs,GetFieldRidList,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.MD,ENCMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\ENCMetadata.cs,GetMethodRidList,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.MD,ENCMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\ENCMetadata.cs,GetEventRidList,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.MD,ENCMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\ENCMetadata.cs,GetPropertyRidList,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.MD,MDTable,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MDTable.cs,MDTable,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.MD,MetadataBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MetadataBase.cs,FindAllRows,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.MD,MetadataBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MetadataBase.cs,InitializeInverseGenericParamOwnerRidList,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.MD,MetadataBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MetadataBase.cs,InitializeNestedClassesDictionary,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet.MD,MetadataFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MetadataFactory.cs,Create,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.MD,MetadataFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MetadataFactory.cs,GetMetadataType,Cyclomatic complexity of the method is 12
Complex Method,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\TablesStream.cs,Initialize,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.Pdb,PdbState,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\PdbState.cs,CreateScope,Cyclomatic complexity of the method is 30
Complex Method,dnlib.DotNet.Pdb,PdbState,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\PdbState.cs,GetInstruction,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.Pdb.Dss,MDEmitter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MDEmitter.cs,GetMethodProps,Cyclomatic complexity of the method is 12
Complex Method,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,CopyTypeName,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.Pdb.Managed,DbiModule,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiModule.cs,ReadLines,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet.Pdb.Managed,DbiScope,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiScope.cs,Read,Cyclomatic complexity of the method is 18
Complex Method,dnlib.DotNet.Pdb.Managed,NumericReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\NumericReader.cs,TryReadNumeric,Cyclomatic complexity of the method is 27
Complex Method,dnlib.DotNet.Pdb.Managed,PdbReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\PdbReader.cs,ReadInternal,Cyclomatic complexity of the method is 12
Complex Method,dnlib.DotNet.Pdb.Portable,DocumentNameReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\DocumentNameReader.cs,ReadSeparatorChar,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet.Pdb.Portable,ImportDefinitionKindUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\ImportDefinitionKindUtils.cs,ToPdbImportDefinitionKind,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.Pdb.Portable,ImportDefinitionKindUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\ImportDefinitionKindUtils.cs,ToImportDefinitionKind,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.Pdb.Portable,ImportScopeBlobReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\ImportScopeBlobReader.cs,Read,Cyclomatic complexity of the method is 15
Complex Method,dnlib.DotNet.Pdb.Portable,ImportScopeBlobWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\ImportScopeBlobWriter.cs,Write,Cyclomatic complexity of the method is 12
Complex Method,dnlib.DotNet.Pdb.Portable,LocalConstantSigBlobReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\LocalConstantSigBlobReader.cs,ReadCore,Cyclomatic complexity of the method is 42
Complex Method,dnlib.DotNet.Pdb.Portable,LocalConstantSigBlobWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\LocalConstantSigBlobWriter.cs,Write,Cyclomatic complexity of the method is 30
Complex Method,dnlib.DotNet.Pdb.Portable,LocalConstantSigBlobWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\LocalConstantSigBlobWriter.cs,WritePrimitiveValue,Cyclomatic complexity of the method is 21
Complex Method,dnlib.DotNet.Pdb.Portable,PortablePdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\PortablePdbCustomDebugInfoReader.cs,Read,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.Pdb.Portable,PortablePdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\PortablePdbCustomDebugInfoReader.cs,ReadAsyncMethodSteppingInformationBlob,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet.Pdb.Portable,PortablePdbCustomDebugInfoWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\PortablePdbCustomDebugInfoWriter.cs,Write,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet.Pdb.Portable,PortablePdbCustomDebugInfoWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\PortablePdbCustomDebugInfoWriter.cs,WriteAsyncMethodSteppingInformation,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.Pdb.Portable,PortablePdbReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\PortablePdbReader.cs,ReadSequencePoints,Cyclomatic complexity of the method is 13
Complex Method,dnlib.DotNet.Pdb.Portable,PortablePdbReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\PortablePdbReader.cs,GetCustomDebugInfos,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.Pdb.Portable,SymbolReaderFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\SymbolReaderFactory.cs,TryCreate,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.Pdb.Portable,SymbolReaderFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\SymbolReaderFactory.cs,TryCreateEmbeddedPortablePdbReader,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoReader.cs,Read,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoReader.cs,ReadRecord,Cyclomatic complexity of the method is 41
Complex Method,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoReader.cs,GetNestedType,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoWriter.cs,Write,Cyclomatic complexity of the method is 50
Complex Method,dnlib.DotNet.Pdb.WindowsPdb,PseudoCustomDebugInfoFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PseudoCustomDebugInfoFactory.cs,TryCreateAsyncMethod,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet.Pdb.WindowsPdb,WindowsPdbWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\WindowsPdbWriter.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.Pdb.WindowsPdb,WindowsPdbWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\WindowsPdbWriter.cs,ShouldAddMethod,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.Pdb.WindowsPdb,WindowsPdbWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\WindowsPdbWriter.cs,Write,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet.Pdb.WindowsPdb,SequencePointHelper,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\WindowsPdbWriter.cs,Write,Cyclomatic complexity of the method is 12
Complex Method,dnlib.DotNet.Resources,BuiltInResourceData,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Resources\BuiltInResourceData.cs,WriteData,Cyclomatic complexity of the method is 19
Complex Method,dnlib.DotNet.Resources,ResourceReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Resources\ResourceReader.cs,Read,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet.Resources,ResourceReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Resources\ResourceReader.cs,ReadResourceData,Cyclomatic complexity of the method is 23
Complex Method,dnlib.DotNet.Writer,CustomAttributeWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,Write,Cyclomatic complexity of the method is 12
Complex Method,dnlib.DotNet.Writer,CustomAttributeWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,VerifyValue,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet.Writer,CustomAttributeWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,ToUInt64,Cyclomatic complexity of the method is 13
Complex Method,dnlib.DotNet.Writer,CustomAttributeWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,ToDouble,Cyclomatic complexity of the method is 13
Complex Method,dnlib.DotNet.Writer,CustomAttributeWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,WriteElem,Cyclomatic complexity of the method is 42
Complex Method,dnlib.DotNet.Writer,CustomAttributeWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,TryWriteEnumUnderlyingTypeValue,Cyclomatic complexity of the method is 12
Complex Method,dnlib.DotNet.Writer,CustomAttributeWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,WriteFieldOrPropType,Cyclomatic complexity of the method is 23
Complex Method,dnlib.DotNet.Writer,ManagedExportsWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ManagedExportsWriter.cs,Initialize,Cyclomatic complexity of the method is 12
Complex Method,dnlib.DotNet.Writer,ManagedExportsWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ManagedExportsWriter.cs,WriteSdataBlob,Cyclomatic complexity of the method is 12
Complex Method,dnlib.DotNet.Writer,ManagedExportsWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ManagedExportsWriter.cs,PatchSdataBytesBlob,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.Writer,ManagedExportsWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ManagedExportsWriter.cs,WriteStubs,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.Writer,MarshalBlobWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MarshalBlobWriter.cs,Write,Cyclomatic complexity of the method is 22
Complex Method,dnlib.DotNet.Writer,MaxStackCalculator,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MaxStackCalculator.cs,Calculate,Cyclomatic complexity of the method is 22
Complex Method,dnlib.DotNet.Writer,MetadataOptions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Metadata.cs,PreserveHeapOrder,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet.Writer,Metadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Metadata.cs,InitializeTypeDefsAndMemberDefs,Cyclomatic complexity of the method is 15
Complex Method,dnlib.DotNet.Writer,Metadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Metadata.cs,WriteTypeDefAndMemberDefCustomAttributesAndCustomDebugInfos,Cyclomatic complexity of the method is 20
Complex Method,dnlib.DotNet.Writer,Metadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Metadata.cs,SortTables,Cyclomatic complexity of the method is 20
Complex Method,dnlib.DotNet.Writer,Metadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Metadata.cs,InitializeGenericParamConstraintTable,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.Writer,Metadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Metadata.cs,WriteMethodBodies,Cyclomatic complexity of the method is 23
Complex Method,dnlib.DotNet.Writer,Metadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Metadata.cs,IsEmptyRootScope,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet.Writer,Metadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Metadata.cs,AddMDTokenProvider,Cyclomatic complexity of the method is 20
Complex Method,dnlib.DotNet.Writer,Metadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Metadata.cs,GetConstantValueAsByteArray,Cyclomatic complexity of the method is 16
Complex Method,dnlib.DotNet.Writer,Metadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Metadata.cs,AddMethodDebugInformation,Cyclomatic complexity of the method is 12
Complex Method,dnlib.DotNet.Writer,Metadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Metadata.cs,GetSingleDocument,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.Writer,Metadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Metadata.cs,GetHeaps,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteFatExceptionClauses,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteSmallExceptionClauses,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.Writer,MethodBodyWriterBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBodyWriterBase.cs,WriteOperand,Cyclomatic complexity of the method is 19
Complex Method,dnlib.DotNet.Writer,ModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriter.cs,WriteFile,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.Writer,ModuleWriterOptionsBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,ModuleWriterOptionsBase,Cyclomatic complexity of the method is 13
Complex Method,dnlib.DotNet.Writer,ModuleWriterBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,WritePortablePdb,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.Writer,ModuleWriterBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,Metadata_MetadataEvent,Cyclomatic complexity of the method is 15
Complex Method,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteFile,Cyclomatic complexity of the method is 26
Complex Method,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateVTableFixups,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet.Writer,NormalMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NormalMetadata.cs,AllocateMemberDefRids,Cyclomatic complexity of the method is 21
Complex Method,dnlib.DotNet.Writer,PreserveTokensMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PreserveTokensMetadata.cs,GetAllTypeDefs,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.Writer,PreserveTokensMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PreserveTokensMetadata.cs,CreateEmptyTableRows,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet.Writer,PreserveTokensMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PreserveTokensMetadata.cs,AllocateMemberDefRids,Cyclomatic complexity of the method is 28
Complex Method,dnlib.DotNet.Writer,PreserveTokensMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PreserveTokensMetadata.cs,ReUseDeletedParamRows,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.Writer,PreserveTokensMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PreserveTokensMetadata.cs,FindMemberDefs,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet.Writer,SignatureWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\SignatureWriter.cs,Write,Cyclomatic complexity of the method is 17
Complex Method,dnlib.DotNet.Writer,SignatureWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\SignatureWriter.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.Writer,TablesHeap,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\TablesHeap.cs,CalculateLength,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.Writer,Win32ResourcesChunk,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,SetOffset,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet.Writer,Win32ResourcesChunk,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,WriteTo,Cyclomatic complexity of the method is 10
Complex Method,dnlib.IO,AlignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedNativeMemoryDataStream.cs,TryGetOffsetOf,Cyclomatic complexity of the method is 8
Complex Method,dnlib.IO,DataReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\DataReader.cs,TryReadCompressedInt32,Cyclomatic complexity of the method is 10
Complex Method,dnlib.IO,UnalignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\UnalignedNativeMemoryDataStream.cs,TryGetOffsetOf,Cyclomatic complexity of the method is 8
Long Parameter List,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyHashAlgorithm.cs,Error,The method has 5 parameters. Parameters: logger' sender' message' arg1' arg2
Long Parameter List,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyHashAlgorithm.cs,Error,The method has 6 parameters. Parameters: logger' sender' message' arg1' arg2' arg3
Long Parameter List,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyHashAlgorithm.cs,Error,The method has 7 parameters. Parameters: logger' sender' message' arg1' arg2' arg3' arg4
Long Parameter List,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyHashAlgorithm.cs,Warning,The method has 5 parameters. Parameters: logger' sender' message' arg1' arg2
Long Parameter List,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyHashAlgorithm.cs,Warning,The method has 6 parameters. Parameters: logger' sender' message' arg1' arg2' arg3
Long Parameter List,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyHashAlgorithm.cs,Warning,The method has 7 parameters. Parameters: logger' sender' message' arg1' arg2' arg3' arg4
Long Parameter List,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyHashAlgorithm.cs,Info,The method has 5 parameters. Parameters: logger' sender' message' arg1' arg2
Long Parameter List,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyHashAlgorithm.cs,Info,The method has 6 parameters. Parameters: logger' sender' message' arg1' arg2' arg3
Long Parameter List,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyHashAlgorithm.cs,Info,The method has 7 parameters. Parameters: logger' sender' message' arg1' arg2' arg3' arg4
Long Parameter List,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyHashAlgorithm.cs,Verbose,The method has 5 parameters. Parameters: logger' sender' message' arg1' arg2
Long Parameter List,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyHashAlgorithm.cs,Verbose,The method has 6 parameters. Parameters: logger' sender' message' arg1' arg2' arg3
Long Parameter List,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyHashAlgorithm.cs,Verbose,The method has 7 parameters. Parameters: logger' sender' message' arg1' arg2' arg3' arg4
Long Parameter List,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyHashAlgorithm.cs,VeryVerbose,The method has 5 parameters. Parameters: logger' sender' message' arg1' arg2
Long Parameter List,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyHashAlgorithm.cs,VeryVerbose,The method has 6 parameters. Parameters: logger' sender' message' arg1' arg2' arg3
Long Parameter List,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyHashAlgorithm.cs,VeryVerbose,The method has 7 parameters. Parameters: logger' sender' message' arg1' arg2' arg3' arg4
Long Parameter List,dnlib.DotNet,MethodSig,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\CallingConventionSig.cs,CreateStaticGeneric,The method has 5 parameters. Parameters: genParamCount' retType' argType1' argType2' argType3
Long Parameter List,dnlib.DotNet,MethodSig,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\CallingConventionSig.cs,CreateInstanceGeneric,The method has 5 parameters. Parameters: genParamCount' retType' argType1' argType2' argType3
Long Parameter List,dnlib.DotNet,MethodSig,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\CallingConventionSig.cs,MethodSig,The method has 5 parameters. Parameters: callingConvention' genParamCount' retType' argType1' argType2
Long Parameter List,dnlib.DotNet,MethodSig,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\CallingConventionSig.cs,MethodSig,The method has 6 parameters. Parameters: callingConvention' genParamCount' retType' argType1' argType2' argType3
Long Parameter List,dnlib.DotNet,MethodSig,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\CallingConventionSig.cs,MethodSig,The method has 5 parameters. Parameters: callingConvention' genParamCount' retType' argTypes' paramsAfterSentinel
Long Parameter List,dnlib.DotNet,PropertySig,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\CallingConventionSig.cs,PropertySig,The method has 5 parameters. Parameters: hasThis' retType' argType1' argType2' argType3
Long Parameter List,dnlib.DotNet,PropertySig,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\CallingConventionSig.cs,PropertySig,The method has 5 parameters. Parameters: callingConvention' genParamCount' retType' argTypes' paramsAfterSentinel
Long Parameter List,dnlib.DotNet,CpuArch,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\CpuArch.cs,WriteStub,The method has 5 parameters. Parameters: stubType' writer' imageBase' stubRva' managedFuncRva
Long Parameter List,dnlib.DotNet,X86CpuArch,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\CpuArch.cs,WriteStub,The method has 5 parameters. Parameters: stubType' writer' imageBase' stubRva' managedFuncRva
Long Parameter List,dnlib.DotNet,X64CpuArch,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\CpuArch.cs,WriteStub,The method has 5 parameters. Parameters: stubType' writer' imageBase' stubRva' managedFuncRva
Long Parameter List,dnlib.DotNet,ItaniumCpuArch,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\CpuArch.cs,WriteStub,The method has 5 parameters. Parameters: stubType' writer' imageBase' stubRva' managedFuncRva
Long Parameter List,dnlib.DotNet,ArmCpuArch,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\CpuArch.cs,WriteStub,The method has 5 parameters. Parameters: stubType' writer' imageBase' stubRva' managedFuncRva
Long Parameter List,dnlib.DotNet,ExportedTypeUser,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ExportedType.cs,ExportedTypeUser,The method has 6 parameters. Parameters: module' typeDefId' typeNamespace' typeName' flags' implementation
Long Parameter List,dnlib.DotNet,FullNameFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\FullNameFactory.cs,PropertyFullName,The method has 5 parameters. Parameters: declaringType' name' propertySig' typeGenArgs' sb
Long Parameter List,dnlib.DotNet,FullNameFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\FullNameFactory.cs,PropertyFullNameSB,The method has 5 parameters. Parameters: declaringType' name' propertySig' typeGenArgs' sb
Long Parameter List,dnlib.DotNet,FullNameFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\FullNameFactory.cs,EventFullName,The method has 5 parameters. Parameters: declaringType' name' typeDefOrRef' typeGenArgs' sb
Long Parameter List,dnlib.DotNet,FullNameFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\FullNameFactory.cs,EventFullNameSB,The method has 5 parameters. Parameters: declaringType' name' typeDefOrRef' typeGenArgs' sb
Long Parameter List,dnlib.DotNet,FullNameFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\FullNameFactory.cs,FieldFullName,The method has 5 parameters. Parameters: declaringType' name' fieldSig' typeGenArgs' sb
Long Parameter List,dnlib.DotNet,FullNameFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\FullNameFactory.cs,FieldFullNameSB,The method has 5 parameters. Parameters: declaringType' name' fieldSig' typeGenArgs' sb
Long Parameter List,dnlib.DotNet,FullNameFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\FullNameFactory.cs,MethodFullName,The method has 7 parameters. Parameters: declaringType' name' methodSig' typeGenArgs' methodGenArgs' gppMethod' sb
Long Parameter List,dnlib.DotNet,FullNameFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\FullNameFactory.cs,MethodFullNameSB,The method has 7 parameters. Parameters: declaringType' name' methodSig' typeGenArgs' methodGenArgs' gppMethod' sb
Long Parameter List,dnlib.DotNet,FullNameFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\FullNameFactory.cs,MethodBaseSigFullName,The method has 5 parameters. Parameters: declType' name' sig' gppMethod' sb
Long Parameter List,dnlib.DotNet,FullNameFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\FullNameFactory.cs,MethodBaseSigFullNameSB,The method has 5 parameters. Parameters: declType' name' sig' gppMethod' sb
Long Parameter List,dnlib.DotNet,FullNameFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\FullNameFactory.cs,FullName,The method has 6 parameters. Parameters: typeSig' isReflection' helper' typeGenArgs' methodGenArgs' sb
Long Parameter List,dnlib.DotNet,FullNameFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\FullNameFactory.cs,FullNameSB,The method has 6 parameters. Parameters: typeSig' isReflection' helper' typeGenArgs' methodGenArgs' sb
Long Parameter List,dnlib.DotNet,IMethodDecrypter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\IDecrypters.cs,GetMethodBody,The method has 5 parameters. Parameters: rid' rva' parameters' gpContext' methodBody
Long Parameter List,dnlib.DotNet,MethodExportInfoProvider,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MethodExportInfoProvider.cs,ReadNames,The method has 5 parameters. Parameters: reader' peImage' numNames' offsetOfNames' offsetOfNameIndexes
Long Parameter List,dnlib.DotNet,EmbeddedResource,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Resource.cs,EmbeddedResource,The method has 5 parameters. Parameters: name' dataReaderFactory' offset' length' flags
Long Parameter List,dnlib.DotNet,SignatureReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SignatureReader.cs,ReadTypeSig,The method has 5 parameters. Parameters: helper' corLibTypes' signature' gpContext' extraData
Long Parameter List,dnlib.DotNet,SignatureReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SignatureReader.cs,ReadTypeSig,The method has 5 parameters. Parameters: helper' corLibTypes' signature' gpContext' extraData
Long Parameter List,dnlib.DotNet,StrongNameKey,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\StrongNameKey.cs,StrongNameKey,The method has 9 parameters. Parameters: hashAlg' publicExponent' modulus' prime1' prime2' exponent1' exponent2' coefficient' privateExponent
Long Parameter List,dnlib.DotNet,TypeDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TypeDef.cs,InitializeEvent,The method has 5 parameters. Parameters: evt' addMethod' invokeMethod' removeMethod' otherMethods
Long Parameter List,dnlib.DotNet,Utils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Utils.cs,GetAssemblyNameString,The method has 5 parameters. Parameters: name' version' culture' publicKey' attributes
Long Parameter List,dnlib.DotNet,ProjectedClass,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\WinMDHelpers.cs,ProjectedClass,The method has 8 parameters. Parameters: mdns' mdname' clrns' clrname' clrAsm' contractAsm' winMDValueType' clrValueType
Long Parameter List,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReader.cs,CreateCilBody,The method has 5 parameters. Parameters: opResolver' code' exceptions' parameters' gpContext
Long Parameter List,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReader.cs,CreateCilBody,The method has 5 parameters. Parameters: opResolver' codeReader' ehReader' parameters' gpContext
Long Parameter List,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReader.cs,CreateCilBody,The method has 8 parameters. Parameters: opResolver' code' exceptions' parameters' flags' maxStack' codeSize' localVarSigTok
Long Parameter List,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReader.cs,CreateCilBody,The method has 9 parameters. Parameters: opResolver' code' exceptions' parameters' flags' maxStack' codeSize' localVarSigTok' gpContext
Long Parameter List,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReader.cs,MethodBodyReader,The method has 5 parameters. Parameters: opResolver' codeReader' ehReader' parameters' gpContext
Long Parameter List,dnlib.DotNet.Emit,OpCode,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\OpCode.cs,OpCode,The method has 7 parameters. Parameters: name' code' operandType' flowControl' opCodeType' push' pop
Long Parameter List,dnlib.DotNet.MD,ColumnInfo,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\ColumnInfo.cs,ColumnInfo,The method has 5 parameters. Parameters: index' name' columnSize' offset' size
Long Parameter List,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,InitializeSizes,The method has 5 parameters. Parameters: bigStrings' bigGuid' bigBlob' systemRowCounts' debugRowCounts
Long Parameter List,dnlib.DotNet.MD,RawModuleRow,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\RawTableRows.cs,RawModuleRow,The method has 5 parameters. Parameters: Generation' Name' Mvid' EncId' EncBaseId
Long Parameter List,dnlib.DotNet.MD,RawTypeDefRow,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\RawTableRows.cs,RawTypeDefRow,The method has 6 parameters. Parameters: Flags' Name' Namespace' Extends' FieldList' MethodList
Long Parameter List,dnlib.DotNet.MD,RawMethodRow,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\RawTableRows.cs,RawMethodRow,The method has 6 parameters. Parameters: RVA' ImplFlags' Flags' Name' Signature' ParamList
Long Parameter List,dnlib.DotNet.MD,RawAssemblyRow,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\RawTableRows.cs,RawAssemblyRow,The method has 9 parameters. Parameters: HashAlgId' MajorVersion' MinorVersion' BuildNumber' RevisionNumber' Flags' PublicKey' Name' Locale
Long Parameter List,dnlib.DotNet.MD,RawAssemblyRefRow,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\RawTableRows.cs,RawAssemblyRefRow,The method has 9 parameters. Parameters: MajorVersion' MinorVersion' BuildNumber' RevisionNumber' Flags' PublicKeyOrToken' Name' Locale' HashValue
Long Parameter List,dnlib.DotNet.MD,RawExportedTypeRow,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\RawTableRows.cs,RawExportedTypeRow,The method has 5 parameters. Parameters: Flags' TypeDefId' TypeName' TypeNamespace' Implementation
Long Parameter List,dnlib.DotNet.MD,RawGenericParamRow,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\RawTableRows.cs,RawGenericParamRow,The method has 5 parameters. Parameters: Number' Flags' Owner' Name' Kind
Long Parameter List,dnlib.DotNet.MD,RawLocalScopeRow,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\RawTableRows.cs,RawLocalScopeRow,The method has 6 parameters. Parameters: Method' ImportScope' VariableList' ConstantList' StartOffset' Length
Long Parameter List,dnlib.DotNet.MD,StreamHeader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\StreamHeader.cs,StreamHeader,The method has 5 parameters. Parameters: reader' throwOnError' verify' runtime' failedVerification
Long Parameter List,dnlib.DotNet.Pdb,PdbDocument,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\PdbDocument.cs,PdbDocument,The method has 6 parameters. Parameters: url' language' languageVendor' documentType' checkSumAlgorithmId' checkSum
Long Parameter List,dnlib.DotNet.Pdb.Dss,ISymUnmanagedReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,GetDocument,The method has 5 parameters. Parameters: url' language' languageVendor' documentType' pRetVal
Long Parameter List,dnlib.DotNet.Pdb.Dss,ISymUnmanagedReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,GetSymAttribute,The method has 5 parameters. Parameters: parent' name' cBuffer' pcBuffer' buffer
Long Parameter List,dnlib.DotNet.Pdb.Dss,ISymUnmanagedReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,GetMethodsFromDocumentPosition,The method has 6 parameters. Parameters: document' line' column' cMethod' pcMethod' pRetVal
Long Parameter List,dnlib.DotNet.Pdb.Dss,ISymUnmanagedReader2,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,GetSymAttributePreRemap,The method has 5 parameters. Parameters: parent' name' cBuffer' pcBuffer' buffer
Long Parameter List,dnlib.DotNet.Pdb.Dss,ISymUnmanagedReader3,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,GetSymAttributeByVersion,The method has 6 parameters. Parameters: token' version' name' cBuffer' pcBuffer' buffer
Long Parameter List,dnlib.DotNet.Pdb.Dss,ISymUnmanagedReader3,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,GetSymAttributeByVersionPreRemap,The method has 6 parameters. Parameters: methodToken' version' name' cBuffer' pcBuffer' buffer
Long Parameter List,dnlib.DotNet.Pdb.Dss,ISymUnmanagedDocument,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,GetSourceRange,The method has 7 parameters. Parameters: startLine' startColumn' endLine' endColumn' cSourceBytes' pcSourceBytes' source
Long Parameter List,dnlib.DotNet.Pdb.Dss,ISymUnmanagedMethod,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,GetRanges,The method has 6 parameters. Parameters: document' line' column' cRanges' pcRanges' ranges
Long Parameter List,dnlib.DotNet.Pdb.Dss,ISymUnmanagedMethod,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,GetSequencePoints,The method has 8 parameters. Parameters: cPoints' pcPoints' offsets' documents' lines' columns' endLines' endColumns
Long Parameter List,dnlib.DotNet.Pdb.Dss,ISymUnmanagedAsyncMethod,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,GetAsyncStepInfo,The method has 5 parameters. Parameters: cStepInfo' pcStepInfo' yieldOffsets' breakpointOffset' breakpointMethod
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,EnumInterfaceImpls,The method has 5 parameters. Parameters: phEnum' td' rImpls' cMax' pcImpls
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,GetTypeDefProps,The method has 6 parameters. Parameters: td' szTypeDef' cchTypeDef' pchTypeDef' pdwTypeDefFlags' ptkExtends
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,GetTypeRefProps,The method has 5 parameters. Parameters: tr' ptkResolutionScope' szName' cchName' pchName
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,EnumMembers,The method has 5 parameters. Parameters: phEnum' cl' rMembers' cMax' pcTokens
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,EnumMembersWithName,The method has 6 parameters. Parameters: phEnum' cl' szName' rMembers' cMax' pcTokens
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,EnumMethods,The method has 5 parameters. Parameters: phEnum' cl' rMethods' cMax' pcTokens
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,EnumMethodsWithName,The method has 6 parameters. Parameters: phEnum' cl' szName' rMethods' cMax' pcTokens
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,EnumFields,The method has 5 parameters. Parameters: phEnum' cl' rFields' cMax' pcTokens
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,EnumFieldsWithName,The method has 6 parameters. Parameters: phEnum' cl' szName' rFields' cMax' pcTokens
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,EnumParams,The method has 5 parameters. Parameters: phEnum' mb' rParams' cMax' pcTokens
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,EnumMemberRefs,The method has 5 parameters. Parameters: phEnum' tkParent' rMemberRefs' cMax' pcTokens
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,EnumMethodImpls,The method has 6 parameters. Parameters: phEnum' td' rMethodBody' rMethodDecl' cMax' pcTokens
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,EnumPermissionSets,The method has 6 parameters. Parameters: phEnum' tk' dwActions' rPermission' cMax' pcTokens
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,FindMember,The method has 5 parameters. Parameters: td' szName' pvSigBlob' cbSigBlob' pmb
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,FindMethod,The method has 5 parameters. Parameters: td' szName' pvSigBlob' cbSigBlob' pmb
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,FindField,The method has 5 parameters. Parameters: td' szName' pvSigBlob' cbSigBlob' pmb
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,FindMemberRef,The method has 5 parameters. Parameters: td' szName' pvSigBlob' cbSigBlob' pmr
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,GetMethodProps,The method has 10 parameters. Parameters: mb' pClass' szMethod' cchMethod' pchMethod' pdwAttr' ppvSigBlob' pcbSigBlob' pulCodeRVA' pdwImplFlags
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,GetMemberRefProps,The method has 7 parameters. Parameters: mr' ptk' szMember' cchMember' pchMember' ppvSigBlob' pbSig
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,EnumProperties,The method has 5 parameters. Parameters: phEnum' td' rProperties' cMax' pcProperties
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,EnumEvents,The method has 5 parameters. Parameters: phEnum' td' rEvents' cMax' pcEvents
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,GetEventProps,The method has 13 parameters. Parameters: ev' pClass' szEvent' cchEvent' pchEvent' pdwEventFlags' ptkEventType' pmdAddOn' pmdRemoveOn' pmdFire' rmdOtherMethod' cMax' pcOtherMethod
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,EnumMethodSemantics,The method has 5 parameters. Parameters: phEnum' mb' rEventProp' cMax' pcEventProp
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,GetClassLayout,The method has 6 parameters. Parameters: td' pdwPackSize' rFieldOffset' cMax' pcFieldOffset' pulClassSize
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,GetPinvokeMap,The method has 6 parameters. Parameters: tk' pdwMappingFlags' szImportName' cchImportName' pchImportName' pmrImportDLL
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,EnumCustomAttributes,The method has 6 parameters. Parameters: phEnum' tk' tkType' rCustomAttributes' cMax' pcCustomAttributes
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,GetCustomAttributeProps,The method has 5 parameters. Parameters: cv' ptkObj' ptkType' ppBlob' pcbSize
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,GetMemberProps,The method has 13 parameters. Parameters: mb' pClass' szMember' cchMember' pchMember' pdwAttr' ppvSigBlob' pcbSigBlob' pulCodeRVA' pdwImplFlags' pdwCPlusTypeFlag' ppValue' pcchValue
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,GetFieldProps,The method has 11 parameters. Parameters: mb' pClass' szField' cchField' pchField' pdwAttr' ppvSigBlob' pcbSigBlob' pdwCPlusTypeFlag' ppValue' pcchValue
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,GetPropertyProps,The method has 16 parameters. Parameters: prop' pClass' szProperty' cchProperty' pchProperty' pdwPropFlags' ppvSig' pbSig' pdwCPlusTypeFlag' ppDefaultValue' pcchDefaultValue' pmdSetter' pmdGetter' rmdOtherMethod' cMax' pcOtherMethod
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,GetParamProps,The method has 10 parameters. Parameters: tk' pmd' pulSequence' szName' cchName' pchName' pdwAttr' pdwCPlusTypeFlag' ppValue' pcchValue
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataEmit,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,DefineTypeDef,The method has 5 parameters. Parameters: szTypeDef' dwTypeDefFlags' tkExtends' rtkImplements' ptd
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataEmit,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,DefineNestedType,The method has 6 parameters. Parameters: szTypeDef' dwTypeDefFlags' tkExtends' rtkImplements' tdEncloser' ptd
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataEmit,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,DefineMethod,The method has 8 parameters. Parameters: td' szName' dwMethodFlags' pvSigBlob' cbSigBlob' ulCodeRVA' dwImplFlags' pmd
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataEmit,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,DefineImportType,The method has 7 parameters. Parameters: pAssemImport' pbHashValue' cbHashValue' pImport' tdImport' pAssemEmit' ptr
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataEmit,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,DefineMemberRef,The method has 5 parameters. Parameters: tkImport' szName' pvSigBlob' cbSigBlob' pmr
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataEmit,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,DefineImportMember,The method has 8 parameters. Parameters: pAssemImport' pbHashValue' cbHashValue' pImport' mbMember' pAssemEmit' tkParent' pmr
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataEmit,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,DefineEvent,The method has 9 parameters. Parameters: td' szEvent' dwEventFlags' tkEventType' mdAddOn' mdRemoveOn' mdFire' rmdOtherMethods' pmdEvent
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataEmit,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,DefinePermissionSet,The method has 5 parameters. Parameters: tk' dwAction' pvPermission' cbPermission' ppm
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataEmit,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,SetEventProps,The method has 7 parameters. Parameters: ev' dwEventFlags' tkEventType' mdAddOn' mdRemoveOn' mdFire' rmdOtherMethods
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataEmit,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,SetPermissionSetProps,The method has 5 parameters. Parameters: tk' dwAction' pvPermission' cbPermission' ppm
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataEmit,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,DefineCustomAttribute,The method has 5 parameters. Parameters: tkOwner' tkCtor' pCustomAttribute' cbCustomAttribute' pcv
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataEmit,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,DefineField,The method has 9 parameters. Parameters: td' szName' dwFieldFlags' pvSigBlob' cbSigBlob' dwCPlusTypeFlag' pValue' cchValue' pmd
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataEmit,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,DefineProperty,The method has 12 parameters. Parameters: td' szProperty' dwPropFlags' pvSig' cbSig' dwCPlusTypeFlag' pValue' cchValue' mdSetter' mdGetter' rmdOtherMethods' pmdProp
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataEmit,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,DefineParam,The method has 8 parameters. Parameters: md' ulParamSeq' szName' dwParamFlags' dwCPlusTypeFlag' pValue' cchValue' ppd
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataEmit,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,SetFieldProps,The method has 5 parameters. Parameters: fd' dwFieldFlags' dwCPlusTypeFlag' pValue' cchValue
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataEmit,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,SetPropertyProps,The method has 8 parameters. Parameters: pr' dwPropFlags' dwCPlusTypeFlag' pValue' cchValue' mdSetter' mdGetter' rmdOtherMethods
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataEmit,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,SetParamProps,The method has 6 parameters. Parameters: pd' szName' dwParamFlags' dwCPlusTypeFlag' pValue' cchValue
Long Parameter List,dnlib.DotNet.Pdb.Dss,IMetaDataEmit,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,TranslateSigWithScope,The method has 11 parameters. Parameters: pAssemImport' pbHashValue' cbHashValue' import' pbSigBlob' cbSigBlob' pAssemEmit' emit' pvTranslatedSig' cbTranslatedSigMax' pcbTranslatedSig
Long Parameter List,dnlib.DotNet.Pdb.Dss,ISymUnmanagedWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,DefineDocument,The method has 5 parameters. Parameters: url' language' languageVendor' documentType' pRetVal
Long Parameter List,dnlib.DotNet.Pdb.Dss,ISymUnmanagedWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,DefineLocalVariable,The method has 10 parameters. Parameters: name' attributes' cSig' signature' addrKind' addr1' addr2' addr3' startOffset' endOffset
Long Parameter List,dnlib.DotNet.Pdb.Dss,ISymUnmanagedWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,DefineParameter,The method has 7 parameters. Parameters: name' attributes' sequence' addrKind' addr1' addr2' addr3
Long Parameter List,dnlib.DotNet.Pdb.Dss,ISymUnmanagedWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,DefineField,The method has 9 parameters. Parameters: parent' name' attributes' cSig' signature' addrKind' addr1' addr2' addr3
Long Parameter List,dnlib.DotNet.Pdb.Dss,ISymUnmanagedWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,DefineGlobalVariable,The method has 8 parameters. Parameters: name' attributes' cSig' signature' addrKind' addr1' addr2' addr3
Long Parameter List,dnlib.DotNet.Pdb.Dss,ISymUnmanagedWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,SetMethodSourceRange,The method has 6 parameters. Parameters: startDoc' startLine' startColumn' endDoc' endLine' endColumn
Long Parameter List,dnlib.DotNet.Pdb.Dss,ISymUnmanagedWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,DefineSequencePoints,The method has 7 parameters. Parameters: document' spCount' offsets' lines' columns' endLines' endColumns
Long Parameter List,dnlib.DotNet.Pdb.Dss,ISymUnmanagedWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,Initialize2,The method has 5 parameters. Parameters: emitter' tempfilename' pIStream' fFullBuild' finalfilename
Long Parameter List,dnlib.DotNet.Pdb.Dss,ISymUnmanagedWriter2,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,DefineDocument,The method has 5 parameters. Parameters: url' language' languageVendor' documentType' pRetVal
Long Parameter List,dnlib.DotNet.Pdb.Dss,ISymUnmanagedWriter2,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,DefineLocalVariable,The method has 10 parameters. Parameters: name' attributes' cSig' signature' addrKind' addr1' addr2' addr3' startOffset' endOffset
Long Parameter List,dnlib.DotNet.Pdb.Dss,ISymUnmanagedWriter2,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,DefineParameter,The method has 7 parameters. Parameters: name' attributes' sequence' addrKind' addr1' addr2' addr3
Long Parameter List,dnlib.DotNet.Pdb.Dss,ISymUnmanagedWriter2,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,DefineField,The method has 9 parameters. Parameters: parent' name' attributes' cSig' signature' addrKind' addr1' addr2' addr3
Long Parameter List,dnlib.DotNet.Pdb.Dss,ISymUnmanagedWriter2,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,DefineGlobalVariable,The method has 8 parameters. Parameters: name' attributes' cSig' signature' addrKind' addr1' addr2' addr3
Long Parameter List,dnlib.DotNet.Pdb.Dss,ISymUnmanagedWriter2,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,SetMethodSourceRange,The method has 6 parameters. Parameters: startDoc' startLine' startColumn' endDoc' endLine' endColumn
Long Parameter List,dnlib.DotNet.Pdb.Dss,ISymUnmanagedWriter2,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,DefineSequencePoints,The method has 7 parameters. Parameters: document' spCount' offsets' lines' columns' endLines' endColumns
Long Parameter List,dnlib.DotNet.Pdb.Dss,ISymUnmanagedWriter2,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,Initialize2,The method has 5 parameters. Parameters: emitter' tempfilename' pIStream' fFullBuild' finalfilename
Long Parameter List,dnlib.DotNet.Pdb.Dss,ISymUnmanagedWriter2,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,DefineLocalVariable2,The method has 9 parameters. Parameters: name' attributes' sigToken' addrKind' addr1' addr2' addr3' startOffset' endOffset
Long Parameter List,dnlib.DotNet.Pdb.Dss,ISymUnmanagedWriter2,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,DefineGlobalVariable2,The method has 7 parameters. Parameters: name' attributes' sigToken' addrKind' addr1' addr2' addr3
Long Parameter List,dnlib.DotNet.Pdb.Dss,ISymUnmanagedWriter5,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ComInterfaces.cs,MapTokenToSourceSpan,The method has 6 parameters. Parameters: token' document' line' column' endLine' endColumn
Long Parameter List,dnlib.DotNet.Pdb.Dss,MDEmitter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MDEmitter.cs,GetMethodProps,The method has 10 parameters. Parameters: mb' pClass' szMethod' cchMethod' pchMethod' pdwAttr' ppvSigBlob' pcbSigBlob' pulCodeRVA' pdwImplFlags
Long Parameter List,dnlib.DotNet.Pdb.Dss,MDEmitter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MDEmitter.cs,GetTypeDefProps,The method has 6 parameters. Parameters: td' szTypeDef' cchTypeDef' pchTypeDef' pdwTypeDefFlags' ptkExtends
Long Parameter List,dnlib.DotNet.Pdb.Dss,MDEmitter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MDEmitter.cs,DefineTypeDef,The method has 5 parameters. Parameters: szTypeDef' dwTypeDefFlags' tkExtends' rtkImplements' ptd
Long Parameter List,dnlib.DotNet.Pdb.Dss,MDEmitter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MDEmitter.cs,DefineNestedType,The method has 6 parameters. Parameters: szTypeDef' dwTypeDefFlags' tkExtends' rtkImplements' tdEncloser' ptd
Long Parameter List,dnlib.DotNet.Pdb.Dss,MDEmitter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MDEmitter.cs,DefineMethod,The method has 8 parameters. Parameters: td' szName' dwMethodFlags' pvSigBlob' cbSigBlob' ulCodeRVA' dwImplFlags' pmd
Long Parameter List,dnlib.DotNet.Pdb.Dss,MDEmitter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MDEmitter.cs,DefineImportType,The method has 7 parameters. Parameters: pAssemImport' pbHashValue' cbHashValue' pImport' tdImport' pAssemEmit' ptr
Long Parameter List,dnlib.DotNet.Pdb.Dss,MDEmitter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MDEmitter.cs,DefineMemberRef,The method has 5 parameters. Parameters: tkImport' szName' pvSigBlob' cbSigBlob' pmr
Long Parameter List,dnlib.DotNet.Pdb.Dss,MDEmitter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MDEmitter.cs,DefineImportMember,The method has 8 parameters. Parameters: pAssemImport' pbHashValue' cbHashValue' pImport' mbMember' pAssemEmit' tkParent' pmr
Long Parameter List,dnlib.DotNet.Pdb.Dss,MDEmitter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MDEmitter.cs,DefineEvent,The method has 9 parameters. Parameters: td' szEvent' dwEventFlags' tkEventType' mdAddOn' mdRemoveOn' mdFire' rmdOtherMethods' pmdEvent
Long Parameter List,dnlib.DotNet.Pdb.Dss,MDEmitter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MDEmitter.cs,DefinePermissionSet,The method has 5 parameters. Parameters: tk' dwAction' pvPermission' cbPermission' ppm
Long Parameter List,dnlib.DotNet.Pdb.Dss,MDEmitter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MDEmitter.cs,SetEventProps,The method has 7 parameters. Parameters: ev' dwEventFlags' tkEventType' mdAddOn' mdRemoveOn' mdFire' rmdOtherMethods
Long Parameter List,dnlib.DotNet.Pdb.Dss,MDEmitter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MDEmitter.cs,SetPermissionSetProps,The method has 5 parameters. Parameters: tk' dwAction' pvPermission' cbPermission' ppm
Long Parameter List,dnlib.DotNet.Pdb.Dss,MDEmitter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MDEmitter.cs,DefineCustomAttribute,The method has 5 parameters. Parameters: tkOwner' tkCtor' pCustomAttribute' cbCustomAttribute' pcv
Long Parameter List,dnlib.DotNet.Pdb.Dss,MDEmitter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MDEmitter.cs,DefineField,The method has 9 parameters. Parameters: td' szName' dwFieldFlags' pvSigBlob' cbSigBlob' dwCPlusTypeFlag' pValue' cchValue' pmd
Long Parameter List,dnlib.DotNet.Pdb.Dss,MDEmitter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MDEmitter.cs,DefineProperty,The method has 12 parameters. Parameters: td' szProperty' dwPropFlags' pvSig' cbSig' dwCPlusTypeFlag' pValue' cchValue' mdSetter' mdGetter' rmdOtherMethods' pmdProp
Long Parameter List,dnlib.DotNet.Pdb.Dss,MDEmitter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MDEmitter.cs,DefineParam,The method has 8 parameters. Parameters: md' ulParamSeq' szName' dwParamFlags' dwCPlusTypeFlag' pValue' cchValue' ppd
Long Parameter List,dnlib.DotNet.Pdb.Dss,MDEmitter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MDEmitter.cs,SetFieldProps,The method has 5 parameters. Parameters: fd' dwFieldFlags' dwCPlusTypeFlag' pValue' cchValue
Long Parameter List,dnlib.DotNet.Pdb.Dss,MDEmitter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MDEmitter.cs,SetPropertyProps,The method has 8 parameters. Parameters: pr' dwPropFlags' dwCPlusTypeFlag' pValue' cchValue' mdSetter' mdGetter' rmdOtherMethods
Long Parameter List,dnlib.DotNet.Pdb.Dss,MDEmitter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MDEmitter.cs,SetParamProps,The method has 6 parameters. Parameters: pd' szName' dwParamFlags' dwCPlusTypeFlag' pValue' cchValue
Long Parameter List,dnlib.DotNet.Pdb.Dss,MDEmitter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MDEmitter.cs,TranslateSigWithScope,The method has 11 parameters. Parameters: pAssemImport' pbHashValue' cbHashValue' import' pbSigBlob' cbSigBlob' pAssemEmit' emit' pvTranslatedSig' cbTranslatedSigMax' pcbTranslatedSig
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,GetTypeDefProps,The method has 6 parameters. Parameters: td' szTypeDef' cchTypeDef' pchTypeDef' pdwTypeDefFlags' ptkExtends
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,GetMethodProps,The method has 10 parameters. Parameters: mb' pClass' szMethod' cchMethod' pchMethod' pdwAttr' ppvSigBlob' pcbSigBlob' pulCodeRVA' pdwImplFlags
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,GetTypeRefProps,The method has 5 parameters. Parameters: tr' ptkResolutionScope' szName' cchName' pchName
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,CopyTypeName,The method has 5 parameters. Parameters: typeNamespace' typeName' destBuffer' destBufferLen' requiredLength
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,EnumInterfaceImpls,The method has 5 parameters. Parameters: phEnum' td' rImpls' cMax' pcImpls
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,EnumMembers,The method has 5 parameters. Parameters: phEnum' cl' rMembers' cMax' pcTokens
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,EnumMembersWithName,The method has 6 parameters. Parameters: phEnum' cl' szName' rMembers' cMax' pcTokens
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,EnumMethods,The method has 5 parameters. Parameters: phEnum' cl' rMethods' cMax' pcTokens
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,EnumMethodsWithName,The method has 6 parameters. Parameters: phEnum' cl' szName' rMethods' cMax' pcTokens
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,EnumFields,The method has 5 parameters. Parameters: phEnum' cl' rFields' cMax' pcTokens
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,EnumFieldsWithName,The method has 6 parameters. Parameters: phEnum' cl' szName' rFields' cMax' pcTokens
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,EnumParams,The method has 5 parameters. Parameters: phEnum' mb' rParams' cMax' pcTokens
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,EnumMemberRefs,The method has 5 parameters. Parameters: phEnum' tkParent' rMemberRefs' cMax' pcTokens
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,EnumMethodImpls,The method has 6 parameters. Parameters: phEnum' td' rMethodBody' rMethodDecl' cMax' pcTokens
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,EnumPermissionSets,The method has 6 parameters. Parameters: phEnum' tk' dwActions' rPermission' cMax' pcTokens
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,FindMember,The method has 5 parameters. Parameters: td' szName' pvSigBlob' cbSigBlob' pmb
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,FindMethod,The method has 5 parameters. Parameters: td' szName' pvSigBlob' cbSigBlob' pmb
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,FindField,The method has 5 parameters. Parameters: td' szName' pvSigBlob' cbSigBlob' pmb
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,FindMemberRef,The method has 5 parameters. Parameters: td' szName' pvSigBlob' cbSigBlob' pmr
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,GetMemberRefProps,The method has 7 parameters. Parameters: mr' ptk' szMember' cchMember' pchMember' ppvSigBlob' pbSig
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,EnumProperties,The method has 5 parameters. Parameters: phEnum' td' rProperties' cMax' pcProperties
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,EnumEvents,The method has 5 parameters. Parameters: phEnum' td' rEvents' cMax' pcEvents
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,GetEventProps,The method has 13 parameters. Parameters: ev' pClass' szEvent' cchEvent' pchEvent' pdwEventFlags' ptkEventType' pmdAddOn' pmdRemoveOn' pmdFire' rmdOtherMethod' cMax' pcOtherMethod
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,EnumMethodSemantics,The method has 5 parameters. Parameters: phEnum' mb' rEventProp' cMax' pcEventProp
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,GetClassLayout,The method has 6 parameters. Parameters: td' pdwPackSize' rFieldOffset' cMax' pcFieldOffset' pulClassSize
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,GetPinvokeMap,The method has 6 parameters. Parameters: tk' pdwMappingFlags' szImportName' cchImportName' pchImportName' pmrImportDLL
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,EnumCustomAttributes,The method has 6 parameters. Parameters: phEnum' tk' tkType' rCustomAttributes' cMax' pcCustomAttributes
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,GetCustomAttributeProps,The method has 5 parameters. Parameters: cv' ptkObj' ptkType' ppBlob' pcbSize
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,GetMemberProps,The method has 13 parameters. Parameters: mb' pClass' szMember' cchMember' pchMember' pdwAttr' ppvSigBlob' pcbSigBlob' pulCodeRVA' pdwImplFlags' pdwCPlusTypeFlag' ppValue' pcchValue
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,GetFieldProps,The method has 11 parameters. Parameters: mb' pClass' szField' cchField' pchField' pdwAttr' ppvSigBlob' pcbSigBlob' pdwCPlusTypeFlag' ppValue' pcchValue
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,GetPropertyProps,The method has 16 parameters. Parameters: prop' pClass' szProperty' cchProperty' pchProperty' pdwPropFlags' ppvSig' pbSig' pdwCPlusTypeFlag' ppDefaultValue' pcchDefaultValue' pmdSetter' pmdGetter' rmdOtherMethod' cMax' pcOtherMethod
Long Parameter List,dnlib.DotNet.Pdb.Dss,MetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MetaDataImport.cs,GetParamProps,The method has 10 parameters. Parameters: tk' pmd' pulSequence' szName' cchName' pchName' pdwAttr' pdwCPlusTypeFlag' ppValue' pcchValue
Long Parameter List,dnlib.DotNet.Pdb.Dss,ReaderMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ReaderMetaDataImport.cs,GetTypeRefProps,The method has 5 parameters. Parameters: tr' ptkResolutionScope' szName' cchName' pchName
Long Parameter List,dnlib.DotNet.Pdb.Dss,ReaderMetaDataImport,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\ReaderMetaDataImport.cs,GetTypeDefProps,The method has 6 parameters. Parameters: td' szTypeDef' cchTypeDef' pchTypeDef' pdwTypeDefFlags' ptkExtends
Long Parameter List,dnlib.DotNet.Pdb.Dss,SymbolWriterImpl,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\SymbolWriterImpl.cs,SymbolWriterImpl,The method has 5 parameters. Parameters: writer' pdbFileName' pdbStream' options' ownsStream
Long Parameter List,dnlib.DotNet.Pdb.Dss,SymbolWriterImpl,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\SymbolWriterImpl.cs,DefineSequencePoints,The method has 7 parameters. Parameters: document' arraySize' offsets' lines' columns' endLines' endColumns
Long Parameter List,dnlib.DotNet.Pdb.Dss,SymbolWriterImpl,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\SymbolWriterImpl.cs,GetDebugInfo,The method has 6 parameters. Parameters: pdbChecksumAlgorithm' pdbAge' guid' stamp' pIDD' codeViewData
Long Parameter List,dnlib.DotNet.Pdb.Dss,SymbolWriterImpl,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\SymbolWriterImpl.cs,DefineLocalVariable,The method has 9 parameters. Parameters: name' attributes' sigToken' addrKind' addr1' addr2' addr3' startOffset' endOffset
Long Parameter List,dnlib.DotNet.Pdb.Managed,DbiScope,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiScope.cs,DbiScope,The method has 5 parameters. Parameters: method' parent' name' offset' length
Long Parameter List,dnlib.DotNet.Pdb.Portable,ImportScopeBlobWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\ImportScopeBlobWriter.cs,Write,The method has 5 parameters. Parameters: helper' systemMetadata' writer' blobHeap' imports
Long Parameter List,dnlib.DotNet.Pdb.Portable,LocalConstantSigBlobWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\LocalConstantSigBlobWriter.cs,Write,The method has 5 parameters. Parameters: helper' systemMetadata' writer' type' value
Long Parameter List,dnlib.DotNet.Pdb.Portable,PortablePdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\PortablePdbCustomDebugInfoReader.cs,Read,The method has 6 parameters. Parameters: module' typeOpt' bodyOpt' gpContext' kind' reader
Long Parameter List,dnlib.DotNet.Pdb.Portable,PortablePdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\PortablePdbCustomDebugInfoReader.cs,PortablePdbCustomDebugInfoReader,The method has 5 parameters. Parameters: module' typeOpt' bodyOpt' gpContext' reader
Long Parameter List,dnlib.DotNet.Pdb.Portable,PortablePdbCustomDebugInfoWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\PortablePdbCustomDebugInfoWriter.cs,Write,The method has 5 parameters. Parameters: helper' methodContext' systemMetadata' cdi' context
Long Parameter List,dnlib.DotNet.Pdb.Portable,PortablePdbReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\PortablePdbReader.cs,GetCustomDebugInfos,The method has 6 parameters. Parameters: token' gpContext' result' methodOpt' bodyOpt' asyncStepInfo
Long Parameter List,dnlib.DotNet.Pdb.Portable,SymbolDocumentImpl,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\SymbolDocumentImpl.cs,SymbolDocumentImpl,The method has 7 parameters. Parameters: url' language' languageVendor' documentType' checkSumAlgorithmId' checkSum' customDebugInfos
Long Parameter List,dnlib.DotNet.Pdb.Portable,SymbolMethodImpl,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\SymbolMethodImpl.cs,SymbolMethodImpl,The method has 5 parameters. Parameters: reader' token' rootScope' sequencePoints' kickoffMethod
Long Parameter List,dnlib.DotNet.Pdb.Portable,SymbolScopeImpl,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\SymbolScopeImpl.cs,SymbolScopeImpl,The method has 5 parameters. Parameters: owner' parent' startOffset' endOffset' customDebugInfos
Long Parameter List,dnlib.DotNet.Pdb.WindowsPdb,PseudoCustomDebugInfoFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PseudoCustomDebugInfoFactory.cs,TryCreateAsyncMethod,The method has 6 parameters. Parameters: module' method' body' asyncKickoffMethod' asyncStepInfos' asyncCatchHandlerILOffset
Long Parameter List,dnlib.DotNet.Pdb.WindowsPdb,SymbolWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\SymbolWriter.cs,GetDebugInfo,The method has 6 parameters. Parameters: pdbChecksumAlgorithm' pdbAge' guid' stamp' pIDD' codeViewData
Long Parameter List,dnlib.DotNet.Pdb.WindowsPdb,SymbolWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\SymbolWriter.cs,DefineSequencePoints,The method has 7 parameters. Parameters: document' arraySize' offsets' lines' columns' endLines' endColumns
Long Parameter List,dnlib.DotNet.Pdb.WindowsPdb,SymbolWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\SymbolWriter.cs,DefineLocalVariable,The method has 9 parameters. Parameters: name' attributes' sigToken' addrKind' addr1' addr2' addr3' startOffset' endOffset
Long Parameter List,dnlib.DotNet.Pdb.WindowsPdb,WindowsPdbWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\WindowsPdbWriter.cs,GetDebugInfo,The method has 6 parameters. Parameters: pdbChecksumAlgorithm' pdbAge' guid' stamp' idd' codeViewData
Long Parameter List,dnlib.DotNet.Writer,DebugDirectory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DebugDirectory.cs,Add,The method has 5 parameters. Parameters: data' type' majorVersion' minorVersion' timeDateStamp
Long Parameter List,dnlib.DotNet.Writer,DebugDirectory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DebugDirectory.cs,Add,The method has 5 parameters. Parameters: chunk' type' majorVersion' minorVersion' timeDateStamp
Long Parameter List,dnlib.DotNet.Writer,DeclSecurityWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DeclSecurityWriter.cs,Write,The method has 5 parameters. Parameters: module' secAttrs' helper' optimizeCustomAttributeSerializedTypeNames' context
Long Parameter List,dnlib.DotNet.Writer,ManagedExportsWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ManagedExportsWriter.cs,ManagedExportsWriter,The method has 6 parameters. Parameters: moduleName' machine' relocDirectory' metadata' peHeaders' logError
Long Parameter List,dnlib.DotNet.Writer,Metadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Metadata.cs,Create,The method has 6 parameters. Parameters: module' constants' methodBodies' netResources' options' debugKind
Long Parameter List,dnlib.DotNet.Writer,Metadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Metadata.cs,Metadata,The method has 7 parameters. Parameters: module' constants' methodBodies' netResources' options' debugKind' isStandaloneDebugMetadata
Long Parameter List,dnlib.DotNet.Writer,ModuleWriterOptionsBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,InitializeEnhancedStrongNameSigning,The method has 5 parameters. Parameters: module' signatureKey' signaturePubKey' identityKey' identityPubKey
Long Parameter List,dnlib.DotNet.Writer,ModuleWriterBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,CalculateRvasAndFileOffsets,The method has 5 parameters. Parameters: chunks' offset' rva' fileAlignment' sectionAlignment
Long Parameter List,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,ReuseIfPossible,The method has 5 parameters. Parameters: section' chunk' origRva' origSize' requiredAlignment
Long Parameter List,dnlib.DotNet.Writer,NormalMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NormalMetadata.cs,NormalMetadata,The method has 7 parameters. Parameters: module' constants' methodBodies' netResources' options' debugKind' isStandaloneDebugMetadata
Long Parameter List,dnlib.DotNet.Writer,PreserveTokensMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PreserveTokensMetadata.cs,PreserveTokensMetadata,The method has 7 parameters. Parameters: module' constants' methodBodies' netResources' options' debugKind' isStandaloneDebugMetadata
Long Parameter List,dnlib.IO,Windows,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\MemoryMappedDataReaderFactory.cs,CreateFile,The method has 7 parameters. Parameters: lpFileName' dwDesiredAccess' dwShareMode' lpSecurityAttributes' dwCreationDisposition' dwFlagsAndAttributes' hTemplateFile
Long Parameter List,dnlib.IO,Windows,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\MemoryMappedDataReaderFactory.cs,CreateFileMapping,The method has 6 parameters. Parameters: hFile' lpAttributes' flProtect' dwMaximumSizeHigh' dwMaximumSizeLow' lpName
Long Parameter List,dnlib.IO,Windows,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\MemoryMappedDataReaderFactory.cs,MapViewOfFile,The method has 5 parameters. Parameters: hFileMappingObject' dwDesiredAccess' dwFileOffsetHigh' dwFileOffsetLow' dwNumberOfBytesToMap
Long Parameter List,dnlib.IO,Unix,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\MemoryMappedDataReaderFactory.cs,mmap32,The method has 6 parameters. Parameters: addr' length' prot' flags' fd' offset
Long Parameter List,dnlib.IO,Unix,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\MemoryMappedDataReaderFactory.cs,mmap64,The method has 6 parameters. Parameters: addr' length' prot' flags' fd' offset
Long Parameter List,dnlib.W32Resources,ResourceData,D:\research\architectureSmells\repos\0xd4d_dnlib\src\W32Resources\ResourceData.cs,ResourceData,The method has 6 parameters. Parameters: name' dataReaderFactory' offset' length' codePage' reserved
Long Parameter List,dnlib.W32Resources,Win32ResourcesPE,D:\research\architectureSmells\repos\0xd4d_dnlib\src\W32Resources\Win32Resources.cs,Win32ResourcesPE,The method has 9 parameters. Parameters: rvaConverter' rsrcReader_factory' rsrcReader_offset' rsrcReader_length' owns_rsrcReader_factory' dataReader_factory' dataReader_offset' dataReader_length' owns_dataReader_factory
Long Parameter List,dnlib.W32Resources,Win32ResourcesPE,D:\research\architectureSmells\repos\0xd4d_dnlib\src\W32Resources\Win32Resources.cs,Win32ResourcesPE,The method has 5 parameters. Parameters: peImage' rsrcReader_factory' rsrcReader_offset' rsrcReader_length' owns_rsrcReader_factory
Long Parameter List,dnlib.W32Resources,Win32ResourcesPE,D:\research\architectureSmells\repos\0xd4d_dnlib\src\W32Resources\Win32Resources.cs,GetDataReaderInfo,The method has 5 parameters. Parameters: rva' size' dataReaderFactory' dataOffset' dataLength
Long Identifier,dnlib.DotNet,DummyLogger,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ILogger.cs,,The length of the parameter ThrowModuleWriterExceptionOnErrorInstance is 41.
Long Identifier,dnlib.DotNet,ModuleDef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDef.cs,,The length of the parameter nativeAndManagedEntryPoint_initialized is 38.
Long Identifier,dnlib.DotNet,FieldEqualityComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,,The length of the parameter CaseInsensitiveCompareDeclaringTypes is 36.
Long Identifier,dnlib.DotNet,FieldEqualityComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,,The length of the parameter CaseInsensitiveDontCompareDeclaringTypes is 40.
Long Identifier,dnlib.DotNet,MethodEqualityComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,,The length of the parameter CaseInsensitiveCompareDeclaringTypes is 36.
Long Identifier,dnlib.DotNet,MethodEqualityComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,,The length of the parameter CaseInsensitiveDontCompareDeclaringTypes is 40.
Long Identifier,dnlib.DotNet,PropertyEqualityComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,,The length of the parameter CaseInsensitiveCompareDeclaringTypes is 36.
Long Identifier,dnlib.DotNet,PropertyEqualityComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,,The length of the parameter CaseInsensitiveDontCompareDeclaringTypes is 40.
Long Identifier,dnlib.DotNet,EventEqualityComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,,The length of the parameter CaseInsensitiveCompareDeclaringTypes is 36.
Long Identifier,dnlib.DotNet,EventEqualityComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,,The length of the parameter CaseInsensitiveDontCompareDeclaringTypes is 40.
Long Identifier,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,,The length of the parameter SigComparerOptions_SubstituteGenericParameters is 46.
Long Identifier,dnlib.DotNet,TypeSpec,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TypeSpec.cs,,The length of the parameter typeSigAndExtraData_isInitialized is 33.
Long Identifier,dnlib.DotNet,WinMDHelpers,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\WinMDHelpers.cs,,The length of the parameter clrAsmName_SystemNumericsVectors is 32.
Long Identifier,dnlib.DotNet,WinMDHelpers,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\WinMDHelpers.cs,,The length of the parameter clrAsmName_SystemRuntimeInteropServicesWindowsRuntime is 53.
Long Identifier,dnlib.DotNet,WinMDHelpers,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\WinMDHelpers.cs,,The length of the parameter clrAsmName_SystemRuntimeWindowsRuntime is 38.
Long Identifier,dnlib.DotNet,WinMDHelpers,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\WinMDHelpers.cs,,The length of the parameter clrAsmName_SystemRuntimeWindowsRuntimeUIXaml is 44.
Long Identifier,dnlib.DotNet.Pdb,CustomDebugInfoGuids,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\CustomDebugInfoGuids.cs,,The length of the parameter AsyncMethodSteppingInformationBlob is 34.
Long Identifier,dnlib.DotNet.Pdb,CustomDebugInfoGuids,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\CustomDebugInfoGuids.cs,,The length of the parameter StateMachineHoistedLocalScopes is 30.
Long Identifier,dnlib.DotNet.Pdb.Dss,SymbolReaderWriterFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\SymbolReaderWriterFactory.cs,,The length of the parameter canTry_Microsoft_DiaSymReader_Native is 36.
Long Identifier,dnlib.DotNet.Writer,DebugDirectory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DebugDirectory.cs,,The length of the parameter DEFAULT_DEBUGDIRECTORY_ALIGNMENT is 32.
Long Identifier,dnlib.DotNet.Writer,DeclSecurityWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DeclSecurityWriter.cs,Write,The length of the parameter optimizeCustomAttributeSerializedTypeNames is 42.
Long Identifier,dnlib.DotNet.Writer,DeclSecurityWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DeclSecurityWriter.cs,Write,The length of the parameter optimizeCustomAttributeSerializedTypeNames is 42.
Long Identifier,dnlib.DotNet.Writer,DeclSecurityWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DeclSecurityWriter.cs,DeclSecurityWriter,The length of the parameter optimizeCustomAttributeSerializedTypeNames is 42.
Long Identifier,dnlib.DotNet.Writer,DeclSecurityWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DeclSecurityWriter.cs,,The length of the parameter optimizeCustomAttributeSerializedTypeNames is 42.
Long Identifier,dnlib.DotNet.Writer,SdataBytesInfo,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ManagedExportsWriter.cs,,The length of the parameter exportDirModuleNameStreamOffset is 31.
Long Identifier,dnlib.DotNet.Writer,SdataBytesInfo,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ManagedExportsWriter.cs,,The length of the parameter exportDirAddressOfFunctionsStreamOffset is 39.
Long Identifier,dnlib.DotNet.Writer,SdataBytesInfo,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ManagedExportsWriter.cs,,The length of the parameter addressOfFunctionsStreamOffset is 30.
Long Identifier,dnlib.DotNet.Writer,SdataBytesInfo,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ManagedExportsWriter.cs,,The length of the parameter addressOfNameOrdinalsStreamOffset is 33.
Long Identifier,dnlib.DotNet.Writer,MarshalBlobWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MarshalBlobWriter.cs,Write,The length of the parameter optimizeCustomAttributeSerializedTypeNames is 42.
Long Identifier,dnlib.DotNet.Writer,MarshalBlobWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MarshalBlobWriter.cs,MarshalBlobWriter,The length of the parameter optimizeCustomAttributeSerializedTypeNames is 42.
Long Identifier,dnlib.DotNet.Writer,MarshalBlobWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MarshalBlobWriter.cs,,The length of the parameter optimizeCustomAttributeSerializedTypeNames is 42.
Long Identifier,dnlib.DotNet.Writer,Metadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Metadata.cs,,The length of the parameter methodDebugInformationInfosUsed is 31.
Long Identifier,dnlib.DotNet.Writer,ModuleWriterBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,WriteWindowsPdb,The length of the parameter addPdbChecksumDebugDirectoryEntry is 33.
Long Identifier,dnlib.DotNet.Writer,ModuleWriterBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,,The length of the parameter DEFAULT_METHODBODIES_ALIGNMENT is 30.
Long Identifier,dnlib.DotNet.Writer,ModuleWriterBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,,The length of the parameter DEFAULT_NETRESOURCES_ALIGNMENT is 30.
Long Identifier,dnlib.DotNet.Writer,ModuleWriterBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,,The length of the parameter DEFAULT_WIN32_RESOURCES_ALIGNMENT is 33.
Long Identifier,dnlib.DotNet.Writer,ModuleWriterBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,,The length of the parameter DEFAULT_STRONGNAMESIG_ALIGNMENT is 31.
Long Identifier,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteFile,The length of the parameter entryPointIsManagedOrNoEntryPoint is 33.
Long Identifier,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The length of the parameter entryPointIsManagedOrNoEntryPoint is 33.
Long Identifier,dnlib.DotNet.Writer,PdbHeap,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PdbHeap.cs,,The length of the parameter referencedTypeSystemTablesInitd is 31.
Long Identifier,dnlib.DotNet.Writer,StringsHeap,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\StringsHeap.cs,,The length of the parameter Comparison_StringsOffsetInfoSorter is 34.
Long Identifier,dnlib.DotNet.Writer,Win32ResourcesChunk,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,,The length of the parameter RESOURCE_DATA_HEADER_ALIGNMENT is 30.
Long Identifier,dnlib.PE,PEImage,D:\research\architectureSmells\repos\0xd4d_dnlib\src\PE\PEImage.cs,,The length of the parameter USE_MEMORY_LAYOUT_WITH_MAPPED_FILES is 35.
Long Statement,dnlib.DotNet,AssemblyDef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyDef.cs,Load,The length of the statement  "					throw new BadImageFormatException($"{module.ToString()} is only a .NET module' not a .NET assembly. Use ModuleDef.Load()."); " is 124.
Long Statement,dnlib.DotNet,AssemblyDef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyDef.cs,Load,The length of the statement  "					throw new BadImageFormatException($"{module.ToString()} (addr: {addr.ToInt64():X8}) is only a .NET module' not a .NET assembly. Use ModuleDef.Load()."); " is 152.
Long Statement,dnlib.DotNet,AssemblyDef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyDef.cs,Load,The length of the statement  "					throw new BadImageFormatException($"{module.ToString()} is only a .NET module' not a .NET assembly. Use ModuleDef.Load()."); " is 124.
Long Statement,dnlib.DotNet,AssemblyDef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyDef.cs,UpdateOrCreateAssemblySignatureKeyAttribute,The length of the statement  "			ca.ConstructorArguments[0] = new CAArgument(manifestModule.CorLibTypes.String' new UTF8String(signaturePubKey.ToString())); " is 123.
Long Statement,dnlib.DotNet,AssemblyDef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyDef.cs,CreateAssemblySignatureKeyAttribute,The length of the statement  "			var owner = manifestModule.UpdateRowId(new TypeRefUser(manifestModule' "System.Reflection"' "AssemblySignatureKeyAttribute"' manifestModule.CorLibTypes.AssemblyRef)); " is 166.
Long Statement,dnlib.DotNet,AssemblyDef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyDef.cs,CreateAssemblySignatureKeyAttribute,The length of the statement  "			var methodSig = MethodSig.CreateInstance(manifestModule.CorLibTypes.Void' manifestModule.CorLibTypes.String' manifestModule.CorLibTypes.String); " is 144.
Long Statement,dnlib.DotNet,AssemblyDef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyDef.cs,CreateAssemblySignatureKeyAttribute,The length of the statement  "			var ctor = manifestModule.UpdateRowId(new MemberRefUser(manifestModule' MethodDef.InstanceConstructorName' methodSig' owner)); " is 126.
Long Statement,dnlib.DotNet,AssemblyDef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyDef.cs,OnAdd,The length of the statement  "				throw new InvalidOperationException("Module already has an assembly. Remove it from that assembly before adding it to this assembly."); " is 135.
Long Statement,dnlib.DotNet,AssemblyDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyDef.cs,InitializeDeclSecurities,The length of the statement  "			var tmp = new LazyList<DeclSecurity' RidList>(list.Count' list' (list2' index) => readerModule.ResolveDeclSecurity(list2[index])); " is 130.
Long Statement,dnlib.DotNet,AssemblyDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyDef.cs,InitializeCustomAttributes,The length of the statement  "			var tmp = new CustomAttributeCollection(list.Count' list' (list2' index) => readerModule.ReadCustomAttribute(list[index])); " is 123.
Long Statement,dnlib.DotNet,AssemblyDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyDef.cs,TryParse,The length of the statement  "				version = new Version(ParseInt32(m.Groups[1].Value)' ParseInt32(m.Groups[2].Value)' ParseInt32(m.Groups[3].Value)' ParseInt32(m.Groups[4].Value)); " is 146.
Long Statement,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyHashAlgorithm.cs,ResolveThrow,The length of the statement  "			throw new MemberRefResolveException($"Could not resolve method/field: {memberRef} ({memberRef?.GetDefinitionAssembly()})"); " is 123.
Long Statement,dnlib.DotNet,AssemblyRefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyRef.cs,InitializeCustomAttributes,The length of the statement  "			var tmp = new CustomAttributeCollection(list.Count' list' (list2' index) => readerModule.ReadCustomAttribute(list[index])); " is 123.
Long Statement,dnlib.DotNet,AssemblyResolver,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyResolver.cs,Resolve2,The length of the statement  "				resolvedAssembly = FindClosestAssembly(assembly' resolvedAssembly' PreFindAssemblies(assembly' sourceModule' false)' moduleContext); " is 132.
Long Statement,dnlib.DotNet,AssemblyResolver,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyResolver.cs,Resolve2,The length of the statement  "				resolvedAssembly = FindClosestAssembly(assembly' resolvedAssembly' FindAssemblies(assembly' sourceModule' false)' moduleContext); " is 129.
Long Statement,dnlib.DotNet,AssemblyResolver,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyResolver.cs,Resolve2,The length of the statement  "				resolvedAssembly = FindClosestAssembly(assembly' resolvedAssembly' PostFindAssemblies(assembly' sourceModule' false)' moduleContext); " is 133.
Long Statement,dnlib.DotNet,CustomAttributeReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\CustomAttributeReader.cs,ReadType,The length of the statement  "			var type = TypeNameParser.ParseAsTypeSigReflection(module' UTF8String.ToSystemStringOrEmpty(name)' asmRefFinder' gpContext); " is 124.
Long Statement,dnlib.DotNet,DeclSecurityMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\DeclSecurity.cs,InitializeCustomAttributes,The length of the statement  "			var tmp = new CustomAttributeCollection(list.Count' list' (list2' index) => readerModule.ReadCustomAttribute(list[index])); " is 123.
Long Statement,dnlib.DotNet,DeclSecurityReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\DeclSecurityReader.cs,ReadBinaryFormat,The length of the statement  "				var attrRef = TypeNameParser.ParseReflection(module' UTF8String.ToSystemStringOrEmpty(name)' new CAAssemblyRefFinder(module)' gpContext); " is 137.
Long Statement,dnlib.DotNet,EventDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\EventDef.cs,InitializeCustomAttributes,The length of the statement  "			var tmp = new CustomAttributeCollection(list.Count' list' (list2' index) => readerModule.ReadCustomAttribute(list[index])); " is 123.
Long Statement,dnlib.DotNet,EventDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\EventDef.cs,InitializeCustomDebugInfos,The length of the statement  "			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table' origRid)' new GenericParamContext(declaringType2)' list); " is 124.
Long Statement,dnlib.DotNet,ExportedTypeMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ExportedType.cs,InitializeCustomAttributes,The length of the statement  "			var tmp = new CustomAttributeCollection(list.Count' list' (list2' index) => readerModule.ReadCustomAttribute(list[index])); " is 123.
Long Statement,dnlib.DotNet,FieldDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\FieldDef.cs,InitializeCustomAttributes,The length of the statement  "			var tmp = new CustomAttributeCollection(list.Count' list' (list2' index) => readerModule.ReadCustomAttribute(list[index])); " is 123.
Long Statement,dnlib.DotNet,FieldDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\FieldDef.cs,InitializeCustomDebugInfos,The length of the statement  "			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table' origRid)' new GenericParamContext(declaringType2)' list); " is 124.
Long Statement,dnlib.DotNet,FileDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\FileDef.cs,InitializeCustomAttributes,The length of the statement  "			var tmp = new CustomAttributeCollection(list.Count' list' (list2' index) => readerModule.ReadCustomAttribute(list[index])); " is 123.
Long Statement,dnlib.DotNet,FrameworkRedirect,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\FrameworkRedirect.cs,InitFrameworkRedirectV4,The length of the statement  "			frmRedir4["Microsoft.Windows.ApplicationServer.Applications"] = new FrameworkRedirectInfo("31bf3856ad364e35"' "4.0.0.0"); " is 121.
Long Statement,dnlib.DotNet,FullNameFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\FullNameFactory.cs,GetAssemblyName,The length of the statement  "			return Utils.GetAssemblyNameString(EscapeAssemblyName(assembly.Name)' assembly.Version' assembly.Culture' pk' assembly.Attributes); " is 131.
Long Statement,dnlib.DotNet,GenericParam,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\GenericParam.cs,OnAdd,The length of the statement  "				throw new InvalidOperationException("Generic param constraint is already owned by another generic param. Set Owner to null first."); " is 132.
Long Statement,dnlib.DotNet,GenericParamMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\GenericParam.cs,InitializeCustomAttributes,The length of the statement  "			var tmp = new CustomAttributeCollection(list.Count' list' (list2' index) => readerModule.ReadCustomAttribute(list[index])); " is 123.
Long Statement,dnlib.DotNet,GenericParamMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\GenericParam.cs,InitializeGenericParamConstraints,The length of the statement  "			var tmp = new LazyList<GenericParamConstraint' RidList>(list.Count' this' list' (list2' index) => readerModule.ResolveGenericParamConstraint(list2[index]' GetGenericParamContext(owner))); " is 187.
Long Statement,dnlib.DotNet,GenericParamMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\GenericParam.cs,OnLazyAdd2,The length of the statement  "				value = readerModule.ForceUpdateRowId(readerModule.ReadGenericParamConstraint(value.Rid' GetGenericParamContext(owner)).InitializeAll()); " is 137.
Long Statement,dnlib.DotNet,GenericParamConstraintMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\GenericParamConstraint.cs,InitializeCustomAttributes,The length of the statement  "			var tmp = new CustomAttributeCollection(list.Count' list' (list2' index) => readerModule.ReadCustomAttribute(list[index])); " is 123.
Long Statement,dnlib.DotNet,Importer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Importer.cs,ImportAsTypeSig,The length of the statement  "				var git = new GenericInstSig(ImportAsTypeSig(type.GetGenericTypeDefinition()) as ClassOrValueTypeSig' (uint)typeGenArgs.Length); " is 128.
Long Statement,dnlib.DotNet,Importer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Importer.cs,CreateTypeRef2,The length of the statement  "				return module.UpdateRowId(new TypeRefUser(module' type.Namespace ?? string.Empty' type.Name ?? string.Empty' CreateScopeReference(type))); " is 138.
Long Statement,dnlib.DotNet,Importer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Importer.cs,CreateTypeRef2,The length of the statement  "			return module.UpdateRowId(new TypeRefUser(module' @namespace ?? string.Empty' name ?? string.Empty' CreateTypeRef2(type.DeclaringType))); " is 137.
Long Statement,dnlib.DotNet,Importer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Importer.cs,CreateScopeReference,The length of the statement  "			return module.UpdateRowId(new AssemblyRefUser(asmName.Name' asmName.Version' PublicKeyBase.CreatePublicKeyToken(pkt)' asmName.CultureInfo.Name)); " is 145.
Long Statement,dnlib.DotNet,Importer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Importer.cs,ImportInternal,The length of the statement  "					method = module.UpdateRowId(new MemberRefUser(module' methodBase.Name' CreateMethodSig(origMethod)' Import(methodBase.DeclaringType))); " is 135.
Long Statement,dnlib.DotNet,Importer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Importer.cs,GetModuleParent,The length of the statement  "				UTF8String.ToSystemStringOrEmpty(modAsm.Name).Equals(module2.Assembly.GetName().Name' StringComparison.OrdinalIgnoreCase); " is 122.
Long Statement,dnlib.DotNet,Importer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Importer.cs,Import,The length of the statement  "				var fieldSig = new FieldSig(ImportAsTypeSig(fieldInfo.FieldType' fieldInfo.GetRequiredCustomModifiers()' fieldInfo.GetOptionalCustomModifiers())); " is 146.
Long Statement,dnlib.DotNet,Importer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Importer.cs,Import2,The length of the statement  "				result = module.UpdateRowId(new TypeRefUser(module' type.Namespace' type.Name' CreateScopeReference(type.DefinitionAssembly' type.Module))); " is 140.
Long Statement,dnlib.DotNet,Importer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Importer.cs,CreateScopeReference,The length of the statement  "			return module.UpdateRowId(new AssemblyRefUser(defAsm.Name' defAsm.Version' pkt' defAsm.Culture) { Attributes = defAsm.Attributes & ~AssemblyAttributes.PublicKey }); " is 164.
Long Statement,dnlib.DotNet,Importer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Importer.cs,Import2,The length of the statement  "				result = module.UpdateRowId(new TypeRefUser(module' type.Namespace' type.Name' CreateScopeReference(type.DefinitionAssembly' type.Module))); " is 140.
Long Statement,dnlib.DotNet,InterfaceImplMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\InterfaceImpl.cs,InitializeCustomAttributes,The length of the statement  "			var tmp = new CustomAttributeCollection(list.Count' list' (list2' index) => readerModule.ReadCustomAttribute(list[index])); " is 123.
Long Statement,dnlib.DotNet,ManifestResourceMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ManifestResource.cs,InitializeCustomAttributes,The length of the statement  "			var tmp = new CustomAttributeCollection(list.Count' list' (list2' index) => readerModule.ReadCustomAttribute(list[index])); " is 123.
Long Statement,dnlib.DotNet,MarshalBlobReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MarshalBlobReader.cs,Read,The length of the statement  "					var udtRef = udtName is null ? null : TypeNameParser.ParseReflection(module' UTF8String.ToSystemStringOrEmpty(udtName)' null' gpContext); " is 137.
Long Statement,dnlib.DotNet,MarshalBlobReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MarshalBlobReader.cs,Read,The length of the statement  "					var cmRef = custMarshalerName.DataLength == 0 ? null : TypeNameParser.ParseReflection(module' UTF8String.ToSystemStringOrEmpty(custMarshalerName)' new CAAssemblyRefFinder(module)' gpContext); " is 191.
Long Statement,dnlib.DotNet,MemberRefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MemberRef.cs,InitializeCustomAttributes,The length of the statement  "			var tmp = new CustomAttributeCollection(list.Count' list' (list2' index) => readerModule.ReadCustomAttribute(list[index])); " is 123.
Long Statement,dnlib.DotNet,MethodDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MethodDef.cs,InitializeParamDefs,The length of the statement  "			var tmp = new LazyList<ParamDef' RidList>(list.Count' this' list' (list2' index) => readerModule.ResolveParam(list2[index])); " is 125.
Long Statement,dnlib.DotNet,MethodDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MethodDef.cs,InitializeGenericParameters,The length of the statement  "			var tmp = new LazyList<GenericParam' RidList>(list.Count' this' list' (list2' index) => readerModule.ResolveGenericParam(list2[index])); " is 136.
Long Statement,dnlib.DotNet,MethodDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MethodDef.cs,InitializeDeclSecurities,The length of the statement  "			var tmp = new LazyList<DeclSecurity' RidList>(list.Count' list' (list2' index) => readerModule.ResolveDeclSecurity(list2[index])); " is 130.
Long Statement,dnlib.DotNet,MethodDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MethodDef.cs,InitializeCustomAttributes,The length of the statement  "			var tmp = new CustomAttributeCollection(list.Count' list' (list2' index) => readerModule.ReadCustomAttribute(list[index])); " is 123.
Long Statement,dnlib.DotNet,MethodDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MethodDef.cs,InitializeOverrides,The length of the statement  "			var tmp = dt is null ? new List<MethodOverride>() : dt.GetMethodOverrides(this' new GenericParamContext(declaringType2' this)); " is 127.
Long Statement,dnlib.DotNet,MethodSpecMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MethodSpec.cs,InitializeCustomAttributes,The length of the statement  "			var tmp = new CustomAttributeCollection(list.Count' list' (list2' index) => readerModule.ReadCustomAttribute(list[index])); " is 123.
Long Statement,dnlib.DotNet,ModuleDef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDef.cs,OnAdd,The length of the statement  "				throw new InvalidOperationException("Type is already owned by another module. Remove it from that module's type list."); " is 120.
Long Statement,dnlib.DotNet,ModuleDefUser,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDef.cs,CreateModuleType,The length of the statement  "			type.Attributes = TypeAttributes.NotPublic | TypeAttributes.AutoLayout | TypeAttributes.Class | TypeAttributes.AnsiClass; " is 121.
Long Statement,dnlib.DotNet,ModuleDefMD2,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDef.cs,InitializeCustomAttributes,The length of the statement  "			var tmp = new CustomAttributeCollection(list.Count' list' (list2' index) => readerModule.ReadCustomAttribute(list[index])); " is 123.
Long Statement,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "			listModuleDefMD = new SimpleLazyList<ModuleDefMD2>(ts.ModuleTable.Rows' rid2 => rid2 == 1 ? this : new ModuleDefMD2(this' rid2)); " is 129.
Long Statement,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "			listInterfaceImplMD = new SimpleLazyList2<InterfaceImplMD>(ts.InterfaceImplTable.Rows' (rid2' gpContext) => new InterfaceImplMD(this' rid2' gpContext)); " is 152.
Long Statement,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "			listMemberRefMD = new SimpleLazyList2<MemberRefMD>(ts.MemberRefTable.Rows' (rid2' gpContext) => new MemberRefMD(this' rid2' gpContext)); " is 136.
Long Statement,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "			listDeclSecurityMD = new SimpleLazyList<DeclSecurityMD>(ts.DeclSecurityTable.Rows' rid2 => new DeclSecurityMD(this' rid2)); " is 123.
Long Statement,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "			listStandAloneSigMD = new SimpleLazyList2<StandAloneSigMD>(ts.StandAloneSigTable.Rows' (rid2' gpContext) => new StandAloneSigMD(this' rid2' gpContext)); " is 152.
Long Statement,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "			listTypeSpecMD = new SimpleLazyList2<TypeSpecMD>(ts.TypeSpecTable.Rows' (rid2' gpContext) => new TypeSpecMD(this' rid2' gpContext)); " is 132.
Long Statement,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "			listExportedTypeMD = new SimpleLazyList<ExportedTypeMD>(ts.ExportedTypeTable.Rows' rid2 => new ExportedTypeMD(this' rid2)); " is 123.
Long Statement,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "			listManifestResourceMD = new SimpleLazyList<ManifestResourceMD>(ts.ManifestResourceTable.Rows' rid2 => new ManifestResourceMD(this' rid2)); " is 139.
Long Statement,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "			listGenericParamMD = new SimpleLazyList<GenericParamMD>(ts.GenericParamTable.Rows' rid2 => new GenericParamMD(this' rid2)); " is 123.
Long Statement,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "			listMethodSpecMD = new SimpleLazyList2<MethodSpecMD>(ts.MethodSpecTable.Rows' (rid2' gpContext) => new MethodSpecMD(this' rid2' gpContext)); " is 140.
Long Statement,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "			listGenericParamConstraintMD = new SimpleLazyList2<GenericParamConstraintMD>(ts.GenericParamConstraintTable.Rows' (rid2' gpContext) => new GenericParamConstraintMD(this' rid2' gpContext)); " is 188.
Long Statement,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,CreateResource,The length of the statement  "					return new EmbeddedResource(mr.Name' dataReaderFactory' resourceOffset' resourceLength' mr.Flags) { Rid = rid' Offset = mr.Offset }; " is 132.
Long Statement,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,NativeWrite,The length of the statement  "			var writer = new DNW.NativeModuleWriter(this' options ?? new DNW.NativeModuleWriterOptions(this' optimizeImageSize: true)); " is 123.
Long Statement,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,NativeWrite,The length of the statement  "			var writer = new DNW.NativeModuleWriter(this' options ?? new DNW.NativeModuleWriterOptions(this' optimizeImageSize: true)); " is 123.
Long Statement,dnlib.DotNet,ModuleRefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleRef.cs,InitializeCustomAttributes,The length of the statement  "			var tmp = new CustomAttributeCollection(list.Count' list' (list2' index) => readerModule.ReadCustomAttribute(list[index])); " is 123.
Long Statement,dnlib.DotNet,ParamDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ParamDef.cs,InitializeCustomAttributes,The length of the statement  "			var tmp = new CustomAttributeCollection(list.Count' list' (list2' index) => readerModule.ReadCustomAttribute(list[index])); " is 123.
Long Statement,dnlib.DotNet,ParamDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ParamDef.cs,InitializeCustomDebugInfos,The length of the statement  "			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table' origRid)' GenericParamContext.Create(declaringMethod)' list); " is 128.
Long Statement,dnlib.DotNet,PropertyDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\PropertyDef.cs,InitializeCustomAttributes,The length of the statement  "			var tmp = new CustomAttributeCollection(list.Count' list' (list2' index) => readerModule.ReadCustomAttribute(list[index])); " is 123.
Long Statement,dnlib.DotNet,PropertyDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\PropertyDef.cs,InitializeCustomDebugInfos,The length of the statement  "			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table' origRid)' new GenericParamContext(declaringType2)' list); " is 124.
Long Statement,dnlib.DotNet,ReflectionExtensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ReflectionExtensions.cs,GetTypeNamespaceAndName_TypeDefOrRef,The length of the statement  "					@namespace = typeFullName.Substring(declTypeFullName.Length + 1' typeFullName.Length - declTypeFullName.Length - 1 - name.Length - 1); " is 134.
Long Statement,dnlib.DotNet,ReflectionExtensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ReflectionExtensions.cs,IsSZArray,The length of the statement  "			var prop = self.GetType().GetProperty("IsSzArray"' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic); " is 121.
Long Statement,dnlib.DotNet,SecurityAttribute,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SecurityAttribute.cs,CreateFromXml,The length of the statement  "			var namedArg = new CANamedArgument(false' module.CorLibTypes.String' "XML"' new CAArgument(module.CorLibTypes.String' utf8Xml)); " is 128.
Long Statement,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,Equals_Names,The length of the statement  "				return UTF8String.ToSystemStringOrEmpty(a).Equals(UTF8String.ToSystemStringOrEmpty(b)' StringComparison.OrdinalIgnoreCase); " is 123.
Long Statement,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,GetHashCode,The length of the statement  "				hash = HASHCODE_MAGIC_ET_GENERICINST + GetHashCode(a.GetGenericTypeDefinition()) + GetHashCode(a.GetGenericArguments()); " is 120.
Long Statement,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "				(!CompareAssemblyPublicKeyToken || PublicKeyBase.TokenEquals(a.PublicKeyOrToken' new PublicKeyToken(bAsmName.GetPublicKeyToken()))) && " is 134.
Long Statement,dnlib.DotNet,StandAloneSigMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\StandAloneSig.cs,InitializeCustomAttributes,The length of the statement  "			var tmp = new CustomAttributeCollection(list.Count' list' (list2' index) => readerModule.ReadCustomAttribute(list[index])); " is 123.
Long Statement,dnlib.DotNet,StrongNameKey,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\StrongNameKey.cs,WithHashAlgorithm,The length of the statement  "			return new StrongNameKey(hashAlgorithm' publicExponent' modulus' prime1' prime2' exponent1' exponent2' coefficient' privateExponent); " is 133.
Long Statement,dnlib.DotNet,TypeDef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TypeDef.cs,OnAdd,The length of the statement  "				throw new InvalidOperationException("Type is already owned by another module. Remove it from that module's type list."); " is 120.
Long Statement,dnlib.DotNet,TypeDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TypeDef.cs,InitializeFields,The length of the statement  "			var tmp = new LazyList<FieldDef' RidList>(list.Count' this' list' (list2' index) => readerModule.ResolveField(list2[index])); " is 125.
Long Statement,dnlib.DotNet,TypeDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TypeDef.cs,InitializeMethods,The length of the statement  "			var tmp = new LazyList<MethodDef' RidList>(list.Count' this' list' (list2' index) => readerModule.ResolveMethod(list2[index])); " is 127.
Long Statement,dnlib.DotNet,TypeDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TypeDef.cs,InitializeGenericParameters,The length of the statement  "			var tmp = new LazyList<GenericParam' RidList>(list.Count' this' list' (list2' index) => readerModule.ResolveGenericParam(list2[index])); " is 136.
Long Statement,dnlib.DotNet,TypeDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TypeDef.cs,InitializeInterfaces,The length of the statement  "			var tmp = new LazyList<InterfaceImpl' RidList>(list.Count' list' (list2' index) => readerModule.ResolveInterfaceImpl(list2[index]' new GenericParamContext(this))); " is 163.
Long Statement,dnlib.DotNet,TypeDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TypeDef.cs,InitializeDeclSecurities,The length of the statement  "			var tmp = new LazyList<DeclSecurity' RidList>(list.Count' list' (list2' index) => readerModule.ResolveDeclSecurity(list2[index])); " is 130.
Long Statement,dnlib.DotNet,TypeDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TypeDef.cs,InitializeEvents,The length of the statement  "			var tmp = new LazyList<EventDef' RidList>(list.Count' this' list' (list2' index) => readerModule.ResolveEvent(list2[index])); " is 125.
Long Statement,dnlib.DotNet,TypeDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TypeDef.cs,InitializeProperties,The length of the statement  "			var tmp = new LazyList<PropertyDef' RidList>(list.Count' this' list' (list2' index) => readerModule.ResolveProperty(list2[index])); " is 131.
Long Statement,dnlib.DotNet,TypeDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TypeDef.cs,InitializeNestedTypes,The length of the statement  "			var tmp = new LazyList<TypeDef' RidList>(list.Count' this' list' (list2' index) => readerModule.ResolveTypeDef(list2[index])); " is 126.
Long Statement,dnlib.DotNet,TypeDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TypeDef.cs,InitializeCustomAttributes,The length of the statement  "			var tmp = new CustomAttributeCollection(list.Count' list' (list2' index) => readerModule.ReadCustomAttribute(list[index])); " is 123.
Long Statement,dnlib.DotNet,TypeRefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TypeRef.cs,InitializeCustomAttributes,The length of the statement  "			var tmp = new CustomAttributeCollection(list.Count' list' (list2' index) => readerModule.ReadCustomAttribute(list[index])); " is 123.
Long Statement,dnlib.DotNet,TypeSpecMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TypeSpec.cs,InitializeCustomAttributes,The length of the statement  "			var tmp = new CustomAttributeCollection(list.Count' list' (list2' index) => readerModule.ReadCustomAttribute(list[index])); " is 123.
Long Statement,dnlib.DotNet,WinMDHelpers,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\WinMDHelpers.cs,CreateAssembly,The length of the statement  "			var asm = new AssemblyRefUser(GetName(clrAsm)' contractAsmVersion' new PublicKeyToken(GetPublicKeyToken(clrAsm))' UTF8String.Empty); " is 132.
Long Statement,dnlib.DotNet,WinMDHelpers,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\WinMDHelpers.cs,GetName,The length of the statement  "			case ClrAssembly.SystemRuntimeInteropServicesWindowsRuntime: return clrAsmName_SystemRuntimeInteropServicesWindowsRuntime; " is 122.
Long Statement,dnlib.DotNet,WinMDHelpers,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\WinMDHelpers.cs,ToCLR,The length of the statement  "			return new ExportedTypeUser(module' 0' pc.ClrClass.Namespace' pc.ClrClass.Name' et.Attributes' CreateAssembly(module' pc.ContractAssembly)); " is 140.
Long Statement,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,Create,The length of the statement  "			if (opCode.OperandType != OperandType.InlineField && opCode.OperandType != OperandType.InlineMethod && opCode.OperandType != OperandType.InlineTok) " is 147.
Long Statement,dnlib.DotNet.Emit,MethodTableToTypeConverter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodTableToTypeConverter.cs,GetTypeNET45,The length of the statement  "			var createdMethod = type.GetMethod(METHOD_NAME' BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance); " is 168.
Long Statement,dnlib.DotNet.Emit,MethodTableToTypeConverter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodTableToTypeConverter.cs,GetTypeNET40,The length of the statement  "			var createdMethod = type.GetMethod(METHOD_NAME' BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance); " is 168.
Long Statement,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The length of the statement  "			tableInfos[(int)Table.AssemblyProcessor] = new TableInfo(Table.AssemblyProcessor' "AssemblyProcessor"' new ColumnInfo[] { " is 121.
Long Statement,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The length of the statement  "			tableInfos[(int)Table.AssemblyRefProcessor] = new TableInfo(Table.AssemblyRefProcessor' "AssemblyRefProcessor"' new ColumnInfo[] { " is 130.
Long Statement,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The length of the statement  "			tableInfos[(int)Table.GenericParamConstraint] = new TableInfo(Table.GenericParamConstraint' "GenericParamConstraint"' new ColumnInfo[] { " is 136.
Long Statement,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The length of the statement  "			tableInfos[(int)Table.MethodDebugInformation] = new TableInfo(Table.MethodDebugInformation' "MethodDebugInformation"' new ColumnInfo[] { " is 136.
Long Statement,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The length of the statement  "			tableInfos[(int)Table.StateMachineMethod] = new TableInfo(Table.StateMachineMethod' "StateMachineMethod"' new ColumnInfo[] { " is 124.
Long Statement,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The length of the statement  "			tableInfos[(int)Table.CustomDebugInformation] = new TableInfo(Table.CustomDebugInformation' "CustomDebugInformation"' new ColumnInfo[] { " is 136.
Long Statement,dnlib.DotNet.Pdb,PdbConstant,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\PdbConstant.cs,ToString,The length of the statement  "			return (type is null ? "" : type.ToString()) + " " + Name + " = " + (Value is null ? "null" : Value.ToString() + " (" + Value.GetType().FullName + ")"); " is 152.
Long Statement,dnlib.DotNet.Pdb,SymbolReaderFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\SymbolReaderFactory.cs,CreateFromAssemblyFile,The length of the statement  "				fileToCheck = assemblyFileName == string.Empty ? pdbFilename : Path.Combine(Path.GetDirectoryName(assemblyFileName)' pdbFilename); " is 130.
Long Statement,dnlib.DotNet.Pdb,SymbolReaderFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\SymbolReaderFactory.cs,CreateCore,The length of the statement  "				if ((pdbContext.Options & PdbReaderOptions.MicrosoftComReader) != 0 && !(pdbStream is null) && IsWindowsPdb(pdbStream.CreateReader())) " is 134.
Long Statement,dnlib.DotNet.Pdb.Dss,SymbolReaderImpl,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\SymbolReaderImpl.cs,GetCustomDebugInfos,The length of the statement  "			var asyncMethod = PseudoCustomDebugInfoFactory.TryCreateAsyncMethod(method.Module' method' body' symMethod.AsyncKickoffMethod' symMethod.AsyncStepInfos' symMethod.AsyncCatchHandlerILOffset); " is 190.
Long Statement,dnlib.DotNet.Pdb.Dss,SymbolReaderWriterFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\SymbolReaderWriterFactory.cs,CreateSymUnmanagedReader,The length of the statement  "				return (ISymUnmanagedReader)Activator.CreateInstance(CorSymReader_Type ??= Type.GetTypeFromCLSID(CLSID_CorSymReader_SxS)); " is 122.
Long Statement,dnlib.DotNet.Pdb.Dss,SymbolReaderWriterFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\SymbolReaderWriterFactory.cs,CreateSymUnmanagedWriter2,The length of the statement  "				return (ISymUnmanagedWriter2)Activator.CreateInstance(CorSymWriterType ??= Type.GetTypeFromCLSID(CLSID_CorSymWriter_SxS)); " is 122.
Long Statement,dnlib.DotNet.Pdb.Dss,SymbolReaderWriterFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\SymbolReaderWriterFactory.cs,Create,The length of the statement  "			return new SymbolWriterImpl(CreateSymUnmanagedWriter2(options)' pdbFileName' File.Create(pdbFileName)' options' ownsStream: true); " is 130.
Long Statement,dnlib.DotNet.Pdb.Managed,DbiFunction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiFunction.cs,CreateSymbolAsyncStepInfos,The length of the statement  "				res[i] = new SymbolAsyncStepInfo(BitConverter.ToUInt32(data' pos)' BitConverter.ToUInt32(data' pos + 8)' BitConverter.ToUInt32(data' pos + 4)); " is 143.
Long Statement,dnlib.DotNet.Pdb.Managed,PdbReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\PdbReader.cs,GetCustomDebugInfos,The length of the statement  "			var asyncMethod = PseudoCustomDebugInfoFactory.TryCreateAsyncMethod(method.Module' method' body' symMethod.AsyncKickoffMethod' symMethod.AsyncStepInfos' symMethod.AsyncCatchHandlerILOffset); " is 190.
Long Statement,dnlib.DotNet.Pdb.Portable,DocumentNameReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\DocumentNameReader.cs,ReadSeparatorChar,The length of the statement  "				decoder.Convert(bytes' 0' 1' prevSepChars' 0' prevSepChars.Length' isLastByte' out int bytesUsed' out prevSepCharsLength' out bool completed); " is 142.
Long Statement,dnlib.DotNet.Pdb.Portable,PortablePdbCustomDebugInfoWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\PortablePdbCustomDebugInfoWriter.cs,GetOffsetSlow,The length of the statement  "			helper.Error("Couldn't find an instruction' maybe it was removed. It's still being referenced by some code or by the PDB"); " is 123.
Long Statement,dnlib.DotNet.Pdb.Portable,PortablePdbReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\PortablePdbReader.cs,GetLanguageVendor,The length of the statement  "			if (language == PdbDocumentConstants.LanguageCSharp || language == PdbDocumentConstants.LanguageVisualBasic || language == PdbDocumentConstants.LanguageFSharp) " is 159.
Long Statement,dnlib.DotNet.Pdb.Portable,PortablePdbReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\PortablePdbReader.cs,ReadDocuments,The length of the statement  "				docs[i] = new SymbolDocumentImpl(url' language' languageVendor' documentType' checkSumAlgorithmId' checkSum' custInfosArray); " is 125.
Long Statement,dnlib.DotNet.Pdb.Portable,PortablePdbReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\PortablePdbReader.cs,ReadVariables,The length of the statement  "				scope.localsList.Add(new SymbolVariableImpl(name' ToSymbolVariableAttributes(row.Attributes)' row.Index' customDebugInfos)); " is 124.
Long Statement,dnlib.DotNet.Pdb.Portable,PortablePdbReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\PortablePdbReader.cs,GetCustomDebugInfos,The length of the statement  "			GetCustomDebugInfos(method.MDToken.ToInt32()' GenericParamContext.Create(method)' result' method' body' out var asyncStepInfo); " is 127.
Long Statement,dnlib.DotNet.Pdb.Portable,PortablePdbReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\PortablePdbReader.cs,GetCustomDebugInfos,The length of the statement  "				var asyncMethod = TryCreateAsyncMethod(module' symMethod.KickoffMethod' asyncStepInfo.AsyncStepInfos' asyncStepInfo.CatchHandler); " is 130.
Long Statement,dnlib.DotNet.Pdb.Portable,SymbolReaderFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\SymbolReaderFactory.cs,TryCreate,The length of the statement  "				// WindowsPDB file: https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PE-COFF.md#codeview-debug-directory-entry-type-2 " is 150.
Long Statement,dnlib.DotNet.Pdb.Portable,SymbolReaderFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\SymbolReaderFactory.cs,TryCreate,The length of the statement  "				var reader = new PortablePdbReader(pdbStream' isEmbeddedPortablePdb ? PdbFileKind.EmbeddedPortablePDB : PdbFileKind.PortablePDB); " is 129.
Long Statement,dnlib.DotNet.Pdb.Portable,SymbolReaderFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\SymbolReaderFactory.cs,TryCreateEmbeddedPortablePdbReader,The length of the statement  "				//		https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PE-COFF.md#embedded-portable-pdb-debug-directory-entry-type-17 " is 148.
Long Statement,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoWriter.cs,GetInstructionOffset,The length of the statement  "			Error("Instruction is missing in body but it's still being referenced by PDB data. Method {0} (0x{1:X8})' instruction: {2}"' method' method.MDToken.Raw' instr); " is 160.
Long Statement,dnlib.DotNet.Pdb.WindowsPdb,WindowsPdbWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\WindowsPdbWriter.cs,WriteAsyncMethod,The length of the statement  "				breakpointOffset[i] = (uint)GetExternalInstructionOffset(ref info' stepInfo.BreakpointMethod' stepInfo.BreakpointInstruction); " is 126.
Long Statement,dnlib.DotNet.Pdb.WindowsPdb,WindowsPdbWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\WindowsPdbWriter.cs,GetExternalInstructionOffset,The length of the statement  "			Error("Async method instruction has been removed but it's still being referenced by PDB info: BP Instruction: {0}' BP Method: {1} (0x{2:X8})' Current Method: {3} (0x{4:X8})"' instr' method' method.MDToken.Raw' info.Method' info.Method.MDToken.Raw); " is 248.
Long Statement,dnlib.DotNet.Pdb.WindowsPdb,SequencePointHelper,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\WindowsPdbWriter.cs,Write,The length of the statement  "						pdbWriter.writer.DefineSequencePoints(pdbWriter.Add(currPdbDoc)' (uint)index' instrOffsets' startLines' startColumns' endLines' endColumns); " is 140.
Long Statement,dnlib.DotNet.Resources,ResourceWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Resources\ResourceWriter.cs,Write,The length of the statement  "			var formatter = new BinaryFormatter(null' new StreamingContext(StreamingContextStates.File | StreamingContextStates.Persistence)); " is 130.
Long Statement,dnlib.DotNet.Writer,CustomAttributeWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,Write,The length of the statement  "				if ((!(ca.ConstructorArguments is null) && ca.ConstructorArguments.Count > 0) || (!(ca.NamedArguments is null) && ca.NamedArguments.Count > 0)) " is 143.
Long Statement,dnlib.DotNet.Writer,DataReaderChunk,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataReaderChunk.cs,SetData,The length of the statement  "				throw new InvalidOperationException("New data must be the same size as the old data after SetOffset() has been called"); " is 120.
Long Statement,dnlib.DotNet.Writer,Extensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Extensions.cs,VerifyWriteTo,The length of the statement  "			//System.Diagnostics.Debug.WriteLine($" RVA 0x{(uint)chunk.RVA:X8} OFFS 0x{(uint)chunk.FileOffset:X8} VSIZE 0x{chunk.GetVirtualSize():X8} {chunk.GetType().FullName}"); " is 167.
Long Statement,dnlib.DotNet.Writer,Hasher,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Hasher.cs,GetChecksumName,The length of the statement  "			// https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PE-COFF.md#pdb-checksum-debug-directory-entry-type-19 " is 138.
Long Statement,dnlib.DotNet.Writer,ManagedExportsWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ManagedExportsWriter.cs,AddExportedMethods,The length of the statement  "				logError("The module has exported methods but the CPU architecture isn't supported: {0} (0x{1:X4})"' new object[] { machine' (ushort)machine }); " is 144.
Long Statement,dnlib.DotNet.Writer,ManagedExportsWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ManagedExportsWriter.cs,AddExportedMethods,The length of the statement  "				logError("Too many methods have been exported. No more than 2^16 methods can be exported. Number of exported methods: {0}"' new object[] { methods.Count }); " is 156.
Long Statement,dnlib.DotNet.Writer,ManagedExportsWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ManagedExportsWriter.cs,WriteSdataBlob,The length of the statement  "					logError("Exported method name is null or empty' method: {0} (0x{1:X8})"' new object[] { info.Method' info.Method.MDToken.Raw }); " is 129.
Long Statement,dnlib.DotNet.Writer,ManagedExportsWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ManagedExportsWriter.cs,WriteSdataBlob,The length of the statement  "			sortedOrdinalMethodInfos.Sort((a' b) => a.Method.ExportInfo.Ordinal.Value.CompareTo(b.Method.ExportInfo.Ordinal.Value)); " is 120.
Long Statement,dnlib.DotNet.Writer,MetadataOptions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Metadata.cs,PreserveHeapOrder,The length of the statement  "					var otherStreams = mod.Metadata.AllStreams.Where(a => a.GetType() == typeof(CustomDotNetStream)).Select(a => new DataReaderHeap(a)); " is 132.
Long Statement,dnlib.DotNet.Writer,MetadataOptions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Metadata.cs,GetOrder,The length of the statement  "			if (heap is DataReaderHeap drHeap && drHeap.OptionalOriginalStream is DotNetStream dnHeap && streamToOrder.TryGetValue(dnHeap' out int order)) " is 142.
Long Statement,dnlib.DotNet.Writer,Metadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Metadata.cs,InitializeTypeDefsAndMemberDefs,The length of the statement  "				typeRow = new RawTypeDefRow((uint)type.Attributes' stringsHeap.Add(type.Name)' stringsHeap.Add(type.Namespace)' type.BaseType is null ? 0 : AddTypeDefOrRef(type.BaseType)' typeRow.FieldList' typeRow.MethodList); " is 211.
Long Statement,dnlib.DotNet.Writer,Metadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Metadata.cs,InitializeTypeDefsAndMemberDefs,The length of the statement  "					row = new RawMethodRow(row.RVA' (ushort)method.ImplAttributes' (ushort)method.Attributes' stringsHeap.Add(method.Name)' GetSignature(method.Signature)' row.ParamList); " is 167.
Long Statement,dnlib.DotNet.Writer,Metadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Metadata.cs,AddDeclSecurities,The length of the statement  "							blobHeap.Add(DeclSecurityWriter.Write(module' decl.SecurityAttributes' this' OptimizeCustomAttributeSerializedTypeNames' bwctx))); " is 130.
Long Statement,dnlib.DotNet.Writer,Metadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Metadata.cs,AddMethodDebugInformation,The length of the statement  "				if (seqPoint.StartLine == SequencePointConstants.HIDDEN_LINE && seqPoint.EndLine == SequencePointConstants.HIDDEN_LINE) { " is 121.
Long Statement,dnlib.DotNet.Writer,Metadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Metadata.cs,AddMethodDebugInformation,The length of the statement  "			var row = new RawMethodDebugInformationRow(singleDoc is null ? 0 : AddPdbDocument(singleDoc)' debugMetadata.blobHeap.Add(seqPointsBlob)); " is 137.
Long Statement,dnlib.DotNet.Writer,Metadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Metadata.cs,AddCustomDebugInformation,The length of the statement  "				AddCustomDebugInformationCore(serializerMethodContext' encodedToken' cdi' CustomDebugInfoGuids.AsyncMethodSteppingInformationBlob); " is 131.
Long Statement,dnlib.DotNet.Writer,Metadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Metadata.cs,AddLocalVariable,The length of the statement  "			var row = new RawLocalVariableRow((ushort)local.Attributes' (ushort)local.Index' debugMetadata.stringsHeap.Add(local.Name)); " is 124.
Long Statement,dnlib.DotNet.Writer,MethodBodyWriterBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBodyWriterBase.cs,GetMaxStack,The length of the statement  "				Error("Error calculating max stack value. If the method's obfuscated' set CilBody.KeepOldMaxStack or MetadataOptions.Flags (KeepOldMaxStack' global option) to ignore this error. Otherwise fix your generated CIL code so it conforms to the ECMA standard."); " is 255.
Long Statement,dnlib.DotNet.Writer,MethodBodyWriterBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBodyWriterBase.cs,GetOffset,The length of the statement  "			Error("Found some other method's instruction or a removed instruction. You probably removed an instruction that is the target of a branch instruction or an instruction that's the first/last instruction in an exception handler."); " is 229.
Long Statement,dnlib.DotNet.Writer,MethodBodyWriterBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBodyWriterBase.cs,WriteShortInlineBrTarget,The length of the statement  "				Error("Target instruction is too far away for a short branch. Use the long branch or call CilBody.SimplifyBranches() and CilBody.OptimizeBranches()"); " is 150.
Long Statement,dnlib.DotNet.Writer,ModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriter.cs,CreateChunks,The length of the statement  "			managedExportsWriter = new ManagedExportsWriter(UTF8String.ToSystemStringOrEmpty(module.Name)' machine' relocDirectory' metadata' peHeaders' (format' args) => Error(format' args)); " is 180.
Long Statement,dnlib.DotNet.Writer,ModuleWriterOptionsBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,TryGetPdbChecksumAlgorithm,The length of the statement  "				if (Hasher.TryGetChecksumAlgorithm(checksumName' out pdbChecksumAlgorithm' out int checksumSize) && (uint)checksumSize == reader.BytesLeft) " is 139.
Long Statement,dnlib.DotNet.Writer,ModuleWriterBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,Write,The length of the statement  "				Debug.Assert(!(TheOptions.StrongNamePublicKey is null)' "Options.StrongNamePublicKey must be initialized when delay signing the assembly"); " is 139.
Long Statement,dnlib.DotNet.Writer,ModuleWriterBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,CreateMetadataChunks,The length of the statement  "			if (!(pdbState is null) && (pdbState.PdbFileKind == PdbFileKind.PortablePDB || pdbState.PdbFileKind == PdbFileKind.EmbeddedPortablePDB)) " is 136.
Long Statement,dnlib.DotNet.Writer,ModuleWriterBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,WriteWindowsPdb,The length of the statement  "				bool hasContentId = pdbWriter.GetDebugInfo(TheOptions.PdbChecksumAlgorithm' ref pdbAge' out var pdbGuid' out uint stamp' out var idd' out var codeViewData); " is 156.
Long Statement,dnlib.DotNet.Writer,ModuleWriterBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,WriteWindowsPdb,The length of the statement  "					{}//TODO: AddPdbChecksumDebugDirectoryEntry(checksumBytes' TheOptions.PdbChecksumAlgorithm);' and verify that the order of the debug dir entries is the same as Roslyn created binaries " is 183.
Long Statement,dnlib.DotNet.Writer,ModuleWriterBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,GetModuleName,The length of the statement  "			if (name.EndsWith(".dll"' StringComparison.OrdinalIgnoreCase) || name.EndsWith(".exe"' StringComparison.OrdinalIgnoreCase) || name.EndsWith(".netmodule"' StringComparison.OrdinalIgnoreCase)) " is 190.
Long Statement,dnlib.DotNet.Writer,ModuleWriterBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,GetDefaultPdbFileName,The length of the statement  "				Error("TheOptions.WritePdb is true but it's not possible to guess the default PDB file name. Set PdbFileName to the name of the PDB file."); " is 140.
Long Statement,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,CreateRawSections,The length of the statement  "				newSection.Chunk = new DataReaderChunk(peImage.CreateReader(peSection.VirtualAddress' sectionSize)' peSection.VirtualSize); " is 123.
Long Statement,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteFile,The length of the statement  "						ReuseIfPossible(rsrcSection' win32Resources' resourceDataDir.VirtualAddress' resourceDataDir.Size' DEFAULT_WIN32_RESOURCES_ALIGNMENT); " is 134.
Long Statement,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteFile,The length of the statement  "				ReuseIfPossible(textSection' imageCor20Header' module.Metadata.PEImage.ImageNTHeaders.OptionalHeader.DataDirectories[14].VirtualAddress' module.Metadata.PEImage.ImageNTHeaders.OptionalHeader.DataDirectories[14].Size' DEFAULT_COR20HEADER_ALIGNMENT); " is 248.
Long Statement,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteFile,The length of the statement  "					ReuseIfPossible(textSection' strongNameSignature' module.Metadata.ImageCor20Header.StrongNameSignature.VirtualAddress' module.Metadata.ImageCor20Header.StrongNameSignature.Size' DEFAULT_STRONGNAMESIG_ALIGNMENT); " is 211.
Long Statement,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteFile,The length of the statement  "				ReuseIfPossible(textSection' netResources' module.Metadata.ImageCor20Header.Resources.VirtualAddress' module.Metadata.ImageCor20Header.Resources.Size' DEFAULT_NETRESOURCES_ALIGNMENT); " is 183.
Long Statement,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteFile,The length of the statement  "				if (debugDataDir.VirtualAddress != 0 && debugDataDir.Size != 0 && TryGetRealDebugDirectorySize(peImage' out uint realDebugDirSize)) " is 131.
Long Statement,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteFile,The length of the statement  "					ReuseIfPossible(textSection' debugDirectory' debugDataDir.VirtualAddress' realDebugDirSize' DebugDirectory.DEFAULT_DEBUGDIRECTORY_ALIGNMENT); " is 141.
Long Statement,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteFile,The length of the statement  "			CalculateRvasAndFileOffsets(chunks' 0' 0' peImage.ImageNTHeaders.OptionalHeader.FileAlignment' peImage.ImageNTHeaders.OptionalHeader.SectionAlignment); " is 151.
Long Statement,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteFile,The length of the statement  "			var sectionSizes = new SectionSizes(peImage.ImageNTHeaders.OptionalHeader.FileAlignment' peImage.ImageNTHeaders.OptionalHeader.SectionAlignment' headerLen' GetSectionSizeInfos); " is 177.
Long Statement,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The length of the statement  "				section.WriteHeaderTo(writer' peImage.ImageNTHeaders.OptionalHeader.FileAlignment' peImage.ImageNTHeaders.OptionalHeader.SectionAlignment' (uint)section.RVA); " is 158.
Long Statement,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,ToWriterOffset,The length of the statement  "				if (section.VirtualAddress <= rva && rva < section.VirtualAddress + Math.Max(section.VirtualSize' section.SizeOfRawData)) " is 121.
Long Statement,dnlib.DotNet.Writer,NormalMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NormalMetadata.cs,AllocateMemberDefRids,The length of the statement  "				typeRow = new RawTypeDefRow(typeRow.Flags' typeRow.Name' typeRow.Namespace' typeRow.Extends' fieldListRid' methodListRid); " is 122.
Long Statement,dnlib.DotNet.Writer,NormalMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NormalMetadata.cs,GetRid,The length of the statement  "				Error("TypeDef {0} ({1:X8}) is not defined in this module ({2}). A type was removed that is still referenced by this module."' td' td.MDToken.Raw' module); " is 155.
Long Statement,dnlib.DotNet.Writer,NormalMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NormalMetadata.cs,GetRid,The length of the statement  "				Error("Field {0} ({1:X8}) is not defined in this module ({2}). A field was removed that is still referenced by this module."' fd' fd.MDToken.Raw' module); " is 154.
Long Statement,dnlib.DotNet.Writer,NormalMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NormalMetadata.cs,GetRid,The length of the statement  "				Error("Method {0} ({1:X8}) is not defined in this module ({2}). A method was removed that is still referenced by this module."' md' md.MDToken.Raw' module); " is 156.
Long Statement,dnlib.DotNet.Writer,NormalMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NormalMetadata.cs,GetRid,The length of the statement  "				Error("Param {0} ({1:X8}) is not defined in this module ({2}). A parameter was removed that is still referenced by this module."' pd' pd.MDToken.Raw' module); " is 158.
Long Statement,dnlib.DotNet.Writer,NormalMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NormalMetadata.cs,GetRid,The length of the statement  "				Error("Event {0} ({1:X8}) is not defined in this module ({2}). An event was removed that is still referenced by this module."' ed' ed.MDToken.Raw' module); " is 155.
Long Statement,dnlib.DotNet.Writer,NormalMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NormalMetadata.cs,GetRid,The length of the statement  "				Error("Property {0} ({1:X8}) is not defined in this module ({2}). A property was removed that is still referenced by this module."' pd' pd.MDToken.Raw' module); " is 160.
Long Statement,dnlib.DotNet.Writer,PEHeaders,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PEHeaders.cs,WriteTo,The length of the statement  "			Debug.Assert(SectionsCount == sections.Count' "One or more sections are empty! The PE file could be bigger than it should be. Empty sections should be removed."); " is 162.
Long Statement,dnlib.DotNet.Writer,PreserveTokensMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PreserveTokensMetadata.cs,GetRid,The length of the statement  "			Error("TypeDef {0} ({1:X8}) is not defined in this module ({2}). A type was removed that is still referenced by this module."' td' td.MDToken.Raw' module); " is 155.
Long Statement,dnlib.DotNet.Writer,PreserveTokensMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PreserveTokensMetadata.cs,GetRid,The length of the statement  "				Error("Field {0} ({1:X8}) is not defined in this module ({2}). A field was removed that is still referenced by this module."' fd' fd.MDToken.Raw' module); " is 154.
Long Statement,dnlib.DotNet.Writer,PreserveTokensMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PreserveTokensMetadata.cs,GetRid,The length of the statement  "				Error("Method {0} ({1:X8}) is not defined in this module ({2}). A method was removed that is still referenced by this module."' md' md.MDToken.Raw' module); " is 156.
Long Statement,dnlib.DotNet.Writer,PreserveTokensMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PreserveTokensMetadata.cs,GetRid,The length of the statement  "				Error("Param {0} ({1:X8}) is not defined in this module ({2}). A parameter was removed that is still referenced by this module."' pd' pd.MDToken.Raw' module); " is 158.
Long Statement,dnlib.DotNet.Writer,PreserveTokensMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PreserveTokensMetadata.cs,GetRid,The length of the statement  "				Error("Event {0} ({1:X8}) is not defined in this module ({2}). An event was removed that is still referenced by this module."' ed' ed.MDToken.Raw' module); " is 155.
Long Statement,dnlib.DotNet.Writer,PreserveTokensMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PreserveTokensMetadata.cs,GetRid,The length of the statement  "				Error("Property {0} ({1:X8}) is not defined in this module ({2}). A property was removed that is still referenced by this module."' pd' pd.MDToken.Raw' module); " is 160.
Long Statement,dnlib.DotNet.Writer,PreserveTokensMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PreserveTokensMetadata.cs,ReUseDeletedFieldRows,The length of the statement  "				var frow = new RawFieldRow((ushort)(FieldAttributes.Public | FieldAttributes.Static)' stringsHeap.Add($"f{frid:X6}")' fieldSig); " is 128.
Long Statement,dnlib.DotNet.Writer,PreserveTokensMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PreserveTokensMetadata.cs,ReUseDeletedMethodRows,The length of the statement  "					(ushort)(MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Abstract)' " is 145.
Long Statement,dnlib.DotNet.Writer,PreserveTokensMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PreserveTokensMetadata.cs,ReUseDeletedParamRows,The length of the statement  "					(ushort)(MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Abstract)' " is 145.
Long Statement,dnlib.DotNet.Writer,PreserveTokensMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PreserveTokensMetadata.cs,AddTypeRef,The length of the statement  "			var row = new RawTypeRefRow(AddResolutionScope(tr.ResolutionScope)' stringsHeap.Add(tr.Name)' stringsHeap.Add(tr.Namespace)); " is 125.
Long Statement,dnlib.DotNet.Writer,SerializerMethodContext,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\SerializerMethodContext.cs,GetOffset,The length of the statement  "			helper.Error("Couldn't find an instruction' maybe it was removed. It's still being referenced by some code or by the PDB"); " is 123.
Long Statement,dnlib.DotNet.Writer,StartupStub,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\StartupStub.cs,SetOffset,The length of the statement  "				logError("The module needs an unmanaged entry point but the CPU architecture isn't supported: {0} (0x{1:X4})"' new object[] { machine' (ushort)machine }); " is 154.
Long Statement,dnlib.DotNet.Writer,StringsHeap,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\StringsHeap.cs,GetOffset,The length of the statement  "				throw new ModuleWriterException("This method can only be called after all strings have been added and this heap is read-only"); " is 127.
Long Statement,dnlib.IO,Windows,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\MemoryMappedDataReaderFactory.cs,Mmap,The length of the statement  "				using (var fileHandle = CreateFile(creator.filename' GENERIC_READ' FILE_SHARE_READ' IntPtr.Zero' OPEN_EXISTING' FILE_ATTRIBUTE_NORMAL' IntPtr.Zero)) { " is 150.
Long Statement,dnlib.IO,Windows,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\MemoryMappedDataReaderFactory.cs,Mmap,The length of the statement  "					using (var fileMapping = CreateFileMapping(fileHandle' IntPtr.Zero' PAGE_READONLY | (mapAsImage ? SEC_IMAGE : 0)' 0' 0' null)) { " is 128.
Long Statement,dnlib.IO,Windows,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\MemoryMappedDataReaderFactory.cs,Mmap,The length of the statement  "							throw new MemoryMappedIONotSupportedException($"Could not create a file mapping object. File: {creator.filename}' error: {Marshal.GetLastWin32Error():X8}"); " is 156.
Long Statement,dnlib.IO,Windows,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\MemoryMappedDataReaderFactory.cs,Mmap,The length of the statement  "							throw new MemoryMappedIONotSupportedException($"Could not map file {creator.filename}. Error: {Marshal.GetLastWin32Error():X8}"); " is 129.
Long Statement,dnlib.IO,Unix,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\MemoryMappedDataReaderFactory.cs,Mmap,The length of the statement  "							throw new MemoryMappedIONotSupportedException($"Could not get length of {creator.filename} (lseek failed): {Marshal.GetLastWin32Error()}"); " is 139.
Long Statement,dnlib.IO,Unix,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\MemoryMappedDataReaderFactory.cs,Mmap,The length of the statement  "							throw new MemoryMappedIONotSupportedException($"Could not map file {creator.filename}. Error: {Marshal.GetLastWin32Error()}"); " is 126.
Long Statement,dnlib.IO,Unix,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\MemoryMappedDataReaderFactory.cs,Mmap,The length of the statement  "							throw new MemoryMappedIONotSupportedException($"Could not get length of {creator.filename} (lseek failed): {Marshal.GetLastWin32Error()}"); " is 139.
Long Statement,dnlib.IO,Unix,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\MemoryMappedDataReaderFactory.cs,Mmap,The length of the statement  "							throw new MemoryMappedIONotSupportedException($"Could not map file {creator.filename}. Error: {Marshal.GetLastWin32Error()}"); " is 126.
Long Statement,dnlib.PE,PEInfo,D:\research\architectureSmells\repos\0xd4d_dnlib\src\PE\PEInfo.cs,ToImageSectionHeader,The length of the statement  "				if (rva >= section.VirtualAddress && rva < section.VirtualAddress + Math.Max(section.VirtualSize' section.SizeOfRawData)) " is 121.
Long Statement,dnlib.PE,PEInfo,D:\research\architectureSmells\repos\0xd4d_dnlib\src\PE\PEInfo.cs,GetImageSize,The length of the statement  "				ulong length2 = AlignUp((ulong)section.VirtualAddress + Math.Max(section.VirtualSize' section.SizeOfRawData)' alignment); " is 121.
Complex Conditional,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,Equals,The conditional expression  "!((fa = a as IField) is null) && !((fb = b as IField) is null) && fa.IsField && fb.IsField"  is complex.
Complex Conditional,dnlib.DotNet,ReflectionTypeNameParser,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TypeNameParser.cs,ReadTSpecs,The conditional expression  "peeked == '*' || peeked == ''' || peeked == '-' || char.IsDigit((char)peeked)"  is complex.
Complex Conditional,dnlib.DotNet.Pdb.Dss,SymbolScopeImpl,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\SymbolScopeImpl.cs,GetSignatureBytes,The conditional expression  "bufSize == 0 || (hr < 0 && hr != E_FAIL && hr != E_NOTIMPL)"  is complex.
Complex Conditional,dnlib.DotNet.Writer,CustomAttributeWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,Write,The conditional expression  "(!(ca.ConstructorArguments is null) && ca.ConstructorArguments.Count > 0) || (!(ca.NamedArguments is null) && ca.NamedArguments.Count > 0)"  is complex.
Complex Conditional,dnlib.DotNet.Writer,MethodBodyChunks,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBodyChunks.cs,Add,The conditional expression  "CanReuseOldBodyLocation && origRva != 0 && origSize != 0 && methodBody.CanReuse(origRva' origSize)"  is complex.
Complex Conditional,dnlib.DotNet.Writer,ModuleWriterOptionsBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,HasMvidSection,The conditional expression  "name[0] == '.' && name[1] == 'm' && name[2] == 'v' && name[3] == 'i' && name[4] == 'd' && name[5] == 0"  is complex.
Complex Conditional,dnlib.DotNet.Writer,USHeap,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\USHeap.cs,WriteString,The conditional expression  "c > 0xFF || (1 <= c && c <= 8) || (0x0E <= c && c <= 0x1F) || c == 0x27 || c == 0x2D || c == 0x7F"  is complex.
Virtual Method Call from Constructor,dnlib.DotNet.Pdb,PdbState,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\PdbState.cs,PdbState,The constructor "PdbState" calls a virtual method "Initialize".
Virtual Method Call from Constructor,dnlib.DotNet.Pdb.WindowsPdb,WindowsPdbWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\WindowsPdbWriter.cs,WindowsPdbWriter,The constructor "WindowsPdbWriter" calls a virtual method "Initialize".
Empty Catch Block,dnlib.DotNet,AssemblyResolver,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyResolver.cs,FindExactAssembly,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,AssemblyResolver,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyResolver.cs,FindClosestAssembly,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,AssemblyResolver,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyResolver.cs,GetDirs,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,AssemblyResolver,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyResolver.cs,GetModulePrivateSearchPaths,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,AssemblyResolver,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyResolver.cs,GetPrivatePaths,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,AssemblyResolver,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyResolver.cs,GetPrivatePaths,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,AssemblyResolver,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyResolver.cs,GetPrivatePaths,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,MethodExportInfoProvider,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MethodExportInfoProvider.cs,MethodExportInfoProvider,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,MethodExportInfoProvider,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MethodExportInfoProvider.cs,MethodExportInfoProvider,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,GetBaseDirectoryOfImage,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,GetBaseDirectoryOfImage,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,TryCreateResourceStream,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,TryCreateResourceStream,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,UTF8String,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\UTF8String.cs,ConvertFromUTF8,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.Pdb,DataReaderFactoryUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\DataReaderFactoryUtils.cs,TryCreateDataReaderFactory,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.Pdb,DataReaderFactoryUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\DataReaderFactoryUtils.cs,TryCreateDataReaderFactory,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.Pdb,DataReaderFactoryUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\DataReaderFactoryUtils.cs,TryCreateDataReaderFactory,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.Pdb,SymbolReaderFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\SymbolReaderFactory.cs,CreateCore,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.Pdb,SymbolReaderFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\SymbolReaderFactory.cs,CreateManagedCore,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.Pdb.Dss,SymbolReaderWriterFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\SymbolReaderWriterFactory.cs,Create,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.Pdb.Dss,SymbolReaderWriterFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\SymbolReaderWriterFactory.cs,Create,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.Pdb.Dss,SymbolReaderWriterFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\SymbolReaderWriterFactory.cs,Create,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.Pdb.Dss,SymbolReaderWriterFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\SymbolReaderWriterFactory.cs,CreateSymUnmanagedReader,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.Pdb.Dss,SymbolReaderWriterFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\SymbolReaderWriterFactory.cs,CreateSymUnmanagedWriter2,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.Pdb.Managed,SymbolReaderFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\SymbolReaderFactory.cs,Create,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.Pdb.Managed,SymbolReaderFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\SymbolReaderFactory.cs,Create,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.Pdb.Portable,LocalConstantSigBlobReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\LocalConstantSigBlobReader.cs,ReadCatch,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.Pdb.Portable,PortablePdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\PortablePdbCustomDebugInfoReader.cs,Read,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.Pdb.Portable,PortablePdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\PortablePdbCustomDebugInfoReader.cs,Read,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.Pdb.Portable,PortablePdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\PortablePdbCustomDebugInfoReader.cs,Read,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.Pdb.Portable,SymbolReaderFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\SymbolReaderFactory.cs,TryCreate,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.Pdb.Portable,SymbolReaderFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\SymbolReaderFactory.cs,TryCreateEmbeddedPortablePdbReader,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoReader.cs,Read,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoReader.cs,Read,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoReader.cs,Read,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.Resources,ResourceDataFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Resources\ResourceDataFactory.cs,GetSerializedTypeAndAssemblyName,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.Writer,ModuleWriterOptionsBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,TryGetPdbChecksumAlgorithm,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.Writer,ModuleWriterOptionsBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,TryGetPdbChecksumAlgorithm,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.Writer,ModuleWriterBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,DeleteFileNoThrow,The method has an empty catch block.
Empty Catch Block,dnlib.IO,MemoryMappedDataReaderFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\MemoryMappedDataReaderFactory.cs,CreateWindows,The method has an empty catch block.
Empty Catch Block,dnlib.IO,MemoryMappedDataReaderFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\MemoryMappedDataReaderFactory.cs,CreateWindows,The method has an empty catch block.
Empty Catch Block,dnlib.IO,MemoryMappedDataReaderFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\MemoryMappedDataReaderFactory.cs,CreateUnix,The method has an empty catch block.
Empty Catch Block,dnlib.IO,MemoryMappedDataReaderFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\MemoryMappedDataReaderFactory.cs,CreateUnix,The method has an empty catch block.
Empty Catch Block,dnlib.IO,MemoryMappedDataReaderFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\MemoryMappedDataReaderFactory.cs,FreeMemoryMappedIoData,The method has an empty catch block.
Empty Catch Block,dnlib.PE,PEImage,D:\research\architectureSmells\repos\0xd4d_dnlib\src\PE\PEImage.cs,ReadImageDebugDirectories,The method has an empty catch block.
Empty Catch Block,dnlib.PE,ProcessorArchUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\PE\ProcessorArchUtils.cs,GetProcessCpuArchitectureCore,The method has an empty catch block.
Magic Number,dnlib.DotNet,AssemblyDef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyDef.cs,IsValidAssemblySignatureKeyAttribute,The following statement contains a magic number: sig is null || sig.Params.Count != 2
Magic Number,dnlib.DotNet,AssemblyDef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyDef.cs,IsValidAssemblySignatureKeyAttribute,The following statement contains a magic number: ca.ConstructorArguments.Count != 2
Magic Number,dnlib.DotNet,AssemblyDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyDef.cs,TryCreateTargetFrameworkInfo,The following statement contains a magic number: values.Length < 2 || values.Length > 3
Magic Number,dnlib.DotNet,AssemblyDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyDef.cs,TryCreateTargetFrameworkInfo,The following statement contains a magic number: values.Length < 2 || values.Length > 3
Magic Number,dnlib.DotNet,AssemblyDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyDef.cs,TryCreateTargetFrameworkInfo,The following statement contains a magic number: kvp.Length != 2
Magic Number,dnlib.DotNet,AssemblyDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyDef.cs,TryParse,The following statement contains a magic number: version = new Version(ParseInt32(m.Groups[1].Value)' ParseInt32(m.Groups[2].Value));
Magic Number,dnlib.DotNet,AssemblyDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyDef.cs,TryParse,The following statement contains a magic number: m.Groups.Count == 3
Magic Number,dnlib.DotNet,AssemblyDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyDef.cs,TryParse,The following statement contains a magic number: version = new Version(ParseInt32(m.Groups[1].Value)' ParseInt32(m.Groups[2].Value)' ParseInt32(m.Groups[3].Value));
Magic Number,dnlib.DotNet,AssemblyDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyDef.cs,TryParse,The following statement contains a magic number: version = new Version(ParseInt32(m.Groups[1].Value)' ParseInt32(m.Groups[2].Value)' ParseInt32(m.Groups[3].Value));
Magic Number,dnlib.DotNet,AssemblyDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyDef.cs,TryParse,The following statement contains a magic number: m.Groups.Count == 4
Magic Number,dnlib.DotNet,AssemblyDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyDef.cs,TryParse,The following statement contains a magic number: version = new Version(ParseInt32(m.Groups[1].Value)' ParseInt32(m.Groups[2].Value)' ParseInt32(m.Groups[3].Value)' ParseInt32(m.Groups[4].Value));
Magic Number,dnlib.DotNet,AssemblyDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyDef.cs,TryParse,The following statement contains a magic number: version = new Version(ParseInt32(m.Groups[1].Value)' ParseInt32(m.Groups[2].Value)' ParseInt32(m.Groups[3].Value)' ParseInt32(m.Groups[4].Value));
Magic Number,dnlib.DotNet,AssemblyDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyDef.cs,TryParse,The following statement contains a magic number: version = new Version(ParseInt32(m.Groups[1].Value)' ParseInt32(m.Groups[2].Value)' ParseInt32(m.Groups[3].Value)' ParseInt32(m.Groups[4].Value));
Magic Number,dnlib.DotNet,AssemblyDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyDef.cs,TryParse,The following statement contains a magic number: m.Groups.Count == 5
Magic Number,dnlib.DotNet,AssemblyHash,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyHash.cs,CreatePublicKeyToken,The following statement contains a magic number: var pkt = new byte[8];
Magic Number,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyHashAlgorithm.cs,GetPrimitiveSize,The following statement contains a magic number: switch (etype) {  			case ElementType.Boolean:  			case ElementType.I1:  			case ElementType.U1:  				return 1;    			case ElementType.Char:  			case ElementType.I2:  			case ElementType.U2:  				return 2;    			case ElementType.I4:  			case ElementType.U4:  			case ElementType.R4:  				return 4;    			case ElementType.I8:  			case ElementType.U8:  			case ElementType.R8:  				return 8;    			case ElementType.Ptr:  			case ElementType.FnPtr:  			case ElementType.I:  			case ElementType.U:  				return ptrSize;    			default:  				return -1;  			}
Magic Number,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyHashAlgorithm.cs,GetPrimitiveSize,The following statement contains a magic number: switch (etype) {  			case ElementType.Boolean:  			case ElementType.I1:  			case ElementType.U1:  				return 1;    			case ElementType.Char:  			case ElementType.I2:  			case ElementType.U2:  				return 2;    			case ElementType.I4:  			case ElementType.U4:  			case ElementType.R4:  				return 4;    			case ElementType.I8:  			case ElementType.U8:  			case ElementType.R8:  				return 8;    			case ElementType.Ptr:  			case ElementType.FnPtr:  			case ElementType.I:  			case ElementType.U:  				return ptrSize;    			default:  				return -1;  			}
Magic Number,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyHashAlgorithm.cs,GetPrimitiveSize,The following statement contains a magic number: switch (etype) {  			case ElementType.Boolean:  			case ElementType.I1:  			case ElementType.U1:  				return 1;    			case ElementType.Char:  			case ElementType.I2:  			case ElementType.U2:  				return 2;    			case ElementType.I4:  			case ElementType.U4:  			case ElementType.R4:  				return 4;    			case ElementType.I8:  			case ElementType.U8:  			case ElementType.R8:  				return 8;    			case ElementType.Ptr:  			case ElementType.FnPtr:  			case ElementType.I:  			case ElementType.U:  				return ptrSize;    			default:  				return -1;  			}
Magic Number,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyHashAlgorithm.cs,GetNonNestedTypeRefScope,The following statement contains a magic number: i < 100
Magic Number,dnlib.DotNet,AssemblyResolver,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyResolver.cs,GetCurrentMonoPrefix,The following statement contains a magic number: i < 4
Magic Number,dnlib.DotNet,AssemblyResolver,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyResolver.cs,GetGacInfos,The following statement contains a magic number: int version = sourceModule is null ? int.MinValue : sourceModule.IsClr40 ? 4 : 2;
Magic Number,dnlib.DotNet,AssemblyResolver,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyResolver.cs,GetGacInfos,The following statement contains a magic number: int version = sourceModule is null ? int.MinValue : sourceModule.IsClr40 ? 4 : 2;
Magic Number,dnlib.DotNet,AssemblyResolver,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyResolver.cs,FindAssembliesModuleSearchPaths,The following statement contains a magic number: i < 2
Magic Number,dnlib.DotNet,ConstantMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  			case ElementType.Boolean:  				if (reader.Length < 1)  					return false;  				return reader.ReadBoolean();    			case ElementType.Char:  				if (reader.Length < 2)  					return (char)0;  				return reader.ReadChar();    			case ElementType.I1:  				if (reader.Length < 1)  					return (sbyte)0;  				return reader.ReadSByte();    			case ElementType.U1:  				if (reader.Length < 1)  					return (byte)0;  				return reader.ReadByte();    			case ElementType.I2:  				if (reader.Length < 2)  					return (short)0;  				return reader.ReadInt16();    			case ElementType.U2:  				if (reader.Length < 2)  					return (ushort)0;  				return reader.ReadUInt16();    			case ElementType.I4:  				if (reader.Length < 4)  					return (int)0;  				return reader.ReadInt32();    			case ElementType.U4:  				if (reader.Length < 4)  					return (uint)0;  				return reader.ReadUInt32();    			case ElementType.I8:  				if (reader.Length < 8)  					return (long)0;  				return reader.ReadInt64();    			case ElementType.U8:  				if (reader.Length < 8)  					return (ulong)0;  				return reader.ReadUInt64();    			case ElementType.R4:  				if (reader.Length < 4)  					return (float)0;  				return reader.ReadSingle();    			case ElementType.R8:  				if (reader.Length < 8)  					return (double)0;  				return reader.ReadDouble();    			case ElementType.String:  				return reader.ReadUtf16String((int)(reader.BytesLeft / 2));    			case ElementType.Class:  				return null;    			default:  				return null;  			}
Magic Number,dnlib.DotNet,ConstantMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  			case ElementType.Boolean:  				if (reader.Length < 1)  					return false;  				return reader.ReadBoolean();    			case ElementType.Char:  				if (reader.Length < 2)  					return (char)0;  				return reader.ReadChar();    			case ElementType.I1:  				if (reader.Length < 1)  					return (sbyte)0;  				return reader.ReadSByte();    			case ElementType.U1:  				if (reader.Length < 1)  					return (byte)0;  				return reader.ReadByte();    			case ElementType.I2:  				if (reader.Length < 2)  					return (short)0;  				return reader.ReadInt16();    			case ElementType.U2:  				if (reader.Length < 2)  					return (ushort)0;  				return reader.ReadUInt16();    			case ElementType.I4:  				if (reader.Length < 4)  					return (int)0;  				return reader.ReadInt32();    			case ElementType.U4:  				if (reader.Length < 4)  					return (uint)0;  				return reader.ReadUInt32();    			case ElementType.I8:  				if (reader.Length < 8)  					return (long)0;  				return reader.ReadInt64();    			case ElementType.U8:  				if (reader.Length < 8)  					return (ulong)0;  				return reader.ReadUInt64();    			case ElementType.R4:  				if (reader.Length < 4)  					return (float)0;  				return reader.ReadSingle();    			case ElementType.R8:  				if (reader.Length < 8)  					return (double)0;  				return reader.ReadDouble();    			case ElementType.String:  				return reader.ReadUtf16String((int)(reader.BytesLeft / 2));    			case ElementType.Class:  				return null;    			default:  				return null;  			}
Magic Number,dnlib.DotNet,ConstantMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  			case ElementType.Boolean:  				if (reader.Length < 1)  					return false;  				return reader.ReadBoolean();    			case ElementType.Char:  				if (reader.Length < 2)  					return (char)0;  				return reader.ReadChar();    			case ElementType.I1:  				if (reader.Length < 1)  					return (sbyte)0;  				return reader.ReadSByte();    			case ElementType.U1:  				if (reader.Length < 1)  					return (byte)0;  				return reader.ReadByte();    			case ElementType.I2:  				if (reader.Length < 2)  					return (short)0;  				return reader.ReadInt16();    			case ElementType.U2:  				if (reader.Length < 2)  					return (ushort)0;  				return reader.ReadUInt16();    			case ElementType.I4:  				if (reader.Length < 4)  					return (int)0;  				return reader.ReadInt32();    			case ElementType.U4:  				if (reader.Length < 4)  					return (uint)0;  				return reader.ReadUInt32();    			case ElementType.I8:  				if (reader.Length < 8)  					return (long)0;  				return reader.ReadInt64();    			case ElementType.U8:  				if (reader.Length < 8)  					return (ulong)0;  				return reader.ReadUInt64();    			case ElementType.R4:  				if (reader.Length < 4)  					return (float)0;  				return reader.ReadSingle();    			case ElementType.R8:  				if (reader.Length < 8)  					return (double)0;  				return reader.ReadDouble();    			case ElementType.String:  				return reader.ReadUtf16String((int)(reader.BytesLeft / 2));    			case ElementType.Class:  				return null;    			default:  				return null;  			}
Magic Number,dnlib.DotNet,ConstantMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  			case ElementType.Boolean:  				if (reader.Length < 1)  					return false;  				return reader.ReadBoolean();    			case ElementType.Char:  				if (reader.Length < 2)  					return (char)0;  				return reader.ReadChar();    			case ElementType.I1:  				if (reader.Length < 1)  					return (sbyte)0;  				return reader.ReadSByte();    			case ElementType.U1:  				if (reader.Length < 1)  					return (byte)0;  				return reader.ReadByte();    			case ElementType.I2:  				if (reader.Length < 2)  					return (short)0;  				return reader.ReadInt16();    			case ElementType.U2:  				if (reader.Length < 2)  					return (ushort)0;  				return reader.ReadUInt16();    			case ElementType.I4:  				if (reader.Length < 4)  					return (int)0;  				return reader.ReadInt32();    			case ElementType.U4:  				if (reader.Length < 4)  					return (uint)0;  				return reader.ReadUInt32();    			case ElementType.I8:  				if (reader.Length < 8)  					return (long)0;  				return reader.ReadInt64();    			case ElementType.U8:  				if (reader.Length < 8)  					return (ulong)0;  				return reader.ReadUInt64();    			case ElementType.R4:  				if (reader.Length < 4)  					return (float)0;  				return reader.ReadSingle();    			case ElementType.R8:  				if (reader.Length < 8)  					return (double)0;  				return reader.ReadDouble();    			case ElementType.String:  				return reader.ReadUtf16String((int)(reader.BytesLeft / 2));    			case ElementType.Class:  				return null;    			default:  				return null;  			}
Magic Number,dnlib.DotNet,ConstantMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  			case ElementType.Boolean:  				if (reader.Length < 1)  					return false;  				return reader.ReadBoolean();    			case ElementType.Char:  				if (reader.Length < 2)  					return (char)0;  				return reader.ReadChar();    			case ElementType.I1:  				if (reader.Length < 1)  					return (sbyte)0;  				return reader.ReadSByte();    			case ElementType.U1:  				if (reader.Length < 1)  					return (byte)0;  				return reader.ReadByte();    			case ElementType.I2:  				if (reader.Length < 2)  					return (short)0;  				return reader.ReadInt16();    			case ElementType.U2:  				if (reader.Length < 2)  					return (ushort)0;  				return reader.ReadUInt16();    			case ElementType.I4:  				if (reader.Length < 4)  					return (int)0;  				return reader.ReadInt32();    			case ElementType.U4:  				if (reader.Length < 4)  					return (uint)0;  				return reader.ReadUInt32();    			case ElementType.I8:  				if (reader.Length < 8)  					return (long)0;  				return reader.ReadInt64();    			case ElementType.U8:  				if (reader.Length < 8)  					return (ulong)0;  				return reader.ReadUInt64();    			case ElementType.R4:  				if (reader.Length < 4)  					return (float)0;  				return reader.ReadSingle();    			case ElementType.R8:  				if (reader.Length < 8)  					return (double)0;  				return reader.ReadDouble();    			case ElementType.String:  				return reader.ReadUtf16String((int)(reader.BytesLeft / 2));    			case ElementType.Class:  				return null;    			default:  				return null;  			}
Magic Number,dnlib.DotNet,ConstantMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  			case ElementType.Boolean:  				if (reader.Length < 1)  					return false;  				return reader.ReadBoolean();    			case ElementType.Char:  				if (reader.Length < 2)  					return (char)0;  				return reader.ReadChar();    			case ElementType.I1:  				if (reader.Length < 1)  					return (sbyte)0;  				return reader.ReadSByte();    			case ElementType.U1:  				if (reader.Length < 1)  					return (byte)0;  				return reader.ReadByte();    			case ElementType.I2:  				if (reader.Length < 2)  					return (short)0;  				return reader.ReadInt16();    			case ElementType.U2:  				if (reader.Length < 2)  					return (ushort)0;  				return reader.ReadUInt16();    			case ElementType.I4:  				if (reader.Length < 4)  					return (int)0;  				return reader.ReadInt32();    			case ElementType.U4:  				if (reader.Length < 4)  					return (uint)0;  				return reader.ReadUInt32();    			case ElementType.I8:  				if (reader.Length < 8)  					return (long)0;  				return reader.ReadInt64();    			case ElementType.U8:  				if (reader.Length < 8)  					return (ulong)0;  				return reader.ReadUInt64();    			case ElementType.R4:  				if (reader.Length < 4)  					return (float)0;  				return reader.ReadSingle();    			case ElementType.R8:  				if (reader.Length < 8)  					return (double)0;  				return reader.ReadDouble();    			case ElementType.String:  				return reader.ReadUtf16String((int)(reader.BytesLeft / 2));    			case ElementType.Class:  				return null;    			default:  				return null;  			}
Magic Number,dnlib.DotNet,ConstantMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  			case ElementType.Boolean:  				if (reader.Length < 1)  					return false;  				return reader.ReadBoolean();    			case ElementType.Char:  				if (reader.Length < 2)  					return (char)0;  				return reader.ReadChar();    			case ElementType.I1:  				if (reader.Length < 1)  					return (sbyte)0;  				return reader.ReadSByte();    			case ElementType.U1:  				if (reader.Length < 1)  					return (byte)0;  				return reader.ReadByte();    			case ElementType.I2:  				if (reader.Length < 2)  					return (short)0;  				return reader.ReadInt16();    			case ElementType.U2:  				if (reader.Length < 2)  					return (ushort)0;  				return reader.ReadUInt16();    			case ElementType.I4:  				if (reader.Length < 4)  					return (int)0;  				return reader.ReadInt32();    			case ElementType.U4:  				if (reader.Length < 4)  					return (uint)0;  				return reader.ReadUInt32();    			case ElementType.I8:  				if (reader.Length < 8)  					return (long)0;  				return reader.ReadInt64();    			case ElementType.U8:  				if (reader.Length < 8)  					return (ulong)0;  				return reader.ReadUInt64();    			case ElementType.R4:  				if (reader.Length < 4)  					return (float)0;  				return reader.ReadSingle();    			case ElementType.R8:  				if (reader.Length < 8)  					return (double)0;  				return reader.ReadDouble();    			case ElementType.String:  				return reader.ReadUtf16String((int)(reader.BytesLeft / 2));    			case ElementType.Class:  				return null;    			default:  				return null;  			}
Magic Number,dnlib.DotNet,ConstantMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  			case ElementType.Boolean:  				if (reader.Length < 1)  					return false;  				return reader.ReadBoolean();    			case ElementType.Char:  				if (reader.Length < 2)  					return (char)0;  				return reader.ReadChar();    			case ElementType.I1:  				if (reader.Length < 1)  					return (sbyte)0;  				return reader.ReadSByte();    			case ElementType.U1:  				if (reader.Length < 1)  					return (byte)0;  				return reader.ReadByte();    			case ElementType.I2:  				if (reader.Length < 2)  					return (short)0;  				return reader.ReadInt16();    			case ElementType.U2:  				if (reader.Length < 2)  					return (ushort)0;  				return reader.ReadUInt16();    			case ElementType.I4:  				if (reader.Length < 4)  					return (int)0;  				return reader.ReadInt32();    			case ElementType.U4:  				if (reader.Length < 4)  					return (uint)0;  				return reader.ReadUInt32();    			case ElementType.I8:  				if (reader.Length < 8)  					return (long)0;  				return reader.ReadInt64();    			case ElementType.U8:  				if (reader.Length < 8)  					return (ulong)0;  				return reader.ReadUInt64();    			case ElementType.R4:  				if (reader.Length < 4)  					return (float)0;  				return reader.ReadSingle();    			case ElementType.R8:  				if (reader.Length < 8)  					return (double)0;  				return reader.ReadDouble();    			case ElementType.String:  				return reader.ReadUtf16String((int)(reader.BytesLeft / 2));    			case ElementType.Class:  				return null;    			default:  				return null;  			}
Magic Number,dnlib.DotNet,ConstantMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  			case ElementType.Boolean:  				if (reader.Length < 1)  					return false;  				return reader.ReadBoolean();    			case ElementType.Char:  				if (reader.Length < 2)  					return (char)0;  				return reader.ReadChar();    			case ElementType.I1:  				if (reader.Length < 1)  					return (sbyte)0;  				return reader.ReadSByte();    			case ElementType.U1:  				if (reader.Length < 1)  					return (byte)0;  				return reader.ReadByte();    			case ElementType.I2:  				if (reader.Length < 2)  					return (short)0;  				return reader.ReadInt16();    			case ElementType.U2:  				if (reader.Length < 2)  					return (ushort)0;  				return reader.ReadUInt16();    			case ElementType.I4:  				if (reader.Length < 4)  					return (int)0;  				return reader.ReadInt32();    			case ElementType.U4:  				if (reader.Length < 4)  					return (uint)0;  				return reader.ReadUInt32();    			case ElementType.I8:  				if (reader.Length < 8)  					return (long)0;  				return reader.ReadInt64();    			case ElementType.U8:  				if (reader.Length < 8)  					return (ulong)0;  				return reader.ReadUInt64();    			case ElementType.R4:  				if (reader.Length < 4)  					return (float)0;  				return reader.ReadSingle();    			case ElementType.R8:  				if (reader.Length < 8)  					return (double)0;  				return reader.ReadDouble();    			case ElementType.String:  				return reader.ReadUtf16String((int)(reader.BytesLeft / 2));    			case ElementType.Class:  				return null;    			default:  				return null;  			}
Magic Number,dnlib.DotNet,ConstantMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  			case ElementType.Boolean:  				if (reader.Length < 1)  					return false;  				return reader.ReadBoolean();    			case ElementType.Char:  				if (reader.Length < 2)  					return (char)0;  				return reader.ReadChar();    			case ElementType.I1:  				if (reader.Length < 1)  					return (sbyte)0;  				return reader.ReadSByte();    			case ElementType.U1:  				if (reader.Length < 1)  					return (byte)0;  				return reader.ReadByte();    			case ElementType.I2:  				if (reader.Length < 2)  					return (short)0;  				return reader.ReadInt16();    			case ElementType.U2:  				if (reader.Length < 2)  					return (ushort)0;  				return reader.ReadUInt16();    			case ElementType.I4:  				if (reader.Length < 4)  					return (int)0;  				return reader.ReadInt32();    			case ElementType.U4:  				if (reader.Length < 4)  					return (uint)0;  				return reader.ReadUInt32();    			case ElementType.I8:  				if (reader.Length < 8)  					return (long)0;  				return reader.ReadInt64();    			case ElementType.U8:  				if (reader.Length < 8)  					return (ulong)0;  				return reader.ReadUInt64();    			case ElementType.R4:  				if (reader.Length < 4)  					return (float)0;  				return reader.ReadSingle();    			case ElementType.R8:  				if (reader.Length < 8)  					return (double)0;  				return reader.ReadDouble();    			case ElementType.String:  				return reader.ReadUtf16String((int)(reader.BytesLeft / 2));    			case ElementType.Class:  				return null;    			default:  				return null;  			}
Magic Number,dnlib.DotNet,X86CpuArch,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\CpuArch.cs,GetStubAlignment,The following statement contains a magic number: switch (stubType) {  			case StubType.Export:  			case StubType.EntryPoint:  				return 4;  			default:  				throw new ArgumentOutOfRangeException();  			}
Magic Number,dnlib.DotNet,X86CpuArch,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\CpuArch.cs,GetStubSize,The following statement contains a magic number: switch (stubType) {  			case StubType.Export:  			case StubType.EntryPoint:  				return 2/*padding*/ + 6;  			default:  				throw new ArgumentOutOfRangeException();  			}
Magic Number,dnlib.DotNet,X86CpuArch,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\CpuArch.cs,GetStubSize,The following statement contains a magic number: switch (stubType) {  			case StubType.Export:  			case StubType.EntryPoint:  				return 2/*padding*/ + 6;  			default:  				throw new ArgumentOutOfRangeException();  			}
Magic Number,dnlib.DotNet,X86CpuArch,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\CpuArch.cs,GetStubCodeOffset,The following statement contains a magic number: switch (stubType) {  			case StubType.Export:  			case StubType.EntryPoint:  				return 2/*padding*/;  			default:  				throw new ArgumentOutOfRangeException();  			}
Magic Number,dnlib.DotNet,X86CpuArch,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\CpuArch.cs,WriteStubRelocs,The following statement contains a magic number: switch (stubType) {  			case StubType.Export:  			case StubType.EntryPoint:  				relocDirectory.Add(chunk' stubOffset + 4);  				break;  			default:  				throw new ArgumentOutOfRangeException();  			}
Magic Number,dnlib.DotNet,X64CpuArch,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\CpuArch.cs,GetStubAlignment,The following statement contains a magic number: switch (stubType) {  			case StubType.Export:  			case StubType.EntryPoint:  				return 4;  			default:  				throw new ArgumentOutOfRangeException();  			}
Magic Number,dnlib.DotNet,X64CpuArch,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\CpuArch.cs,GetStubSize,The following statement contains a magic number: switch (stubType) {  			case StubType.Export:  			case StubType.EntryPoint:  				return 2/*padding*/ + 12;  			default:  				throw new ArgumentOutOfRangeException();  			}
Magic Number,dnlib.DotNet,X64CpuArch,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\CpuArch.cs,GetStubSize,The following statement contains a magic number: switch (stubType) {  			case StubType.Export:  			case StubType.EntryPoint:  				return 2/*padding*/ + 12;  			default:  				throw new ArgumentOutOfRangeException();  			}
Magic Number,dnlib.DotNet,X64CpuArch,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\CpuArch.cs,GetStubCodeOffset,The following statement contains a magic number: switch (stubType) {  			case StubType.Export:  			case StubType.EntryPoint:  				return 2/*padding*/;  			default:  				throw new ArgumentOutOfRangeException();  			}
Magic Number,dnlib.DotNet,X64CpuArch,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\CpuArch.cs,WriteStubRelocs,The following statement contains a magic number: switch (stubType) {  			case StubType.Export:  			case StubType.EntryPoint:  				relocDirectory.Add(chunk' stubOffset + 4);  				break;  			default:  				throw new ArgumentOutOfRangeException();  			}
Magic Number,dnlib.DotNet,ItaniumCpuArch,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\CpuArch.cs,GetStubAlignment,The following statement contains a magic number: switch (stubType) {  			case StubType.Export:  			case StubType.EntryPoint:  				return 16;  			default:  				throw new ArgumentOutOfRangeException();  			}
Magic Number,dnlib.DotNet,ArmCpuArch,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\CpuArch.cs,GetStubAlignment,The following statement contains a magic number: switch (stubType) {  			case StubType.Export:  			case StubType.EntryPoint:  				return 4;  			default:  				throw new ArgumentOutOfRangeException();  			}
Magic Number,dnlib.DotNet,ArmCpuArch,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\CpuArch.cs,GetStubSize,The following statement contains a magic number: switch (stubType) {  			case StubType.Export:  			case StubType.EntryPoint:  				return 8;  			default:  				throw new ArgumentOutOfRangeException();  			}
Magic Number,dnlib.DotNet,ArmCpuArch,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\CpuArch.cs,WriteStubRelocs,The following statement contains a magic number: switch (stubType) {  			case StubType.Export:  			case StubType.EntryPoint:  				relocDirectory.Add(chunk' stubOffset + 4);  				break;  			default:  				throw new ArgumentOutOfRangeException();  			}
Magic Number,dnlib.DotNet,DeclSecurityReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\DeclSecurityReader.cs,ReadXmlFormat,The following statement contains a magic number: var xml = reader.ReadUtf16String((int)reader.Length / 2);
Magic Number,dnlib.DotNet,FieldDef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\FieldDef.cs,GetPointerSize,The following statement contains a magic number: return 4;
Magic Number,dnlib.DotNet,FieldDef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\FieldDef.cs,GetPointerSize,The following statement contains a magic number: return 4;
Magic Number,dnlib.DotNet,ImplMap,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ImplMap.cs,GetDllName,The following statement contains a magic number: return dllName.Substring(0' dllName.Length - 4);
Magic Number,dnlib.DotNet,MethodExportInfoProvider,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MethodExportInfoProvider.cs,Initialize,The following statement contains a magic number: uint slotSize = is64bit ? 8U : 4;
Magic Number,dnlib.DotNet,MethodExportInfoProvider,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MethodExportInfoProvider.cs,Initialize,The following statement contains a magic number: uint slotSize = is64bit ? 8U : 4;
Magic Number,dnlib.DotNet,MethodExportInfoProvider,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MethodExportInfoProvider.cs,Initialize,The following statement contains a magic number: slotSize == 8
Magic Number,dnlib.DotNet,MethodExportInfoProvider,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MethodExportInfoProvider.cs,Initialize,The following statement contains a magic number: (ulong)reader.Position + 8 <= endPos && reader.CanRead(8U)
Magic Number,dnlib.DotNet,MethodExportInfoProvider,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MethodExportInfoProvider.cs,Initialize,The following statement contains a magic number: (ulong)reader.Position + 8 <= endPos && reader.CanRead(8U)
Magic Number,dnlib.DotNet,MethodExportInfoProvider,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MethodExportInfoProvider.cs,GetOffsetToExportInfoDictionary,The following statement contains a magic number: reader.Position += 16;
Magic Number,dnlib.DotNet,MethodExportInfoProvider,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MethodExportInfoProvider.cs,GetOffsetToExportInfoDictionary,The following statement contains a magic number: var nextOffset = reader.Position + 4;
Magic Number,dnlib.DotNet,ModuleDef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDef.cs,CalculateRuntimeVersionWinMD,The following statement contains a magic number: s = s.Substring(3);
Magic Number,dnlib.DotNet,ModuleDef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDef.cs,GetPointerSize,The following statement contains a magic number: return 8;
Magic Number,dnlib.DotNet,ModuleDef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDef.cs,GetPointerSize,The following statement contains a magic number: return 4;
Magic Number,dnlib.DotNet,ModuleDef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDef.cs,GetPointerSize,The following statement contains a magic number: return 4;
Magic Number,dnlib.DotNet,ModuleDef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDef.cs,GetPointerSize,The following statement contains a magic number: return 4;
Magic Number,dnlib.DotNet,ModuleDef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDef.cs,GetPointerSize,The following statement contains a magic number: switch (flags & (ComImageFlags.Bit32Required | ComImageFlags.Bit32Preferred)) {  			case 0:  				// Machine and ILOnly flag should be checked  				break;    			case ComImageFlags.Bit32Preferred:  				// Illegal  				break;    			case ComImageFlags.Bit32Required:  				// x86 image (32-bit process)  				return 4;    			case ComImageFlags.Bit32Required | ComImageFlags.Bit32Preferred:  				// Platform neutral but prefers to be 32-bit  				return prefer32bitPointerSize;  			}
Magic Number,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,ModuleDefMD,The following statement contains a magic number: Cor20HeaderRuntimeVersion = (uint)(Metadata.ImageCor20Header.MajorRuntimeVersion << 16) | Metadata.ImageCor20Header.MinorRuntimeVersion;
Magic Number,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The following statement contains a magic number: i < 64
Magic Number,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,TryCreateResourceStream,The following statement contains a magic number: (ulong)offset + 4 > resources.Size
Magic Number,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,TryCreateResourceStream,The following statement contains a magic number: (ulong)resourcesBaseOffs + offset + 4 > fullReader.Length
Magic Number,dnlib.DotNet,Resolver,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Resolver.cs,ResolveExportedType,The following statement contains a magic number: i < 30
Magic Number,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> 19);
Magic Number,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> 19);
Magic Number,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> 19);
Magic Number,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> 19);
Magic Number,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> 19);
Magic Number,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> 19);
Magic Number,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> 19);
Magic Number,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> 19);
Magic Number,dnlib.DotNet,SignatureReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\SignatureReader.cs,ReadType,The following statement contains a magic number: switch ((ElementType)reader.ReadByte()) {  			case ElementType.Void:		result = corLibTypes.Void; break;  			case ElementType.Boolean:	result = corLibTypes.Boolean; break;  			case ElementType.Char:		result = corLibTypes.Char; break;  			case ElementType.I1:		result = corLibTypes.SByte; break;  			case ElementType.U1:		result = corLibTypes.Byte; break;  			case ElementType.I2:		result = corLibTypes.Int16; break;  			case ElementType.U2:		result = corLibTypes.UInt16; break;  			case ElementType.I4:		result = corLibTypes.Int32; break;  			case ElementType.U4:		result = corLibTypes.UInt32; break;  			case ElementType.I8:		result = corLibTypes.Int64; break;  			case ElementType.U8:		result = corLibTypes.UInt64; break;  			case ElementType.R4:		result = corLibTypes.Single; break;  			case ElementType.R8:		result = corLibTypes.Double; break;  			case ElementType.String:	result = corLibTypes.String; break;  			case ElementType.TypedByRef:result = corLibTypes.TypedReference; break;  			case ElementType.I:			result = corLibTypes.IntPtr; break;  			case ElementType.U:			result = corLibTypes.UIntPtr; break;  			case ElementType.Object:	result = corLibTypes.Object; break;    			case ElementType.Ptr:		result = new PtrSig(ReadType()); break;  			case ElementType.ByRef:		result = new ByRefSig(ReadType()); break;  			case ElementType.ValueType:	result = new ValueTypeSig(ReadTypeDefOrRef()); break;  			case ElementType.Class:		result = new ClassSig(ReadTypeDefOrRef()); break;  			case ElementType.FnPtr:		result = new FnPtrSig(ReadSig()); break;  			case ElementType.SZArray:	result = new SZArraySig(ReadType()); break;  			case ElementType.CModReqd:	result = new CModReqdSig(ReadTypeDefOrRef()' ReadType()); break;  			case ElementType.CModOpt:	result = new CModOptSig(ReadTypeDefOrRef()' ReadType()); break;  			case ElementType.Sentinel:	result = new SentinelSig(); break;  			case ElementType.Pinned:	result = new PinnedSig(ReadType()); break;    			case ElementType.Var:  				if (!reader.TryReadCompressedUInt32(out num))  					break;  				result = new GenericVar(num' gpContext.Type);  				break;    			case ElementType.MVar:  				if (!reader.TryReadCompressedUInt32(out num))  					break;  				result = new GenericMVar(num' gpContext.Method);  				break;    			case ElementType.ValueArray:  				nextType = ReadType();  				if (!reader.TryReadCompressedUInt32(out num))  					break;  				result = new ValueArraySig(nextType' num);  				break;    			case ElementType.Module:  				if (!reader.TryReadCompressedUInt32(out num))  					break;  				result = new ModuleSig(num' ReadType());  				break;    			case ElementType.GenericInst:  				nextType = ReadType();  				if (!reader.TryReadCompressedUInt32(out num))  					break;  				var genericInstSig = new GenericInstSig(nextType as ClassOrValueTypeSig' num);  				var args = genericInstSig.GenericArguments;  				for (i = 0; i < num; i++)  					args.Add(ReadType());  				result = genericInstSig;  				break;    			case ElementType.Array:  				nextType = ReadType();  				uint rank;  				if (!reader.TryReadCompressedUInt32(out rank))  					break;  				if (rank > MaxArrayRank)  					break;  				if (rank == 0) {  					result = new ArraySig(nextType' rank);  					break;  				}  				if (!reader.TryReadCompressedUInt32(out num))  					break;  				if (num > MaxArrayRank)  					break;  				var sizes = new List<uint>((int)num);  				for (i = 0; i < num; i++) {  					if (!reader.TryReadCompressedUInt32(out uint size))  						goto exit;  					sizes.Add(size);  				}  				if (!reader.TryReadCompressedUInt32(out num))  					break;  				if (num > MaxArrayRank)  					break;  				var lowerBounds = new List<int>((int)num);  				for (i = 0; i < num; i++) {  					if (!reader.TryReadCompressedInt32(out int size))  						goto exit;  					lowerBounds.Add(size);  				}  				result = new ArraySig(nextType' rank' sizes' lowerBounds);  				break;    			case ElementType.Internal:  				IntPtr address;  				if (IntPtr.Size == 4)  					address = new IntPtr(reader.ReadInt32());  				else  					address = new IntPtr(reader.ReadInt64());  				result = helper.ConvertRTInternalAddress(address);  				break;    			case ElementType.End:  			case ElementType.R:  			default:  				result = null;  				break;  			}
Magic Number,dnlib.DotNet,StrongNamePublicKey,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\StrongNameKey.cs,StrongNamePublicKey,The following statement contains a magic number: reader.ReadByte() != 6
Magic Number,dnlib.DotNet,StrongNamePublicKey,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\StrongNameKey.cs,StrongNamePublicKey,The following statement contains a magic number: reader.ReadByte() != 2
Magic Number,dnlib.DotNet,StrongNamePublicKey,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\StrongNameKey.cs,StrongNamePublicKey,The following statement contains a magic number: publicExponent = reader.ReadBytesReverse(4);
Magic Number,dnlib.DotNet,StrongNamePublicKey,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\StrongNameKey.cs,StrongNamePublicKey,The following statement contains a magic number: modulus = reader.ReadBytesReverse((int)(bitLength / 8));
Magic Number,dnlib.DotNet,StrongNamePublicKey,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\StrongNameKey.cs,CreatePublicKey,The following statement contains a magic number: writer.Write((byte)6);
Magic Number,dnlib.DotNet,StrongNamePublicKey,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\StrongNameKey.cs,CreatePublicKey,The following statement contains a magic number: writer.Write((byte)2);
Magic Number,dnlib.DotNet,StrongNamePublicKey,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\StrongNameKey.cs,CreatePublicKey,The following statement contains a magic number: writer.Write(modulus.Length * 8);
Magic Number,dnlib.DotNet,StrongNameKey,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\StrongNameKey.cs,StrongNameKey,The following statement contains a magic number: reader.ReadByte() != 7
Magic Number,dnlib.DotNet,StrongNameKey,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\StrongNameKey.cs,StrongNameKey,The following statement contains a magic number: reader.ReadByte() != 2
Magic Number,dnlib.DotNet,StrongNameKey,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\StrongNameKey.cs,StrongNameKey,The following statement contains a magic number: publicExponent = reader.ReadBytesReverse(4);
Magic Number,dnlib.DotNet,StrongNameKey,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\StrongNameKey.cs,StrongNameKey,The following statement contains a magic number: int len8 = (int)(bitLength / 8);
Magic Number,dnlib.DotNet,StrongNameKey,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\StrongNameKey.cs,StrongNameKey,The following statement contains a magic number: int len16 = (int)(bitLength / 16);
Magic Number,dnlib.DotNet,StrongNameKey,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\StrongNameKey.cs,CreateStrongName,The following statement contains a magic number: writer.Write((byte)7);
Magic Number,dnlib.DotNet,StrongNameKey,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\StrongNameKey.cs,CreateStrongName,The following statement contains a magic number: writer.Write((byte)2);
Magic Number,dnlib.DotNet,StrongNameKey,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\StrongNameKey.cs,CreateStrongName,The following statement contains a magic number: writer.Write(modulus.Length * 8);
Magic Number,dnlib.DotNet,StrongNameSigner,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: stream.Position += 6;
Magic Number,dnlib.DotNet,StrongNameSigner,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: stream.Position -= 8;
Magic Number,dnlib.DotNet,StrongNameSigner,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: stream.Position -= 2;
Magic Number,dnlib.DotNet,StrongNameSigner,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: i < 4
Magic Number,dnlib.DotNet,StrongNameSigner,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: const int imageDirsSize = 16 * 8;
Magic Number,dnlib.DotNet,StrongNameSigner,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: const int imageDirsSize = 16 * 8;
Magic Number,dnlib.DotNet,StrongNameSigner,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: buffer[4 * 8 + i] = 0;
Magic Number,dnlib.DotNet,StrongNameSigner,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: buffer[4 * 8 + i] = 0;
Magic Number,dnlib.DotNet,StrongNameSigner,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: i < 8
Magic Number,dnlib.DotNet,TIAHelper,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TIAHelper.cs,GetInfo,The following statement contains a magic number: tia.ConstructorArguments.Count >= 2
Magic Number,dnlib.DotNet,TIAHelper,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TIAHelper.cs,CheckEquivalent,The following statement contains a magic number: !(td is null) && i < 1000
Magic Number,dnlib.DotNet,TIAHelper,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TIAHelper.cs,Equivalent,The following statement contains a magic number: i < 1000
Magic Number,dnlib.DotNet,TypeDef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TypeDef.cs,FindOrCreateStaticConstructor,The following statement contains a magic number: body.MaxStack = 8;
Magic Number,dnlib.DotNet,TypeDef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TypeDef.cs,FindMethodImplMethod,The following statement contains a magic number: i < 10
Magic Number,dnlib.DotNet,TypeNameParser,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TypeNameParser.cs,ReadUInt32,The following statement contains a magic number: uint newVal = val * 10 + (uint)(c - '0');
Magic Number,dnlib.DotNet,TypeRef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TypeRef.cs,GetNonNestedTypeRef,The following statement contains a magic number: i < 1000
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Utils.cs,ToHex,The following statement contains a magic number: var chars = new char[bytes.Length * 2];
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Utils.cs,ToHex,The following statement contains a magic number: chars[j++] = ToHexChar(b >> 4' upper);
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Utils.cs,ToHexChar,The following statement contains a magic number: 0 <= val && val <= 9
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Utils.cs,ToHexChar,The following statement contains a magic number: return (char)(val - 10 + (upper ? (int)'A' : (int)'a'));
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Utils.cs,ParseBytes,The following statement contains a magic number: hexString.Length % 2 != 0
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Utils.cs,ParseBytes,The following statement contains a magic number: var bytes = new byte[hexString.Length / 2];
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Utils.cs,ParseBytes,The following statement contains a magic number: bytes[i / 2] = (byte)((upper << 4) | lower);
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Utils.cs,ParseBytes,The following statement contains a magic number: bytes[i / 2] = (byte)((upper << 4) | lower);
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Utils.cs,TryParseHexChar,The following statement contains a magic number: return 10 + (ushort)c - (ushort)'a';
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Utils.cs,TryParseHexChar,The following statement contains a magic number: return 10 + (ushort)c - (ushort)'A';
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Utils.cs,GetHashCode,The following statement contains a magic number: int count = Math.Min(a.Length / 2' 20);
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Utils.cs,GetHashCode,The following statement contains a magic number: int count = Math.Min(a.Length / 2' 20);
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Utils.cs,GetHashCode,The following statement contains a magic number: hash ^= a[i] | ((uint)a[j] << 8);
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Utils.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> 19);
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Utils.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> 19);
Magic Number,dnlib.DotNet,VTableFixups,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\VTableFixups.cs,Initialize,The following statement contains a magic number: vtables = new List<VTable>((int)info.Size / 8);
Magic Number,dnlib.DotNet,VTableFixups,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\VTableFixups.cs,Initialize,The following statement contains a magic number: uint slotSize = vtable.Is64Bit ? 8U : 4;
Magic Number,dnlib.DotNet,VTableFixups,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\VTableFixups.cs,Initialize,The following statement contains a magic number: uint slotSize = vtable.Is64Bit ? 8U : 4;
Magic Number,dnlib.DotNet,VTableFixups,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\VTableFixups.cs,Initialize,The following statement contains a magic number: slotSize == 8
Magic Number,dnlib.DotNet,VTableFixups,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\VTableFixups.cs,Initialize,The following statement contains a magic number: (ulong)reader.Position + 8 <= endPos && reader.CanRead(8U)
Magic Number,dnlib.DotNet,VTableFixups,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\VTableFixups.cs,Initialize,The following statement contains a magic number: (ulong)reader.Position + 8 <= endPos && reader.CanRead(8U)
Magic Number,dnlib.DotNet.Emit,Extensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Code.cs,ToOpCode,The following statement contains a magic number: int hi = (ushort)code >> 8;
Magic Number,dnlib.DotNet.Emit,DynamicMethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\DynamicMethodBodyReader.cs,CreateExceptionHandlers,The following statement contains a magic number: ehHeader.Length < 4
Magic Number,dnlib.DotNet.Emit,DynamicMethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\DynamicMethodBodyReader.cs,CreateExceptionHandlers,The following statement contains a magic number: int numHandlers = (ushort)((reader.ReadByte() - 2) / 12);
Magic Number,dnlib.DotNet.Emit,DynamicMethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\DynamicMethodBodyReader.cs,CreateExceptionHandlers,The following statement contains a magic number: int numHandlers = (ushort)((reader.ReadByte() - 2) / 12);
Magic Number,dnlib.DotNet.Emit,DynamicMethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\DynamicMethodBodyReader.cs,CreateExceptionHandlers,The following statement contains a magic number: reader.BaseStream.Position + 12 > reader.BaseStream.Length
Magic Number,dnlib.DotNet.Emit,DynamicMethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\DynamicMethodBodyReader.cs,ReadToken,The following statement contains a magic number: switch (token >> 24) {  			case 0x02:  				return ImportType(rid);    			case 0x04:  				return ImportField(rid);    			case 0x06:  			case 0x0A:  				return ImportMethod(rid);    			case 0x11:  				return ImportSignature(rid);    			case 0x70:  				return Resolve(rid) as string;    			default:  				return null;  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,CreateLdcI4,The following statement contains a magic number: switch (value) {  			case -1:return OpCodes.Ldc_I4_M1.ToInstruction();  			case 0: return OpCodes.Ldc_I4_0.ToInstruction();  			case 1: return OpCodes.Ldc_I4_1.ToInstruction();  			case 2: return OpCodes.Ldc_I4_2.ToInstruction();  			case 3: return OpCodes.Ldc_I4_3.ToInstruction();  			case 4: return OpCodes.Ldc_I4_4.ToInstruction();  			case 5: return OpCodes.Ldc_I4_5.ToInstruction();  			case 6: return OpCodes.Ldc_I4_6.ToInstruction();  			case 7: return OpCodes.Ldc_I4_7.ToInstruction();  			case 8: return OpCodes.Ldc_I4_8.ToInstruction();  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,CreateLdcI4,The following statement contains a magic number: switch (value) {  			case -1:return OpCodes.Ldc_I4_M1.ToInstruction();  			case 0: return OpCodes.Ldc_I4_0.ToInstruction();  			case 1: return OpCodes.Ldc_I4_1.ToInstruction();  			case 2: return OpCodes.Ldc_I4_2.ToInstruction();  			case 3: return OpCodes.Ldc_I4_3.ToInstruction();  			case 4: return OpCodes.Ldc_I4_4.ToInstruction();  			case 5: return OpCodes.Ldc_I4_5.ToInstruction();  			case 6: return OpCodes.Ldc_I4_6.ToInstruction();  			case 7: return OpCodes.Ldc_I4_7.ToInstruction();  			case 8: return OpCodes.Ldc_I4_8.ToInstruction();  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,CreateLdcI4,The following statement contains a magic number: switch (value) {  			case -1:return OpCodes.Ldc_I4_M1.ToInstruction();  			case 0: return OpCodes.Ldc_I4_0.ToInstruction();  			case 1: return OpCodes.Ldc_I4_1.ToInstruction();  			case 2: return OpCodes.Ldc_I4_2.ToInstruction();  			case 3: return OpCodes.Ldc_I4_3.ToInstruction();  			case 4: return OpCodes.Ldc_I4_4.ToInstruction();  			case 5: return OpCodes.Ldc_I4_5.ToInstruction();  			case 6: return OpCodes.Ldc_I4_6.ToInstruction();  			case 7: return OpCodes.Ldc_I4_7.ToInstruction();  			case 8: return OpCodes.Ldc_I4_8.ToInstruction();  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,CreateLdcI4,The following statement contains a magic number: switch (value) {  			case -1:return OpCodes.Ldc_I4_M1.ToInstruction();  			case 0: return OpCodes.Ldc_I4_0.ToInstruction();  			case 1: return OpCodes.Ldc_I4_1.ToInstruction();  			case 2: return OpCodes.Ldc_I4_2.ToInstruction();  			case 3: return OpCodes.Ldc_I4_3.ToInstruction();  			case 4: return OpCodes.Ldc_I4_4.ToInstruction();  			case 5: return OpCodes.Ldc_I4_5.ToInstruction();  			case 6: return OpCodes.Ldc_I4_6.ToInstruction();  			case 7: return OpCodes.Ldc_I4_7.ToInstruction();  			case 8: return OpCodes.Ldc_I4_8.ToInstruction();  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,CreateLdcI4,The following statement contains a magic number: switch (value) {  			case -1:return OpCodes.Ldc_I4_M1.ToInstruction();  			case 0: return OpCodes.Ldc_I4_0.ToInstruction();  			case 1: return OpCodes.Ldc_I4_1.ToInstruction();  			case 2: return OpCodes.Ldc_I4_2.ToInstruction();  			case 3: return OpCodes.Ldc_I4_3.ToInstruction();  			case 4: return OpCodes.Ldc_I4_4.ToInstruction();  			case 5: return OpCodes.Ldc_I4_5.ToInstruction();  			case 6: return OpCodes.Ldc_I4_6.ToInstruction();  			case 7: return OpCodes.Ldc_I4_7.ToInstruction();  			case 8: return OpCodes.Ldc_I4_8.ToInstruction();  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,CreateLdcI4,The following statement contains a magic number: switch (value) {  			case -1:return OpCodes.Ldc_I4_M1.ToInstruction();  			case 0: return OpCodes.Ldc_I4_0.ToInstruction();  			case 1: return OpCodes.Ldc_I4_1.ToInstruction();  			case 2: return OpCodes.Ldc_I4_2.ToInstruction();  			case 3: return OpCodes.Ldc_I4_3.ToInstruction();  			case 4: return OpCodes.Ldc_I4_4.ToInstruction();  			case 5: return OpCodes.Ldc_I4_5.ToInstruction();  			case 6: return OpCodes.Ldc_I4_6.ToInstruction();  			case 7: return OpCodes.Ldc_I4_7.ToInstruction();  			case 8: return OpCodes.Ldc_I4_8.ToInstruction();  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,CreateLdcI4,The following statement contains a magic number: switch (value) {  			case -1:return OpCodes.Ldc_I4_M1.ToInstruction();  			case 0: return OpCodes.Ldc_I4_0.ToInstruction();  			case 1: return OpCodes.Ldc_I4_1.ToInstruction();  			case 2: return OpCodes.Ldc_I4_2.ToInstruction();  			case 3: return OpCodes.Ldc_I4_3.ToInstruction();  			case 4: return OpCodes.Ldc_I4_4.ToInstruction();  			case 5: return OpCodes.Ldc_I4_5.ToInstruction();  			case 6: return OpCodes.Ldc_I4_6.ToInstruction();  			case 7: return OpCodes.Ldc_I4_7.ToInstruction();  			case 8: return OpCodes.Ldc_I4_8.ToInstruction();  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,GetSize,The following statement contains a magic number: switch (opCode.OperandType) {  			case OperandType.InlineBrTarget:  			case OperandType.InlineField:  			case OperandType.InlineI:  			case OperandType.InlineMethod:  			case OperandType.InlineSig:  			case OperandType.InlineString:  			case OperandType.InlineTok:  			case OperandType.InlineType:  			case OperandType.ShortInlineR:  				return opCode.Size + 4;    			case OperandType.InlineI8:  			case OperandType.InlineR:  				return opCode.Size + 8;    			case OperandType.InlineNone:  			case OperandType.InlinePhi:  			default:  				return opCode.Size;    			case OperandType.InlineSwitch:  				var targets = Operand as IList<Instruction>;  				return opCode.Size + 4 + (targets is null ? 0 : targets.Count * 4);    			case OperandType.InlineVar:  				return opCode.Size + 2;    			case OperandType.ShortInlineBrTarget:  			case OperandType.ShortInlineI:  			case OperandType.ShortInlineVar:  				return opCode.Size + 1;  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,GetSize,The following statement contains a magic number: switch (opCode.OperandType) {  			case OperandType.InlineBrTarget:  			case OperandType.InlineField:  			case OperandType.InlineI:  			case OperandType.InlineMethod:  			case OperandType.InlineSig:  			case OperandType.InlineString:  			case OperandType.InlineTok:  			case OperandType.InlineType:  			case OperandType.ShortInlineR:  				return opCode.Size + 4;    			case OperandType.InlineI8:  			case OperandType.InlineR:  				return opCode.Size + 8;    			case OperandType.InlineNone:  			case OperandType.InlinePhi:  			default:  				return opCode.Size;    			case OperandType.InlineSwitch:  				var targets = Operand as IList<Instruction>;  				return opCode.Size + 4 + (targets is null ? 0 : targets.Count * 4);    			case OperandType.InlineVar:  				return opCode.Size + 2;    			case OperandType.ShortInlineBrTarget:  			case OperandType.ShortInlineI:  			case OperandType.ShortInlineVar:  				return opCode.Size + 1;  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,GetSize,The following statement contains a magic number: switch (opCode.OperandType) {  			case OperandType.InlineBrTarget:  			case OperandType.InlineField:  			case OperandType.InlineI:  			case OperandType.InlineMethod:  			case OperandType.InlineSig:  			case OperandType.InlineString:  			case OperandType.InlineTok:  			case OperandType.InlineType:  			case OperandType.ShortInlineR:  				return opCode.Size + 4;    			case OperandType.InlineI8:  			case OperandType.InlineR:  				return opCode.Size + 8;    			case OperandType.InlineNone:  			case OperandType.InlinePhi:  			default:  				return opCode.Size;    			case OperandType.InlineSwitch:  				var targets = Operand as IList<Instruction>;  				return opCode.Size + 4 + (targets is null ? 0 : targets.Count * 4);    			case OperandType.InlineVar:  				return opCode.Size + 2;    			case OperandType.ShortInlineBrTarget:  			case OperandType.ShortInlineI:  			case OperandType.ShortInlineVar:  				return opCode.Size + 1;  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,GetSize,The following statement contains a magic number: switch (opCode.OperandType) {  			case OperandType.InlineBrTarget:  			case OperandType.InlineField:  			case OperandType.InlineI:  			case OperandType.InlineMethod:  			case OperandType.InlineSig:  			case OperandType.InlineString:  			case OperandType.InlineTok:  			case OperandType.InlineType:  			case OperandType.ShortInlineR:  				return opCode.Size + 4;    			case OperandType.InlineI8:  			case OperandType.InlineR:  				return opCode.Size + 8;    			case OperandType.InlineNone:  			case OperandType.InlinePhi:  			default:  				return opCode.Size;    			case OperandType.InlineSwitch:  				var targets = Operand as IList<Instruction>;  				return opCode.Size + 4 + (targets is null ? 0 : targets.Count * 4);    			case OperandType.InlineVar:  				return opCode.Size + 2;    			case OperandType.ShortInlineBrTarget:  			case OperandType.ShortInlineI:  			case OperandType.ShortInlineVar:  				return opCode.Size + 1;  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,GetSize,The following statement contains a magic number: switch (opCode.OperandType) {  			case OperandType.InlineBrTarget:  			case OperandType.InlineField:  			case OperandType.InlineI:  			case OperandType.InlineMethod:  			case OperandType.InlineSig:  			case OperandType.InlineString:  			case OperandType.InlineTok:  			case OperandType.InlineType:  			case OperandType.ShortInlineR:  				return opCode.Size + 4;    			case OperandType.InlineI8:  			case OperandType.InlineR:  				return opCode.Size + 8;    			case OperandType.InlineNone:  			case OperandType.InlinePhi:  			default:  				return opCode.Size;    			case OperandType.InlineSwitch:  				var targets = Operand as IList<Instruction>;  				return opCode.Size + 4 + (targets is null ? 0 : targets.Count * 4);    			case OperandType.InlineVar:  				return opCode.Size + 2;    			case OperandType.ShortInlineBrTarget:  			case OperandType.ShortInlineI:  			case OperandType.ShortInlineVar:  				return opCode.Size + 1;  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,CalculateStackUsageNonCall,The following statement contains a magic number: switch (opCode.StackBehaviourPush) {  			case StackBehaviour.Push0:  				pushes = 0;  				break;    			case StackBehaviour.Push1:  			case StackBehaviour.Pushi:  			case StackBehaviour.Pushi8:  			case StackBehaviour.Pushr4:  			case StackBehaviour.Pushr8:  			case StackBehaviour.Pushref:  				pushes = 1;  				break;    			case StackBehaviour.Push1_push1:  				pushes = 2;  				break;    			case StackBehaviour.Varpush:	// only call' calli' callvirt which are handled elsewhere  			default:  				pushes = 0;  				break;  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,CalculateStackUsageNonCall,The following statement contains a magic number: switch (opCode.StackBehaviourPop) {  			case StackBehaviour.Pop0:  				pops = 0;  				break;    			case StackBehaviour.Pop1:  			case StackBehaviour.Popi:  			case StackBehaviour.Popref:  				pops = 1;  				break;    			case StackBehaviour.Pop1_pop1:  			case StackBehaviour.Popi_pop1:  			case StackBehaviour.Popi_popi:  			case StackBehaviour.Popi_popi8:  			case StackBehaviour.Popi_popr4:  			case StackBehaviour.Popi_popr8:  			case StackBehaviour.Popref_pop1:  			case StackBehaviour.Popref_popi:  				pops = 2;  				break;    			case StackBehaviour.Popi_popi_popi:  			case StackBehaviour.Popref_popi_popi:  			case StackBehaviour.Popref_popi_popi8:  			case StackBehaviour.Popref_popi_popr4:  			case StackBehaviour.Popref_popi_popr8:  			case StackBehaviour.Popref_popi_popref:  			case StackBehaviour.Popref_popi_pop1:  				pops = 3;  				break;    			case StackBehaviour.PopAll:  				pops = -1;  				break;    			case StackBehaviour.Varpop:	// call' calli' callvirt' newobj (all handled elsewhere)' and ret  				if (hasReturnValue)  					pops = 1;  				else  					pops = 0;  				break;    			default:  				pops = 0;  				break;  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,CalculateStackUsageNonCall,The following statement contains a magic number: switch (opCode.StackBehaviourPop) {  			case StackBehaviour.Pop0:  				pops = 0;  				break;    			case StackBehaviour.Pop1:  			case StackBehaviour.Popi:  			case StackBehaviour.Popref:  				pops = 1;  				break;    			case StackBehaviour.Pop1_pop1:  			case StackBehaviour.Popi_pop1:  			case StackBehaviour.Popi_popi:  			case StackBehaviour.Popi_popi8:  			case StackBehaviour.Popi_popr4:  			case StackBehaviour.Popi_popr8:  			case StackBehaviour.Popref_pop1:  			case StackBehaviour.Popref_popi:  				pops = 2;  				break;    			case StackBehaviour.Popi_popi_popi:  			case StackBehaviour.Popref_popi_popi:  			case StackBehaviour.Popref_popi_popi8:  			case StackBehaviour.Popref_popi_popr4:  			case StackBehaviour.Popref_popi_popr8:  			case StackBehaviour.Popref_popi_popref:  			case StackBehaviour.Popref_popi_pop1:  				pops = 3;  				break;    			case StackBehaviour.PopAll:  				pops = -1;  				break;    			case StackBehaviour.Varpop:	// call' calli' callvirt' newobj (all handled elsewhere)' and ret  				if (hasReturnValue)  					pops = 1;  				else  					pops = 0;  				break;    			default:  				pops = 0;  				break;  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,The following statement contains a magic number: switch (OpCode.Code) {  			case Code.Ldc_I4_M1:return -1;  			case Code.Ldc_I4_0:	return 0;  			case Code.Ldc_I4_1:	return 1;  			case Code.Ldc_I4_2:	return 2;  			case Code.Ldc_I4_3:	return 3;  			case Code.Ldc_I4_4:	return 4;  			case Code.Ldc_I4_5:	return 5;  			case Code.Ldc_I4_6:	return 6;  			case Code.Ldc_I4_7:	return 7;  			case Code.Ldc_I4_8:	return 8;  			case Code.Ldc_I4_S:	return (sbyte)Operand;  			case Code.Ldc_I4:	return (int)Operand;  			default:  				throw new InvalidOperationException($"Not a ldc.i4 instruction: {this}");  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,The following statement contains a magic number: switch (OpCode.Code) {  			case Code.Ldc_I4_M1:return -1;  			case Code.Ldc_I4_0:	return 0;  			case Code.Ldc_I4_1:	return 1;  			case Code.Ldc_I4_2:	return 2;  			case Code.Ldc_I4_3:	return 3;  			case Code.Ldc_I4_4:	return 4;  			case Code.Ldc_I4_5:	return 5;  			case Code.Ldc_I4_6:	return 6;  			case Code.Ldc_I4_7:	return 7;  			case Code.Ldc_I4_8:	return 8;  			case Code.Ldc_I4_S:	return (sbyte)Operand;  			case Code.Ldc_I4:	return (int)Operand;  			default:  				throw new InvalidOperationException($"Not a ldc.i4 instruction: {this}");  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,The following statement contains a magic number: switch (OpCode.Code) {  			case Code.Ldc_I4_M1:return -1;  			case Code.Ldc_I4_0:	return 0;  			case Code.Ldc_I4_1:	return 1;  			case Code.Ldc_I4_2:	return 2;  			case Code.Ldc_I4_3:	return 3;  			case Code.Ldc_I4_4:	return 4;  			case Code.Ldc_I4_5:	return 5;  			case Code.Ldc_I4_6:	return 6;  			case Code.Ldc_I4_7:	return 7;  			case Code.Ldc_I4_8:	return 8;  			case Code.Ldc_I4_S:	return (sbyte)Operand;  			case Code.Ldc_I4:	return (int)Operand;  			default:  				throw new InvalidOperationException($"Not a ldc.i4 instruction: {this}");  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,The following statement contains a magic number: switch (OpCode.Code) {  			case Code.Ldc_I4_M1:return -1;  			case Code.Ldc_I4_0:	return 0;  			case Code.Ldc_I4_1:	return 1;  			case Code.Ldc_I4_2:	return 2;  			case Code.Ldc_I4_3:	return 3;  			case Code.Ldc_I4_4:	return 4;  			case Code.Ldc_I4_5:	return 5;  			case Code.Ldc_I4_6:	return 6;  			case Code.Ldc_I4_7:	return 7;  			case Code.Ldc_I4_8:	return 8;  			case Code.Ldc_I4_S:	return (sbyte)Operand;  			case Code.Ldc_I4:	return (int)Operand;  			default:  				throw new InvalidOperationException($"Not a ldc.i4 instruction: {this}");  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,The following statement contains a magic number: switch (OpCode.Code) {  			case Code.Ldc_I4_M1:return -1;  			case Code.Ldc_I4_0:	return 0;  			case Code.Ldc_I4_1:	return 1;  			case Code.Ldc_I4_2:	return 2;  			case Code.Ldc_I4_3:	return 3;  			case Code.Ldc_I4_4:	return 4;  			case Code.Ldc_I4_5:	return 5;  			case Code.Ldc_I4_6:	return 6;  			case Code.Ldc_I4_7:	return 7;  			case Code.Ldc_I4_8:	return 8;  			case Code.Ldc_I4_S:	return (sbyte)Operand;  			case Code.Ldc_I4:	return (int)Operand;  			default:  				throw new InvalidOperationException($"Not a ldc.i4 instruction: {this}");  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,The following statement contains a magic number: switch (OpCode.Code) {  			case Code.Ldc_I4_M1:return -1;  			case Code.Ldc_I4_0:	return 0;  			case Code.Ldc_I4_1:	return 1;  			case Code.Ldc_I4_2:	return 2;  			case Code.Ldc_I4_3:	return 3;  			case Code.Ldc_I4_4:	return 4;  			case Code.Ldc_I4_5:	return 5;  			case Code.Ldc_I4_6:	return 6;  			case Code.Ldc_I4_7:	return 7;  			case Code.Ldc_I4_8:	return 8;  			case Code.Ldc_I4_S:	return (sbyte)Operand;  			case Code.Ldc_I4:	return (int)Operand;  			default:  				throw new InvalidOperationException($"Not a ldc.i4 instruction: {this}");  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,The following statement contains a magic number: switch (OpCode.Code) {  			case Code.Ldc_I4_M1:return -1;  			case Code.Ldc_I4_0:	return 0;  			case Code.Ldc_I4_1:	return 1;  			case Code.Ldc_I4_2:	return 2;  			case Code.Ldc_I4_3:	return 3;  			case Code.Ldc_I4_4:	return 4;  			case Code.Ldc_I4_5:	return 5;  			case Code.Ldc_I4_6:	return 6;  			case Code.Ldc_I4_7:	return 7;  			case Code.Ldc_I4_8:	return 8;  			case Code.Ldc_I4_S:	return (sbyte)Operand;  			case Code.Ldc_I4:	return (int)Operand;  			default:  				throw new InvalidOperationException($"Not a ldc.i4 instruction: {this}");  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,GetParameterIndex,The following statement contains a magic number: switch (OpCode.Code) {  			case Code.Ldarg_0: return 0;  			case Code.Ldarg_1: return 1;  			case Code.Ldarg_2: return 2;  			case Code.Ldarg_3: return 3;    			case Code.Starg:  			case Code.Starg_S:  			case Code.Ldarga:  			case Code.Ldarga_S:  			case Code.Ldarg:  			case Code.Ldarg_S:  				var parameter = Operand as Parameter;  				if (!(parameter is null))  					return parameter.Index;  				break;  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,GetParameterIndex,The following statement contains a magic number: switch (OpCode.Code) {  			case Code.Ldarg_0: return 0;  			case Code.Ldarg_1: return 1;  			case Code.Ldarg_2: return 2;  			case Code.Ldarg_3: return 3;    			case Code.Starg:  			case Code.Starg_S:  			case Code.Ldarga:  			case Code.Ldarga_S:  			case Code.Ldarg:  			case Code.Ldarg_S:  				var parameter = Operand as Parameter;  				if (!(parameter is null))  					return parameter.Index;  				break;  			}
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  			case 2:  			case 6:  				// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  				flags = 2;  				maxStack = 8;  				codeSize = (uint)(b >> 2);  				localVarSigTok = 0;  				headerSize = 1;  				break;    			case 3:  				// Fat header. Can have locals and exception handlers  				flags = (ushort)((reader.ReadByte() << 8) | b);  				headerSize = (byte)(flags >> 12);  				maxStack = reader.ReadUInt16();  				codeSize = reader.ReadUInt32();  				localVarSigTok = reader.ReadUInt32();    				// The CLR allows the code to start inside the method header. But if it does'  				// the CLR doesn't read any exceptions.  				reader.Position = reader.Position - 12 + headerSize * 4U;  				if (headerSize < 3)  					flags &= 0xFFF7;  				headerSize *= 4;  				break;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  			case 2:  			case 6:  				// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  				flags = 2;  				maxStack = 8;  				codeSize = (uint)(b >> 2);  				localVarSigTok = 0;  				headerSize = 1;  				break;    			case 3:  				// Fat header. Can have locals and exception handlers  				flags = (ushort)((reader.ReadByte() << 8) | b);  				headerSize = (byte)(flags >> 12);  				maxStack = reader.ReadUInt16();  				codeSize = reader.ReadUInt32();  				localVarSigTok = reader.ReadUInt32();    				// The CLR allows the code to start inside the method header. But if it does'  				// the CLR doesn't read any exceptions.  				reader.Position = reader.Position - 12 + headerSize * 4U;  				if (headerSize < 3)  					flags &= 0xFFF7;  				headerSize *= 4;  				break;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  			case 2:  			case 6:  				// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  				flags = 2;  				maxStack = 8;  				codeSize = (uint)(b >> 2);  				localVarSigTok = 0;  				headerSize = 1;  				break;    			case 3:  				// Fat header. Can have locals and exception handlers  				flags = (ushort)((reader.ReadByte() << 8) | b);  				headerSize = (byte)(flags >> 12);  				maxStack = reader.ReadUInt16();  				codeSize = reader.ReadUInt32();  				localVarSigTok = reader.ReadUInt32();    				// The CLR allows the code to start inside the method header. But if it does'  				// the CLR doesn't read any exceptions.  				reader.Position = reader.Position - 12 + headerSize * 4U;  				if (headerSize < 3)  					flags &= 0xFFF7;  				headerSize *= 4;  				break;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  			case 2:  			case 6:  				// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  				flags = 2;  				maxStack = 8;  				codeSize = (uint)(b >> 2);  				localVarSigTok = 0;  				headerSize = 1;  				break;    			case 3:  				// Fat header. Can have locals and exception handlers  				flags = (ushort)((reader.ReadByte() << 8) | b);  				headerSize = (byte)(flags >> 12);  				maxStack = reader.ReadUInt16();  				codeSize = reader.ReadUInt32();  				localVarSigTok = reader.ReadUInt32();    				// The CLR allows the code to start inside the method header. But if it does'  				// the CLR doesn't read any exceptions.  				reader.Position = reader.Position - 12 + headerSize * 4U;  				if (headerSize < 3)  					flags &= 0xFFF7;  				headerSize *= 4;  				break;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  			case 2:  			case 6:  				// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  				flags = 2;  				maxStack = 8;  				codeSize = (uint)(b >> 2);  				localVarSigTok = 0;  				headerSize = 1;  				break;    			case 3:  				// Fat header. Can have locals and exception handlers  				flags = (ushort)((reader.ReadByte() << 8) | b);  				headerSize = (byte)(flags >> 12);  				maxStack = reader.ReadUInt16();  				codeSize = reader.ReadUInt32();  				localVarSigTok = reader.ReadUInt32();    				// The CLR allows the code to start inside the method header. But if it does'  				// the CLR doesn't read any exceptions.  				reader.Position = reader.Position - 12 + headerSize * 4U;  				if (headerSize < 3)  					flags &= 0xFFF7;  				headerSize *= 4;  				break;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  			case 2:  			case 6:  				// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  				flags = 2;  				maxStack = 8;  				codeSize = (uint)(b >> 2);  				localVarSigTok = 0;  				headerSize = 1;  				break;    			case 3:  				// Fat header. Can have locals and exception handlers  				flags = (ushort)((reader.ReadByte() << 8) | b);  				headerSize = (byte)(flags >> 12);  				maxStack = reader.ReadUInt16();  				codeSize = reader.ReadUInt32();  				localVarSigTok = reader.ReadUInt32();    				// The CLR allows the code to start inside the method header. But if it does'  				// the CLR doesn't read any exceptions.  				reader.Position = reader.Position - 12 + headerSize * 4U;  				if (headerSize < 3)  					flags &= 0xFFF7;  				headerSize *= 4;  				break;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  			case 2:  			case 6:  				// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  				flags = 2;  				maxStack = 8;  				codeSize = (uint)(b >> 2);  				localVarSigTok = 0;  				headerSize = 1;  				break;    			case 3:  				// Fat header. Can have locals and exception handlers  				flags = (ushort)((reader.ReadByte() << 8) | b);  				headerSize = (byte)(flags >> 12);  				maxStack = reader.ReadUInt16();  				codeSize = reader.ReadUInt32();  				localVarSigTok = reader.ReadUInt32();    				// The CLR allows the code to start inside the method header. But if it does'  				// the CLR doesn't read any exceptions.  				reader.Position = reader.Position - 12 + headerSize * 4U;  				if (headerSize < 3)  					flags &= 0xFFF7;  				headerSize *= 4;  				break;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  			case 2:  			case 6:  				// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  				flags = 2;  				maxStack = 8;  				codeSize = (uint)(b >> 2);  				localVarSigTok = 0;  				headerSize = 1;  				break;    			case 3:  				// Fat header. Can have locals and exception handlers  				flags = (ushort)((reader.ReadByte() << 8) | b);  				headerSize = (byte)(flags >> 12);  				maxStack = reader.ReadUInt16();  				codeSize = reader.ReadUInt32();  				localVarSigTok = reader.ReadUInt32();    				// The CLR allows the code to start inside the method header. But if it does'  				// the CLR doesn't read any exceptions.  				reader.Position = reader.Position - 12 + headerSize * 4U;  				if (headerSize < 3)  					flags &= 0xFFF7;  				headerSize *= 4;  				break;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  			case 2:  			case 6:  				// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  				flags = 2;  				maxStack = 8;  				codeSize = (uint)(b >> 2);  				localVarSigTok = 0;  				headerSize = 1;  				break;    			case 3:  				// Fat header. Can have locals and exception handlers  				flags = (ushort)((reader.ReadByte() << 8) | b);  				headerSize = (byte)(flags >> 12);  				maxStack = reader.ReadUInt16();  				codeSize = reader.ReadUInt32();  				localVarSigTok = reader.ReadUInt32();    				// The CLR allows the code to start inside the method header. But if it does'  				// the CLR doesn't read any exceptions.  				reader.Position = reader.Position - 12 + headerSize * 4U;  				if (headerSize < 3)  					flags &= 0xFFF7;  				headerSize *= 4;  				break;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  			case 2:  			case 6:  				// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  				flags = 2;  				maxStack = 8;  				codeSize = (uint)(b >> 2);  				localVarSigTok = 0;  				headerSize = 1;  				break;    			case 3:  				// Fat header. Can have locals and exception handlers  				flags = (ushort)((reader.ReadByte() << 8) | b);  				headerSize = (byte)(flags >> 12);  				maxStack = reader.ReadUInt16();  				codeSize = reader.ReadUInt32();  				localVarSigTok = reader.ReadUInt32();    				// The CLR allows the code to start inside the method header. But if it does'  				// the CLR doesn't read any exceptions.  				reader.Position = reader.Position - 12 + headerSize * 4U;  				if (headerSize < 3)  					flags &= 0xFFF7;  				headerSize *= 4;  				break;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  			case 2:  			case 6:  				// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  				flags = 2;  				maxStack = 8;  				codeSize = (uint)(b >> 2);  				localVarSigTok = 0;  				headerSize = 1;  				break;    			case 3:  				// Fat header. Can have locals and exception handlers  				flags = (ushort)((reader.ReadByte() << 8) | b);  				headerSize = (byte)(flags >> 12);  				maxStack = reader.ReadUInt16();  				codeSize = reader.ReadUInt32();  				localVarSigTok = reader.ReadUInt32();    				// The CLR allows the code to start inside the method header. But if it does'  				// the CLR doesn't read any exceptions.  				reader.Position = reader.Position - 12 + headerSize * 4U;  				if (headerSize < 3)  					flags &= 0xFFF7;  				headerSize *= 4;  				break;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  			case 2:  			case 6:  				// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  				flags = 2;  				maxStack = 8;  				codeSize = (uint)(b >> 2);  				localVarSigTok = 0;  				headerSize = 1;  				break;    			case 3:  				// Fat header. Can have locals and exception handlers  				flags = (ushort)((reader.ReadByte() << 8) | b);  				headerSize = (byte)(flags >> 12);  				maxStack = reader.ReadUInt16();  				codeSize = reader.ReadUInt32();  				localVarSigTok = reader.ReadUInt32();    				// The CLR allows the code to start inside the method header. But if it does'  				// the CLR doesn't read any exceptions.  				reader.Position = reader.Position - 12 + headerSize * 4U;  				if (headerSize < 3)  					flags &= 0xFFF7;  				headerSize *= 4;  				break;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  			case 2:  			case 6:  				// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  				flags = 2;  				maxStack = 8;  				codeSize = (uint)(b >> 2);  				localVarSigTok = 0;  				headerSize = 1;  				break;    			case 3:  				// Fat header. Can have locals and exception handlers  				flags = (ushort)((reader.ReadByte() << 8) | b);  				headerSize = (byte)(flags >> 12);  				maxStack = reader.ReadUInt16();  				codeSize = reader.ReadUInt32();  				localVarSigTok = reader.ReadUInt32();    				// The CLR allows the code to start inside the method header. But if it does'  				// the CLR doesn't read any exceptions.  				reader.Position = reader.Position - 12 + headerSize * 4U;  				if (headerSize < 3)  					flags &= 0xFFF7;  				headerSize *= 4;  				break;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadExceptionHandlers,The following statement contains a magic number: (flags & 8) == 0
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadFatExceptionHandlers,The following statement contains a magic number: int num = GetNumberOfExceptionHandlers((ehReader.ReadUInt32() >> 8) / 24);
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadFatExceptionHandlers,The following statement contains a magic number: int num = GetNumberOfExceptionHandlers((ehReader.ReadUInt32() >> 8) / 24);
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadSmallExceptionHandlers,The following statement contains a magic number: int num = GetNumberOfExceptionHandlers((uint)ehReader.ReadByte() / 12);
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadSmallExceptionHandlers,The following statement contains a magic number: ehReader.Position += 2;
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReader.cs,CreateCilBody,The following statement contains a magic number: bool initLocals = flags == 2 || (flags & 0x10) != 0;
Magic Number,dnlib.DotNet.Emit,MethodBodyReaderBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReaderBase.cs,GetInstruction,The following statement contains a magic number: int i = (lo + hi) / 2;
Magic Number,dnlib.DotNet.Emit,MethodBodyReaderBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReaderBase.cs,ReadOneInstruction,The following statement contains a magic number: currentOffset += (uint)(instr.OpCode.Size + 4 + 4 * targets.Count);
Magic Number,dnlib.DotNet.Emit,MethodBodyReaderBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReaderBase.cs,ReadOneInstruction,The following statement contains a magic number: currentOffset += (uint)(instr.OpCode.Size + 4 + 4 * targets.Count);
Magic Number,dnlib.DotNet.Emit,MethodBodyReaderBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReaderBase.cs,ReadInlineSwitch,The following statement contains a magic number: long offsetAfterInstr = (long)instr.Offset + (long)instr.OpCode.Size + 4L + (long)num * 4;
Magic Number,dnlib.DotNet.Emit,MethodBodyReaderBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReaderBase.cs,ReadInlineSwitch,The following statement contains a magic number: long offsetAfterInstr = (long)instr.Offset + (long)instr.OpCode.Size + 4L + (long)num * 4;
Magic Number,dnlib.DotNet.Emit,MethodTableToTypeConverter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodTableToTypeConverter.cs,GetTypeNET45,The following statement contains a magic number: int maxStack = 8;
Magic Number,dnlib.DotNet.Emit,MethodTableToTypeConverter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodTableToTypeConverter.cs,GetTypeNET45,The following statement contains a magic number: setMethodBodyMethodInfo.Invoke(mb' new object[5] { code' maxStack' locals' null' null });
Magic Number,dnlib.DotNet.Emit,MethodTableToTypeConverter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodTableToTypeConverter.cs,GetLocalSignature,The following statement contains a magic number: return new byte[] {  					0x07'  					0x01'  					(byte)ElementType.Internal'  					(byte)mtValue'  					(byte)(mtValue >> 8)'  					(byte)(mtValue >> 16)'  					(byte)(mtValue >> 24)'  				};
Magic Number,dnlib.DotNet.Emit,MethodTableToTypeConverter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodTableToTypeConverter.cs,GetLocalSignature,The following statement contains a magic number: return new byte[] {  					0x07'  					0x01'  					(byte)ElementType.Internal'  					(byte)mtValue'  					(byte)(mtValue >> 8)'  					(byte)(mtValue >> 16)'  					(byte)(mtValue >> 24)'  				};
Magic Number,dnlib.DotNet.Emit,MethodTableToTypeConverter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodTableToTypeConverter.cs,GetLocalSignature,The following statement contains a magic number: return new byte[] {  					0x07'  					0x01'  					(byte)ElementType.Internal'  					(byte)mtValue'  					(byte)(mtValue >> 8)'  					(byte)(mtValue >> 16)'  					(byte)(mtValue >> 24)'  				};
Magic Number,dnlib.DotNet.Emit,MethodTableToTypeConverter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodTableToTypeConverter.cs,GetLocalSignature,The following statement contains a magic number: IntPtr.Size == 4
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  				case Code.Beq_S:  					instr.OpCode = OpCodes.Beq;  					break;    				case Code.Bge_S:  					instr.OpCode = OpCodes.Bge;  					break;    				case Code.Bge_Un_S:  					instr.OpCode = OpCodes.Bge_Un;  					break;    				case Code.Bgt_S:  					instr.OpCode = OpCodes.Bgt;  					break;    				case Code.Bgt_Un_S:  					instr.OpCode = OpCodes.Bgt_Un;  					break;    				case Code.Ble_S:  					instr.OpCode = OpCodes.Ble;  					break;    				case Code.Ble_Un_S:  					instr.OpCode = OpCodes.Ble_Un;  					break;    				case Code.Blt_S:  					instr.OpCode = OpCodes.Blt;  					break;    				case Code.Blt_Un_S:  					instr.OpCode = OpCodes.Blt_Un;  					break;    				case Code.Bne_Un_S:  					instr.OpCode = OpCodes.Bne_Un;  					break;    				case Code.Br_S:  					instr.OpCode = OpCodes.Br;  					break;    				case Code.Brfalse_S:  					instr.OpCode = OpCodes.Brfalse;  					break;    				case Code.Brtrue_S:  					instr.OpCode = OpCodes.Brtrue;  					break;    				case Code.Ldarg_0:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 0);  					break;    				case Code.Ldarg_1:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 1);  					break;    				case Code.Ldarg_2:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 2);  					break;    				case Code.Ldarg_3:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 3);  					break;    				case Code.Ldarg_S:  					instr.OpCode = OpCodes.Ldarg;  					break;    				case Code.Ldarga_S:  					instr.OpCode = OpCodes.Ldarga;  					break;    				case Code.Ldc_I4_0:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 0;  					break;    				case Code.Ldc_I4_1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 1;  					break;    				case Code.Ldc_I4_2:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 2;  					break;    				case Code.Ldc_I4_3:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 3;  					break;    				case Code.Ldc_I4_4:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 4;  					break;    				case Code.Ldc_I4_5:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 5;  					break;    				case Code.Ldc_I4_6:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 6;  					break;    				case Code.Ldc_I4_7:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 7;  					break;    				case Code.Ldc_I4_8:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 8;  					break;    				case Code.Ldc_I4_M1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = -1;  					break;    				case Code.Ldc_I4_S:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldloc_0:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Ldloc_1:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Ldloc_2:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Ldloc_3:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Ldloc_S:  					instr.OpCode = OpCodes.Ldloc;  					break;    				case Code.Ldloca_S:  					instr.OpCode = OpCodes.Ldloca;  					break;    				case Code.Leave_S:  					instr.OpCode = OpCodes.Leave;  					break;    				case Code.Starg_S:  					instr.OpCode = OpCodes.Starg;  					break;    				case Code.Stloc_0:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Stloc_1:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Stloc_2:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Stloc_3:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Stloc_S:  					instr.OpCode = OpCodes.Stloc;  					break;  				}
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  				case Code.Beq_S:  					instr.OpCode = OpCodes.Beq;  					break;    				case Code.Bge_S:  					instr.OpCode = OpCodes.Bge;  					break;    				case Code.Bge_Un_S:  					instr.OpCode = OpCodes.Bge_Un;  					break;    				case Code.Bgt_S:  					instr.OpCode = OpCodes.Bgt;  					break;    				case Code.Bgt_Un_S:  					instr.OpCode = OpCodes.Bgt_Un;  					break;    				case Code.Ble_S:  					instr.OpCode = OpCodes.Ble;  					break;    				case Code.Ble_Un_S:  					instr.OpCode = OpCodes.Ble_Un;  					break;    				case Code.Blt_S:  					instr.OpCode = OpCodes.Blt;  					break;    				case Code.Blt_Un_S:  					instr.OpCode = OpCodes.Blt_Un;  					break;    				case Code.Bne_Un_S:  					instr.OpCode = OpCodes.Bne_Un;  					break;    				case Code.Br_S:  					instr.OpCode = OpCodes.Br;  					break;    				case Code.Brfalse_S:  					instr.OpCode = OpCodes.Brfalse;  					break;    				case Code.Brtrue_S:  					instr.OpCode = OpCodes.Brtrue;  					break;    				case Code.Ldarg_0:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 0);  					break;    				case Code.Ldarg_1:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 1);  					break;    				case Code.Ldarg_2:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 2);  					break;    				case Code.Ldarg_3:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 3);  					break;    				case Code.Ldarg_S:  					instr.OpCode = OpCodes.Ldarg;  					break;    				case Code.Ldarga_S:  					instr.OpCode = OpCodes.Ldarga;  					break;    				case Code.Ldc_I4_0:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 0;  					break;    				case Code.Ldc_I4_1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 1;  					break;    				case Code.Ldc_I4_2:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 2;  					break;    				case Code.Ldc_I4_3:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 3;  					break;    				case Code.Ldc_I4_4:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 4;  					break;    				case Code.Ldc_I4_5:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 5;  					break;    				case Code.Ldc_I4_6:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 6;  					break;    				case Code.Ldc_I4_7:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 7;  					break;    				case Code.Ldc_I4_8:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 8;  					break;    				case Code.Ldc_I4_M1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = -1;  					break;    				case Code.Ldc_I4_S:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldloc_0:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Ldloc_1:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Ldloc_2:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Ldloc_3:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Ldloc_S:  					instr.OpCode = OpCodes.Ldloc;  					break;    				case Code.Ldloca_S:  					instr.OpCode = OpCodes.Ldloca;  					break;    				case Code.Leave_S:  					instr.OpCode = OpCodes.Leave;  					break;    				case Code.Starg_S:  					instr.OpCode = OpCodes.Starg;  					break;    				case Code.Stloc_0:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Stloc_1:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Stloc_2:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Stloc_3:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Stloc_S:  					instr.OpCode = OpCodes.Stloc;  					break;  				}
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  				case Code.Beq_S:  					instr.OpCode = OpCodes.Beq;  					break;    				case Code.Bge_S:  					instr.OpCode = OpCodes.Bge;  					break;    				case Code.Bge_Un_S:  					instr.OpCode = OpCodes.Bge_Un;  					break;    				case Code.Bgt_S:  					instr.OpCode = OpCodes.Bgt;  					break;    				case Code.Bgt_Un_S:  					instr.OpCode = OpCodes.Bgt_Un;  					break;    				case Code.Ble_S:  					instr.OpCode = OpCodes.Ble;  					break;    				case Code.Ble_Un_S:  					instr.OpCode = OpCodes.Ble_Un;  					break;    				case Code.Blt_S:  					instr.OpCode = OpCodes.Blt;  					break;    				case Code.Blt_Un_S:  					instr.OpCode = OpCodes.Blt_Un;  					break;    				case Code.Bne_Un_S:  					instr.OpCode = OpCodes.Bne_Un;  					break;    				case Code.Br_S:  					instr.OpCode = OpCodes.Br;  					break;    				case Code.Brfalse_S:  					instr.OpCode = OpCodes.Brfalse;  					break;    				case Code.Brtrue_S:  					instr.OpCode = OpCodes.Brtrue;  					break;    				case Code.Ldarg_0:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 0);  					break;    				case Code.Ldarg_1:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 1);  					break;    				case Code.Ldarg_2:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 2);  					break;    				case Code.Ldarg_3:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 3);  					break;    				case Code.Ldarg_S:  					instr.OpCode = OpCodes.Ldarg;  					break;    				case Code.Ldarga_S:  					instr.OpCode = OpCodes.Ldarga;  					break;    				case Code.Ldc_I4_0:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 0;  					break;    				case Code.Ldc_I4_1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 1;  					break;    				case Code.Ldc_I4_2:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 2;  					break;    				case Code.Ldc_I4_3:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 3;  					break;    				case Code.Ldc_I4_4:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 4;  					break;    				case Code.Ldc_I4_5:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 5;  					break;    				case Code.Ldc_I4_6:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 6;  					break;    				case Code.Ldc_I4_7:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 7;  					break;    				case Code.Ldc_I4_8:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 8;  					break;    				case Code.Ldc_I4_M1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = -1;  					break;    				case Code.Ldc_I4_S:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldloc_0:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Ldloc_1:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Ldloc_2:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Ldloc_3:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Ldloc_S:  					instr.OpCode = OpCodes.Ldloc;  					break;    				case Code.Ldloca_S:  					instr.OpCode = OpCodes.Ldloca;  					break;    				case Code.Leave_S:  					instr.OpCode = OpCodes.Leave;  					break;    				case Code.Starg_S:  					instr.OpCode = OpCodes.Starg;  					break;    				case Code.Stloc_0:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Stloc_1:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Stloc_2:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Stloc_3:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Stloc_S:  					instr.OpCode = OpCodes.Stloc;  					break;  				}
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  				case Code.Beq_S:  					instr.OpCode = OpCodes.Beq;  					break;    				case Code.Bge_S:  					instr.OpCode = OpCodes.Bge;  					break;    				case Code.Bge_Un_S:  					instr.OpCode = OpCodes.Bge_Un;  					break;    				case Code.Bgt_S:  					instr.OpCode = OpCodes.Bgt;  					break;    				case Code.Bgt_Un_S:  					instr.OpCode = OpCodes.Bgt_Un;  					break;    				case Code.Ble_S:  					instr.OpCode = OpCodes.Ble;  					break;    				case Code.Ble_Un_S:  					instr.OpCode = OpCodes.Ble_Un;  					break;    				case Code.Blt_S:  					instr.OpCode = OpCodes.Blt;  					break;    				case Code.Blt_Un_S:  					instr.OpCode = OpCodes.Blt_Un;  					break;    				case Code.Bne_Un_S:  					instr.OpCode = OpCodes.Bne_Un;  					break;    				case Code.Br_S:  					instr.OpCode = OpCodes.Br;  					break;    				case Code.Brfalse_S:  					instr.OpCode = OpCodes.Brfalse;  					break;    				case Code.Brtrue_S:  					instr.OpCode = OpCodes.Brtrue;  					break;    				case Code.Ldarg_0:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 0);  					break;    				case Code.Ldarg_1:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 1);  					break;    				case Code.Ldarg_2:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 2);  					break;    				case Code.Ldarg_3:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 3);  					break;    				case Code.Ldarg_S:  					instr.OpCode = OpCodes.Ldarg;  					break;    				case Code.Ldarga_S:  					instr.OpCode = OpCodes.Ldarga;  					break;    				case Code.Ldc_I4_0:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 0;  					break;    				case Code.Ldc_I4_1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 1;  					break;    				case Code.Ldc_I4_2:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 2;  					break;    				case Code.Ldc_I4_3:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 3;  					break;    				case Code.Ldc_I4_4:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 4;  					break;    				case Code.Ldc_I4_5:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 5;  					break;    				case Code.Ldc_I4_6:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 6;  					break;    				case Code.Ldc_I4_7:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 7;  					break;    				case Code.Ldc_I4_8:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 8;  					break;    				case Code.Ldc_I4_M1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = -1;  					break;    				case Code.Ldc_I4_S:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldloc_0:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Ldloc_1:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Ldloc_2:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Ldloc_3:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Ldloc_S:  					instr.OpCode = OpCodes.Ldloc;  					break;    				case Code.Ldloca_S:  					instr.OpCode = OpCodes.Ldloca;  					break;    				case Code.Leave_S:  					instr.OpCode = OpCodes.Leave;  					break;    				case Code.Starg_S:  					instr.OpCode = OpCodes.Starg;  					break;    				case Code.Stloc_0:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Stloc_1:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Stloc_2:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Stloc_3:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Stloc_S:  					instr.OpCode = OpCodes.Stloc;  					break;  				}
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  				case Code.Beq_S:  					instr.OpCode = OpCodes.Beq;  					break;    				case Code.Bge_S:  					instr.OpCode = OpCodes.Bge;  					break;    				case Code.Bge_Un_S:  					instr.OpCode = OpCodes.Bge_Un;  					break;    				case Code.Bgt_S:  					instr.OpCode = OpCodes.Bgt;  					break;    				case Code.Bgt_Un_S:  					instr.OpCode = OpCodes.Bgt_Un;  					break;    				case Code.Ble_S:  					instr.OpCode = OpCodes.Ble;  					break;    				case Code.Ble_Un_S:  					instr.OpCode = OpCodes.Ble_Un;  					break;    				case Code.Blt_S:  					instr.OpCode = OpCodes.Blt;  					break;    				case Code.Blt_Un_S:  					instr.OpCode = OpCodes.Blt_Un;  					break;    				case Code.Bne_Un_S:  					instr.OpCode = OpCodes.Bne_Un;  					break;    				case Code.Br_S:  					instr.OpCode = OpCodes.Br;  					break;    				case Code.Brfalse_S:  					instr.OpCode = OpCodes.Brfalse;  					break;    				case Code.Brtrue_S:  					instr.OpCode = OpCodes.Brtrue;  					break;    				case Code.Ldarg_0:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 0);  					break;    				case Code.Ldarg_1:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 1);  					break;    				case Code.Ldarg_2:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 2);  					break;    				case Code.Ldarg_3:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 3);  					break;    				case Code.Ldarg_S:  					instr.OpCode = OpCodes.Ldarg;  					break;    				case Code.Ldarga_S:  					instr.OpCode = OpCodes.Ldarga;  					break;    				case Code.Ldc_I4_0:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 0;  					break;    				case Code.Ldc_I4_1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 1;  					break;    				case Code.Ldc_I4_2:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 2;  					break;    				case Code.Ldc_I4_3:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 3;  					break;    				case Code.Ldc_I4_4:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 4;  					break;    				case Code.Ldc_I4_5:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 5;  					break;    				case Code.Ldc_I4_6:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 6;  					break;    				case Code.Ldc_I4_7:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 7;  					break;    				case Code.Ldc_I4_8:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 8;  					break;    				case Code.Ldc_I4_M1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = -1;  					break;    				case Code.Ldc_I4_S:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldloc_0:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Ldloc_1:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Ldloc_2:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Ldloc_3:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Ldloc_S:  					instr.OpCode = OpCodes.Ldloc;  					break;    				case Code.Ldloca_S:  					instr.OpCode = OpCodes.Ldloca;  					break;    				case Code.Leave_S:  					instr.OpCode = OpCodes.Leave;  					break;    				case Code.Starg_S:  					instr.OpCode = OpCodes.Starg;  					break;    				case Code.Stloc_0:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Stloc_1:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Stloc_2:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Stloc_3:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Stloc_S:  					instr.OpCode = OpCodes.Stloc;  					break;  				}
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  				case Code.Beq_S:  					instr.OpCode = OpCodes.Beq;  					break;    				case Code.Bge_S:  					instr.OpCode = OpCodes.Bge;  					break;    				case Code.Bge_Un_S:  					instr.OpCode = OpCodes.Bge_Un;  					break;    				case Code.Bgt_S:  					instr.OpCode = OpCodes.Bgt;  					break;    				case Code.Bgt_Un_S:  					instr.OpCode = OpCodes.Bgt_Un;  					break;    				case Code.Ble_S:  					instr.OpCode = OpCodes.Ble;  					break;    				case Code.Ble_Un_S:  					instr.OpCode = OpCodes.Ble_Un;  					break;    				case Code.Blt_S:  					instr.OpCode = OpCodes.Blt;  					break;    				case Code.Blt_Un_S:  					instr.OpCode = OpCodes.Blt_Un;  					break;    				case Code.Bne_Un_S:  					instr.OpCode = OpCodes.Bne_Un;  					break;    				case Code.Br_S:  					instr.OpCode = OpCodes.Br;  					break;    				case Code.Brfalse_S:  					instr.OpCode = OpCodes.Brfalse;  					break;    				case Code.Brtrue_S:  					instr.OpCode = OpCodes.Brtrue;  					break;    				case Code.Ldarg_0:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 0);  					break;    				case Code.Ldarg_1:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 1);  					break;    				case Code.Ldarg_2:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 2);  					break;    				case Code.Ldarg_3:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 3);  					break;    				case Code.Ldarg_S:  					instr.OpCode = OpCodes.Ldarg;  					break;    				case Code.Ldarga_S:  					instr.OpCode = OpCodes.Ldarga;  					break;    				case Code.Ldc_I4_0:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 0;  					break;    				case Code.Ldc_I4_1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 1;  					break;    				case Code.Ldc_I4_2:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 2;  					break;    				case Code.Ldc_I4_3:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 3;  					break;    				case Code.Ldc_I4_4:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 4;  					break;    				case Code.Ldc_I4_5:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 5;  					break;    				case Code.Ldc_I4_6:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 6;  					break;    				case Code.Ldc_I4_7:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 7;  					break;    				case Code.Ldc_I4_8:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 8;  					break;    				case Code.Ldc_I4_M1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = -1;  					break;    				case Code.Ldc_I4_S:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldloc_0:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Ldloc_1:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Ldloc_2:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Ldloc_3:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Ldloc_S:  					instr.OpCode = OpCodes.Ldloc;  					break;    				case Code.Ldloca_S:  					instr.OpCode = OpCodes.Ldloca;  					break;    				case Code.Leave_S:  					instr.OpCode = OpCodes.Leave;  					break;    				case Code.Starg_S:  					instr.OpCode = OpCodes.Starg;  					break;    				case Code.Stloc_0:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Stloc_1:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Stloc_2:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Stloc_3:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Stloc_S:  					instr.OpCode = OpCodes.Stloc;  					break;  				}
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  				case Code.Beq_S:  					instr.OpCode = OpCodes.Beq;  					break;    				case Code.Bge_S:  					instr.OpCode = OpCodes.Bge;  					break;    				case Code.Bge_Un_S:  					instr.OpCode = OpCodes.Bge_Un;  					break;    				case Code.Bgt_S:  					instr.OpCode = OpCodes.Bgt;  					break;    				case Code.Bgt_Un_S:  					instr.OpCode = OpCodes.Bgt_Un;  					break;    				case Code.Ble_S:  					instr.OpCode = OpCodes.Ble;  					break;    				case Code.Ble_Un_S:  					instr.OpCode = OpCodes.Ble_Un;  					break;    				case Code.Blt_S:  					instr.OpCode = OpCodes.Blt;  					break;    				case Code.Blt_Un_S:  					instr.OpCode = OpCodes.Blt_Un;  					break;    				case Code.Bne_Un_S:  					instr.OpCode = OpCodes.Bne_Un;  					break;    				case Code.Br_S:  					instr.OpCode = OpCodes.Br;  					break;    				case Code.Brfalse_S:  					instr.OpCode = OpCodes.Brfalse;  					break;    				case Code.Brtrue_S:  					instr.OpCode = OpCodes.Brtrue;  					break;    				case Code.Ldarg_0:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 0);  					break;    				case Code.Ldarg_1:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 1);  					break;    				case Code.Ldarg_2:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 2);  					break;    				case Code.Ldarg_3:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 3);  					break;    				case Code.Ldarg_S:  					instr.OpCode = OpCodes.Ldarg;  					break;    				case Code.Ldarga_S:  					instr.OpCode = OpCodes.Ldarga;  					break;    				case Code.Ldc_I4_0:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 0;  					break;    				case Code.Ldc_I4_1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 1;  					break;    				case Code.Ldc_I4_2:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 2;  					break;    				case Code.Ldc_I4_3:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 3;  					break;    				case Code.Ldc_I4_4:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 4;  					break;    				case Code.Ldc_I4_5:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 5;  					break;    				case Code.Ldc_I4_6:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 6;  					break;    				case Code.Ldc_I4_7:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 7;  					break;    				case Code.Ldc_I4_8:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 8;  					break;    				case Code.Ldc_I4_M1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = -1;  					break;    				case Code.Ldc_I4_S:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldloc_0:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Ldloc_1:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Ldloc_2:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Ldloc_3:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Ldloc_S:  					instr.OpCode = OpCodes.Ldloc;  					break;    				case Code.Ldloca_S:  					instr.OpCode = OpCodes.Ldloca;  					break;    				case Code.Leave_S:  					instr.OpCode = OpCodes.Leave;  					break;    				case Code.Starg_S:  					instr.OpCode = OpCodes.Starg;  					break;    				case Code.Stloc_0:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Stloc_1:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Stloc_2:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Stloc_3:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Stloc_S:  					instr.OpCode = OpCodes.Stloc;  					break;  				}
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  				case Code.Beq_S:  					instr.OpCode = OpCodes.Beq;  					break;    				case Code.Bge_S:  					instr.OpCode = OpCodes.Bge;  					break;    				case Code.Bge_Un_S:  					instr.OpCode = OpCodes.Bge_Un;  					break;    				case Code.Bgt_S:  					instr.OpCode = OpCodes.Bgt;  					break;    				case Code.Bgt_Un_S:  					instr.OpCode = OpCodes.Bgt_Un;  					break;    				case Code.Ble_S:  					instr.OpCode = OpCodes.Ble;  					break;    				case Code.Ble_Un_S:  					instr.OpCode = OpCodes.Ble_Un;  					break;    				case Code.Blt_S:  					instr.OpCode = OpCodes.Blt;  					break;    				case Code.Blt_Un_S:  					instr.OpCode = OpCodes.Blt_Un;  					break;    				case Code.Bne_Un_S:  					instr.OpCode = OpCodes.Bne_Un;  					break;    				case Code.Br_S:  					instr.OpCode = OpCodes.Br;  					break;    				case Code.Brfalse_S:  					instr.OpCode = OpCodes.Brfalse;  					break;    				case Code.Brtrue_S:  					instr.OpCode = OpCodes.Brtrue;  					break;    				case Code.Ldarg_0:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 0);  					break;    				case Code.Ldarg_1:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 1);  					break;    				case Code.Ldarg_2:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 2);  					break;    				case Code.Ldarg_3:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 3);  					break;    				case Code.Ldarg_S:  					instr.OpCode = OpCodes.Ldarg;  					break;    				case Code.Ldarga_S:  					instr.OpCode = OpCodes.Ldarga;  					break;    				case Code.Ldc_I4_0:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 0;  					break;    				case Code.Ldc_I4_1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 1;  					break;    				case Code.Ldc_I4_2:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 2;  					break;    				case Code.Ldc_I4_3:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 3;  					break;    				case Code.Ldc_I4_4:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 4;  					break;    				case Code.Ldc_I4_5:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 5;  					break;    				case Code.Ldc_I4_6:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 6;  					break;    				case Code.Ldc_I4_7:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 7;  					break;    				case Code.Ldc_I4_8:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 8;  					break;    				case Code.Ldc_I4_M1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = -1;  					break;    				case Code.Ldc_I4_S:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldloc_0:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Ldloc_1:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Ldloc_2:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Ldloc_3:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Ldloc_S:  					instr.OpCode = OpCodes.Ldloc;  					break;    				case Code.Ldloca_S:  					instr.OpCode = OpCodes.Ldloca;  					break;    				case Code.Leave_S:  					instr.OpCode = OpCodes.Leave;  					break;    				case Code.Starg_S:  					instr.OpCode = OpCodes.Starg;  					break;    				case Code.Stloc_0:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Stloc_1:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Stloc_2:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Stloc_3:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Stloc_S:  					instr.OpCode = OpCodes.Stloc;  					break;  				}
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  				case Code.Beq_S:  					instr.OpCode = OpCodes.Beq;  					break;    				case Code.Bge_S:  					instr.OpCode = OpCodes.Bge;  					break;    				case Code.Bge_Un_S:  					instr.OpCode = OpCodes.Bge_Un;  					break;    				case Code.Bgt_S:  					instr.OpCode = OpCodes.Bgt;  					break;    				case Code.Bgt_Un_S:  					instr.OpCode = OpCodes.Bgt_Un;  					break;    				case Code.Ble_S:  					instr.OpCode = OpCodes.Ble;  					break;    				case Code.Ble_Un_S:  					instr.OpCode = OpCodes.Ble_Un;  					break;    				case Code.Blt_S:  					instr.OpCode = OpCodes.Blt;  					break;    				case Code.Blt_Un_S:  					instr.OpCode = OpCodes.Blt_Un;  					break;    				case Code.Bne_Un_S:  					instr.OpCode = OpCodes.Bne_Un;  					break;    				case Code.Br_S:  					instr.OpCode = OpCodes.Br;  					break;    				case Code.Brfalse_S:  					instr.OpCode = OpCodes.Brfalse;  					break;    				case Code.Brtrue_S:  					instr.OpCode = OpCodes.Brtrue;  					break;    				case Code.Ldarg_0:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 0);  					break;    				case Code.Ldarg_1:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 1);  					break;    				case Code.Ldarg_2:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 2);  					break;    				case Code.Ldarg_3:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 3);  					break;    				case Code.Ldarg_S:  					instr.OpCode = OpCodes.Ldarg;  					break;    				case Code.Ldarga_S:  					instr.OpCode = OpCodes.Ldarga;  					break;    				case Code.Ldc_I4_0:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 0;  					break;    				case Code.Ldc_I4_1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 1;  					break;    				case Code.Ldc_I4_2:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 2;  					break;    				case Code.Ldc_I4_3:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 3;  					break;    				case Code.Ldc_I4_4:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 4;  					break;    				case Code.Ldc_I4_5:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 5;  					break;    				case Code.Ldc_I4_6:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 6;  					break;    				case Code.Ldc_I4_7:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 7;  					break;    				case Code.Ldc_I4_8:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 8;  					break;    				case Code.Ldc_I4_M1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = -1;  					break;    				case Code.Ldc_I4_S:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldloc_0:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Ldloc_1:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Ldloc_2:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Ldloc_3:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Ldloc_S:  					instr.OpCode = OpCodes.Ldloc;  					break;    				case Code.Ldloca_S:  					instr.OpCode = OpCodes.Ldloca;  					break;    				case Code.Leave_S:  					instr.OpCode = OpCodes.Leave;  					break;    				case Code.Starg_S:  					instr.OpCode = OpCodes.Starg;  					break;    				case Code.Stloc_0:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Stloc_1:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Stloc_2:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Stloc_3:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Stloc_S:  					instr.OpCode = OpCodes.Stloc;  					break;  				}
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  				case Code.Beq_S:  					instr.OpCode = OpCodes.Beq;  					break;    				case Code.Bge_S:  					instr.OpCode = OpCodes.Bge;  					break;    				case Code.Bge_Un_S:  					instr.OpCode = OpCodes.Bge_Un;  					break;    				case Code.Bgt_S:  					instr.OpCode = OpCodes.Bgt;  					break;    				case Code.Bgt_Un_S:  					instr.OpCode = OpCodes.Bgt_Un;  					break;    				case Code.Ble_S:  					instr.OpCode = OpCodes.Ble;  					break;    				case Code.Ble_Un_S:  					instr.OpCode = OpCodes.Ble_Un;  					break;    				case Code.Blt_S:  					instr.OpCode = OpCodes.Blt;  					break;    				case Code.Blt_Un_S:  					instr.OpCode = OpCodes.Blt_Un;  					break;    				case Code.Bne_Un_S:  					instr.OpCode = OpCodes.Bne_Un;  					break;    				case Code.Br_S:  					instr.OpCode = OpCodes.Br;  					break;    				case Code.Brfalse_S:  					instr.OpCode = OpCodes.Brfalse;  					break;    				case Code.Brtrue_S:  					instr.OpCode = OpCodes.Brtrue;  					break;    				case Code.Ldarg_0:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 0);  					break;    				case Code.Ldarg_1:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 1);  					break;    				case Code.Ldarg_2:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 2);  					break;    				case Code.Ldarg_3:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 3);  					break;    				case Code.Ldarg_S:  					instr.OpCode = OpCodes.Ldarg;  					break;    				case Code.Ldarga_S:  					instr.OpCode = OpCodes.Ldarga;  					break;    				case Code.Ldc_I4_0:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 0;  					break;    				case Code.Ldc_I4_1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 1;  					break;    				case Code.Ldc_I4_2:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 2;  					break;    				case Code.Ldc_I4_3:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 3;  					break;    				case Code.Ldc_I4_4:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 4;  					break;    				case Code.Ldc_I4_5:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 5;  					break;    				case Code.Ldc_I4_6:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 6;  					break;    				case Code.Ldc_I4_7:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 7;  					break;    				case Code.Ldc_I4_8:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 8;  					break;    				case Code.Ldc_I4_M1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = -1;  					break;    				case Code.Ldc_I4_S:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldloc_0:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Ldloc_1:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Ldloc_2:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Ldloc_3:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Ldloc_S:  					instr.OpCode = OpCodes.Ldloc;  					break;    				case Code.Ldloca_S:  					instr.OpCode = OpCodes.Ldloca;  					break;    				case Code.Leave_S:  					instr.OpCode = OpCodes.Leave;  					break;    				case Code.Starg_S:  					instr.OpCode = OpCodes.Starg;  					break;    				case Code.Stloc_0:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Stloc_1:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Stloc_2:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Stloc_3:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Stloc_S:  					instr.OpCode = OpCodes.Stloc;  					break;  				}
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  				case Code.Beq_S:  					instr.OpCode = OpCodes.Beq;  					break;    				case Code.Bge_S:  					instr.OpCode = OpCodes.Bge;  					break;    				case Code.Bge_Un_S:  					instr.OpCode = OpCodes.Bge_Un;  					break;    				case Code.Bgt_S:  					instr.OpCode = OpCodes.Bgt;  					break;    				case Code.Bgt_Un_S:  					instr.OpCode = OpCodes.Bgt_Un;  					break;    				case Code.Ble_S:  					instr.OpCode = OpCodes.Ble;  					break;    				case Code.Ble_Un_S:  					instr.OpCode = OpCodes.Ble_Un;  					break;    				case Code.Blt_S:  					instr.OpCode = OpCodes.Blt;  					break;    				case Code.Blt_Un_S:  					instr.OpCode = OpCodes.Blt_Un;  					break;    				case Code.Bne_Un_S:  					instr.OpCode = OpCodes.Bne_Un;  					break;    				case Code.Br_S:  					instr.OpCode = OpCodes.Br;  					break;    				case Code.Brfalse_S:  					instr.OpCode = OpCodes.Brfalse;  					break;    				case Code.Brtrue_S:  					instr.OpCode = OpCodes.Brtrue;  					break;    				case Code.Ldarg_0:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 0);  					break;    				case Code.Ldarg_1:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 1);  					break;    				case Code.Ldarg_2:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 2);  					break;    				case Code.Ldarg_3:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 3);  					break;    				case Code.Ldarg_S:  					instr.OpCode = OpCodes.Ldarg;  					break;    				case Code.Ldarga_S:  					instr.OpCode = OpCodes.Ldarga;  					break;    				case Code.Ldc_I4_0:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 0;  					break;    				case Code.Ldc_I4_1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 1;  					break;    				case Code.Ldc_I4_2:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 2;  					break;    				case Code.Ldc_I4_3:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 3;  					break;    				case Code.Ldc_I4_4:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 4;  					break;    				case Code.Ldc_I4_5:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 5;  					break;    				case Code.Ldc_I4_6:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 6;  					break;    				case Code.Ldc_I4_7:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 7;  					break;    				case Code.Ldc_I4_8:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 8;  					break;    				case Code.Ldc_I4_M1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = -1;  					break;    				case Code.Ldc_I4_S:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldloc_0:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Ldloc_1:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Ldloc_2:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Ldloc_3:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Ldloc_S:  					instr.OpCode = OpCodes.Ldloc;  					break;    				case Code.Ldloca_S:  					instr.OpCode = OpCodes.Ldloca;  					break;    				case Code.Leave_S:  					instr.OpCode = OpCodes.Leave;  					break;    				case Code.Starg_S:  					instr.OpCode = OpCodes.Starg;  					break;    				case Code.Stloc_0:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Stloc_1:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Stloc_2:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Stloc_3:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Stloc_S:  					instr.OpCode = OpCodes.Stloc;  					break;  				}
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  				case Code.Beq_S:  					instr.OpCode = OpCodes.Beq;  					break;    				case Code.Bge_S:  					instr.OpCode = OpCodes.Bge;  					break;    				case Code.Bge_Un_S:  					instr.OpCode = OpCodes.Bge_Un;  					break;    				case Code.Bgt_S:  					instr.OpCode = OpCodes.Bgt;  					break;    				case Code.Bgt_Un_S:  					instr.OpCode = OpCodes.Bgt_Un;  					break;    				case Code.Ble_S:  					instr.OpCode = OpCodes.Ble;  					break;    				case Code.Ble_Un_S:  					instr.OpCode = OpCodes.Ble_Un;  					break;    				case Code.Blt_S:  					instr.OpCode = OpCodes.Blt;  					break;    				case Code.Blt_Un_S:  					instr.OpCode = OpCodes.Blt_Un;  					break;    				case Code.Bne_Un_S:  					instr.OpCode = OpCodes.Bne_Un;  					break;    				case Code.Br_S:  					instr.OpCode = OpCodes.Br;  					break;    				case Code.Brfalse_S:  					instr.OpCode = OpCodes.Brfalse;  					break;    				case Code.Brtrue_S:  					instr.OpCode = OpCodes.Brtrue;  					break;    				case Code.Ldarg_0:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 0);  					break;    				case Code.Ldarg_1:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 1);  					break;    				case Code.Ldarg_2:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 2);  					break;    				case Code.Ldarg_3:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 3);  					break;    				case Code.Ldarg_S:  					instr.OpCode = OpCodes.Ldarg;  					break;    				case Code.Ldarga_S:  					instr.OpCode = OpCodes.Ldarga;  					break;    				case Code.Ldc_I4_0:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 0;  					break;    				case Code.Ldc_I4_1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 1;  					break;    				case Code.Ldc_I4_2:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 2;  					break;    				case Code.Ldc_I4_3:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 3;  					break;    				case Code.Ldc_I4_4:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 4;  					break;    				case Code.Ldc_I4_5:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 5;  					break;    				case Code.Ldc_I4_6:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 6;  					break;    				case Code.Ldc_I4_7:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 7;  					break;    				case Code.Ldc_I4_8:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 8;  					break;    				case Code.Ldc_I4_M1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = -1;  					break;    				case Code.Ldc_I4_S:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldloc_0:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Ldloc_1:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Ldloc_2:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Ldloc_3:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Ldloc_S:  					instr.OpCode = OpCodes.Ldloc;  					break;    				case Code.Ldloca_S:  					instr.OpCode = OpCodes.Ldloca;  					break;    				case Code.Leave_S:  					instr.OpCode = OpCodes.Leave;  					break;    				case Code.Starg_S:  					instr.OpCode = OpCodes.Starg;  					break;    				case Code.Stloc_0:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Stloc_1:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Stloc_2:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Stloc_3:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Stloc_S:  					instr.OpCode = OpCodes.Stloc;  					break;  				}
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  				case Code.Beq_S:  					instr.OpCode = OpCodes.Beq;  					break;    				case Code.Bge_S:  					instr.OpCode = OpCodes.Bge;  					break;    				case Code.Bge_Un_S:  					instr.OpCode = OpCodes.Bge_Un;  					break;    				case Code.Bgt_S:  					instr.OpCode = OpCodes.Bgt;  					break;    				case Code.Bgt_Un_S:  					instr.OpCode = OpCodes.Bgt_Un;  					break;    				case Code.Ble_S:  					instr.OpCode = OpCodes.Ble;  					break;    				case Code.Ble_Un_S:  					instr.OpCode = OpCodes.Ble_Un;  					break;    				case Code.Blt_S:  					instr.OpCode = OpCodes.Blt;  					break;    				case Code.Blt_Un_S:  					instr.OpCode = OpCodes.Blt_Un;  					break;    				case Code.Bne_Un_S:  					instr.OpCode = OpCodes.Bne_Un;  					break;    				case Code.Br_S:  					instr.OpCode = OpCodes.Br;  					break;    				case Code.Brfalse_S:  					instr.OpCode = OpCodes.Brfalse;  					break;    				case Code.Brtrue_S:  					instr.OpCode = OpCodes.Brtrue;  					break;    				case Code.Ldarg_0:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 0);  					break;    				case Code.Ldarg_1:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 1);  					break;    				case Code.Ldarg_2:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 2);  					break;    				case Code.Ldarg_3:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 3);  					break;    				case Code.Ldarg_S:  					instr.OpCode = OpCodes.Ldarg;  					break;    				case Code.Ldarga_S:  					instr.OpCode = OpCodes.Ldarga;  					break;    				case Code.Ldc_I4_0:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 0;  					break;    				case Code.Ldc_I4_1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 1;  					break;    				case Code.Ldc_I4_2:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 2;  					break;    				case Code.Ldc_I4_3:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 3;  					break;    				case Code.Ldc_I4_4:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 4;  					break;    				case Code.Ldc_I4_5:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 5;  					break;    				case Code.Ldc_I4_6:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 6;  					break;    				case Code.Ldc_I4_7:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 7;  					break;    				case Code.Ldc_I4_8:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 8;  					break;    				case Code.Ldc_I4_M1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = -1;  					break;    				case Code.Ldc_I4_S:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldloc_0:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Ldloc_1:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Ldloc_2:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Ldloc_3:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Ldloc_S:  					instr.OpCode = OpCodes.Ldloc;  					break;    				case Code.Ldloca_S:  					instr.OpCode = OpCodes.Ldloca;  					break;    				case Code.Leave_S:  					instr.OpCode = OpCodes.Leave;  					break;    				case Code.Starg_S:  					instr.OpCode = OpCodes.Starg;  					break;    				case Code.Stloc_0:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Stloc_1:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Stloc_2:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Stloc_3:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Stloc_S:  					instr.OpCode = OpCodes.Stloc;  					break;  				}
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  				case Code.Ldarg:  				case Code.Ldarg_S:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (arg.Index == 0) {  						instr.OpCode = OpCodes.Ldarg_0;  						instr.Operand = null;  					}  					else if (arg.Index == 1) {  						instr.OpCode = OpCodes.Ldarg_1;  						instr.Operand = null;  					}  					else if (arg.Index == 2) {  						instr.OpCode = OpCodes.Ldarg_2;  						instr.Operand = null;  					}  					else if (arg.Index == 3) {  						instr.OpCode = OpCodes.Ldarg_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarg_S;  					break;    				case Code.Ldarga:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarga_S;  					break;    				case Code.Ldc_I4:  				case Code.Ldc_I4_S:  					int i4;  					if (instr.Operand is int)  						i4 = (int)instr.Operand;  					else if (instr.Operand is sbyte)  						i4 = (sbyte)instr.Operand;  					else  						break;  					switch (i4) {  					case 0:  						instr.OpCode = OpCodes.Ldc_I4_0;  						instr.Operand = null;  						break;    					case 1:  						instr.OpCode = OpCodes.Ldc_I4_1;  						instr.Operand = null;  						break;    					case 2:  						instr.OpCode = OpCodes.Ldc_I4_2;  						instr.Operand = null;  						break;    					case 3:  						instr.OpCode = OpCodes.Ldc_I4_3;  						instr.Operand = null;  						break;    					case 4:  						instr.OpCode = OpCodes.Ldc_I4_4;  						instr.Operand = null;  						break;    					case 5:  						instr.OpCode = OpCodes.Ldc_I4_5;  						instr.Operand = null;  						break;    					case 6:  						instr.OpCode = OpCodes.Ldc_I4_6;  						instr.Operand = null;  						break;    					case 7:  						instr.OpCode = OpCodes.Ldc_I4_7;  						instr.Operand = null;  						break;    					case 8:  						instr.OpCode = OpCodes.Ldc_I4_8;  						instr.Operand = null;  						break;    					case -1:  						instr.OpCode = OpCodes.Ldc_I4_M1;  						instr.Operand = null;  						break;    					default:  						if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  							instr.OpCode = OpCodes.Ldc_I4_S;  							instr.Operand = (sbyte)i4;  						}  						break;  					}  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Ldloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Ldloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Ldloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Ldloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloc_S;  					break;    				case Code.Ldloca:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloca_S;  					break;    				case Code.Starg:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Starg_S;  					break;    				case Code.Stloc:  				case Code.Stloc_S:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Stloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Stloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Stloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Stloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Stloc_S;  					break;  				}
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  				case Code.Ldarg:  				case Code.Ldarg_S:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (arg.Index == 0) {  						instr.OpCode = OpCodes.Ldarg_0;  						instr.Operand = null;  					}  					else if (arg.Index == 1) {  						instr.OpCode = OpCodes.Ldarg_1;  						instr.Operand = null;  					}  					else if (arg.Index == 2) {  						instr.OpCode = OpCodes.Ldarg_2;  						instr.Operand = null;  					}  					else if (arg.Index == 3) {  						instr.OpCode = OpCodes.Ldarg_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarg_S;  					break;    				case Code.Ldarga:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarga_S;  					break;    				case Code.Ldc_I4:  				case Code.Ldc_I4_S:  					int i4;  					if (instr.Operand is int)  						i4 = (int)instr.Operand;  					else if (instr.Operand is sbyte)  						i4 = (sbyte)instr.Operand;  					else  						break;  					switch (i4) {  					case 0:  						instr.OpCode = OpCodes.Ldc_I4_0;  						instr.Operand = null;  						break;    					case 1:  						instr.OpCode = OpCodes.Ldc_I4_1;  						instr.Operand = null;  						break;    					case 2:  						instr.OpCode = OpCodes.Ldc_I4_2;  						instr.Operand = null;  						break;    					case 3:  						instr.OpCode = OpCodes.Ldc_I4_3;  						instr.Operand = null;  						break;    					case 4:  						instr.OpCode = OpCodes.Ldc_I4_4;  						instr.Operand = null;  						break;    					case 5:  						instr.OpCode = OpCodes.Ldc_I4_5;  						instr.Operand = null;  						break;    					case 6:  						instr.OpCode = OpCodes.Ldc_I4_6;  						instr.Operand = null;  						break;    					case 7:  						instr.OpCode = OpCodes.Ldc_I4_7;  						instr.Operand = null;  						break;    					case 8:  						instr.OpCode = OpCodes.Ldc_I4_8;  						instr.Operand = null;  						break;    					case -1:  						instr.OpCode = OpCodes.Ldc_I4_M1;  						instr.Operand = null;  						break;    					default:  						if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  							instr.OpCode = OpCodes.Ldc_I4_S;  							instr.Operand = (sbyte)i4;  						}  						break;  					}  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Ldloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Ldloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Ldloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Ldloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloc_S;  					break;    				case Code.Ldloca:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloca_S;  					break;    				case Code.Starg:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Starg_S;  					break;    				case Code.Stloc:  				case Code.Stloc_S:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Stloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Stloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Stloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Stloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Stloc_S;  					break;  				}
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  				case Code.Ldarg:  				case Code.Ldarg_S:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (arg.Index == 0) {  						instr.OpCode = OpCodes.Ldarg_0;  						instr.Operand = null;  					}  					else if (arg.Index == 1) {  						instr.OpCode = OpCodes.Ldarg_1;  						instr.Operand = null;  					}  					else if (arg.Index == 2) {  						instr.OpCode = OpCodes.Ldarg_2;  						instr.Operand = null;  					}  					else if (arg.Index == 3) {  						instr.OpCode = OpCodes.Ldarg_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarg_S;  					break;    				case Code.Ldarga:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarga_S;  					break;    				case Code.Ldc_I4:  				case Code.Ldc_I4_S:  					int i4;  					if (instr.Operand is int)  						i4 = (int)instr.Operand;  					else if (instr.Operand is sbyte)  						i4 = (sbyte)instr.Operand;  					else  						break;  					switch (i4) {  					case 0:  						instr.OpCode = OpCodes.Ldc_I4_0;  						instr.Operand = null;  						break;    					case 1:  						instr.OpCode = OpCodes.Ldc_I4_1;  						instr.Operand = null;  						break;    					case 2:  						instr.OpCode = OpCodes.Ldc_I4_2;  						instr.Operand = null;  						break;    					case 3:  						instr.OpCode = OpCodes.Ldc_I4_3;  						instr.Operand = null;  						break;    					case 4:  						instr.OpCode = OpCodes.Ldc_I4_4;  						instr.Operand = null;  						break;    					case 5:  						instr.OpCode = OpCodes.Ldc_I4_5;  						instr.Operand = null;  						break;    					case 6:  						instr.OpCode = OpCodes.Ldc_I4_6;  						instr.Operand = null;  						break;    					case 7:  						instr.OpCode = OpCodes.Ldc_I4_7;  						instr.Operand = null;  						break;    					case 8:  						instr.OpCode = OpCodes.Ldc_I4_8;  						instr.Operand = null;  						break;    					case -1:  						instr.OpCode = OpCodes.Ldc_I4_M1;  						instr.Operand = null;  						break;    					default:  						if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  							instr.OpCode = OpCodes.Ldc_I4_S;  							instr.Operand = (sbyte)i4;  						}  						break;  					}  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Ldloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Ldloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Ldloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Ldloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloc_S;  					break;    				case Code.Ldloca:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloca_S;  					break;    				case Code.Starg:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Starg_S;  					break;    				case Code.Stloc:  				case Code.Stloc_S:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Stloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Stloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Stloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Stloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Stloc_S;  					break;  				}
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  				case Code.Ldarg:  				case Code.Ldarg_S:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (arg.Index == 0) {  						instr.OpCode = OpCodes.Ldarg_0;  						instr.Operand = null;  					}  					else if (arg.Index == 1) {  						instr.OpCode = OpCodes.Ldarg_1;  						instr.Operand = null;  					}  					else if (arg.Index == 2) {  						instr.OpCode = OpCodes.Ldarg_2;  						instr.Operand = null;  					}  					else if (arg.Index == 3) {  						instr.OpCode = OpCodes.Ldarg_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarg_S;  					break;    				case Code.Ldarga:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarga_S;  					break;    				case Code.Ldc_I4:  				case Code.Ldc_I4_S:  					int i4;  					if (instr.Operand is int)  						i4 = (int)instr.Operand;  					else if (instr.Operand is sbyte)  						i4 = (sbyte)instr.Operand;  					else  						break;  					switch (i4) {  					case 0:  						instr.OpCode = OpCodes.Ldc_I4_0;  						instr.Operand = null;  						break;    					case 1:  						instr.OpCode = OpCodes.Ldc_I4_1;  						instr.Operand = null;  						break;    					case 2:  						instr.OpCode = OpCodes.Ldc_I4_2;  						instr.Operand = null;  						break;    					case 3:  						instr.OpCode = OpCodes.Ldc_I4_3;  						instr.Operand = null;  						break;    					case 4:  						instr.OpCode = OpCodes.Ldc_I4_4;  						instr.Operand = null;  						break;    					case 5:  						instr.OpCode = OpCodes.Ldc_I4_5;  						instr.Operand = null;  						break;    					case 6:  						instr.OpCode = OpCodes.Ldc_I4_6;  						instr.Operand = null;  						break;    					case 7:  						instr.OpCode = OpCodes.Ldc_I4_7;  						instr.Operand = null;  						break;    					case 8:  						instr.OpCode = OpCodes.Ldc_I4_8;  						instr.Operand = null;  						break;    					case -1:  						instr.OpCode = OpCodes.Ldc_I4_M1;  						instr.Operand = null;  						break;    					default:  						if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  							instr.OpCode = OpCodes.Ldc_I4_S;  							instr.Operand = (sbyte)i4;  						}  						break;  					}  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Ldloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Ldloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Ldloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Ldloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloc_S;  					break;    				case Code.Ldloca:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloca_S;  					break;    				case Code.Starg:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Starg_S;  					break;    				case Code.Stloc:  				case Code.Stloc_S:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Stloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Stloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Stloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Stloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Stloc_S;  					break;  				}
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  				case Code.Ldarg:  				case Code.Ldarg_S:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (arg.Index == 0) {  						instr.OpCode = OpCodes.Ldarg_0;  						instr.Operand = null;  					}  					else if (arg.Index == 1) {  						instr.OpCode = OpCodes.Ldarg_1;  						instr.Operand = null;  					}  					else if (arg.Index == 2) {  						instr.OpCode = OpCodes.Ldarg_2;  						instr.Operand = null;  					}  					else if (arg.Index == 3) {  						instr.OpCode = OpCodes.Ldarg_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarg_S;  					break;    				case Code.Ldarga:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarga_S;  					break;    				case Code.Ldc_I4:  				case Code.Ldc_I4_S:  					int i4;  					if (instr.Operand is int)  						i4 = (int)instr.Operand;  					else if (instr.Operand is sbyte)  						i4 = (sbyte)instr.Operand;  					else  						break;  					switch (i4) {  					case 0:  						instr.OpCode = OpCodes.Ldc_I4_0;  						instr.Operand = null;  						break;    					case 1:  						instr.OpCode = OpCodes.Ldc_I4_1;  						instr.Operand = null;  						break;    					case 2:  						instr.OpCode = OpCodes.Ldc_I4_2;  						instr.Operand = null;  						break;    					case 3:  						instr.OpCode = OpCodes.Ldc_I4_3;  						instr.Operand = null;  						break;    					case 4:  						instr.OpCode = OpCodes.Ldc_I4_4;  						instr.Operand = null;  						break;    					case 5:  						instr.OpCode = OpCodes.Ldc_I4_5;  						instr.Operand = null;  						break;    					case 6:  						instr.OpCode = OpCodes.Ldc_I4_6;  						instr.Operand = null;  						break;    					case 7:  						instr.OpCode = OpCodes.Ldc_I4_7;  						instr.Operand = null;  						break;    					case 8:  						instr.OpCode = OpCodes.Ldc_I4_8;  						instr.Operand = null;  						break;    					case -1:  						instr.OpCode = OpCodes.Ldc_I4_M1;  						instr.Operand = null;  						break;    					default:  						if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  							instr.OpCode = OpCodes.Ldc_I4_S;  							instr.Operand = (sbyte)i4;  						}  						break;  					}  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Ldloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Ldloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Ldloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Ldloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloc_S;  					break;    				case Code.Ldloca:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloca_S;  					break;    				case Code.Starg:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Starg_S;  					break;    				case Code.Stloc:  				case Code.Stloc_S:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Stloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Stloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Stloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Stloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Stloc_S;  					break;  				}
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  				case Code.Ldarg:  				case Code.Ldarg_S:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (arg.Index == 0) {  						instr.OpCode = OpCodes.Ldarg_0;  						instr.Operand = null;  					}  					else if (arg.Index == 1) {  						instr.OpCode = OpCodes.Ldarg_1;  						instr.Operand = null;  					}  					else if (arg.Index == 2) {  						instr.OpCode = OpCodes.Ldarg_2;  						instr.Operand = null;  					}  					else if (arg.Index == 3) {  						instr.OpCode = OpCodes.Ldarg_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarg_S;  					break;    				case Code.Ldarga:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarga_S;  					break;    				case Code.Ldc_I4:  				case Code.Ldc_I4_S:  					int i4;  					if (instr.Operand is int)  						i4 = (int)instr.Operand;  					else if (instr.Operand is sbyte)  						i4 = (sbyte)instr.Operand;  					else  						break;  					switch (i4) {  					case 0:  						instr.OpCode = OpCodes.Ldc_I4_0;  						instr.Operand = null;  						break;    					case 1:  						instr.OpCode = OpCodes.Ldc_I4_1;  						instr.Operand = null;  						break;    					case 2:  						instr.OpCode = OpCodes.Ldc_I4_2;  						instr.Operand = null;  						break;    					case 3:  						instr.OpCode = OpCodes.Ldc_I4_3;  						instr.Operand = null;  						break;    					case 4:  						instr.OpCode = OpCodes.Ldc_I4_4;  						instr.Operand = null;  						break;    					case 5:  						instr.OpCode = OpCodes.Ldc_I4_5;  						instr.Operand = null;  						break;    					case 6:  						instr.OpCode = OpCodes.Ldc_I4_6;  						instr.Operand = null;  						break;    					case 7:  						instr.OpCode = OpCodes.Ldc_I4_7;  						instr.Operand = null;  						break;    					case 8:  						instr.OpCode = OpCodes.Ldc_I4_8;  						instr.Operand = null;  						break;    					case -1:  						instr.OpCode = OpCodes.Ldc_I4_M1;  						instr.Operand = null;  						break;    					default:  						if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  							instr.OpCode = OpCodes.Ldc_I4_S;  							instr.Operand = (sbyte)i4;  						}  						break;  					}  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Ldloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Ldloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Ldloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Ldloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloc_S;  					break;    				case Code.Ldloca:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloca_S;  					break;    				case Code.Starg:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Starg_S;  					break;    				case Code.Stloc:  				case Code.Stloc_S:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Stloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Stloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Stloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Stloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Stloc_S;  					break;  				}
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  				case Code.Ldarg:  				case Code.Ldarg_S:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (arg.Index == 0) {  						instr.OpCode = OpCodes.Ldarg_0;  						instr.Operand = null;  					}  					else if (arg.Index == 1) {  						instr.OpCode = OpCodes.Ldarg_1;  						instr.Operand = null;  					}  					else if (arg.Index == 2) {  						instr.OpCode = OpCodes.Ldarg_2;  						instr.Operand = null;  					}  					else if (arg.Index == 3) {  						instr.OpCode = OpCodes.Ldarg_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarg_S;  					break;    				case Code.Ldarga:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarga_S;  					break;    				case Code.Ldc_I4:  				case Code.Ldc_I4_S:  					int i4;  					if (instr.Operand is int)  						i4 = (int)instr.Operand;  					else if (instr.Operand is sbyte)  						i4 = (sbyte)instr.Operand;  					else  						break;  					switch (i4) {  					case 0:  						instr.OpCode = OpCodes.Ldc_I4_0;  						instr.Operand = null;  						break;    					case 1:  						instr.OpCode = OpCodes.Ldc_I4_1;  						instr.Operand = null;  						break;    					case 2:  						instr.OpCode = OpCodes.Ldc_I4_2;  						instr.Operand = null;  						break;    					case 3:  						instr.OpCode = OpCodes.Ldc_I4_3;  						instr.Operand = null;  						break;    					case 4:  						instr.OpCode = OpCodes.Ldc_I4_4;  						instr.Operand = null;  						break;    					case 5:  						instr.OpCode = OpCodes.Ldc_I4_5;  						instr.Operand = null;  						break;    					case 6:  						instr.OpCode = OpCodes.Ldc_I4_6;  						instr.Operand = null;  						break;    					case 7:  						instr.OpCode = OpCodes.Ldc_I4_7;  						instr.Operand = null;  						break;    					case 8:  						instr.OpCode = OpCodes.Ldc_I4_8;  						instr.Operand = null;  						break;    					case -1:  						instr.OpCode = OpCodes.Ldc_I4_M1;  						instr.Operand = null;  						break;    					default:  						if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  							instr.OpCode = OpCodes.Ldc_I4_S;  							instr.Operand = (sbyte)i4;  						}  						break;  					}  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Ldloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Ldloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Ldloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Ldloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloc_S;  					break;    				case Code.Ldloca:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloca_S;  					break;    				case Code.Starg:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Starg_S;  					break;    				case Code.Stloc:  				case Code.Stloc_S:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Stloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Stloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Stloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Stloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Stloc_S;  					break;  				}
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  				case Code.Ldarg:  				case Code.Ldarg_S:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (arg.Index == 0) {  						instr.OpCode = OpCodes.Ldarg_0;  						instr.Operand = null;  					}  					else if (arg.Index == 1) {  						instr.OpCode = OpCodes.Ldarg_1;  						instr.Operand = null;  					}  					else if (arg.Index == 2) {  						instr.OpCode = OpCodes.Ldarg_2;  						instr.Operand = null;  					}  					else if (arg.Index == 3) {  						instr.OpCode = OpCodes.Ldarg_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarg_S;  					break;    				case Code.Ldarga:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarga_S;  					break;    				case Code.Ldc_I4:  				case Code.Ldc_I4_S:  					int i4;  					if (instr.Operand is int)  						i4 = (int)instr.Operand;  					else if (instr.Operand is sbyte)  						i4 = (sbyte)instr.Operand;  					else  						break;  					switch (i4) {  					case 0:  						instr.OpCode = OpCodes.Ldc_I4_0;  						instr.Operand = null;  						break;    					case 1:  						instr.OpCode = OpCodes.Ldc_I4_1;  						instr.Operand = null;  						break;    					case 2:  						instr.OpCode = OpCodes.Ldc_I4_2;  						instr.Operand = null;  						break;    					case 3:  						instr.OpCode = OpCodes.Ldc_I4_3;  						instr.Operand = null;  						break;    					case 4:  						instr.OpCode = OpCodes.Ldc_I4_4;  						instr.Operand = null;  						break;    					case 5:  						instr.OpCode = OpCodes.Ldc_I4_5;  						instr.Operand = null;  						break;    					case 6:  						instr.OpCode = OpCodes.Ldc_I4_6;  						instr.Operand = null;  						break;    					case 7:  						instr.OpCode = OpCodes.Ldc_I4_7;  						instr.Operand = null;  						break;    					case 8:  						instr.OpCode = OpCodes.Ldc_I4_8;  						instr.Operand = null;  						break;    					case -1:  						instr.OpCode = OpCodes.Ldc_I4_M1;  						instr.Operand = null;  						break;    					default:  						if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  							instr.OpCode = OpCodes.Ldc_I4_S;  							instr.Operand = (sbyte)i4;  						}  						break;  					}  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Ldloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Ldloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Ldloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Ldloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloc_S;  					break;    				case Code.Ldloca:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloca_S;  					break;    				case Code.Starg:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Starg_S;  					break;    				case Code.Stloc:  				case Code.Stloc_S:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Stloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Stloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Stloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Stloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Stloc_S;  					break;  				}
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  				case Code.Ldarg:  				case Code.Ldarg_S:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (arg.Index == 0) {  						instr.OpCode = OpCodes.Ldarg_0;  						instr.Operand = null;  					}  					else if (arg.Index == 1) {  						instr.OpCode = OpCodes.Ldarg_1;  						instr.Operand = null;  					}  					else if (arg.Index == 2) {  						instr.OpCode = OpCodes.Ldarg_2;  						instr.Operand = null;  					}  					else if (arg.Index == 3) {  						instr.OpCode = OpCodes.Ldarg_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarg_S;  					break;    				case Code.Ldarga:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarga_S;  					break;    				case Code.Ldc_I4:  				case Code.Ldc_I4_S:  					int i4;  					if (instr.Operand is int)  						i4 = (int)instr.Operand;  					else if (instr.Operand is sbyte)  						i4 = (sbyte)instr.Operand;  					else  						break;  					switch (i4) {  					case 0:  						instr.OpCode = OpCodes.Ldc_I4_0;  						instr.Operand = null;  						break;    					case 1:  						instr.OpCode = OpCodes.Ldc_I4_1;  						instr.Operand = null;  						break;    					case 2:  						instr.OpCode = OpCodes.Ldc_I4_2;  						instr.Operand = null;  						break;    					case 3:  						instr.OpCode = OpCodes.Ldc_I4_3;  						instr.Operand = null;  						break;    					case 4:  						instr.OpCode = OpCodes.Ldc_I4_4;  						instr.Operand = null;  						break;    					case 5:  						instr.OpCode = OpCodes.Ldc_I4_5;  						instr.Operand = null;  						break;    					case 6:  						instr.OpCode = OpCodes.Ldc_I4_6;  						instr.Operand = null;  						break;    					case 7:  						instr.OpCode = OpCodes.Ldc_I4_7;  						instr.Operand = null;  						break;    					case 8:  						instr.OpCode = OpCodes.Ldc_I4_8;  						instr.Operand = null;  						break;    					case -1:  						instr.OpCode = OpCodes.Ldc_I4_M1;  						instr.Operand = null;  						break;    					default:  						if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  							instr.OpCode = OpCodes.Ldc_I4_S;  							instr.Operand = (sbyte)i4;  						}  						break;  					}  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Ldloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Ldloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Ldloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Ldloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloc_S;  					break;    				case Code.Ldloca:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloca_S;  					break;    				case Code.Starg:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Starg_S;  					break;    				case Code.Stloc:  				case Code.Stloc_S:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Stloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Stloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Stloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Stloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Stloc_S;  					break;  				}
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  				case Code.Ldarg:  				case Code.Ldarg_S:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (arg.Index == 0) {  						instr.OpCode = OpCodes.Ldarg_0;  						instr.Operand = null;  					}  					else if (arg.Index == 1) {  						instr.OpCode = OpCodes.Ldarg_1;  						instr.Operand = null;  					}  					else if (arg.Index == 2) {  						instr.OpCode = OpCodes.Ldarg_2;  						instr.Operand = null;  					}  					else if (arg.Index == 3) {  						instr.OpCode = OpCodes.Ldarg_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarg_S;  					break;    				case Code.Ldarga:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarga_S;  					break;    				case Code.Ldc_I4:  				case Code.Ldc_I4_S:  					int i4;  					if (instr.Operand is int)  						i4 = (int)instr.Operand;  					else if (instr.Operand is sbyte)  						i4 = (sbyte)instr.Operand;  					else  						break;  					switch (i4) {  					case 0:  						instr.OpCode = OpCodes.Ldc_I4_0;  						instr.Operand = null;  						break;    					case 1:  						instr.OpCode = OpCodes.Ldc_I4_1;  						instr.Operand = null;  						break;    					case 2:  						instr.OpCode = OpCodes.Ldc_I4_2;  						instr.Operand = null;  						break;    					case 3:  						instr.OpCode = OpCodes.Ldc_I4_3;  						instr.Operand = null;  						break;    					case 4:  						instr.OpCode = OpCodes.Ldc_I4_4;  						instr.Operand = null;  						break;    					case 5:  						instr.OpCode = OpCodes.Ldc_I4_5;  						instr.Operand = null;  						break;    					case 6:  						instr.OpCode = OpCodes.Ldc_I4_6;  						instr.Operand = null;  						break;    					case 7:  						instr.OpCode = OpCodes.Ldc_I4_7;  						instr.Operand = null;  						break;    					case 8:  						instr.OpCode = OpCodes.Ldc_I4_8;  						instr.Operand = null;  						break;    					case -1:  						instr.OpCode = OpCodes.Ldc_I4_M1;  						instr.Operand = null;  						break;    					default:  						if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  							instr.OpCode = OpCodes.Ldc_I4_S;  							instr.Operand = (sbyte)i4;  						}  						break;  					}  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Ldloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Ldloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Ldloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Ldloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloc_S;  					break;    				case Code.Ldloca:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloca_S;  					break;    				case Code.Starg:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Starg_S;  					break;    				case Code.Stloc:  				case Code.Stloc_S:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Stloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Stloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Stloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Stloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Stloc_S;  					break;  				}
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  				case Code.Ldarg:  				case Code.Ldarg_S:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (arg.Index == 0) {  						instr.OpCode = OpCodes.Ldarg_0;  						instr.Operand = null;  					}  					else if (arg.Index == 1) {  						instr.OpCode = OpCodes.Ldarg_1;  						instr.Operand = null;  					}  					else if (arg.Index == 2) {  						instr.OpCode = OpCodes.Ldarg_2;  						instr.Operand = null;  					}  					else if (arg.Index == 3) {  						instr.OpCode = OpCodes.Ldarg_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarg_S;  					break;    				case Code.Ldarga:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarga_S;  					break;    				case Code.Ldc_I4:  				case Code.Ldc_I4_S:  					int i4;  					if (instr.Operand is int)  						i4 = (int)instr.Operand;  					else if (instr.Operand is sbyte)  						i4 = (sbyte)instr.Operand;  					else  						break;  					switch (i4) {  					case 0:  						instr.OpCode = OpCodes.Ldc_I4_0;  						instr.Operand = null;  						break;    					case 1:  						instr.OpCode = OpCodes.Ldc_I4_1;  						instr.Operand = null;  						break;    					case 2:  						instr.OpCode = OpCodes.Ldc_I4_2;  						instr.Operand = null;  						break;    					case 3:  						instr.OpCode = OpCodes.Ldc_I4_3;  						instr.Operand = null;  						break;    					case 4:  						instr.OpCode = OpCodes.Ldc_I4_4;  						instr.Operand = null;  						break;    					case 5:  						instr.OpCode = OpCodes.Ldc_I4_5;  						instr.Operand = null;  						break;    					case 6:  						instr.OpCode = OpCodes.Ldc_I4_6;  						instr.Operand = null;  						break;    					case 7:  						instr.OpCode = OpCodes.Ldc_I4_7;  						instr.Operand = null;  						break;    					case 8:  						instr.OpCode = OpCodes.Ldc_I4_8;  						instr.Operand = null;  						break;    					case -1:  						instr.OpCode = OpCodes.Ldc_I4_M1;  						instr.Operand = null;  						break;    					default:  						if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  							instr.OpCode = OpCodes.Ldc_I4_S;  							instr.Operand = (sbyte)i4;  						}  						break;  					}  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Ldloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Ldloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Ldloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Ldloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloc_S;  					break;    				case Code.Ldloca:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloca_S;  					break;    				case Code.Starg:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Starg_S;  					break;    				case Code.Stloc:  				case Code.Stloc_S:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Stloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Stloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Stloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Stloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Stloc_S;  					break;  				}
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  				case Code.Ldarg:  				case Code.Ldarg_S:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (arg.Index == 0) {  						instr.OpCode = OpCodes.Ldarg_0;  						instr.Operand = null;  					}  					else if (arg.Index == 1) {  						instr.OpCode = OpCodes.Ldarg_1;  						instr.Operand = null;  					}  					else if (arg.Index == 2) {  						instr.OpCode = OpCodes.Ldarg_2;  						instr.Operand = null;  					}  					else if (arg.Index == 3) {  						instr.OpCode = OpCodes.Ldarg_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarg_S;  					break;    				case Code.Ldarga:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarga_S;  					break;    				case Code.Ldc_I4:  				case Code.Ldc_I4_S:  					int i4;  					if (instr.Operand is int)  						i4 = (int)instr.Operand;  					else if (instr.Operand is sbyte)  						i4 = (sbyte)instr.Operand;  					else  						break;  					switch (i4) {  					case 0:  						instr.OpCode = OpCodes.Ldc_I4_0;  						instr.Operand = null;  						break;    					case 1:  						instr.OpCode = OpCodes.Ldc_I4_1;  						instr.Operand = null;  						break;    					case 2:  						instr.OpCode = OpCodes.Ldc_I4_2;  						instr.Operand = null;  						break;    					case 3:  						instr.OpCode = OpCodes.Ldc_I4_3;  						instr.Operand = null;  						break;    					case 4:  						instr.OpCode = OpCodes.Ldc_I4_4;  						instr.Operand = null;  						break;    					case 5:  						instr.OpCode = OpCodes.Ldc_I4_5;  						instr.Operand = null;  						break;    					case 6:  						instr.OpCode = OpCodes.Ldc_I4_6;  						instr.Operand = null;  						break;    					case 7:  						instr.OpCode = OpCodes.Ldc_I4_7;  						instr.Operand = null;  						break;    					case 8:  						instr.OpCode = OpCodes.Ldc_I4_8;  						instr.Operand = null;  						break;    					case -1:  						instr.OpCode = OpCodes.Ldc_I4_M1;  						instr.Operand = null;  						break;    					default:  						if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  							instr.OpCode = OpCodes.Ldc_I4_S;  							instr.Operand = (sbyte)i4;  						}  						break;  					}  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Ldloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Ldloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Ldloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Ldloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloc_S;  					break;    				case Code.Ldloca:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloca_S;  					break;    				case Code.Starg:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Starg_S;  					break;    				case Code.Stloc:  				case Code.Stloc_S:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Stloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Stloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Stloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Stloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Stloc_S;  					break;  				}
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  				case Code.Ldarg:  				case Code.Ldarg_S:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (arg.Index == 0) {  						instr.OpCode = OpCodes.Ldarg_0;  						instr.Operand = null;  					}  					else if (arg.Index == 1) {  						instr.OpCode = OpCodes.Ldarg_1;  						instr.Operand = null;  					}  					else if (arg.Index == 2) {  						instr.OpCode = OpCodes.Ldarg_2;  						instr.Operand = null;  					}  					else if (arg.Index == 3) {  						instr.OpCode = OpCodes.Ldarg_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarg_S;  					break;    				case Code.Ldarga:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarga_S;  					break;    				case Code.Ldc_I4:  				case Code.Ldc_I4_S:  					int i4;  					if (instr.Operand is int)  						i4 = (int)instr.Operand;  					else if (instr.Operand is sbyte)  						i4 = (sbyte)instr.Operand;  					else  						break;  					switch (i4) {  					case 0:  						instr.OpCode = OpCodes.Ldc_I4_0;  						instr.Operand = null;  						break;    					case 1:  						instr.OpCode = OpCodes.Ldc_I4_1;  						instr.Operand = null;  						break;    					case 2:  						instr.OpCode = OpCodes.Ldc_I4_2;  						instr.Operand = null;  						break;    					case 3:  						instr.OpCode = OpCodes.Ldc_I4_3;  						instr.Operand = null;  						break;    					case 4:  						instr.OpCode = OpCodes.Ldc_I4_4;  						instr.Operand = null;  						break;    					case 5:  						instr.OpCode = OpCodes.Ldc_I4_5;  						instr.Operand = null;  						break;    					case 6:  						instr.OpCode = OpCodes.Ldc_I4_6;  						instr.Operand = null;  						break;    					case 7:  						instr.OpCode = OpCodes.Ldc_I4_7;  						instr.Operand = null;  						break;    					case 8:  						instr.OpCode = OpCodes.Ldc_I4_8;  						instr.Operand = null;  						break;    					case -1:  						instr.OpCode = OpCodes.Ldc_I4_M1;  						instr.Operand = null;  						break;    					default:  						if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  							instr.OpCode = OpCodes.Ldc_I4_S;  							instr.Operand = (sbyte)i4;  						}  						break;  					}  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Ldloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Ldloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Ldloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Ldloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloc_S;  					break;    				case Code.Ldloca:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloca_S;  					break;    				case Code.Starg:  					arg = instr.Operand as Parameter;  					if (arg is null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Starg_S;  					break;    				case Code.Stloc:  				case Code.Stloc_S:  					local = instr.Operand as Local;  					if (local is null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Stloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Stloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Stloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Stloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Stloc_S;  					break;  				}
Magic Number,dnlib.DotNet.Emit,OpCode,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\OpCode.cs,OpCode,The following statement contains a magic number: ((ushort)code >> 8) == 0
Magic Number,dnlib.DotNet.MD,ColumnInfo,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\ColumnInfo.cs,Read,The following statement contains a magic number: switch (size) {  			case 1: return reader.ReadByte();  			case 2: return reader.ReadUInt16();  			case 4: return reader.ReadUInt32();  			default: throw new InvalidOperationException("Invalid column size");  			}
Magic Number,dnlib.DotNet.MD,ColumnInfo,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\ColumnInfo.cs,Read,The following statement contains a magic number: switch (size) {  			case 1: return reader.ReadByte();  			case 2: return reader.ReadUInt16();  			case 4: return reader.ReadUInt32();  			default: throw new InvalidOperationException("Invalid column size");  			}
Magic Number,dnlib.DotNet.MD,ColumnInfo,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\ColumnInfo.cs,Unsafe_Read24,The following statement contains a magic number: Debug.Assert(size == 2 || size == 4);
Magic Number,dnlib.DotNet.MD,ColumnInfo,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\ColumnInfo.cs,Unsafe_Read24,The following statement contains a magic number: Debug.Assert(size == 2 || size == 4);
Magic Number,dnlib.DotNet.MD,ColumnInfo,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\ColumnInfo.cs,Unsafe_Read24,The following statement contains a magic number: return size == 2 ? reader.Unsafe_ReadUInt16() : reader.Unsafe_ReadUInt32();
Magic Number,dnlib.DotNet.MD,ColumnInfo,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\ColumnInfo.cs,Write,The following statement contains a magic number: switch (size) {  			case 1: writer.WriteByte((byte)value); break;  			case 2: writer.WriteUInt16((ushort)value); break;  			case 4: writer.WriteUInt32(value); break;  			default: throw new InvalidOperationException("Invalid column size");  			}
Magic Number,dnlib.DotNet.MD,ColumnInfo,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\ColumnInfo.cs,Write,The following statement contains a magic number: switch (size) {  			case 1: writer.WriteByte((byte)value); break;  			case 2: writer.WriteUInt16((ushort)value); break;  			case 4: writer.WriteUInt32(value); break;  			default: throw new InvalidOperationException("Invalid column size");  			}
Magic Number,dnlib.DotNet.MD,ColumnInfo,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\ColumnInfo.cs,Write24,The following statement contains a magic number: Debug.Assert(size == 2 || size == 4);
Magic Number,dnlib.DotNet.MD,ColumnInfo,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\ColumnInfo.cs,Write24,The following statement contains a magic number: Debug.Assert(size == 2 || size == 4);
Magic Number,dnlib.DotNet.MD,ColumnInfo,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\ColumnInfo.cs,Write24,The following statement contains a magic number: size == 2
Magic Number,dnlib.DotNet.MD,CompressedMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\CompressedMetadata.cs,BinarySearch,The following statement contains a magic number: uint rid = (ridLo + ridHi) / 2;
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: return count > 0xFFFF ? 4 : 2;
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: return count > 0xFFFF ? 4 : 2;
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Module] = new TableInfo(Table.Module' "Module"' new ColumnInfo[] {  				new ColumnInfo(0' "Generation"' ColumnSize.UInt16)'  				new ColumnInfo(1' "Name"' ColumnSize.Strings)'  				new ColumnInfo(2' "Mvid"' ColumnSize.GUID)'  				new ColumnInfo(3' "EncId"' ColumnSize.GUID)'  				new ColumnInfo(4' "EncBaseId"' ColumnSize.GUID)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Module] = new TableInfo(Table.Module' "Module"' new ColumnInfo[] {  				new ColumnInfo(0' "Generation"' ColumnSize.UInt16)'  				new ColumnInfo(1' "Name"' ColumnSize.Strings)'  				new ColumnInfo(2' "Mvid"' ColumnSize.GUID)'  				new ColumnInfo(3' "EncId"' ColumnSize.GUID)'  				new ColumnInfo(4' "EncBaseId"' ColumnSize.GUID)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Module] = new TableInfo(Table.Module' "Module"' new ColumnInfo[] {  				new ColumnInfo(0' "Generation"' ColumnSize.UInt16)'  				new ColumnInfo(1' "Name"' ColumnSize.Strings)'  				new ColumnInfo(2' "Mvid"' ColumnSize.GUID)'  				new ColumnInfo(3' "EncId"' ColumnSize.GUID)'  				new ColumnInfo(4' "EncBaseId"' ColumnSize.GUID)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.TypeRef] = new TableInfo(Table.TypeRef' "TypeRef"' new ColumnInfo[] {  				new ColumnInfo(0' "ResolutionScope"' ColumnSize.ResolutionScope)'  				new ColumnInfo(1' "Name"' ColumnSize.Strings)'  				new ColumnInfo(2' "Namespace"' ColumnSize.Strings)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.TypeDef] = new TableInfo(Table.TypeDef' "TypeDef"' new ColumnInfo[] {  				new ColumnInfo(0' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(1' "Name"' ColumnSize.Strings)'  				new ColumnInfo(2' "Namespace"' ColumnSize.Strings)'  				new ColumnInfo(3' "Extends"' ColumnSize.TypeDefOrRef)'  				new ColumnInfo(4' "FieldList"' ColumnSize.Field)'  				new ColumnInfo(5' "MethodList"' ColumnSize.Method)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.TypeDef] = new TableInfo(Table.TypeDef' "TypeDef"' new ColumnInfo[] {  				new ColumnInfo(0' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(1' "Name"' ColumnSize.Strings)'  				new ColumnInfo(2' "Namespace"' ColumnSize.Strings)'  				new ColumnInfo(3' "Extends"' ColumnSize.TypeDefOrRef)'  				new ColumnInfo(4' "FieldList"' ColumnSize.Field)'  				new ColumnInfo(5' "MethodList"' ColumnSize.Method)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.TypeDef] = new TableInfo(Table.TypeDef' "TypeDef"' new ColumnInfo[] {  				new ColumnInfo(0' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(1' "Name"' ColumnSize.Strings)'  				new ColumnInfo(2' "Namespace"' ColumnSize.Strings)'  				new ColumnInfo(3' "Extends"' ColumnSize.TypeDefOrRef)'  				new ColumnInfo(4' "FieldList"' ColumnSize.Field)'  				new ColumnInfo(5' "MethodList"' ColumnSize.Method)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.TypeDef] = new TableInfo(Table.TypeDef' "TypeDef"' new ColumnInfo[] {  				new ColumnInfo(0' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(1' "Name"' ColumnSize.Strings)'  				new ColumnInfo(2' "Namespace"' ColumnSize.Strings)'  				new ColumnInfo(3' "Extends"' ColumnSize.TypeDefOrRef)'  				new ColumnInfo(4' "FieldList"' ColumnSize.Field)'  				new ColumnInfo(5' "MethodList"' ColumnSize.Method)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Field] = new TableInfo(Table.Field' "Field"' new ColumnInfo[] {  				new ColumnInfo(0' "Flags"' ColumnSize.UInt16)'  				new ColumnInfo(1' "Name"' ColumnSize.Strings)'  				new ColumnInfo(2' "Signature"' ColumnSize.Blob)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Method] = new TableInfo(Table.Method' "Method"' new ColumnInfo[] {  				new ColumnInfo(0' "RVA"' ColumnSize.UInt32)'  				new ColumnInfo(1' "ImplFlags"' ColumnSize.UInt16)'  				new ColumnInfo(2' "Flags"' ColumnSize.UInt16)'  				new ColumnInfo(3' "Name"' ColumnSize.Strings)'  				new ColumnInfo(4' "Signature"' ColumnSize.Blob)'  				new ColumnInfo(5' "ParamList"' ColumnSize.Param)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Method] = new TableInfo(Table.Method' "Method"' new ColumnInfo[] {  				new ColumnInfo(0' "RVA"' ColumnSize.UInt32)'  				new ColumnInfo(1' "ImplFlags"' ColumnSize.UInt16)'  				new ColumnInfo(2' "Flags"' ColumnSize.UInt16)'  				new ColumnInfo(3' "Name"' ColumnSize.Strings)'  				new ColumnInfo(4' "Signature"' ColumnSize.Blob)'  				new ColumnInfo(5' "ParamList"' ColumnSize.Param)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Method] = new TableInfo(Table.Method' "Method"' new ColumnInfo[] {  				new ColumnInfo(0' "RVA"' ColumnSize.UInt32)'  				new ColumnInfo(1' "ImplFlags"' ColumnSize.UInt16)'  				new ColumnInfo(2' "Flags"' ColumnSize.UInt16)'  				new ColumnInfo(3' "Name"' ColumnSize.Strings)'  				new ColumnInfo(4' "Signature"' ColumnSize.Blob)'  				new ColumnInfo(5' "ParamList"' ColumnSize.Param)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Method] = new TableInfo(Table.Method' "Method"' new ColumnInfo[] {  				new ColumnInfo(0' "RVA"' ColumnSize.UInt32)'  				new ColumnInfo(1' "ImplFlags"' ColumnSize.UInt16)'  				new ColumnInfo(2' "Flags"' ColumnSize.UInt16)'  				new ColumnInfo(3' "Name"' ColumnSize.Strings)'  				new ColumnInfo(4' "Signature"' ColumnSize.Blob)'  				new ColumnInfo(5' "ParamList"' ColumnSize.Param)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Param] = new TableInfo(Table.Param' "Param"' new ColumnInfo[] {  				new ColumnInfo(0' "Flags"' ColumnSize.UInt16)'  				new ColumnInfo(1' "Sequence"' ColumnSize.UInt16)'  				new ColumnInfo(2' "Name"' ColumnSize.Strings)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.MemberRef] = new TableInfo(Table.MemberRef' "MemberRef"' new ColumnInfo[] {  				new ColumnInfo(0' "Class"' ColumnSize.MemberRefParent)'  				new ColumnInfo(1' "Name"' ColumnSize.Strings)'  				new ColumnInfo(2' "Signature"' ColumnSize.Blob)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Constant] = new TableInfo(Table.Constant' "Constant"' new ColumnInfo[] {  				new ColumnInfo(0' "Type"' ColumnSize.Byte)'  				new ColumnInfo(1' "Padding"' ColumnSize.Byte)'  				new ColumnInfo(2' "Parent"' ColumnSize.HasConstant)'  				new ColumnInfo(3' "Value"' ColumnSize.Blob)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Constant] = new TableInfo(Table.Constant' "Constant"' new ColumnInfo[] {  				new ColumnInfo(0' "Type"' ColumnSize.Byte)'  				new ColumnInfo(1' "Padding"' ColumnSize.Byte)'  				new ColumnInfo(2' "Parent"' ColumnSize.HasConstant)'  				new ColumnInfo(3' "Value"' ColumnSize.Blob)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.CustomAttribute] = new TableInfo(Table.CustomAttribute' "CustomAttribute"' new ColumnInfo[] {  				new ColumnInfo(0' "Parent"' ColumnSize.HasCustomAttribute)'  				new ColumnInfo(1' "Type"' ColumnSize.CustomAttributeType)'  				new ColumnInfo(2' "Value"' ColumnSize.Blob)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.DeclSecurity] = new TableInfo(Table.DeclSecurity' "DeclSecurity"' new ColumnInfo[] {  				new ColumnInfo(0' "Action"' ColumnSize.Int16)'  				new ColumnInfo(1' "Parent"' ColumnSize.HasDeclSecurity)'  				new ColumnInfo(2' "PermissionSet"' ColumnSize.Blob)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.ClassLayout] = new TableInfo(Table.ClassLayout' "ClassLayout"' new ColumnInfo[] {  				new ColumnInfo(0' "PackingSize"' ColumnSize.UInt16)'  				new ColumnInfo(1' "ClassSize"' ColumnSize.UInt32)'  				new ColumnInfo(2' "Parent"' ColumnSize.TypeDef)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Event] = new TableInfo(Table.Event' "Event"' new ColumnInfo[] {  				new ColumnInfo(0' "EventFlags"' ColumnSize.UInt16)'  				new ColumnInfo(1' "Name"' ColumnSize.Strings)'  				new ColumnInfo(2' "EventType"' ColumnSize.TypeDefOrRef)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Property] = new TableInfo(Table.Property' "Property"' new ColumnInfo[] {  				new ColumnInfo(0' "PropFlags"' ColumnSize.UInt16)'  				new ColumnInfo(1' "Name"' ColumnSize.Strings)'  				new ColumnInfo(2' "Type"' ColumnSize.Blob)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.MethodSemantics] = new TableInfo(Table.MethodSemantics' "MethodSemantics"' new ColumnInfo[] {  				new ColumnInfo(0' "Semantic"' ColumnSize.UInt16)'  				new ColumnInfo(1' "Method"' ColumnSize.Method)'  				new ColumnInfo(2' "Association"' ColumnSize.HasSemantic)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.MethodImpl] = new TableInfo(Table.MethodImpl' "MethodImpl"' new ColumnInfo[] {  				new ColumnInfo(0' "Class"' ColumnSize.TypeDef)'  				new ColumnInfo(1' "MethodBody"' ColumnSize.MethodDefOrRef)'  				new ColumnInfo(2' "MethodDeclaration"' ColumnSize.MethodDefOrRef)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.ImplMap] = new TableInfo(Table.ImplMap' "ImplMap"' new ColumnInfo[] {  				new ColumnInfo(0' "MappingFlags"' ColumnSize.UInt16)'  				new ColumnInfo(1' "MemberForwarded"' ColumnSize.MemberForwarded)'  				new ColumnInfo(2' "ImportName"' ColumnSize.Strings)'  				new ColumnInfo(3' "ImportScope"' ColumnSize.ModuleRef)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.ImplMap] = new TableInfo(Table.ImplMap' "ImplMap"' new ColumnInfo[] {  				new ColumnInfo(0' "MappingFlags"' ColumnSize.UInt16)'  				new ColumnInfo(1' "MemberForwarded"' ColumnSize.MemberForwarded)'  				new ColumnInfo(2' "ImportName"' ColumnSize.Strings)'  				new ColumnInfo(3' "ImportScope"' ColumnSize.ModuleRef)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Assembly] = new TableInfo(Table.Assembly' "Assembly"' new ColumnInfo[] {  				new ColumnInfo(0' "HashAlgId"' ColumnSize.UInt32)'  				new ColumnInfo(1' "MajorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(2' "MinorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(3' "BuildNumber"' ColumnSize.UInt16)'  				new ColumnInfo(4' "RevisionNumber"' ColumnSize.UInt16)'  				new ColumnInfo(5' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(6' "PublicKey"' ColumnSize.Blob)'  				new ColumnInfo(7' "Name"' ColumnSize.Strings)'  				new ColumnInfo(8' "Locale"' ColumnSize.Strings)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Assembly] = new TableInfo(Table.Assembly' "Assembly"' new ColumnInfo[] {  				new ColumnInfo(0' "HashAlgId"' ColumnSize.UInt32)'  				new ColumnInfo(1' "MajorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(2' "MinorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(3' "BuildNumber"' ColumnSize.UInt16)'  				new ColumnInfo(4' "RevisionNumber"' ColumnSize.UInt16)'  				new ColumnInfo(5' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(6' "PublicKey"' ColumnSize.Blob)'  				new ColumnInfo(7' "Name"' ColumnSize.Strings)'  				new ColumnInfo(8' "Locale"' ColumnSize.Strings)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Assembly] = new TableInfo(Table.Assembly' "Assembly"' new ColumnInfo[] {  				new ColumnInfo(0' "HashAlgId"' ColumnSize.UInt32)'  				new ColumnInfo(1' "MajorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(2' "MinorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(3' "BuildNumber"' ColumnSize.UInt16)'  				new ColumnInfo(4' "RevisionNumber"' ColumnSize.UInt16)'  				new ColumnInfo(5' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(6' "PublicKey"' ColumnSize.Blob)'  				new ColumnInfo(7' "Name"' ColumnSize.Strings)'  				new ColumnInfo(8' "Locale"' ColumnSize.Strings)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Assembly] = new TableInfo(Table.Assembly' "Assembly"' new ColumnInfo[] {  				new ColumnInfo(0' "HashAlgId"' ColumnSize.UInt32)'  				new ColumnInfo(1' "MajorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(2' "MinorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(3' "BuildNumber"' ColumnSize.UInt16)'  				new ColumnInfo(4' "RevisionNumber"' ColumnSize.UInt16)'  				new ColumnInfo(5' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(6' "PublicKey"' ColumnSize.Blob)'  				new ColumnInfo(7' "Name"' ColumnSize.Strings)'  				new ColumnInfo(8' "Locale"' ColumnSize.Strings)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Assembly] = new TableInfo(Table.Assembly' "Assembly"' new ColumnInfo[] {  				new ColumnInfo(0' "HashAlgId"' ColumnSize.UInt32)'  				new ColumnInfo(1' "MajorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(2' "MinorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(3' "BuildNumber"' ColumnSize.UInt16)'  				new ColumnInfo(4' "RevisionNumber"' ColumnSize.UInt16)'  				new ColumnInfo(5' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(6' "PublicKey"' ColumnSize.Blob)'  				new ColumnInfo(7' "Name"' ColumnSize.Strings)'  				new ColumnInfo(8' "Locale"' ColumnSize.Strings)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Assembly] = new TableInfo(Table.Assembly' "Assembly"' new ColumnInfo[] {  				new ColumnInfo(0' "HashAlgId"' ColumnSize.UInt32)'  				new ColumnInfo(1' "MajorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(2' "MinorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(3' "BuildNumber"' ColumnSize.UInt16)'  				new ColumnInfo(4' "RevisionNumber"' ColumnSize.UInt16)'  				new ColumnInfo(5' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(6' "PublicKey"' ColumnSize.Blob)'  				new ColumnInfo(7' "Name"' ColumnSize.Strings)'  				new ColumnInfo(8' "Locale"' ColumnSize.Strings)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Assembly] = new TableInfo(Table.Assembly' "Assembly"' new ColumnInfo[] {  				new ColumnInfo(0' "HashAlgId"' ColumnSize.UInt32)'  				new ColumnInfo(1' "MajorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(2' "MinorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(3' "BuildNumber"' ColumnSize.UInt16)'  				new ColumnInfo(4' "RevisionNumber"' ColumnSize.UInt16)'  				new ColumnInfo(5' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(6' "PublicKey"' ColumnSize.Blob)'  				new ColumnInfo(7' "Name"' ColumnSize.Strings)'  				new ColumnInfo(8' "Locale"' ColumnSize.Strings)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.AssemblyOS] = new TableInfo(Table.AssemblyOS' "AssemblyOS"' new ColumnInfo[] {  				new ColumnInfo(0' "OSPlatformId"' ColumnSize.UInt32)'  				new ColumnInfo(1' "OSMajorVersion"' ColumnSize.UInt32)'  				new ColumnInfo(2' "OSMinorVersion"' ColumnSize.UInt32)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.AssemblyRef] = new TableInfo(Table.AssemblyRef' "AssemblyRef"' new ColumnInfo[] {  				new ColumnInfo(0' "MajorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(1' "MinorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(2' "BuildNumber"' ColumnSize.UInt16)'  				new ColumnInfo(3' "RevisionNumber"' ColumnSize.UInt16)'  				new ColumnInfo(4' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(5' "PublicKeyOrToken"' ColumnSize.Blob)'  				new ColumnInfo(6' "Name"' ColumnSize.Strings)'  				new ColumnInfo(7' "Locale"' ColumnSize.Strings)'  				new ColumnInfo(8' "HashValue"' ColumnSize.Blob)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.AssemblyRef] = new TableInfo(Table.AssemblyRef' "AssemblyRef"' new ColumnInfo[] {  				new ColumnInfo(0' "MajorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(1' "MinorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(2' "BuildNumber"' ColumnSize.UInt16)'  				new ColumnInfo(3' "RevisionNumber"' ColumnSize.UInt16)'  				new ColumnInfo(4' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(5' "PublicKeyOrToken"' ColumnSize.Blob)'  				new ColumnInfo(6' "Name"' ColumnSize.Strings)'  				new ColumnInfo(7' "Locale"' ColumnSize.Strings)'  				new ColumnInfo(8' "HashValue"' ColumnSize.Blob)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.AssemblyRef] = new TableInfo(Table.AssemblyRef' "AssemblyRef"' new ColumnInfo[] {  				new ColumnInfo(0' "MajorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(1' "MinorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(2' "BuildNumber"' ColumnSize.UInt16)'  				new ColumnInfo(3' "RevisionNumber"' ColumnSize.UInt16)'  				new ColumnInfo(4' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(5' "PublicKeyOrToken"' ColumnSize.Blob)'  				new ColumnInfo(6' "Name"' ColumnSize.Strings)'  				new ColumnInfo(7' "Locale"' ColumnSize.Strings)'  				new ColumnInfo(8' "HashValue"' ColumnSize.Blob)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.AssemblyRef] = new TableInfo(Table.AssemblyRef' "AssemblyRef"' new ColumnInfo[] {  				new ColumnInfo(0' "MajorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(1' "MinorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(2' "BuildNumber"' ColumnSize.UInt16)'  				new ColumnInfo(3' "RevisionNumber"' ColumnSize.UInt16)'  				new ColumnInfo(4' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(5' "PublicKeyOrToken"' ColumnSize.Blob)'  				new ColumnInfo(6' "Name"' ColumnSize.Strings)'  				new ColumnInfo(7' "Locale"' ColumnSize.Strings)'  				new ColumnInfo(8' "HashValue"' ColumnSize.Blob)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.AssemblyRef] = new TableInfo(Table.AssemblyRef' "AssemblyRef"' new ColumnInfo[] {  				new ColumnInfo(0' "MajorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(1' "MinorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(2' "BuildNumber"' ColumnSize.UInt16)'  				new ColumnInfo(3' "RevisionNumber"' ColumnSize.UInt16)'  				new ColumnInfo(4' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(5' "PublicKeyOrToken"' ColumnSize.Blob)'  				new ColumnInfo(6' "Name"' ColumnSize.Strings)'  				new ColumnInfo(7' "Locale"' ColumnSize.Strings)'  				new ColumnInfo(8' "HashValue"' ColumnSize.Blob)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.AssemblyRef] = new TableInfo(Table.AssemblyRef' "AssemblyRef"' new ColumnInfo[] {  				new ColumnInfo(0' "MajorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(1' "MinorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(2' "BuildNumber"' ColumnSize.UInt16)'  				new ColumnInfo(3' "RevisionNumber"' ColumnSize.UInt16)'  				new ColumnInfo(4' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(5' "PublicKeyOrToken"' ColumnSize.Blob)'  				new ColumnInfo(6' "Name"' ColumnSize.Strings)'  				new ColumnInfo(7' "Locale"' ColumnSize.Strings)'  				new ColumnInfo(8' "HashValue"' ColumnSize.Blob)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.AssemblyRef] = new TableInfo(Table.AssemblyRef' "AssemblyRef"' new ColumnInfo[] {  				new ColumnInfo(0' "MajorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(1' "MinorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(2' "BuildNumber"' ColumnSize.UInt16)'  				new ColumnInfo(3' "RevisionNumber"' ColumnSize.UInt16)'  				new ColumnInfo(4' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(5' "PublicKeyOrToken"' ColumnSize.Blob)'  				new ColumnInfo(6' "Name"' ColumnSize.Strings)'  				new ColumnInfo(7' "Locale"' ColumnSize.Strings)'  				new ColumnInfo(8' "HashValue"' ColumnSize.Blob)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.AssemblyRefOS] = new TableInfo(Table.AssemblyRefOS' "AssemblyRefOS"' new ColumnInfo[] {  				new ColumnInfo(0' "OSPlatformId"' ColumnSize.UInt32)'  				new ColumnInfo(1' "OSMajorVersion"' ColumnSize.UInt32)'  				new ColumnInfo(2' "OSMinorVersion"' ColumnSize.UInt32)'  				new ColumnInfo(3' "AssemblyRef"' ColumnSize.AssemblyRef)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.AssemblyRefOS] = new TableInfo(Table.AssemblyRefOS' "AssemblyRefOS"' new ColumnInfo[] {  				new ColumnInfo(0' "OSPlatformId"' ColumnSize.UInt32)'  				new ColumnInfo(1' "OSMajorVersion"' ColumnSize.UInt32)'  				new ColumnInfo(2' "OSMinorVersion"' ColumnSize.UInt32)'  				new ColumnInfo(3' "AssemblyRef"' ColumnSize.AssemblyRef)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.File] = new TableInfo(Table.File' "File"' new ColumnInfo[] {  				new ColumnInfo(0' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(1' "Name"' ColumnSize.Strings)'  				new ColumnInfo(2' "HashValue"' ColumnSize.Blob)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.ExportedType] = new TableInfo(Table.ExportedType' "ExportedType"' new ColumnInfo[] {  				new ColumnInfo(0' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(1' "TypeDefId"' ColumnSize.UInt32)'  				new ColumnInfo(2' "TypeName"' ColumnSize.Strings)'  				new ColumnInfo(3' "TypeNamespace"' ColumnSize.Strings)'  				new ColumnInfo(4' "Implementation"' ColumnSize.Implementation)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.ExportedType] = new TableInfo(Table.ExportedType' "ExportedType"' new ColumnInfo[] {  				new ColumnInfo(0' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(1' "TypeDefId"' ColumnSize.UInt32)'  				new ColumnInfo(2' "TypeName"' ColumnSize.Strings)'  				new ColumnInfo(3' "TypeNamespace"' ColumnSize.Strings)'  				new ColumnInfo(4' "Implementation"' ColumnSize.Implementation)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.ExportedType] = new TableInfo(Table.ExportedType' "ExportedType"' new ColumnInfo[] {  				new ColumnInfo(0' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(1' "TypeDefId"' ColumnSize.UInt32)'  				new ColumnInfo(2' "TypeName"' ColumnSize.Strings)'  				new ColumnInfo(3' "TypeNamespace"' ColumnSize.Strings)'  				new ColumnInfo(4' "Implementation"' ColumnSize.Implementation)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.ManifestResource] = new TableInfo(Table.ManifestResource' "ManifestResource"' new ColumnInfo[] {  				new ColumnInfo(0' "Offset"' ColumnSize.UInt32)'  				new ColumnInfo(1' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(2' "Name"' ColumnSize.Strings)'  				new ColumnInfo(3' "Implementation"' ColumnSize.Implementation)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.ManifestResource] = new TableInfo(Table.ManifestResource' "ManifestResource"' new ColumnInfo[] {  				new ColumnInfo(0' "Offset"' ColumnSize.UInt32)'  				new ColumnInfo(1' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(2' "Name"' ColumnSize.Strings)'  				new ColumnInfo(3' "Implementation"' ColumnSize.Implementation)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.GenericParam] = new TableInfo(Table.GenericParam' "GenericParam"' new ColumnInfo[] {  					new ColumnInfo(0' "Number"' ColumnSize.UInt16)'  					new ColumnInfo(1' "Flags"' ColumnSize.UInt16)'  					new ColumnInfo(2' "Owner"' ColumnSize.TypeOrMethodDef)'  					new ColumnInfo(3' "Name"' ColumnSize.Strings)'  					new ColumnInfo(4' "Kind"' ColumnSize.TypeDefOrRef)'  				});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.GenericParam] = new TableInfo(Table.GenericParam' "GenericParam"' new ColumnInfo[] {  					new ColumnInfo(0' "Number"' ColumnSize.UInt16)'  					new ColumnInfo(1' "Flags"' ColumnSize.UInt16)'  					new ColumnInfo(2' "Owner"' ColumnSize.TypeOrMethodDef)'  					new ColumnInfo(3' "Name"' ColumnSize.Strings)'  					new ColumnInfo(4' "Kind"' ColumnSize.TypeDefOrRef)'  				});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.GenericParam] = new TableInfo(Table.GenericParam' "GenericParam"' new ColumnInfo[] {  					new ColumnInfo(0' "Number"' ColumnSize.UInt16)'  					new ColumnInfo(1' "Flags"' ColumnSize.UInt16)'  					new ColumnInfo(2' "Owner"' ColumnSize.TypeOrMethodDef)'  					new ColumnInfo(3' "Name"' ColumnSize.Strings)'  					new ColumnInfo(4' "Kind"' ColumnSize.TypeDefOrRef)'  				});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Document] = new TableInfo(Table.Document' "Document"' new ColumnInfo[] {  				new ColumnInfo(0' "Name"' ColumnSize.Blob)'  				new ColumnInfo(1' "HashAlgorithm"' ColumnSize.GUID)'  				new ColumnInfo(2' "Hash"' ColumnSize.Blob)'  				new ColumnInfo(3' "Language"' ColumnSize.GUID)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Document] = new TableInfo(Table.Document' "Document"' new ColumnInfo[] {  				new ColumnInfo(0' "Name"' ColumnSize.Blob)'  				new ColumnInfo(1' "HashAlgorithm"' ColumnSize.GUID)'  				new ColumnInfo(2' "Hash"' ColumnSize.Blob)'  				new ColumnInfo(3' "Language"' ColumnSize.GUID)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.LocalScope] = new TableInfo(Table.LocalScope' "LocalScope"' new ColumnInfo[] {  				new ColumnInfo(0' "Method"' ColumnSize.Method)'  				new ColumnInfo(1' "ImportScope"' ColumnSize.ImportScope)'  				new ColumnInfo(2' "VariableList"' ColumnSize.LocalVariable)'  				new ColumnInfo(3' "ConstantList"' ColumnSize.LocalConstant)'  				new ColumnInfo(4' "StartOffset"' ColumnSize.UInt32)'  				new ColumnInfo(5' "Length"' ColumnSize.UInt32)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.LocalScope] = new TableInfo(Table.LocalScope' "LocalScope"' new ColumnInfo[] {  				new ColumnInfo(0' "Method"' ColumnSize.Method)'  				new ColumnInfo(1' "ImportScope"' ColumnSize.ImportScope)'  				new ColumnInfo(2' "VariableList"' ColumnSize.LocalVariable)'  				new ColumnInfo(3' "ConstantList"' ColumnSize.LocalConstant)'  				new ColumnInfo(4' "StartOffset"' ColumnSize.UInt32)'  				new ColumnInfo(5' "Length"' ColumnSize.UInt32)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.LocalScope] = new TableInfo(Table.LocalScope' "LocalScope"' new ColumnInfo[] {  				new ColumnInfo(0' "Method"' ColumnSize.Method)'  				new ColumnInfo(1' "ImportScope"' ColumnSize.ImportScope)'  				new ColumnInfo(2' "VariableList"' ColumnSize.LocalVariable)'  				new ColumnInfo(3' "ConstantList"' ColumnSize.LocalConstant)'  				new ColumnInfo(4' "StartOffset"' ColumnSize.UInt32)'  				new ColumnInfo(5' "Length"' ColumnSize.UInt32)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.LocalScope] = new TableInfo(Table.LocalScope' "LocalScope"' new ColumnInfo[] {  				new ColumnInfo(0' "Method"' ColumnSize.Method)'  				new ColumnInfo(1' "ImportScope"' ColumnSize.ImportScope)'  				new ColumnInfo(2' "VariableList"' ColumnSize.LocalVariable)'  				new ColumnInfo(3' "ConstantList"' ColumnSize.LocalConstant)'  				new ColumnInfo(4' "StartOffset"' ColumnSize.UInt32)'  				new ColumnInfo(5' "Length"' ColumnSize.UInt32)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.LocalVariable] = new TableInfo(Table.LocalVariable' "LocalVariable"' new ColumnInfo[] {  				new ColumnInfo(0' "Attributes"' ColumnSize.UInt16)'  				new ColumnInfo(1' "Index"' ColumnSize.UInt16)'  				new ColumnInfo(2' "Name"' ColumnSize.Strings)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.CustomDebugInformation] = new TableInfo(Table.CustomDebugInformation' "CustomDebugInformation"' new ColumnInfo[] {  				new ColumnInfo(0' "Parent"' ColumnSize.HasCustomDebugInformation)'  				new ColumnInfo(1' "Kind"' ColumnSize.GUID)'  				new ColumnInfo(2' "Value"' ColumnSize.Blob)'  			});
Magic Number,dnlib.DotNet.MD,ENCMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\ENCMetadata.cs,GetFieldRidList,The following statement contains a magic number: var list = GetRidList(tablesStream.TypeDefTable' typeDefRid' 4' tablesStream.FieldTable);
Magic Number,dnlib.DotNet.MD,ENCMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\ENCMetadata.cs,GetMethodRidList,The following statement contains a magic number: var list = GetRidList(tablesStream.TypeDefTable' typeDefRid' 5' tablesStream.MethodTable);
Magic Number,dnlib.DotNet.MD,ENCMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\ENCMetadata.cs,GetParamRidList,The following statement contains a magic number: var list = GetRidList(tablesStream.MethodTable' methodRid' 5' tablesStream.ParamTable);
Magic Number,dnlib.DotNet.MD,ENCMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\ENCMetadata.cs,BinarySearch,The following statement contains a magic number: uint rid = (ridLo + ridHi) / 2;
Magic Number,dnlib.DotNet.MD,GuidStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\GuidStream.cs,Read,The following statement contains a magic number: reader.Position = (index - 1) * 16;
Magic Number,dnlib.DotNet.MD,MDTable,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MDTable.cs,MDTable,The following statement contains a magic number: Column2 = columns[2];
Magic Number,dnlib.DotNet.MD,MDTable,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MDTable.cs,MDTable,The following statement contains a magic number: length > 2
Magic Number,dnlib.DotNet.MD,MDTable,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MDTable.cs,MDTable,The following statement contains a magic number: Column3 = columns[3];
Magic Number,dnlib.DotNet.MD,MDTable,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MDTable.cs,MDTable,The following statement contains a magic number: length > 3
Magic Number,dnlib.DotNet.MD,MDTable,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MDTable.cs,MDTable,The following statement contains a magic number: Column4 = columns[4];
Magic Number,dnlib.DotNet.MD,MDTable,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MDTable.cs,MDTable,The following statement contains a magic number: length > 4
Magic Number,dnlib.DotNet.MD,MDTable,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MDTable.cs,MDTable,The following statement contains a magic number: Column5 = columns[5];
Magic Number,dnlib.DotNet.MD,MDTable,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MDTable.cs,MDTable,The following statement contains a magic number: length > 5
Magic Number,dnlib.DotNet.MD,MDTable,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MDTable.cs,MDTable,The following statement contains a magic number: Column6 = columns[6];
Magic Number,dnlib.DotNet.MD,MDTable,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MDTable.cs,MDTable,The following statement contains a magic number: length > 6
Magic Number,dnlib.DotNet.MD,MDTable,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MDTable.cs,MDTable,The following statement contains a magic number: Column7 = columns[7];
Magic Number,dnlib.DotNet.MD,MDTable,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MDTable.cs,MDTable,The following statement contains a magic number: length > 7
Magic Number,dnlib.DotNet.MD,MDTable,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MDTable.cs,MDTable,The following statement contains a magic number: Column8 = columns[8];
Magic Number,dnlib.DotNet.MD,MDTable,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MDTable.cs,MDTable,The following statement contains a magic number: length > 8
Magic Number,dnlib.DotNet.MD,MetadataBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MetadataBase.cs,GetGenericParamRidList,The following statement contains a magic number: return FindAllRowsUnsorted(tablesStream.GenericParamTable' 2' codedToken);
Magic Number,dnlib.DotNet.MD,MetadataBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MetadataBase.cs,GetMethodSemanticsRidList,The following statement contains a magic number: return FindAllRowsUnsorted(tablesStream.MethodSemanticsTable' 2' codedToken);
Magic Number,dnlib.DotNet.MD,MetadataBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MetadataBase.cs,GetClassLayoutRid,The following statement contains a magic number: var list = FindAllRowsUnsorted(tablesStream.ClassLayoutTable' 2' typeDefRid);
Magic Number,dnlib.DotNet.MD,MetadataBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MetadataBase.cs,GetConstantRid,The following statement contains a magic number: var list = FindAllRowsUnsorted(tablesStream.ConstantTable' 2' codedToken);
Magic Number,dnlib.DotNet.MD,MetadataBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MetadataBase.cs,InitializeInverseGenericParamOwnerRidList,The following statement contains a magic number: var ownerCol = gpTable.TableInfo.Columns[2];
Magic Number,dnlib.DotNet.MD,SortedTable,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MetadataBase.cs,InitializeKeys,The following statement contains a magic number: Debug.Assert(keyColumn.Size == 2 || keyColumn.Size == 4);
Magic Number,dnlib.DotNet.MD,SortedTable,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MetadataBase.cs,InitializeKeys,The following statement contains a magic number: Debug.Assert(keyColumn.Size == 2 || keyColumn.Size == 4);
Magic Number,dnlib.DotNet.MD,SortedTable,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MetadataBase.cs,BinarySearch,The following statement contains a magic number: int curr = (lo + hi) / 2;
Magic Number,dnlib.DotNet.MD,MetadataFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MetadataFactory.cs,Create,The following statement contains a magic number: var dotNetDir = peImage.ImageNTHeaders.OptionalHeader.DataDirectories[14];
Magic Number,dnlib.DotNet.MD,MetadataHeader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MetadataHeader.cs,ReadString,The following statement contains a magic number: endOffset = (endOffset + 3) / 4 * 4;
Magic Number,dnlib.DotNet.MD,MetadataHeader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MetadataHeader.cs,ReadString,The following statement contains a magic number: endOffset = (endOffset + 3) / 4 * 4;
Magic Number,dnlib.DotNet.MD,MetadataHeader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\MetadataHeader.cs,ReadString,The following statement contains a magic number: endOffset = (endOffset + 3) / 4 * 4;
Magic Number,dnlib.DotNet.MD,PdbStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\PdbStream.cs,PdbStream,The following statement contains a magic number: Id = reader.ReadBytes(20);
Magic Number,dnlib.DotNet.MD,PdbStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\PdbStream.cs,PdbStream,The following statement contains a magic number: var rows = new uint[64];
Magic Number,dnlib.DotNet.MD,StreamHeader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\StreamHeader.cs,StreamHeader,The following statement contains a magic number: name = ReadString(ref reader' 32' verify' ref failedVerification);
Magic Number,dnlib.DotNet.MD,StreamHeader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\StreamHeader.cs,ReadString,The following statement contains a magic number: reader.Position = origPos + (((uint)i + 1 + 3) & ~3U);
Magic Number,dnlib.DotNet.MD,StreamHeader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\StreamHeader.cs,ReadString,The following statement contains a magic number: reader.Position = origPos + (((uint)i + 1 + 3) & ~3U);
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\TablesStream.cs,Initialize,The following statement contains a magic number: var sizes = new uint[64];
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\TablesStream.cs,Initialize,The following statement contains a magic number: i < 64
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\TablesStream.cs,Initialize,The following statement contains a magic number: i < 64
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\TablesStream.cs,IsSorted,The following statement contains a magic number: (uint)index >= 64
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\TablesStream.cs,TryReadColumn24,The following statement contains a magic number: Debug.Assert(column.Size == 2 || column.Size == 4);
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\TablesStream.cs,TryReadColumn24,The following statement contains a magic number: Debug.Assert(column.Size == 2 || column.Size == 4);
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\TablesStream.cs,TryReadColumn24,The following statement contains a magic number: value = column.Size == 2 ? reader.Unsafe_ReadUInt16() : reader.Unsafe_ReadUInt32();
Magic Number,dnlib.DotNet.MD,USStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\USStream.cs,Read,The following statement contains a magic number: return reader.ReadUtf16String((int)(length / 2));
Magic Number,dnlib.DotNet.Pdb,PdbReaderContext,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\PdbReaderContext.cs,TryGetCodeViewData,The following statement contains a magic number: reader.Length < 4 + 16 + 4 + 1
Magic Number,dnlib.DotNet.Pdb,PdbReaderContext,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\PdbReaderContext.cs,TryGetCodeViewData,The following statement contains a magic number: reader.Length < 4 + 16 + 4 + 1
Magic Number,dnlib.DotNet.Pdb,PdbReaderContext,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\PdbReaderContext.cs,TryGetCodeViewData,The following statement contains a magic number: reader.Length < 4 + 16 + 4 + 1
Magic Number,dnlib.DotNet.Pdb,SymbolReaderFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\SymbolReaderFactory.cs,CreateManagedCore,The following statement contains a magic number: reader.Length >= 4
Magic Number,dnlib.DotNet.Pdb.Dss,MDEmitter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MDEmitter.cs,GetMethodProps,The following statement contains a magic number: (mb >> 24) != 0x06
Magic Number,dnlib.DotNet.Pdb.Dss,MDEmitter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MDEmitter.cs,GetTypeDefProps,The following statement contains a magic number: (td >> 24) != 0x02
Magic Number,dnlib.DotNet.Pdb.Dss,MDEmitter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\MDEmitter.cs,GetNestedClassProps,The following statement contains a magic number: (tdNestedClass >> 24) != 0x02
Magic Number,dnlib.DotNet.Pdb.Dss,StreamIStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\StreamIStream.cs,Stat,The following statement contains a magic number: s.grfMode = 2;
Magic Number,dnlib.DotNet.Pdb.Dss,SymbolWriterImpl,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\SymbolWriterImpl.cs,GetDebugInfo,The following statement contains a magic number: var guidBytes = new byte[16];
Magic Number,dnlib.DotNet.Pdb.Dss,SymbolWriterImpl,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\SymbolWriterImpl.cs,GetDebugInfo,The following statement contains a magic number: Array.Copy(codeViewData' 4' guidBytes' 0' 16);
Magic Number,dnlib.DotNet.Pdb.Dss,SymbolWriterImpl,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\SymbolWriterImpl.cs,GetDebugInfo,The following statement contains a magic number: Array.Copy(codeViewData' 4' guidBytes' 0' 16);
Magic Number,dnlib.DotNet.Pdb.Managed,DbiFunction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiFunction.cs,Read,The following statement contains a magic number: reader.Position += 4;
Magic Number,dnlib.DotNet.Pdb.Managed,DbiFunction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiFunction.cs,Read,The following statement contains a magic number: reader.Position += 4;
Magic Number,dnlib.DotNet.Pdb.Managed,DbiFunction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiFunction.cs,Read,The following statement contains a magic number: reader.Position += 8;
Magic Number,dnlib.DotNet.Pdb.Managed,DbiFunction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiFunction.cs,Read,The following statement contains a magic number: reader.Position += 1 + 2;
Magic Number,dnlib.DotNet.Pdb.Managed,DbiFunction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiFunction.cs,CreateSymbolAsyncStepInfos,The following statement contains a magic number: data is null || data.Length < 12
Magic Number,dnlib.DotNet.Pdb.Managed,DbiFunction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiFunction.cs,CreateSymbolAsyncStepInfos,The following statement contains a magic number: int pos = 8;
Magic Number,dnlib.DotNet.Pdb.Managed,DbiFunction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiFunction.cs,CreateSymbolAsyncStepInfos,The following statement contains a magic number: pos += 4;
Magic Number,dnlib.DotNet.Pdb.Managed,DbiFunction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiFunction.cs,CreateSymbolAsyncStepInfos,The following statement contains a magic number: pos + (long)count * 12 > data.Length
Magic Number,dnlib.DotNet.Pdb.Managed,DbiFunction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiFunction.cs,CreateSymbolAsyncStepInfos,The following statement contains a magic number: res[i] = new SymbolAsyncStepInfo(BitConverter.ToUInt32(data' pos)' BitConverter.ToUInt32(data' pos + 8)' BitConverter.ToUInt32(data' pos + 4));
Magic Number,dnlib.DotNet.Pdb.Managed,DbiFunction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiFunction.cs,CreateSymbolAsyncStepInfos,The following statement contains a magic number: res[i] = new SymbolAsyncStepInfo(BitConverter.ToUInt32(data' pos)' BitConverter.ToUInt32(data' pos + 8)' BitConverter.ToUInt32(data' pos + 4));
Magic Number,dnlib.DotNet.Pdb.Managed,DbiFunction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiFunction.cs,CreateSymbolAsyncStepInfos,The following statement contains a magic number: pos += 12;
Magic Number,dnlib.DotNet.Pdb.Managed,DbiModule,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiModule.cs,Read,The following statement contains a magic number: reader.Position += 34;
Magic Number,dnlib.DotNet.Pdb.Managed,DbiModule,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiModule.cs,Read,The following statement contains a magic number: reader.Position += 16;
Magic Number,dnlib.DotNet.Pdb.Managed,DbiModule,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiModule.cs,Read,The following statement contains a magic number: reader.Position = (reader.Position + 3) & (~3U);
Magic Number,dnlib.DotNet.Pdb.Managed,DbiModule,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiModule.cs,Read,The following statement contains a magic number: reader.Position = (reader.Position + 3) & (~3U);
Magic Number,dnlib.DotNet.Pdb.Managed,DbiModule,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiModule.cs,ReadFunctions,The following statement contains a magic number: reader.ReadUInt32() != 4
Magic Number,dnlib.DotNet.Pdb.Managed,DbiModule,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiModule.cs,ReadLines,The following statement contains a magic number: var end = (begin + size + 3) & ~3U;
Magic Number,dnlib.DotNet.Pdb.Managed,DbiModule,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiModule.cs,ReadLines,The following statement contains a magic number: var end = (begin + size + 3) & ~3U;
Magic Number,dnlib.DotNet.Pdb.Managed,DbiModule,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiModule.cs,ReadFiles,The following statement contains a magic number: reader.Position = (reader.Position + 3) & (~3U);
Magic Number,dnlib.DotNet.Pdb.Managed,DbiModule,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiModule.cs,ReadFiles,The following statement contains a magic number: reader.Position = (reader.Position + 3) & (~3U);
Magic Number,dnlib.DotNet.Pdb.Managed,DbiModule,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiModule.cs,ReadLines,The following statement contains a magic number: reader.Position += 4;
Magic Number,dnlib.DotNet.Pdb.Managed,DbiModule,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiModule.cs,ReadLines,The following statement contains a magic number: reader.Position += 4;
Magic Number,dnlib.DotNet.Pdb.Managed,DbiModule,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiModule.cs,ReadLines,The following statement contains a magic number: const int LINE_ENTRY_SIZE = 8;
Magic Number,dnlib.DotNet.Pdb.Managed,DbiModule,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiModule.cs,ReadLines,The following statement contains a magic number: const int COL_ENTRY_SIZE = 4;
Magic Number,dnlib.DotNet.Pdb.Managed,DbiModule,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiModule.cs,ReadLines,The following statement contains a magic number: line.EndLine = line.Line + (int)((lineFlags >> 24) & 0x7F);
Magic Number,dnlib.DotNet.Pdb.Managed,DbiScope,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiScope.cs,Read,The following statement contains a magic number: switch (type) {  					case SymbolType.S_BLOCK32: {  						reader.Position += 4;  						childEnd = reader.ReadUInt32();  						var len = reader.ReadUInt32();  						var addr = PdbAddress.ReadAddress(ref reader);  						name = PdbReader.ReadCString(ref reader);  						child = new DbiScope(method' this' name' addr.Offset' len);  						break;  					}  					case SymbolType.S_UNAMESPACE:  						namespacesList.Add(new DbiNamespace(PdbReader.ReadCString(ref reader)));  						break;  					case SymbolType.S_MANSLOT: {  						var variable = new DbiVariable();  						if (variable.Read(ref reader))  							localsList.Add(variable);  						break;  					}  					case SymbolType.S_OEM:  						if ((ulong)reader.Position + 20 > end)  							break;  						if (!ReadAndCompareBytes(ref reader' end' dotNetOemGuid)) {  							Debug.Fail("Unknown OEM record GUID' not .NET GUID");  							break;  						}  						reader.Position += 4;// typeIndex or 0  						name = ReadUnicodeString(ref reader' end);  						Debug.Assert(!(name is null));  						if (name is null)  							break;  						var data = reader.ReadBytes((int)(end - reader.Position));  						if (oemInfos is null)  							oemInfos = new List<OemInfo>(1);  						oemInfos.Add(new OemInfo(name' data));	  						break;  					case SymbolType.S_MANCONSTANT:  						uint signatureToken = reader.ReadUInt32();  						object value;  						if (!NumericReader.TryReadNumeric(ref reader' end' out value))  							break;  						name = PdbReader.ReadCString(ref reader);  						if (constants is null)  							constants = new List<ConstantInfo>();  						constants.Add(new ConstantInfo(name' signatureToken' value));  						break;  					case SymbolType.S_END:  						break;  					default:  						break;  				}
Magic Number,dnlib.DotNet.Pdb.Managed,DbiScope,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiScope.cs,Read,The following statement contains a magic number: switch (type) {  					case SymbolType.S_BLOCK32: {  						reader.Position += 4;  						childEnd = reader.ReadUInt32();  						var len = reader.ReadUInt32();  						var addr = PdbAddress.ReadAddress(ref reader);  						name = PdbReader.ReadCString(ref reader);  						child = new DbiScope(method' this' name' addr.Offset' len);  						break;  					}  					case SymbolType.S_UNAMESPACE:  						namespacesList.Add(new DbiNamespace(PdbReader.ReadCString(ref reader)));  						break;  					case SymbolType.S_MANSLOT: {  						var variable = new DbiVariable();  						if (variable.Read(ref reader))  							localsList.Add(variable);  						break;  					}  					case SymbolType.S_OEM:  						if ((ulong)reader.Position + 20 > end)  							break;  						if (!ReadAndCompareBytes(ref reader' end' dotNetOemGuid)) {  							Debug.Fail("Unknown OEM record GUID' not .NET GUID");  							break;  						}  						reader.Position += 4;// typeIndex or 0  						name = ReadUnicodeString(ref reader' end);  						Debug.Assert(!(name is null));  						if (name is null)  							break;  						var data = reader.ReadBytes((int)(end - reader.Position));  						if (oemInfos is null)  							oemInfos = new List<OemInfo>(1);  						oemInfos.Add(new OemInfo(name' data));	  						break;  					case SymbolType.S_MANCONSTANT:  						uint signatureToken = reader.ReadUInt32();  						object value;  						if (!NumericReader.TryReadNumeric(ref reader' end' out value))  							break;  						name = PdbReader.ReadCString(ref reader);  						if (constants is null)  							constants = new List<ConstantInfo>();  						constants.Add(new ConstantInfo(name' signatureToken' value));  						break;  					case SymbolType.S_END:  						break;  					default:  						break;  				}
Magic Number,dnlib.DotNet.Pdb.Managed,DbiScope,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiScope.cs,Read,The following statement contains a magic number: switch (type) {  					case SymbolType.S_BLOCK32: {  						reader.Position += 4;  						childEnd = reader.ReadUInt32();  						var len = reader.ReadUInt32();  						var addr = PdbAddress.ReadAddress(ref reader);  						name = PdbReader.ReadCString(ref reader);  						child = new DbiScope(method' this' name' addr.Offset' len);  						break;  					}  					case SymbolType.S_UNAMESPACE:  						namespacesList.Add(new DbiNamespace(PdbReader.ReadCString(ref reader)));  						break;  					case SymbolType.S_MANSLOT: {  						var variable = new DbiVariable();  						if (variable.Read(ref reader))  							localsList.Add(variable);  						break;  					}  					case SymbolType.S_OEM:  						if ((ulong)reader.Position + 20 > end)  							break;  						if (!ReadAndCompareBytes(ref reader' end' dotNetOemGuid)) {  							Debug.Fail("Unknown OEM record GUID' not .NET GUID");  							break;  						}  						reader.Position += 4;// typeIndex or 0  						name = ReadUnicodeString(ref reader' end);  						Debug.Assert(!(name is null));  						if (name is null)  							break;  						var data = reader.ReadBytes((int)(end - reader.Position));  						if (oemInfos is null)  							oemInfos = new List<OemInfo>(1);  						oemInfos.Add(new OemInfo(name' data));	  						break;  					case SymbolType.S_MANCONSTANT:  						uint signatureToken = reader.ReadUInt32();  						object value;  						if (!NumericReader.TryReadNumeric(ref reader' end' out value))  							break;  						name = PdbReader.ReadCString(ref reader);  						if (constants is null)  							constants = new List<ConstantInfo>();  						constants.Add(new ConstantInfo(name' signatureToken' value));  						break;  					case SymbolType.S_END:  						break;  					default:  						break;  				}
Magic Number,dnlib.DotNet.Pdb.Managed,DbiScope,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiScope.cs,ReadUnicodeString,The following statement contains a magic number: (ulong)reader.Position + 2 > end
Magic Number,dnlib.DotNet.Pdb.Managed,DbiVariable,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiVariable.cs,Read,The following statement contains a magic number: reader.Position += 10;
Magic Number,dnlib.DotNet.Pdb.Managed,DbiVariable,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\DbiVariable.cs,GetAttributes,The following statement contains a magic number: const int fCompGenx = 4;
Magic Number,dnlib.DotNet.Pdb.Managed,NumericReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\NumericReader.cs,TryReadNumeric,The following statement contains a magic number: position + 2 > end
Magic Number,dnlib.DotNet.Pdb.Managed,NumericReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\NumericReader.cs,TryReadNumeric,The following statement contains a magic number: switch (numLeaf) {  			case NumericLeaf.LF_CHAR:  				if (position > end)  					return false;  				value = reader.ReadSByte();  				return true;    			case NumericLeaf.LF_SHORT:  				if (position + 2 > end)  					return false;  				value = reader.ReadInt16();  				return true;    			case NumericLeaf.LF_USHORT:  				if (position + 2 > end)  					return false;  				value = reader.ReadUInt16();  				return true;    			case NumericLeaf.LF_LONG:  				if (position + 4 > end)  					return false;  				value = reader.ReadInt32();  				return true;    			case NumericLeaf.LF_ULONG:  				if (position + 4 > end)  					return false;  				value = reader.ReadUInt32();  				return true;    			case NumericLeaf.LF_REAL32:  				if (position + 4 > end)  					return false;  				value = reader.ReadSingle();  				return true;    			case NumericLeaf.LF_REAL64:  				if (position + 8 > end)  					return false;  				value = reader.ReadDouble();  				return true;    			case NumericLeaf.LF_QUADWORD:  				if (position + 8 > end)  					return false;  				value = reader.ReadInt64();  				return true;    			case NumericLeaf.LF_UQUADWORD:  				if (position + 8 > end)  					return false;  				value = reader.ReadUInt64();  				return true;    			case NumericLeaf.LF_VARSTRING:  				if (position + 2 > end)  					return false;  				int varStrLen = reader.ReadUInt16();  				if (position + (uint)varStrLen > end)  					return false;  				value = reader.ReadUtf8String(varStrLen);  				return true;    			case NumericLeaf.LF_VARIANT:  				if (position + 0x10 > end)  					return false;  				int v0 = reader.ReadInt32();  				int v1 = reader.ReadInt32();  				int v2 = reader.ReadInt32();  				int v3 = reader.ReadInt32();  				byte scale = (byte)(v0 >> 16);  				if (scale <= 28)  					value = new decimal(v2' v3' v1' v0 < 0' scale);  				else  					value = null;  				return true;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Pdb.Managed,NumericReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\NumericReader.cs,TryReadNumeric,The following statement contains a magic number: switch (numLeaf) {  			case NumericLeaf.LF_CHAR:  				if (position > end)  					return false;  				value = reader.ReadSByte();  				return true;    			case NumericLeaf.LF_SHORT:  				if (position + 2 > end)  					return false;  				value = reader.ReadInt16();  				return true;    			case NumericLeaf.LF_USHORT:  				if (position + 2 > end)  					return false;  				value = reader.ReadUInt16();  				return true;    			case NumericLeaf.LF_LONG:  				if (position + 4 > end)  					return false;  				value = reader.ReadInt32();  				return true;    			case NumericLeaf.LF_ULONG:  				if (position + 4 > end)  					return false;  				value = reader.ReadUInt32();  				return true;    			case NumericLeaf.LF_REAL32:  				if (position + 4 > end)  					return false;  				value = reader.ReadSingle();  				return true;    			case NumericLeaf.LF_REAL64:  				if (position + 8 > end)  					return false;  				value = reader.ReadDouble();  				return true;    			case NumericLeaf.LF_QUADWORD:  				if (position + 8 > end)  					return false;  				value = reader.ReadInt64();  				return true;    			case NumericLeaf.LF_UQUADWORD:  				if (position + 8 > end)  					return false;  				value = reader.ReadUInt64();  				return true;    			case NumericLeaf.LF_VARSTRING:  				if (position + 2 > end)  					return false;  				int varStrLen = reader.ReadUInt16();  				if (position + (uint)varStrLen > end)  					return false;  				value = reader.ReadUtf8String(varStrLen);  				return true;    			case NumericLeaf.LF_VARIANT:  				if (position + 0x10 > end)  					return false;  				int v0 = reader.ReadInt32();  				int v1 = reader.ReadInt32();  				int v2 = reader.ReadInt32();  				int v3 = reader.ReadInt32();  				byte scale = (byte)(v0 >> 16);  				if (scale <= 28)  					value = new decimal(v2' v3' v1' v0 < 0' scale);  				else  					value = null;  				return true;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Pdb.Managed,NumericReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\NumericReader.cs,TryReadNumeric,The following statement contains a magic number: switch (numLeaf) {  			case NumericLeaf.LF_CHAR:  				if (position > end)  					return false;  				value = reader.ReadSByte();  				return true;    			case NumericLeaf.LF_SHORT:  				if (position + 2 > end)  					return false;  				value = reader.ReadInt16();  				return true;    			case NumericLeaf.LF_USHORT:  				if (position + 2 > end)  					return false;  				value = reader.ReadUInt16();  				return true;    			case NumericLeaf.LF_LONG:  				if (position + 4 > end)  					return false;  				value = reader.ReadInt32();  				return true;    			case NumericLeaf.LF_ULONG:  				if (position + 4 > end)  					return false;  				value = reader.ReadUInt32();  				return true;    			case NumericLeaf.LF_REAL32:  				if (position + 4 > end)  					return false;  				value = reader.ReadSingle();  				return true;    			case NumericLeaf.LF_REAL64:  				if (position + 8 > end)  					return false;  				value = reader.ReadDouble();  				return true;    			case NumericLeaf.LF_QUADWORD:  				if (position + 8 > end)  					return false;  				value = reader.ReadInt64();  				return true;    			case NumericLeaf.LF_UQUADWORD:  				if (position + 8 > end)  					return false;  				value = reader.ReadUInt64();  				return true;    			case NumericLeaf.LF_VARSTRING:  				if (position + 2 > end)  					return false;  				int varStrLen = reader.ReadUInt16();  				if (position + (uint)varStrLen > end)  					return false;  				value = reader.ReadUtf8String(varStrLen);  				return true;    			case NumericLeaf.LF_VARIANT:  				if (position + 0x10 > end)  					return false;  				int v0 = reader.ReadInt32();  				int v1 = reader.ReadInt32();  				int v2 = reader.ReadInt32();  				int v3 = reader.ReadInt32();  				byte scale = (byte)(v0 >> 16);  				if (scale <= 28)  					value = new decimal(v2' v3' v1' v0 < 0' scale);  				else  					value = null;  				return true;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Pdb.Managed,NumericReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\NumericReader.cs,TryReadNumeric,The following statement contains a magic number: switch (numLeaf) {  			case NumericLeaf.LF_CHAR:  				if (position > end)  					return false;  				value = reader.ReadSByte();  				return true;    			case NumericLeaf.LF_SHORT:  				if (position + 2 > end)  					return false;  				value = reader.ReadInt16();  				return true;    			case NumericLeaf.LF_USHORT:  				if (position + 2 > end)  					return false;  				value = reader.ReadUInt16();  				return true;    			case NumericLeaf.LF_LONG:  				if (position + 4 > end)  					return false;  				value = reader.ReadInt32();  				return true;    			case NumericLeaf.LF_ULONG:  				if (position + 4 > end)  					return false;  				value = reader.ReadUInt32();  				return true;    			case NumericLeaf.LF_REAL32:  				if (position + 4 > end)  					return false;  				value = reader.ReadSingle();  				return true;    			case NumericLeaf.LF_REAL64:  				if (position + 8 > end)  					return false;  				value = reader.ReadDouble();  				return true;    			case NumericLeaf.LF_QUADWORD:  				if (position + 8 > end)  					return false;  				value = reader.ReadInt64();  				return true;    			case NumericLeaf.LF_UQUADWORD:  				if (position + 8 > end)  					return false;  				value = reader.ReadUInt64();  				return true;    			case NumericLeaf.LF_VARSTRING:  				if (position + 2 > end)  					return false;  				int varStrLen = reader.ReadUInt16();  				if (position + (uint)varStrLen > end)  					return false;  				value = reader.ReadUtf8String(varStrLen);  				return true;    			case NumericLeaf.LF_VARIANT:  				if (position + 0x10 > end)  					return false;  				int v0 = reader.ReadInt32();  				int v1 = reader.ReadInt32();  				int v2 = reader.ReadInt32();  				int v3 = reader.ReadInt32();  				byte scale = (byte)(v0 >> 16);  				if (scale <= 28)  					value = new decimal(v2' v3' v1' v0 < 0' scale);  				else  					value = null;  				return true;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Pdb.Managed,NumericReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\NumericReader.cs,TryReadNumeric,The following statement contains a magic number: switch (numLeaf) {  			case NumericLeaf.LF_CHAR:  				if (position > end)  					return false;  				value = reader.ReadSByte();  				return true;    			case NumericLeaf.LF_SHORT:  				if (position + 2 > end)  					return false;  				value = reader.ReadInt16();  				return true;    			case NumericLeaf.LF_USHORT:  				if (position + 2 > end)  					return false;  				value = reader.ReadUInt16();  				return true;    			case NumericLeaf.LF_LONG:  				if (position + 4 > end)  					return false;  				value = reader.ReadInt32();  				return true;    			case NumericLeaf.LF_ULONG:  				if (position + 4 > end)  					return false;  				value = reader.ReadUInt32();  				return true;    			case NumericLeaf.LF_REAL32:  				if (position + 4 > end)  					return false;  				value = reader.ReadSingle();  				return true;    			case NumericLeaf.LF_REAL64:  				if (position + 8 > end)  					return false;  				value = reader.ReadDouble();  				return true;    			case NumericLeaf.LF_QUADWORD:  				if (position + 8 > end)  					return false;  				value = reader.ReadInt64();  				return true;    			case NumericLeaf.LF_UQUADWORD:  				if (position + 8 > end)  					return false;  				value = reader.ReadUInt64();  				return true;    			case NumericLeaf.LF_VARSTRING:  				if (position + 2 > end)  					return false;  				int varStrLen = reader.ReadUInt16();  				if (position + (uint)varStrLen > end)  					return false;  				value = reader.ReadUtf8String(varStrLen);  				return true;    			case NumericLeaf.LF_VARIANT:  				if (position + 0x10 > end)  					return false;  				int v0 = reader.ReadInt32();  				int v1 = reader.ReadInt32();  				int v2 = reader.ReadInt32();  				int v3 = reader.ReadInt32();  				byte scale = (byte)(v0 >> 16);  				if (scale <= 28)  					value = new decimal(v2' v3' v1' v0 < 0' scale);  				else  					value = null;  				return true;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Pdb.Managed,NumericReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\NumericReader.cs,TryReadNumeric,The following statement contains a magic number: switch (numLeaf) {  			case NumericLeaf.LF_CHAR:  				if (position > end)  					return false;  				value = reader.ReadSByte();  				return true;    			case NumericLeaf.LF_SHORT:  				if (position + 2 > end)  					return false;  				value = reader.ReadInt16();  				return true;    			case NumericLeaf.LF_USHORT:  				if (position + 2 > end)  					return false;  				value = reader.ReadUInt16();  				return true;    			case NumericLeaf.LF_LONG:  				if (position + 4 > end)  					return false;  				value = reader.ReadInt32();  				return true;    			case NumericLeaf.LF_ULONG:  				if (position + 4 > end)  					return false;  				value = reader.ReadUInt32();  				return true;    			case NumericLeaf.LF_REAL32:  				if (position + 4 > end)  					return false;  				value = reader.ReadSingle();  				return true;    			case NumericLeaf.LF_REAL64:  				if (position + 8 > end)  					return false;  				value = reader.ReadDouble();  				return true;    			case NumericLeaf.LF_QUADWORD:  				if (position + 8 > end)  					return false;  				value = reader.ReadInt64();  				return true;    			case NumericLeaf.LF_UQUADWORD:  				if (position + 8 > end)  					return false;  				value = reader.ReadUInt64();  				return true;    			case NumericLeaf.LF_VARSTRING:  				if (position + 2 > end)  					return false;  				int varStrLen = reader.ReadUInt16();  				if (position + (uint)varStrLen > end)  					return false;  				value = reader.ReadUtf8String(varStrLen);  				return true;    			case NumericLeaf.LF_VARIANT:  				if (position + 0x10 > end)  					return false;  				int v0 = reader.ReadInt32();  				int v1 = reader.ReadInt32();  				int v2 = reader.ReadInt32();  				int v3 = reader.ReadInt32();  				byte scale = (byte)(v0 >> 16);  				if (scale <= 28)  					value = new decimal(v2' v3' v1' v0 < 0' scale);  				else  					value = null;  				return true;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Pdb.Managed,NumericReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\NumericReader.cs,TryReadNumeric,The following statement contains a magic number: switch (numLeaf) {  			case NumericLeaf.LF_CHAR:  				if (position > end)  					return false;  				value = reader.ReadSByte();  				return true;    			case NumericLeaf.LF_SHORT:  				if (position + 2 > end)  					return false;  				value = reader.ReadInt16();  				return true;    			case NumericLeaf.LF_USHORT:  				if (position + 2 > end)  					return false;  				value = reader.ReadUInt16();  				return true;    			case NumericLeaf.LF_LONG:  				if (position + 4 > end)  					return false;  				value = reader.ReadInt32();  				return true;    			case NumericLeaf.LF_ULONG:  				if (position + 4 > end)  					return false;  				value = reader.ReadUInt32();  				return true;    			case NumericLeaf.LF_REAL32:  				if (position + 4 > end)  					return false;  				value = reader.ReadSingle();  				return true;    			case NumericLeaf.LF_REAL64:  				if (position + 8 > end)  					return false;  				value = reader.ReadDouble();  				return true;    			case NumericLeaf.LF_QUADWORD:  				if (position + 8 > end)  					return false;  				value = reader.ReadInt64();  				return true;    			case NumericLeaf.LF_UQUADWORD:  				if (position + 8 > end)  					return false;  				value = reader.ReadUInt64();  				return true;    			case NumericLeaf.LF_VARSTRING:  				if (position + 2 > end)  					return false;  				int varStrLen = reader.ReadUInt16();  				if (position + (uint)varStrLen > end)  					return false;  				value = reader.ReadUtf8String(varStrLen);  				return true;    			case NumericLeaf.LF_VARIANT:  				if (position + 0x10 > end)  					return false;  				int v0 = reader.ReadInt32();  				int v1 = reader.ReadInt32();  				int v2 = reader.ReadInt32();  				int v3 = reader.ReadInt32();  				byte scale = (byte)(v0 >> 16);  				if (scale <= 28)  					value = new decimal(v2' v3' v1' v0 < 0' scale);  				else  					value = null;  				return true;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Pdb.Managed,NumericReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\NumericReader.cs,TryReadNumeric,The following statement contains a magic number: switch (numLeaf) {  			case NumericLeaf.LF_CHAR:  				if (position > end)  					return false;  				value = reader.ReadSByte();  				return true;    			case NumericLeaf.LF_SHORT:  				if (position + 2 > end)  					return false;  				value = reader.ReadInt16();  				return true;    			case NumericLeaf.LF_USHORT:  				if (position + 2 > end)  					return false;  				value = reader.ReadUInt16();  				return true;    			case NumericLeaf.LF_LONG:  				if (position + 4 > end)  					return false;  				value = reader.ReadInt32();  				return true;    			case NumericLeaf.LF_ULONG:  				if (position + 4 > end)  					return false;  				value = reader.ReadUInt32();  				return true;    			case NumericLeaf.LF_REAL32:  				if (position + 4 > end)  					return false;  				value = reader.ReadSingle();  				return true;    			case NumericLeaf.LF_REAL64:  				if (position + 8 > end)  					return false;  				value = reader.ReadDouble();  				return true;    			case NumericLeaf.LF_QUADWORD:  				if (position + 8 > end)  					return false;  				value = reader.ReadInt64();  				return true;    			case NumericLeaf.LF_UQUADWORD:  				if (position + 8 > end)  					return false;  				value = reader.ReadUInt64();  				return true;    			case NumericLeaf.LF_VARSTRING:  				if (position + 2 > end)  					return false;  				int varStrLen = reader.ReadUInt16();  				if (position + (uint)varStrLen > end)  					return false;  				value = reader.ReadUtf8String(varStrLen);  				return true;    			case NumericLeaf.LF_VARIANT:  				if (position + 0x10 > end)  					return false;  				int v0 = reader.ReadInt32();  				int v1 = reader.ReadInt32();  				int v2 = reader.ReadInt32();  				int v3 = reader.ReadInt32();  				byte scale = (byte)(v0 >> 16);  				if (scale <= 28)  					value = new decimal(v2' v3' v1' v0 < 0' scale);  				else  					value = null;  				return true;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Pdb.Managed,NumericReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\NumericReader.cs,TryReadNumeric,The following statement contains a magic number: switch (numLeaf) {  			case NumericLeaf.LF_CHAR:  				if (position > end)  					return false;  				value = reader.ReadSByte();  				return true;    			case NumericLeaf.LF_SHORT:  				if (position + 2 > end)  					return false;  				value = reader.ReadInt16();  				return true;    			case NumericLeaf.LF_USHORT:  				if (position + 2 > end)  					return false;  				value = reader.ReadUInt16();  				return true;    			case NumericLeaf.LF_LONG:  				if (position + 4 > end)  					return false;  				value = reader.ReadInt32();  				return true;    			case NumericLeaf.LF_ULONG:  				if (position + 4 > end)  					return false;  				value = reader.ReadUInt32();  				return true;    			case NumericLeaf.LF_REAL32:  				if (position + 4 > end)  					return false;  				value = reader.ReadSingle();  				return true;    			case NumericLeaf.LF_REAL64:  				if (position + 8 > end)  					return false;  				value = reader.ReadDouble();  				return true;    			case NumericLeaf.LF_QUADWORD:  				if (position + 8 > end)  					return false;  				value = reader.ReadInt64();  				return true;    			case NumericLeaf.LF_UQUADWORD:  				if (position + 8 > end)  					return false;  				value = reader.ReadUInt64();  				return true;    			case NumericLeaf.LF_VARSTRING:  				if (position + 2 > end)  					return false;  				int varStrLen = reader.ReadUInt16();  				if (position + (uint)varStrLen > end)  					return false;  				value = reader.ReadUtf8String(varStrLen);  				return true;    			case NumericLeaf.LF_VARIANT:  				if (position + 0x10 > end)  					return false;  				int v0 = reader.ReadInt32();  				int v1 = reader.ReadInt32();  				int v2 = reader.ReadInt32();  				int v3 = reader.ReadInt32();  				byte scale = (byte)(v0 >> 16);  				if (scale <= 28)  					value = new decimal(v2' v3' v1' v0 < 0' scale);  				else  					value = null;  				return true;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Pdb.Managed,NumericReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\NumericReader.cs,TryReadNumeric,The following statement contains a magic number: switch (numLeaf) {  			case NumericLeaf.LF_CHAR:  				if (position > end)  					return false;  				value = reader.ReadSByte();  				return true;    			case NumericLeaf.LF_SHORT:  				if (position + 2 > end)  					return false;  				value = reader.ReadInt16();  				return true;    			case NumericLeaf.LF_USHORT:  				if (position + 2 > end)  					return false;  				value = reader.ReadUInt16();  				return true;    			case NumericLeaf.LF_LONG:  				if (position + 4 > end)  					return false;  				value = reader.ReadInt32();  				return true;    			case NumericLeaf.LF_ULONG:  				if (position + 4 > end)  					return false;  				value = reader.ReadUInt32();  				return true;    			case NumericLeaf.LF_REAL32:  				if (position + 4 > end)  					return false;  				value = reader.ReadSingle();  				return true;    			case NumericLeaf.LF_REAL64:  				if (position + 8 > end)  					return false;  				value = reader.ReadDouble();  				return true;    			case NumericLeaf.LF_QUADWORD:  				if (position + 8 > end)  					return false;  				value = reader.ReadInt64();  				return true;    			case NumericLeaf.LF_UQUADWORD:  				if (position + 8 > end)  					return false;  				value = reader.ReadUInt64();  				return true;    			case NumericLeaf.LF_VARSTRING:  				if (position + 2 > end)  					return false;  				int varStrLen = reader.ReadUInt16();  				if (position + (uint)varStrLen > end)  					return false;  				value = reader.ReadUtf8String(varStrLen);  				return true;    			case NumericLeaf.LF_VARIANT:  				if (position + 0x10 > end)  					return false;  				int v0 = reader.ReadInt32();  				int v1 = reader.ReadInt32();  				int v2 = reader.ReadInt32();  				int v3 = reader.ReadInt32();  				byte scale = (byte)(v0 >> 16);  				if (scale <= 28)  					value = new decimal(v2' v3' v1' v0 < 0' scale);  				else  					value = null;  				return true;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Pdb.Managed,NumericReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\NumericReader.cs,TryReadNumeric,The following statement contains a magic number: switch (numLeaf) {  			case NumericLeaf.LF_CHAR:  				if (position > end)  					return false;  				value = reader.ReadSByte();  				return true;    			case NumericLeaf.LF_SHORT:  				if (position + 2 > end)  					return false;  				value = reader.ReadInt16();  				return true;    			case NumericLeaf.LF_USHORT:  				if (position + 2 > end)  					return false;  				value = reader.ReadUInt16();  				return true;    			case NumericLeaf.LF_LONG:  				if (position + 4 > end)  					return false;  				value = reader.ReadInt32();  				return true;    			case NumericLeaf.LF_ULONG:  				if (position + 4 > end)  					return false;  				value = reader.ReadUInt32();  				return true;    			case NumericLeaf.LF_REAL32:  				if (position + 4 > end)  					return false;  				value = reader.ReadSingle();  				return true;    			case NumericLeaf.LF_REAL64:  				if (position + 8 > end)  					return false;  				value = reader.ReadDouble();  				return true;    			case NumericLeaf.LF_QUADWORD:  				if (position + 8 > end)  					return false;  				value = reader.ReadInt64();  				return true;    			case NumericLeaf.LF_UQUADWORD:  				if (position + 8 > end)  					return false;  				value = reader.ReadUInt64();  				return true;    			case NumericLeaf.LF_VARSTRING:  				if (position + 2 > end)  					return false;  				int varStrLen = reader.ReadUInt16();  				if (position + (uint)varStrLen > end)  					return false;  				value = reader.ReadUtf8String(varStrLen);  				return true;    			case NumericLeaf.LF_VARIANT:  				if (position + 0x10 > end)  					return false;  				int v0 = reader.ReadInt32();  				int v1 = reader.ReadInt32();  				int v2 = reader.ReadInt32();  				int v3 = reader.ReadInt32();  				byte scale = (byte)(v0 >> 16);  				if (scale <= 28)  					value = new decimal(v2' v3' v1' v0 < 0' scale);  				else  					value = null;  				return true;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Pdb.Managed,PdbReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\PdbReader.cs,ReadInternal,The following statement contains a magic number: string sig = reader.ReadString(30' Encoding.ASCII);
Magic Number,dnlib.DotNet.Pdb.Managed,PdbReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\PdbReader.cs,ReadInternal,The following statement contains a magic number: reader.Position += 2;
Magic Number,dnlib.DotNet.Pdb.Managed,PdbReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\PdbReader.cs,ReadInternal,The following statement contains a magic number: var numOfPtrPages = RoundUpDiv(numOfRootPages * 4' pageSize);
Magic Number,dnlib.DotNet.Pdb.Managed,PdbReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\PdbReader.cs,ReadNames,The following statement contains a magic number: stream.Position = 8;
Magic Number,dnlib.DotNet.Pdb.Managed,PdbReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\PdbReader.cs,ReadNames,The following statement contains a magic number: var entryOk = new BitArray(stream.ReadBytes(stream.ReadInt32() * 4));
Magic Number,dnlib.DotNet.Pdb.Managed,PdbReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\PdbReader.cs,ReadStringTable,The following statement contains a magic number: stream.Position = 8;
Magic Number,dnlib.DotNet.Pdb.Managed,PdbReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\PdbReader.cs,ReadModules,The following statement contains a magic number: stream.Position = 20;
Magic Number,dnlib.DotNet.Pdb.Managed,PdbReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\PdbReader.cs,ReadModules,The following statement contains a magic number: stream.Position += 2;
Magic Number,dnlib.DotNet.Pdb.Managed,PdbReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\PdbReader.cs,ReadModules,The following statement contains a magic number: stream.Position += 8;
Magic Number,dnlib.DotNet.Pdb.Managed,PdbReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\PdbReader.cs,ReadModules,The following statement contains a magic number: stream.Position += 12;
Magic Number,dnlib.DotNet.Pdb.Managed,PdbReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\PdbReader.cs,ReadGlobalSymbols,The following statement contains a magic number: reader.Position += 4;
Magic Number,dnlib.DotNet.Pdb.Managed,PdbReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\PdbReader.cs,ReadGlobalSymbols,The following statement contains a magic number: reader.Position += 2;
Magic Number,dnlib.DotNet.Pdb.Managed,PdbReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Managed\PdbReader.cs,ApplyRidMap,The following statement contains a magic number: var map = new uint[reader.Length / 4];
Magic Number,dnlib.DotNet.Pdb.Portable,DocumentNameReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\DocumentNameReader.cs,DocumentNameReader,The following statement contains a magic number: prevSepChars = new char[2];
Magic Number,dnlib.DotNet.Pdb.Portable,DocumentNameReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\DocumentNameReader.cs,DocumentNameReader,The following statement contains a magic number: prevSepCharBytes = new byte[3];
Magic Number,dnlib.DotNet.Pdb.Portable,ImportDefinitionKindUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\ImportDefinitionKindUtils.cs,ToPdbImportDefinitionKind,The following statement contains a magic number: switch (value) {  			case 1:		return PdbImportDefinitionKind.ImportNamespace;  			case 2:		return PdbImportDefinitionKind.ImportAssemblyNamespace;  			case 3:		return PdbImportDefinitionKind.ImportType;  			case 4:		return PdbImportDefinitionKind.ImportXmlNamespace;  			case 5:		return PdbImportDefinitionKind.ImportAssemblyReferenceAlias;  			case 6:		return PdbImportDefinitionKind.AliasAssemblyReference;  			case 7:		return PdbImportDefinitionKind.AliasNamespace;  			case 8:		return PdbImportDefinitionKind.AliasAssemblyNamespace;  			case 9:		return PdbImportDefinitionKind.AliasType;  			default:  				Debug.Fail("Unknown import definition kind: 0x" + value.ToString("X"));  				return UNKNOWN_IMPORT_KIND;  			}
Magic Number,dnlib.DotNet.Pdb.Portable,ImportDefinitionKindUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\ImportDefinitionKindUtils.cs,ToPdbImportDefinitionKind,The following statement contains a magic number: switch (value) {  			case 1:		return PdbImportDefinitionKind.ImportNamespace;  			case 2:		return PdbImportDefinitionKind.ImportAssemblyNamespace;  			case 3:		return PdbImportDefinitionKind.ImportType;  			case 4:		return PdbImportDefinitionKind.ImportXmlNamespace;  			case 5:		return PdbImportDefinitionKind.ImportAssemblyReferenceAlias;  			case 6:		return PdbImportDefinitionKind.AliasAssemblyReference;  			case 7:		return PdbImportDefinitionKind.AliasNamespace;  			case 8:		return PdbImportDefinitionKind.AliasAssemblyNamespace;  			case 9:		return PdbImportDefinitionKind.AliasType;  			default:  				Debug.Fail("Unknown import definition kind: 0x" + value.ToString("X"));  				return UNKNOWN_IMPORT_KIND;  			}
Magic Number,dnlib.DotNet.Pdb.Portable,ImportDefinitionKindUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\ImportDefinitionKindUtils.cs,ToPdbImportDefinitionKind,The following statement contains a magic number: switch (value) {  			case 1:		return PdbImportDefinitionKind.ImportNamespace;  			case 2:		return PdbImportDefinitionKind.ImportAssemblyNamespace;  			case 3:		return PdbImportDefinitionKind.ImportType;  			case 4:		return PdbImportDefinitionKind.ImportXmlNamespace;  			case 5:		return PdbImportDefinitionKind.ImportAssemblyReferenceAlias;  			case 6:		return PdbImportDefinitionKind.AliasAssemblyReference;  			case 7:		return PdbImportDefinitionKind.AliasNamespace;  			case 8:		return PdbImportDefinitionKind.AliasAssemblyNamespace;  			case 9:		return PdbImportDefinitionKind.AliasType;  			default:  				Debug.Fail("Unknown import definition kind: 0x" + value.ToString("X"));  				return UNKNOWN_IMPORT_KIND;  			}
Magic Number,dnlib.DotNet.Pdb.Portable,ImportDefinitionKindUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\ImportDefinitionKindUtils.cs,ToPdbImportDefinitionKind,The following statement contains a magic number: switch (value) {  			case 1:		return PdbImportDefinitionKind.ImportNamespace;  			case 2:		return PdbImportDefinitionKind.ImportAssemblyNamespace;  			case 3:		return PdbImportDefinitionKind.ImportType;  			case 4:		return PdbImportDefinitionKind.ImportXmlNamespace;  			case 5:		return PdbImportDefinitionKind.ImportAssemblyReferenceAlias;  			case 6:		return PdbImportDefinitionKind.AliasAssemblyReference;  			case 7:		return PdbImportDefinitionKind.AliasNamespace;  			case 8:		return PdbImportDefinitionKind.AliasAssemblyNamespace;  			case 9:		return PdbImportDefinitionKind.AliasType;  			default:  				Debug.Fail("Unknown import definition kind: 0x" + value.ToString("X"));  				return UNKNOWN_IMPORT_KIND;  			}
Magic Number,dnlib.DotNet.Pdb.Portable,ImportDefinitionKindUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\ImportDefinitionKindUtils.cs,ToPdbImportDefinitionKind,The following statement contains a magic number: switch (value) {  			case 1:		return PdbImportDefinitionKind.ImportNamespace;  			case 2:		return PdbImportDefinitionKind.ImportAssemblyNamespace;  			case 3:		return PdbImportDefinitionKind.ImportType;  			case 4:		return PdbImportDefinitionKind.ImportXmlNamespace;  			case 5:		return PdbImportDefinitionKind.ImportAssemblyReferenceAlias;  			case 6:		return PdbImportDefinitionKind.AliasAssemblyReference;  			case 7:		return PdbImportDefinitionKind.AliasNamespace;  			case 8:		return PdbImportDefinitionKind.AliasAssemblyNamespace;  			case 9:		return PdbImportDefinitionKind.AliasType;  			default:  				Debug.Fail("Unknown import definition kind: 0x" + value.ToString("X"));  				return UNKNOWN_IMPORT_KIND;  			}
Magic Number,dnlib.DotNet.Pdb.Portable,ImportDefinitionKindUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\ImportDefinitionKindUtils.cs,ToPdbImportDefinitionKind,The following statement contains a magic number: switch (value) {  			case 1:		return PdbImportDefinitionKind.ImportNamespace;  			case 2:		return PdbImportDefinitionKind.ImportAssemblyNamespace;  			case 3:		return PdbImportDefinitionKind.ImportType;  			case 4:		return PdbImportDefinitionKind.ImportXmlNamespace;  			case 5:		return PdbImportDefinitionKind.ImportAssemblyReferenceAlias;  			case 6:		return PdbImportDefinitionKind.AliasAssemblyReference;  			case 7:		return PdbImportDefinitionKind.AliasNamespace;  			case 8:		return PdbImportDefinitionKind.AliasAssemblyNamespace;  			case 9:		return PdbImportDefinitionKind.AliasType;  			default:  				Debug.Fail("Unknown import definition kind: 0x" + value.ToString("X"));  				return UNKNOWN_IMPORT_KIND;  			}
Magic Number,dnlib.DotNet.Pdb.Portable,ImportDefinitionKindUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\ImportDefinitionKindUtils.cs,ToPdbImportDefinitionKind,The following statement contains a magic number: switch (value) {  			case 1:		return PdbImportDefinitionKind.ImportNamespace;  			case 2:		return PdbImportDefinitionKind.ImportAssemblyNamespace;  			case 3:		return PdbImportDefinitionKind.ImportType;  			case 4:		return PdbImportDefinitionKind.ImportXmlNamespace;  			case 5:		return PdbImportDefinitionKind.ImportAssemblyReferenceAlias;  			case 6:		return PdbImportDefinitionKind.AliasAssemblyReference;  			case 7:		return PdbImportDefinitionKind.AliasNamespace;  			case 8:		return PdbImportDefinitionKind.AliasAssemblyNamespace;  			case 9:		return PdbImportDefinitionKind.AliasType;  			default:  				Debug.Fail("Unknown import definition kind: 0x" + value.ToString("X"));  				return UNKNOWN_IMPORT_KIND;  			}
Magic Number,dnlib.DotNet.Pdb.Portable,ImportDefinitionKindUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\ImportDefinitionKindUtils.cs,ToPdbImportDefinitionKind,The following statement contains a magic number: switch (value) {  			case 1:		return PdbImportDefinitionKind.ImportNamespace;  			case 2:		return PdbImportDefinitionKind.ImportAssemblyNamespace;  			case 3:		return PdbImportDefinitionKind.ImportType;  			case 4:		return PdbImportDefinitionKind.ImportXmlNamespace;  			case 5:		return PdbImportDefinitionKind.ImportAssemblyReferenceAlias;  			case 6:		return PdbImportDefinitionKind.AliasAssemblyReference;  			case 7:		return PdbImportDefinitionKind.AliasNamespace;  			case 8:		return PdbImportDefinitionKind.AliasAssemblyNamespace;  			case 9:		return PdbImportDefinitionKind.AliasType;  			default:  				Debug.Fail("Unknown import definition kind: 0x" + value.ToString("X"));  				return UNKNOWN_IMPORT_KIND;  			}
Magic Number,dnlib.DotNet.Pdb.Portable,ImportDefinitionKindUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\ImportDefinitionKindUtils.cs,ToImportDefinitionKind,The following statement contains a magic number: switch (kind) {  			case PdbImportDefinitionKind.ImportNamespace:				rawKind = 1; return true;  			case PdbImportDefinitionKind.ImportAssemblyNamespace:		rawKind = 2; return true;  			case PdbImportDefinitionKind.ImportType:					rawKind = 3; return true;  			case PdbImportDefinitionKind.ImportXmlNamespace:			rawKind = 4; return true;  			case PdbImportDefinitionKind.ImportAssemblyReferenceAlias:	rawKind = 5; return true;  			case PdbImportDefinitionKind.AliasAssemblyReference:		rawKind = 6; return true;  			case PdbImportDefinitionKind.AliasNamespace:				rawKind = 7; return true;  			case PdbImportDefinitionKind.AliasAssemblyNamespace:		rawKind = 8; return true;  			case PdbImportDefinitionKind.AliasType:						rawKind = 9; return true;  			default:													rawKind = uint.MaxValue; return false;  			}
Magic Number,dnlib.DotNet.Pdb.Portable,ImportDefinitionKindUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\ImportDefinitionKindUtils.cs,ToImportDefinitionKind,The following statement contains a magic number: switch (kind) {  			case PdbImportDefinitionKind.ImportNamespace:				rawKind = 1; return true;  			case PdbImportDefinitionKind.ImportAssemblyNamespace:		rawKind = 2; return true;  			case PdbImportDefinitionKind.ImportType:					rawKind = 3; return true;  			case PdbImportDefinitionKind.ImportXmlNamespace:			rawKind = 4; return true;  			case PdbImportDefinitionKind.ImportAssemblyReferenceAlias:	rawKind = 5; return true;  			case PdbImportDefinitionKind.AliasAssemblyReference:		rawKind = 6; return true;  			case PdbImportDefinitionKind.AliasNamespace:				rawKind = 7; return true;  			case PdbImportDefinitionKind.AliasAssemblyNamespace:		rawKind = 8; return true;  			case PdbImportDefinitionKind.AliasType:						rawKind = 9; return true;  			default:													rawKind = uint.MaxValue; return false;  			}
Magic Number,dnlib.DotNet.Pdb.Portable,ImportDefinitionKindUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\ImportDefinitionKindUtils.cs,ToImportDefinitionKind,The following statement contains a magic number: switch (kind) {  			case PdbImportDefinitionKind.ImportNamespace:				rawKind = 1; return true;  			case PdbImportDefinitionKind.ImportAssemblyNamespace:		rawKind = 2; return true;  			case PdbImportDefinitionKind.ImportType:					rawKind = 3; return true;  			case PdbImportDefinitionKind.ImportXmlNamespace:			rawKind = 4; return true;  			case PdbImportDefinitionKind.ImportAssemblyReferenceAlias:	rawKind = 5; return true;  			case PdbImportDefinitionKind.AliasAssemblyReference:		rawKind = 6; return true;  			case PdbImportDefinitionKind.AliasNamespace:				rawKind = 7; return true;  			case PdbImportDefinitionKind.AliasAssemblyNamespace:		rawKind = 8; return true;  			case PdbImportDefinitionKind.AliasType:						rawKind = 9; return true;  			default:													rawKind = uint.MaxValue; return false;  			}
Magic Number,dnlib.DotNet.Pdb.Portable,ImportDefinitionKindUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\ImportDefinitionKindUtils.cs,ToImportDefinitionKind,The following statement contains a magic number: switch (kind) {  			case PdbImportDefinitionKind.ImportNamespace:				rawKind = 1; return true;  			case PdbImportDefinitionKind.ImportAssemblyNamespace:		rawKind = 2; return true;  			case PdbImportDefinitionKind.ImportType:					rawKind = 3; return true;  			case PdbImportDefinitionKind.ImportXmlNamespace:			rawKind = 4; return true;  			case PdbImportDefinitionKind.ImportAssemblyReferenceAlias:	rawKind = 5; return true;  			case PdbImportDefinitionKind.AliasAssemblyReference:		rawKind = 6; return true;  			case PdbImportDefinitionKind.AliasNamespace:				rawKind = 7; return true;  			case PdbImportDefinitionKind.AliasAssemblyNamespace:		rawKind = 8; return true;  			case PdbImportDefinitionKind.AliasType:						rawKind = 9; return true;  			default:													rawKind = uint.MaxValue; return false;  			}
Magic Number,dnlib.DotNet.Pdb.Portable,ImportDefinitionKindUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\ImportDefinitionKindUtils.cs,ToImportDefinitionKind,The following statement contains a magic number: switch (kind) {  			case PdbImportDefinitionKind.ImportNamespace:				rawKind = 1; return true;  			case PdbImportDefinitionKind.ImportAssemblyNamespace:		rawKind = 2; return true;  			case PdbImportDefinitionKind.ImportType:					rawKind = 3; return true;  			case PdbImportDefinitionKind.ImportXmlNamespace:			rawKind = 4; return true;  			case PdbImportDefinitionKind.ImportAssemblyReferenceAlias:	rawKind = 5; return true;  			case PdbImportDefinitionKind.AliasAssemblyReference:		rawKind = 6; return true;  			case PdbImportDefinitionKind.AliasNamespace:				rawKind = 7; return true;  			case PdbImportDefinitionKind.AliasAssemblyNamespace:		rawKind = 8; return true;  			case PdbImportDefinitionKind.AliasType:						rawKind = 9; return true;  			default:													rawKind = uint.MaxValue; return false;  			}
Magic Number,dnlib.DotNet.Pdb.Portable,ImportDefinitionKindUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\ImportDefinitionKindUtils.cs,ToImportDefinitionKind,The following statement contains a magic number: switch (kind) {  			case PdbImportDefinitionKind.ImportNamespace:				rawKind = 1; return true;  			case PdbImportDefinitionKind.ImportAssemblyNamespace:		rawKind = 2; return true;  			case PdbImportDefinitionKind.ImportType:					rawKind = 3; return true;  			case PdbImportDefinitionKind.ImportXmlNamespace:			rawKind = 4; return true;  			case PdbImportDefinitionKind.ImportAssemblyReferenceAlias:	rawKind = 5; return true;  			case PdbImportDefinitionKind.AliasAssemblyReference:		rawKind = 6; return true;  			case PdbImportDefinitionKind.AliasNamespace:				rawKind = 7; return true;  			case PdbImportDefinitionKind.AliasAssemblyNamespace:		rawKind = 8; return true;  			case PdbImportDefinitionKind.AliasType:						rawKind = 9; return true;  			default:													rawKind = uint.MaxValue; return false;  			}
Magic Number,dnlib.DotNet.Pdb.Portable,ImportDefinitionKindUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\ImportDefinitionKindUtils.cs,ToImportDefinitionKind,The following statement contains a magic number: switch (kind) {  			case PdbImportDefinitionKind.ImportNamespace:				rawKind = 1; return true;  			case PdbImportDefinitionKind.ImportAssemblyNamespace:		rawKind = 2; return true;  			case PdbImportDefinitionKind.ImportType:					rawKind = 3; return true;  			case PdbImportDefinitionKind.ImportXmlNamespace:			rawKind = 4; return true;  			case PdbImportDefinitionKind.ImportAssemblyReferenceAlias:	rawKind = 5; return true;  			case PdbImportDefinitionKind.AliasAssemblyReference:		rawKind = 6; return true;  			case PdbImportDefinitionKind.AliasNamespace:				rawKind = 7; return true;  			case PdbImportDefinitionKind.AliasAssemblyNamespace:		rawKind = 8; return true;  			case PdbImportDefinitionKind.AliasType:						rawKind = 9; return true;  			default:													rawKind = uint.MaxValue; return false;  			}
Magic Number,dnlib.DotNet.Pdb.Portable,ImportDefinitionKindUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\ImportDefinitionKindUtils.cs,ToImportDefinitionKind,The following statement contains a magic number: switch (kind) {  			case PdbImportDefinitionKind.ImportNamespace:				rawKind = 1; return true;  			case PdbImportDefinitionKind.ImportAssemblyNamespace:		rawKind = 2; return true;  			case PdbImportDefinitionKind.ImportType:					rawKind = 3; return true;  			case PdbImportDefinitionKind.ImportXmlNamespace:			rawKind = 4; return true;  			case PdbImportDefinitionKind.ImportAssemblyReferenceAlias:	rawKind = 5; return true;  			case PdbImportDefinitionKind.AliasAssemblyReference:		rawKind = 6; return true;  			case PdbImportDefinitionKind.AliasNamespace:				rawKind = 7; return true;  			case PdbImportDefinitionKind.AliasAssemblyNamespace:		rawKind = 8; return true;  			case PdbImportDefinitionKind.AliasType:						rawKind = 9; return true;  			default:													rawKind = uint.MaxValue; return false;  			}
Magic Number,dnlib.DotNet.Pdb.Portable,LocalConstantSigBlobReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\LocalConstantSigBlobReader.cs,ReadCore,The following statement contains a magic number: switch (et) {  			case ElementType.Boolean:  				type = module.CorLibTypes.Boolean;  				value = reader.ReadBoolean();  				if (reader.Position < reader.Length)  					type = ReadTypeDefOrRefSig();  				res = true;  				break;    			case ElementType.Char:  				type = module.CorLibTypes.Char;  				value = reader.ReadChar();  				if (reader.Position < reader.Length)  					type = ReadTypeDefOrRefSig();  				res = true;  				break;    			case ElementType.I1:  				type = module.CorLibTypes.SByte;  				value = reader.ReadSByte();  				if (reader.Position < reader.Length)  					type = ReadTypeDefOrRefSig();  				res = true;  				break;    			case ElementType.U1:  				type = module.CorLibTypes.Byte;  				value = reader.ReadByte();  				if (reader.Position < reader.Length)  					type = ReadTypeDefOrRefSig();  				res = true;  				break;    			case ElementType.I2:  				type = module.CorLibTypes.Int16;  				value = reader.ReadInt16();  				if (reader.Position < reader.Length)  					type = ReadTypeDefOrRefSig();  				res = true;  				break;    			case ElementType.U2:  				type = module.CorLibTypes.UInt16;  				value = reader.ReadUInt16();  				if (reader.Position < reader.Length)  					type = ReadTypeDefOrRefSig();  				res = true;  				break;    			case ElementType.I4:  				type = module.CorLibTypes.Int32;  				value = reader.ReadInt32();  				if (reader.Position < reader.Length)  					type = ReadTypeDefOrRefSig();  				res = true;  				break;    			case ElementType.U4:  				type = module.CorLibTypes.UInt32;  				value = reader.ReadUInt32();  				if (reader.Position < reader.Length)  					type = ReadTypeDefOrRefSig();  				res = true;  				break;    			case ElementType.I8:  				type = module.CorLibTypes.Int64;  				value = reader.ReadInt64();  				if (reader.Position < reader.Length)  					type = ReadTypeDefOrRefSig();  				res = true;  				break;    			case ElementType.U8:  				type = module.CorLibTypes.UInt64;  				value = reader.ReadUInt64();  				if (reader.Position < reader.Length)  					type = ReadTypeDefOrRefSig();  				res = true;  				break;    			case ElementType.R4:  				type = module.CorLibTypes.Single;  				value = reader.ReadSingle();  				res = true;  				break;    			case ElementType.R8:  				type = module.CorLibTypes.Double;  				value = reader.ReadDouble();  				res = true;  				break;    			case ElementType.String:  				type = module.CorLibTypes.String;  				value = ReadString();  				res = true;  				break;    			case ElementType.Ptr:  				res = ReadCatch(out type' out value);  				if (res)  					type = new PtrSig(type);  				break;    			case ElementType.ByRef:  				res = ReadCatch(out type' out value);  				if (res)  					type = new ByRefSig(type);  				break;    			case ElementType.Object:  				type = module.CorLibTypes.Object;  				value = null;  				res = true;  				break;    			case ElementType.ValueType:  				tdr = ReadTypeDefOrRef();  				type = tdr.ToTypeSig();  				value = null;  				if (GetName(tdr' out ns' out name) && ns == stringSystem && tdr.DefinitionAssembly.IsCorLib()) {  					if (name == stringDecimal) {  						if (reader.Length - reader.Position != 13)  							goto default;  						try {  							byte b = reader.ReadByte();  							value = new Decimal(reader.ReadInt32()' reader.ReadInt32()' reader.ReadInt32()' (b & 0x80) != 0' (byte)(b & 0x7F));  						}  						catch {  							goto default;  						}  					}  					else if (name == stringDateTime) {  						if (reader.Length - reader.Position != 8)  							goto default;  						try {  							value = new DateTime(reader.ReadInt64());  						}  						catch {  							goto default;  						}  					}  				}  				if (value is null && reader.Position != reader.Length)  					value = reader.ReadRemainingBytes();  				res = true;  				break;    			case ElementType.Class:  				type = new ClassSig(ReadTypeDefOrRef());  				value = reader.Position == reader.Length ? null : reader.ReadRemainingBytes();  				res = true;  				break;    			case ElementType.CModReqd:  				tdr = ReadTypeDefOrRef();  				res = ReadCatch(out type' out value);  				if (res)  					type = new CModReqdSig(tdr' type);  				break;    			case ElementType.CModOpt:  				tdr = ReadTypeDefOrRef();  				res = ReadCatch(out type' out value);  				if (res)  					type = new CModOptSig(tdr' type);  				break;    			case ElementType.Var:  			case ElementType.Array:  			case ElementType.GenericInst:  			case ElementType.TypedByRef:  			case ElementType.I:  			case ElementType.U:  			case ElementType.FnPtr:  			case ElementType.SZArray:  			case ElementType.MVar:  			case ElementType.End:  			case ElementType.Void:  			case ElementType.ValueArray:  			case ElementType.R:  			case ElementType.Internal:  			case ElementType.Module:  			case ElementType.Sentinel:  			case ElementType.Pinned:  			default:  				Debug.Fail("Unsupported element type in LocalConstant sig blob: " + et.ToString());  				res = false;  				type = null;  				value = null;  				break;  			}
Magic Number,dnlib.DotNet.Pdb.Portable,LocalConstantSigBlobReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\LocalConstantSigBlobReader.cs,ReadCore,The following statement contains a magic number: switch (et) {  			case ElementType.Boolean:  				type = module.CorLibTypes.Boolean;  				value = reader.ReadBoolean();  				if (reader.Position < reader.Length)  					type = ReadTypeDefOrRefSig();  				res = true;  				break;    			case ElementType.Char:  				type = module.CorLibTypes.Char;  				value = reader.ReadChar();  				if (reader.Position < reader.Length)  					type = ReadTypeDefOrRefSig();  				res = true;  				break;    			case ElementType.I1:  				type = module.CorLibTypes.SByte;  				value = reader.ReadSByte();  				if (reader.Position < reader.Length)  					type = ReadTypeDefOrRefSig();  				res = true;  				break;    			case ElementType.U1:  				type = module.CorLibTypes.Byte;  				value = reader.ReadByte();  				if (reader.Position < reader.Length)  					type = ReadTypeDefOrRefSig();  				res = true;  				break;    			case ElementType.I2:  				type = module.CorLibTypes.Int16;  				value = reader.ReadInt16();  				if (reader.Position < reader.Length)  					type = ReadTypeDefOrRefSig();  				res = true;  				break;    			case ElementType.U2:  				type = module.CorLibTypes.UInt16;  				value = reader.ReadUInt16();  				if (reader.Position < reader.Length)  					type = ReadTypeDefOrRefSig();  				res = true;  				break;    			case ElementType.I4:  				type = module.CorLibTypes.Int32;  				value = reader.ReadInt32();  				if (reader.Position < reader.Length)  					type = ReadTypeDefOrRefSig();  				res = true;  				break;    			case ElementType.U4:  				type = module.CorLibTypes.UInt32;  				value = reader.ReadUInt32();  				if (reader.Position < reader.Length)  					type = ReadTypeDefOrRefSig();  				res = true;  				break;    			case ElementType.I8:  				type = module.CorLibTypes.Int64;  				value = reader.ReadInt64();  				if (reader.Position < reader.Length)  					type = ReadTypeDefOrRefSig();  				res = true;  				break;    			case ElementType.U8:  				type = module.CorLibTypes.UInt64;  				value = reader.ReadUInt64();  				if (reader.Position < reader.Length)  					type = ReadTypeDefOrRefSig();  				res = true;  				break;    			case ElementType.R4:  				type = module.CorLibTypes.Single;  				value = reader.ReadSingle();  				res = true;  				break;    			case ElementType.R8:  				type = module.CorLibTypes.Double;  				value = reader.ReadDouble();  				res = true;  				break;    			case ElementType.String:  				type = module.CorLibTypes.String;  				value = ReadString();  				res = true;  				break;    			case ElementType.Ptr:  				res = ReadCatch(out type' out value);  				if (res)  					type = new PtrSig(type);  				break;    			case ElementType.ByRef:  				res = ReadCatch(out type' out value);  				if (res)  					type = new ByRefSig(type);  				break;    			case ElementType.Object:  				type = module.CorLibTypes.Object;  				value = null;  				res = true;  				break;    			case ElementType.ValueType:  				tdr = ReadTypeDefOrRef();  				type = tdr.ToTypeSig();  				value = null;  				if (GetName(tdr' out ns' out name) && ns == stringSystem && tdr.DefinitionAssembly.IsCorLib()) {  					if (name == stringDecimal) {  						if (reader.Length - reader.Position != 13)  							goto default;  						try {  							byte b = reader.ReadByte();  							value = new Decimal(reader.ReadInt32()' reader.ReadInt32()' reader.ReadInt32()' (b & 0x80) != 0' (byte)(b & 0x7F));  						}  						catch {  							goto default;  						}  					}  					else if (name == stringDateTime) {  						if (reader.Length - reader.Position != 8)  							goto default;  						try {  							value = new DateTime(reader.ReadInt64());  						}  						catch {  							goto default;  						}  					}  				}  				if (value is null && reader.Position != reader.Length)  					value = reader.ReadRemainingBytes();  				res = true;  				break;    			case ElementType.Class:  				type = new ClassSig(ReadTypeDefOrRef());  				value = reader.Position == reader.Length ? null : reader.ReadRemainingBytes();  				res = true;  				break;    			case ElementType.CModReqd:  				tdr = ReadTypeDefOrRef();  				res = ReadCatch(out type' out value);  				if (res)  					type = new CModReqdSig(tdr' type);  				break;    			case ElementType.CModOpt:  				tdr = ReadTypeDefOrRef();  				res = ReadCatch(out type' out value);  				if (res)  					type = new CModOptSig(tdr' type);  				break;    			case ElementType.Var:  			case ElementType.Array:  			case ElementType.GenericInst:  			case ElementType.TypedByRef:  			case ElementType.I:  			case ElementType.U:  			case ElementType.FnPtr:  			case ElementType.SZArray:  			case ElementType.MVar:  			case ElementType.End:  			case ElementType.Void:  			case ElementType.ValueArray:  			case ElementType.R:  			case ElementType.Internal:  			case ElementType.Module:  			case ElementType.Sentinel:  			case ElementType.Pinned:  			default:  				Debug.Fail("Unsupported element type in LocalConstant sig blob: " + et.ToString());  				res = false;  				type = null;  				value = null;  				break;  			}
Magic Number,dnlib.DotNet.Pdb.Portable,LocalConstantSigBlobReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\LocalConstantSigBlobReader.cs,ReadString,The following statement contains a magic number: return reader.ReadUtf16String((int)(reader.BytesLeft / 2));
Magic Number,dnlib.DotNet.Pdb.Portable,LocalConstantSigBlobWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\LocalConstantSigBlobWriter.cs,Write,The following statement contains a magic number: switch (et) {  				case ElementType.Boolean:  				case ElementType.Char:  				case ElementType.I1:  				case ElementType.U1:  				case ElementType.I2:  				case ElementType.U2:  				case ElementType.I4:  				case ElementType.U4:  				case ElementType.I8:  				case ElementType.U8:  					WritePrimitiveValue(writer' et' value);  					return;    				case ElementType.R4:  					if (value is float)  						writer.WriteSingle((float)value);  					else {  						helper.Error("Expected a Single constant");  						writer.WriteSingle(0);  					}  					return;    				case ElementType.R8:  					if (value is double)  						writer.WriteDouble((double)value);  					else {  						helper.Error("Expected a Double constant");  						writer.WriteDouble(0);  					}  					return;    				case ElementType.String:  					if (value is null)  						writer.WriteByte((byte)0xFF);  					else if (value is string)  						writer.WriteBytes(Encoding.Unicode.GetBytes((string)value));  					else  						helper.Error("Expected a String constant");  					return;    				case ElementType.Ptr:  				case ElementType.ByRef:  					WriteTypeDefOrRef(writer' new TypeSpecUser(type));  					return;    				case ElementType.Object:  					return;    				case ElementType.ValueType:  					var tdr = ((ValueTypeSig)type).TypeDefOrRef;  					var td = tdr.ResolveTypeDef();  					if (td is null)  						helper.Error($"Couldn't resolve type 0x{tdr?.MDToken.Raw ?? 0:X8}");  					else if (td.IsEnum) {  						var underlyingType = td.GetEnumUnderlyingType().RemovePinnedAndModifiers();  						switch (underlyingType.GetElementType()) {  						case ElementType.Boolean:  						case ElementType.Char:  						case ElementType.I1:  						case ElementType.U1:  						case ElementType.I2:  						case ElementType.U2:  						case ElementType.I4:  						case ElementType.U4:  						case ElementType.I8:  						case ElementType.U8:  							writer.Position--;  							writer.WriteByte((byte)underlyingType.GetElementType());  							WritePrimitiveValue(writer' underlyingType.GetElementType()' value);  							WriteTypeDefOrRef(writer' tdr);  							return;  						default:  							helper.Error("Invalid enum underlying type");  							return;  						}  					}  					else {  						WriteTypeDefOrRef(writer' tdr);  						bool valueWritten = false;  						if (GetName(tdr' out var ns' out var name) && ns == stringSystem && tdr.DefinitionAssembly.IsCorLib()) {  							if (name == stringDecimal) {  								if (value is decimal) {  									var bits = decimal.GetBits((decimal)value);  									writer.WriteByte((byte)((((uint)bits[3] >> 31) << 7) | (((uint)bits[3] >> 16) & 0x7F)));  									writer.WriteInt32(bits[0]);  									writer.WriteInt32(bits[1]);  									writer.WriteInt32(bits[2]);  								}  								else {  									helper.Error("Expected a Decimal constant");  									writer.WriteBytes(new byte[13]);  								}  								valueWritten = true;  							}  							else if (name == stringDateTime) {  								if (value is DateTime)  									writer.WriteInt64(((DateTime)value).Ticks);  								else {  									helper.Error("Expected a DateTime constant");  									writer.WriteInt64(0);  								}  								valueWritten = true;  							}  						}  						if (!valueWritten) {  							if (value is byte[])  								writer.WriteBytes((byte[])value);  							else if (!(value is null)) {  								helper.Error("Unsupported constant: " + value.GetType().FullName);  								return;  							}  						}  					}  					return;    				case ElementType.Class:  					WriteTypeDefOrRef(writer' ((ClassSig)type).TypeDefOrRef);  					if (value is byte[])  						writer.WriteBytes((byte[])value);  					else if (!(value is null))  						helper.Error("Expected a null constant");  					return;    				case ElementType.CModReqd:  				case ElementType.CModOpt:  					WriteTypeDefOrRef(writer' ((ModifierSig)type).Modifier);  					break;    				case ElementType.Var:  				case ElementType.Array:  				case ElementType.GenericInst:  				case ElementType.TypedByRef:  				case ElementType.I:  				case ElementType.U:  				case ElementType.FnPtr:  				case ElementType.SZArray:  				case ElementType.MVar:  					WriteTypeDefOrRef(writer' new TypeSpecUser(type));  					return;    				case ElementType.End:  				case ElementType.Void:  				case ElementType.ValueArray:  				case ElementType.R:  				case ElementType.Internal:  				case ElementType.Module:  				case ElementType.Sentinel:  				case ElementType.Pinned:  				default:  					helper.Error("Unsupported element type in LocalConstant sig blob: " + et.ToString());  					return;  				}
Magic Number,dnlib.DotNet.Pdb.Portable,LocalConstantSigBlobWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\LocalConstantSigBlobWriter.cs,Write,The following statement contains a magic number: switch (et) {  				case ElementType.Boolean:  				case ElementType.Char:  				case ElementType.I1:  				case ElementType.U1:  				case ElementType.I2:  				case ElementType.U2:  				case ElementType.I4:  				case ElementType.U4:  				case ElementType.I8:  				case ElementType.U8:  					WritePrimitiveValue(writer' et' value);  					return;    				case ElementType.R4:  					if (value is float)  						writer.WriteSingle((float)value);  					else {  						helper.Error("Expected a Single constant");  						writer.WriteSingle(0);  					}  					return;    				case ElementType.R8:  					if (value is double)  						writer.WriteDouble((double)value);  					else {  						helper.Error("Expected a Double constant");  						writer.WriteDouble(0);  					}  					return;    				case ElementType.String:  					if (value is null)  						writer.WriteByte((byte)0xFF);  					else if (value is string)  						writer.WriteBytes(Encoding.Unicode.GetBytes((string)value));  					else  						helper.Error("Expected a String constant");  					return;    				case ElementType.Ptr:  				case ElementType.ByRef:  					WriteTypeDefOrRef(writer' new TypeSpecUser(type));  					return;    				case ElementType.Object:  					return;    				case ElementType.ValueType:  					var tdr = ((ValueTypeSig)type).TypeDefOrRef;  					var td = tdr.ResolveTypeDef();  					if (td is null)  						helper.Error($"Couldn't resolve type 0x{tdr?.MDToken.Raw ?? 0:X8}");  					else if (td.IsEnum) {  						var underlyingType = td.GetEnumUnderlyingType().RemovePinnedAndModifiers();  						switch (underlyingType.GetElementType()) {  						case ElementType.Boolean:  						case ElementType.Char:  						case ElementType.I1:  						case ElementType.U1:  						case ElementType.I2:  						case ElementType.U2:  						case ElementType.I4:  						case ElementType.U4:  						case ElementType.I8:  						case ElementType.U8:  							writer.Position--;  							writer.WriteByte((byte)underlyingType.GetElementType());  							WritePrimitiveValue(writer' underlyingType.GetElementType()' value);  							WriteTypeDefOrRef(writer' tdr);  							return;  						default:  							helper.Error("Invalid enum underlying type");  							return;  						}  					}  					else {  						WriteTypeDefOrRef(writer' tdr);  						bool valueWritten = false;  						if (GetName(tdr' out var ns' out var name) && ns == stringSystem && tdr.DefinitionAssembly.IsCorLib()) {  							if (name == stringDecimal) {  								if (value is decimal) {  									var bits = decimal.GetBits((decimal)value);  									writer.WriteByte((byte)((((uint)bits[3] >> 31) << 7) | (((uint)bits[3] >> 16) & 0x7F)));  									writer.WriteInt32(bits[0]);  									writer.WriteInt32(bits[1]);  									writer.WriteInt32(bits[2]);  								}  								else {  									helper.Error("Expected a Decimal constant");  									writer.WriteBytes(new byte[13]);  								}  								valueWritten = true;  							}  							else if (name == stringDateTime) {  								if (value is DateTime)  									writer.WriteInt64(((DateTime)value).Ticks);  								else {  									helper.Error("Expected a DateTime constant");  									writer.WriteInt64(0);  								}  								valueWritten = true;  							}  						}  						if (!valueWritten) {  							if (value is byte[])  								writer.WriteBytes((byte[])value);  							else if (!(value is null)) {  								helper.Error("Unsupported constant: " + value.GetType().FullName);  								return;  							}  						}  					}  					return;    				case ElementType.Class:  					WriteTypeDefOrRef(writer' ((ClassSig)type).TypeDefOrRef);  					if (value is byte[])  						writer.WriteBytes((byte[])value);  					else if (!(value is null))  						helper.Error("Expected a null constant");  					return;    				case ElementType.CModReqd:  				case ElementType.CModOpt:  					WriteTypeDefOrRef(writer' ((ModifierSig)type).Modifier);  					break;    				case ElementType.Var:  				case ElementType.Array:  				case ElementType.GenericInst:  				case ElementType.TypedByRef:  				case ElementType.I:  				case ElementType.U:  				case ElementType.FnPtr:  				case ElementType.SZArray:  				case ElementType.MVar:  					WriteTypeDefOrRef(writer' new TypeSpecUser(type));  					return;    				case ElementType.End:  				case ElementType.Void:  				case ElementType.ValueArray:  				case ElementType.R:  				case ElementType.Internal:  				case ElementType.Module:  				case ElementType.Sentinel:  				case ElementType.Pinned:  				default:  					helper.Error("Unsupported element type in LocalConstant sig blob: " + et.ToString());  					return;  				}
Magic Number,dnlib.DotNet.Pdb.Portable,LocalConstantSigBlobWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\LocalConstantSigBlobWriter.cs,Write,The following statement contains a magic number: switch (et) {  				case ElementType.Boolean:  				case ElementType.Char:  				case ElementType.I1:  				case ElementType.U1:  				case ElementType.I2:  				case ElementType.U2:  				case ElementType.I4:  				case ElementType.U4:  				case ElementType.I8:  				case ElementType.U8:  					WritePrimitiveValue(writer' et' value);  					return;    				case ElementType.R4:  					if (value is float)  						writer.WriteSingle((float)value);  					else {  						helper.Error("Expected a Single constant");  						writer.WriteSingle(0);  					}  					return;    				case ElementType.R8:  					if (value is double)  						writer.WriteDouble((double)value);  					else {  						helper.Error("Expected a Double constant");  						writer.WriteDouble(0);  					}  					return;    				case ElementType.String:  					if (value is null)  						writer.WriteByte((byte)0xFF);  					else if (value is string)  						writer.WriteBytes(Encoding.Unicode.GetBytes((string)value));  					else  						helper.Error("Expected a String constant");  					return;    				case ElementType.Ptr:  				case ElementType.ByRef:  					WriteTypeDefOrRef(writer' new TypeSpecUser(type));  					return;    				case ElementType.Object:  					return;    				case ElementType.ValueType:  					var tdr = ((ValueTypeSig)type).TypeDefOrRef;  					var td = tdr.ResolveTypeDef();  					if (td is null)  						helper.Error($"Couldn't resolve type 0x{tdr?.MDToken.Raw ?? 0:X8}");  					else if (td.IsEnum) {  						var underlyingType = td.GetEnumUnderlyingType().RemovePinnedAndModifiers();  						switch (underlyingType.GetElementType()) {  						case ElementType.Boolean:  						case ElementType.Char:  						case ElementType.I1:  						case ElementType.U1:  						case ElementType.I2:  						case ElementType.U2:  						case ElementType.I4:  						case ElementType.U4:  						case ElementType.I8:  						case ElementType.U8:  							writer.Position--;  							writer.WriteByte((byte)underlyingType.GetElementType());  							WritePrimitiveValue(writer' underlyingType.GetElementType()' value);  							WriteTypeDefOrRef(writer' tdr);  							return;  						default:  							helper.Error("Invalid enum underlying type");  							return;  						}  					}  					else {  						WriteTypeDefOrRef(writer' tdr);  						bool valueWritten = false;  						if (GetName(tdr' out var ns' out var name) && ns == stringSystem && tdr.DefinitionAssembly.IsCorLib()) {  							if (name == stringDecimal) {  								if (value is decimal) {  									var bits = decimal.GetBits((decimal)value);  									writer.WriteByte((byte)((((uint)bits[3] >> 31) << 7) | (((uint)bits[3] >> 16) & 0x7F)));  									writer.WriteInt32(bits[0]);  									writer.WriteInt32(bits[1]);  									writer.WriteInt32(bits[2]);  								}  								else {  									helper.Error("Expected a Decimal constant");  									writer.WriteBytes(new byte[13]);  								}  								valueWritten = true;  							}  							else if (name == stringDateTime) {  								if (value is DateTime)  									writer.WriteInt64(((DateTime)value).Ticks);  								else {  									helper.Error("Expected a DateTime constant");  									writer.WriteInt64(0);  								}  								valueWritten = true;  							}  						}  						if (!valueWritten) {  							if (value is byte[])  								writer.WriteBytes((byte[])value);  							else if (!(value is null)) {  								helper.Error("Unsupported constant: " + value.GetType().FullName);  								return;  							}  						}  					}  					return;    				case ElementType.Class:  					WriteTypeDefOrRef(writer' ((ClassSig)type).TypeDefOrRef);  					if (value is byte[])  						writer.WriteBytes((byte[])value);  					else if (!(value is null))  						helper.Error("Expected a null constant");  					return;    				case ElementType.CModReqd:  				case ElementType.CModOpt:  					WriteTypeDefOrRef(writer' ((ModifierSig)type).Modifier);  					break;    				case ElementType.Var:  				case ElementType.Array:  				case ElementType.GenericInst:  				case ElementType.TypedByRef:  				case ElementType.I:  				case ElementType.U:  				case ElementType.FnPtr:  				case ElementType.SZArray:  				case ElementType.MVar:  					WriteTypeDefOrRef(writer' new TypeSpecUser(type));  					return;    				case ElementType.End:  				case ElementType.Void:  				case ElementType.ValueArray:  				case ElementType.R:  				case ElementType.Internal:  				case ElementType.Module:  				case ElementType.Sentinel:  				case ElementType.Pinned:  				default:  					helper.Error("Unsupported element type in LocalConstant sig blob: " + et.ToString());  					return;  				}
Magic Number,dnlib.DotNet.Pdb.Portable,LocalConstantSigBlobWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\LocalConstantSigBlobWriter.cs,Write,The following statement contains a magic number: switch (et) {  				case ElementType.Boolean:  				case ElementType.Char:  				case ElementType.I1:  				case ElementType.U1:  				case ElementType.I2:  				case ElementType.U2:  				case ElementType.I4:  				case ElementType.U4:  				case ElementType.I8:  				case ElementType.U8:  					WritePrimitiveValue(writer' et' value);  					return;    				case ElementType.R4:  					if (value is float)  						writer.WriteSingle((float)value);  					else {  						helper.Error("Expected a Single constant");  						writer.WriteSingle(0);  					}  					return;    				case ElementType.R8:  					if (value is double)  						writer.WriteDouble((double)value);  					else {  						helper.Error("Expected a Double constant");  						writer.WriteDouble(0);  					}  					return;    				case ElementType.String:  					if (value is null)  						writer.WriteByte((byte)0xFF);  					else if (value is string)  						writer.WriteBytes(Encoding.Unicode.GetBytes((string)value));  					else  						helper.Error("Expected a String constant");  					return;    				case ElementType.Ptr:  				case ElementType.ByRef:  					WriteTypeDefOrRef(writer' new TypeSpecUser(type));  					return;    				case ElementType.Object:  					return;    				case ElementType.ValueType:  					var tdr = ((ValueTypeSig)type).TypeDefOrRef;  					var td = tdr.ResolveTypeDef();  					if (td is null)  						helper.Error($"Couldn't resolve type 0x{tdr?.MDToken.Raw ?? 0:X8}");  					else if (td.IsEnum) {  						var underlyingType = td.GetEnumUnderlyingType().RemovePinnedAndModifiers();  						switch (underlyingType.GetElementType()) {  						case ElementType.Boolean:  						case ElementType.Char:  						case ElementType.I1:  						case ElementType.U1:  						case ElementType.I2:  						case ElementType.U2:  						case ElementType.I4:  						case ElementType.U4:  						case ElementType.I8:  						case ElementType.U8:  							writer.Position--;  							writer.WriteByte((byte)underlyingType.GetElementType());  							WritePrimitiveValue(writer' underlyingType.GetElementType()' value);  							WriteTypeDefOrRef(writer' tdr);  							return;  						default:  							helper.Error("Invalid enum underlying type");  							return;  						}  					}  					else {  						WriteTypeDefOrRef(writer' tdr);  						bool valueWritten = false;  						if (GetName(tdr' out var ns' out var name) && ns == stringSystem && tdr.DefinitionAssembly.IsCorLib()) {  							if (name == stringDecimal) {  								if (value is decimal) {  									var bits = decimal.GetBits((decimal)value);  									writer.WriteByte((byte)((((uint)bits[3] >> 31) << 7) | (((uint)bits[3] >> 16) & 0x7F)));  									writer.WriteInt32(bits[0]);  									writer.WriteInt32(bits[1]);  									writer.WriteInt32(bits[2]);  								}  								else {  									helper.Error("Expected a Decimal constant");  									writer.WriteBytes(new byte[13]);  								}  								valueWritten = true;  							}  							else if (name == stringDateTime) {  								if (value is DateTime)  									writer.WriteInt64(((DateTime)value).Ticks);  								else {  									helper.Error("Expected a DateTime constant");  									writer.WriteInt64(0);  								}  								valueWritten = true;  							}  						}  						if (!valueWritten) {  							if (value is byte[])  								writer.WriteBytes((byte[])value);  							else if (!(value is null)) {  								helper.Error("Unsupported constant: " + value.GetType().FullName);  								return;  							}  						}  					}  					return;    				case ElementType.Class:  					WriteTypeDefOrRef(writer' ((ClassSig)type).TypeDefOrRef);  					if (value is byte[])  						writer.WriteBytes((byte[])value);  					else if (!(value is null))  						helper.Error("Expected a null constant");  					return;    				case ElementType.CModReqd:  				case ElementType.CModOpt:  					WriteTypeDefOrRef(writer' ((ModifierSig)type).Modifier);  					break;    				case ElementType.Var:  				case ElementType.Array:  				case ElementType.GenericInst:  				case ElementType.TypedByRef:  				case ElementType.I:  				case ElementType.U:  				case ElementType.FnPtr:  				case ElementType.SZArray:  				case ElementType.MVar:  					WriteTypeDefOrRef(writer' new TypeSpecUser(type));  					return;    				case ElementType.End:  				case ElementType.Void:  				case ElementType.ValueArray:  				case ElementType.R:  				case ElementType.Internal:  				case ElementType.Module:  				case ElementType.Sentinel:  				case ElementType.Pinned:  				default:  					helper.Error("Unsupported element type in LocalConstant sig blob: " + et.ToString());  					return;  				}
Magic Number,dnlib.DotNet.Pdb.Portable,LocalConstantSigBlobWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\LocalConstantSigBlobWriter.cs,Write,The following statement contains a magic number: switch (et) {  				case ElementType.Boolean:  				case ElementType.Char:  				case ElementType.I1:  				case ElementType.U1:  				case ElementType.I2:  				case ElementType.U2:  				case ElementType.I4:  				case ElementType.U4:  				case ElementType.I8:  				case ElementType.U8:  					WritePrimitiveValue(writer' et' value);  					return;    				case ElementType.R4:  					if (value is float)  						writer.WriteSingle((float)value);  					else {  						helper.Error("Expected a Single constant");  						writer.WriteSingle(0);  					}  					return;    				case ElementType.R8:  					if (value is double)  						writer.WriteDouble((double)value);  					else {  						helper.Error("Expected a Double constant");  						writer.WriteDouble(0);  					}  					return;    				case ElementType.String:  					if (value is null)  						writer.WriteByte((byte)0xFF);  					else if (value is string)  						writer.WriteBytes(Encoding.Unicode.GetBytes((string)value));  					else  						helper.Error("Expected a String constant");  					return;    				case ElementType.Ptr:  				case ElementType.ByRef:  					WriteTypeDefOrRef(writer' new TypeSpecUser(type));  					return;    				case ElementType.Object:  					return;    				case ElementType.ValueType:  					var tdr = ((ValueTypeSig)type).TypeDefOrRef;  					var td = tdr.ResolveTypeDef();  					if (td is null)  						helper.Error($"Couldn't resolve type 0x{tdr?.MDToken.Raw ?? 0:X8}");  					else if (td.IsEnum) {  						var underlyingType = td.GetEnumUnderlyingType().RemovePinnedAndModifiers();  						switch (underlyingType.GetElementType()) {  						case ElementType.Boolean:  						case ElementType.Char:  						case ElementType.I1:  						case ElementType.U1:  						case ElementType.I2:  						case ElementType.U2:  						case ElementType.I4:  						case ElementType.U4:  						case ElementType.I8:  						case ElementType.U8:  							writer.Position--;  							writer.WriteByte((byte)underlyingType.GetElementType());  							WritePrimitiveValue(writer' underlyingType.GetElementType()' value);  							WriteTypeDefOrRef(writer' tdr);  							return;  						default:  							helper.Error("Invalid enum underlying type");  							return;  						}  					}  					else {  						WriteTypeDefOrRef(writer' tdr);  						bool valueWritten = false;  						if (GetName(tdr' out var ns' out var name) && ns == stringSystem && tdr.DefinitionAssembly.IsCorLib()) {  							if (name == stringDecimal) {  								if (value is decimal) {  									var bits = decimal.GetBits((decimal)value);  									writer.WriteByte((byte)((((uint)bits[3] >> 31) << 7) | (((uint)bits[3] >> 16) & 0x7F)));  									writer.WriteInt32(bits[0]);  									writer.WriteInt32(bits[1]);  									writer.WriteInt32(bits[2]);  								}  								else {  									helper.Error("Expected a Decimal constant");  									writer.WriteBytes(new byte[13]);  								}  								valueWritten = true;  							}  							else if (name == stringDateTime) {  								if (value is DateTime)  									writer.WriteInt64(((DateTime)value).Ticks);  								else {  									helper.Error("Expected a DateTime constant");  									writer.WriteInt64(0);  								}  								valueWritten = true;  							}  						}  						if (!valueWritten) {  							if (value is byte[])  								writer.WriteBytes((byte[])value);  							else if (!(value is null)) {  								helper.Error("Unsupported constant: " + value.GetType().FullName);  								return;  							}  						}  					}  					return;    				case ElementType.Class:  					WriteTypeDefOrRef(writer' ((ClassSig)type).TypeDefOrRef);  					if (value is byte[])  						writer.WriteBytes((byte[])value);  					else if (!(value is null))  						helper.Error("Expected a null constant");  					return;    				case ElementType.CModReqd:  				case ElementType.CModOpt:  					WriteTypeDefOrRef(writer' ((ModifierSig)type).Modifier);  					break;    				case ElementType.Var:  				case ElementType.Array:  				case ElementType.GenericInst:  				case ElementType.TypedByRef:  				case ElementType.I:  				case ElementType.U:  				case ElementType.FnPtr:  				case ElementType.SZArray:  				case ElementType.MVar:  					WriteTypeDefOrRef(writer' new TypeSpecUser(type));  					return;    				case ElementType.End:  				case ElementType.Void:  				case ElementType.ValueArray:  				case ElementType.R:  				case ElementType.Internal:  				case ElementType.Module:  				case ElementType.Sentinel:  				case ElementType.Pinned:  				default:  					helper.Error("Unsupported element type in LocalConstant sig blob: " + et.ToString());  					return;  				}
Magic Number,dnlib.DotNet.Pdb.Portable,LocalConstantSigBlobWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\LocalConstantSigBlobWriter.cs,Write,The following statement contains a magic number: switch (et) {  				case ElementType.Boolean:  				case ElementType.Char:  				case ElementType.I1:  				case ElementType.U1:  				case ElementType.I2:  				case ElementType.U2:  				case ElementType.I4:  				case ElementType.U4:  				case ElementType.I8:  				case ElementType.U8:  					WritePrimitiveValue(writer' et' value);  					return;    				case ElementType.R4:  					if (value is float)  						writer.WriteSingle((float)value);  					else {  						helper.Error("Expected a Single constant");  						writer.WriteSingle(0);  					}  					return;    				case ElementType.R8:  					if (value is double)  						writer.WriteDouble((double)value);  					else {  						helper.Error("Expected a Double constant");  						writer.WriteDouble(0);  					}  					return;    				case ElementType.String:  					if (value is null)  						writer.WriteByte((byte)0xFF);  					else if (value is string)  						writer.WriteBytes(Encoding.Unicode.GetBytes((string)value));  					else  						helper.Error("Expected a String constant");  					return;    				case ElementType.Ptr:  				case ElementType.ByRef:  					WriteTypeDefOrRef(writer' new TypeSpecUser(type));  					return;    				case ElementType.Object:  					return;    				case ElementType.ValueType:  					var tdr = ((ValueTypeSig)type).TypeDefOrRef;  					var td = tdr.ResolveTypeDef();  					if (td is null)  						helper.Error($"Couldn't resolve type 0x{tdr?.MDToken.Raw ?? 0:X8}");  					else if (td.IsEnum) {  						var underlyingType = td.GetEnumUnderlyingType().RemovePinnedAndModifiers();  						switch (underlyingType.GetElementType()) {  						case ElementType.Boolean:  						case ElementType.Char:  						case ElementType.I1:  						case ElementType.U1:  						case ElementType.I2:  						case ElementType.U2:  						case ElementType.I4:  						case ElementType.U4:  						case ElementType.I8:  						case ElementType.U8:  							writer.Position--;  							writer.WriteByte((byte)underlyingType.GetElementType());  							WritePrimitiveValue(writer' underlyingType.GetElementType()' value);  							WriteTypeDefOrRef(writer' tdr);  							return;  						default:  							helper.Error("Invalid enum underlying type");  							return;  						}  					}  					else {  						WriteTypeDefOrRef(writer' tdr);  						bool valueWritten = false;  						if (GetName(tdr' out var ns' out var name) && ns == stringSystem && tdr.DefinitionAssembly.IsCorLib()) {  							if (name == stringDecimal) {  								if (value is decimal) {  									var bits = decimal.GetBits((decimal)value);  									writer.WriteByte((byte)((((uint)bits[3] >> 31) << 7) | (((uint)bits[3] >> 16) & 0x7F)));  									writer.WriteInt32(bits[0]);  									writer.WriteInt32(bits[1]);  									writer.WriteInt32(bits[2]);  								}  								else {  									helper.Error("Expected a Decimal constant");  									writer.WriteBytes(new byte[13]);  								}  								valueWritten = true;  							}  							else if (name == stringDateTime) {  								if (value is DateTime)  									writer.WriteInt64(((DateTime)value).Ticks);  								else {  									helper.Error("Expected a DateTime constant");  									writer.WriteInt64(0);  								}  								valueWritten = true;  							}  						}  						if (!valueWritten) {  							if (value is byte[])  								writer.WriteBytes((byte[])value);  							else if (!(value is null)) {  								helper.Error("Unsupported constant: " + value.GetType().FullName);  								return;  							}  						}  					}  					return;    				case ElementType.Class:  					WriteTypeDefOrRef(writer' ((ClassSig)type).TypeDefOrRef);  					if (value is byte[])  						writer.WriteBytes((byte[])value);  					else if (!(value is null))  						helper.Error("Expected a null constant");  					return;    				case ElementType.CModReqd:  				case ElementType.CModOpt:  					WriteTypeDefOrRef(writer' ((ModifierSig)type).Modifier);  					break;    				case ElementType.Var:  				case ElementType.Array:  				case ElementType.GenericInst:  				case ElementType.TypedByRef:  				case ElementType.I:  				case ElementType.U:  				case ElementType.FnPtr:  				case ElementType.SZArray:  				case ElementType.MVar:  					WriteTypeDefOrRef(writer' new TypeSpecUser(type));  					return;    				case ElementType.End:  				case ElementType.Void:  				case ElementType.ValueArray:  				case ElementType.R:  				case ElementType.Internal:  				case ElementType.Module:  				case ElementType.Sentinel:  				case ElementType.Pinned:  				default:  					helper.Error("Unsupported element type in LocalConstant sig blob: " + et.ToString());  					return;  				}
Magic Number,dnlib.DotNet.Pdb.Portable,LocalConstantSigBlobWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\LocalConstantSigBlobWriter.cs,Write,The following statement contains a magic number: switch (et) {  				case ElementType.Boolean:  				case ElementType.Char:  				case ElementType.I1:  				case ElementType.U1:  				case ElementType.I2:  				case ElementType.U2:  				case ElementType.I4:  				case ElementType.U4:  				case ElementType.I8:  				case ElementType.U8:  					WritePrimitiveValue(writer' et' value);  					return;    				case ElementType.R4:  					if (value is float)  						writer.WriteSingle((float)value);  					else {  						helper.Error("Expected a Single constant");  						writer.WriteSingle(0);  					}  					return;    				case ElementType.R8:  					if (value is double)  						writer.WriteDouble((double)value);  					else {  						helper.Error("Expected a Double constant");  						writer.WriteDouble(0);  					}  					return;    				case ElementType.String:  					if (value is null)  						writer.WriteByte((byte)0xFF);  					else if (value is string)  						writer.WriteBytes(Encoding.Unicode.GetBytes((string)value));  					else  						helper.Error("Expected a String constant");  					return;    				case ElementType.Ptr:  				case ElementType.ByRef:  					WriteTypeDefOrRef(writer' new TypeSpecUser(type));  					return;    				case ElementType.Object:  					return;    				case ElementType.ValueType:  					var tdr = ((ValueTypeSig)type).TypeDefOrRef;  					var td = tdr.ResolveTypeDef();  					if (td is null)  						helper.Error($"Couldn't resolve type 0x{tdr?.MDToken.Raw ?? 0:X8}");  					else if (td.IsEnum) {  						var underlyingType = td.GetEnumUnderlyingType().RemovePinnedAndModifiers();  						switch (underlyingType.GetElementType()) {  						case ElementType.Boolean:  						case ElementType.Char:  						case ElementType.I1:  						case ElementType.U1:  						case ElementType.I2:  						case ElementType.U2:  						case ElementType.I4:  						case ElementType.U4:  						case ElementType.I8:  						case ElementType.U8:  							writer.Position--;  							writer.WriteByte((byte)underlyingType.GetElementType());  							WritePrimitiveValue(writer' underlyingType.GetElementType()' value);  							WriteTypeDefOrRef(writer' tdr);  							return;  						default:  							helper.Error("Invalid enum underlying type");  							return;  						}  					}  					else {  						WriteTypeDefOrRef(writer' tdr);  						bool valueWritten = false;  						if (GetName(tdr' out var ns' out var name) && ns == stringSystem && tdr.DefinitionAssembly.IsCorLib()) {  							if (name == stringDecimal) {  								if (value is decimal) {  									var bits = decimal.GetBits((decimal)value);  									writer.WriteByte((byte)((((uint)bits[3] >> 31) << 7) | (((uint)bits[3] >> 16) & 0x7F)));  									writer.WriteInt32(bits[0]);  									writer.WriteInt32(bits[1]);  									writer.WriteInt32(bits[2]);  								}  								else {  									helper.Error("Expected a Decimal constant");  									writer.WriteBytes(new byte[13]);  								}  								valueWritten = true;  							}  							else if (name == stringDateTime) {  								if (value is DateTime)  									writer.WriteInt64(((DateTime)value).Ticks);  								else {  									helper.Error("Expected a DateTime constant");  									writer.WriteInt64(0);  								}  								valueWritten = true;  							}  						}  						if (!valueWritten) {  							if (value is byte[])  								writer.WriteBytes((byte[])value);  							else if (!(value is null)) {  								helper.Error("Unsupported constant: " + value.GetType().FullName);  								return;  							}  						}  					}  					return;    				case ElementType.Class:  					WriteTypeDefOrRef(writer' ((ClassSig)type).TypeDefOrRef);  					if (value is byte[])  						writer.WriteBytes((byte[])value);  					else if (!(value is null))  						helper.Error("Expected a null constant");  					return;    				case ElementType.CModReqd:  				case ElementType.CModOpt:  					WriteTypeDefOrRef(writer' ((ModifierSig)type).Modifier);  					break;    				case ElementType.Var:  				case ElementType.Array:  				case ElementType.GenericInst:  				case ElementType.TypedByRef:  				case ElementType.I:  				case ElementType.U:  				case ElementType.FnPtr:  				case ElementType.SZArray:  				case ElementType.MVar:  					WriteTypeDefOrRef(writer' new TypeSpecUser(type));  					return;    				case ElementType.End:  				case ElementType.Void:  				case ElementType.ValueArray:  				case ElementType.R:  				case ElementType.Internal:  				case ElementType.Module:  				case ElementType.Sentinel:  				case ElementType.Pinned:  				default:  					helper.Error("Unsupported element type in LocalConstant sig blob: " + et.ToString());  					return;  				}
Magic Number,dnlib.DotNet.Pdb.Portable,PortablePdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\PortablePdbCustomDebugInfoReader.cs,ReadDynamicLocalVariables,The following statement contains a magic number: var flags = new bool[(int)reader.Length * 8];
Magic Number,dnlib.DotNet.Pdb.Portable,PortablePdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\PortablePdbCustomDebugInfoReader.cs,ReadStateMachineHoistedLocalScopes,The following statement contains a magic number: int count = (int)(reader.Length / 8);
Magic Number,dnlib.DotNet.Pdb.Portable,PortablePdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\PortablePdbCustomDebugInfoReader.cs,GetInstruction,The following statement contains a magic number: int i = (lo + hi) / 2;
Magic Number,dnlib.DotNet.Pdb.Portable,PortablePdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\PortablePdbCustomDebugInfoReader.cs,GetInstruction,The following statement contains a magic number: int i = (lo + hi) / 2;
Magic Number,dnlib.DotNet.Pdb.Portable,PortablePdbReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\PortablePdbReader.cs,MatchesModule,The following statement contains a magic number: Array.Resize(ref pdbGuidArray' 16);
Magic Number,dnlib.DotNet.Pdb.Portable,PortablePdbReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\PortablePdbReader.cs,MatchesModule,The following statement contains a magic number: BitConverter.ToUInt32(pdbStream.Id' 16) != timestamp
Magic Number,dnlib.DotNet.Pdb.Portable,PortablePdbReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\PortablePdbReader.cs,ReadPdbImportScope,The following statement contains a magic number: const int MAX = 1000;
Magic Number,dnlib.DotNet.Pdb.Portable,SymbolReaderFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\SymbolReaderFactory.cs,TryCreate,The following statement contains a magic number: pdbStream.Length < 4
Magic Number,dnlib.DotNet.Pdb.Portable,SymbolReaderFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Portable\SymbolReaderFactory.cs,TryCreateEmbeddedPortablePdbReader,The following statement contains a magic number: reader.Length < 8
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoReader.cs,Read,The following statement contains a magic number: reader.Length < 4
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoReader.cs,Read,The following statement contains a magic number: reader.Position += 2;
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoReader.cs,Read,The following statement contains a magic number: recSize < 8 || (ulong)reader.Position - 8 + (uint)recSize > reader.Length
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoReader.cs,Read,The following statement contains a magic number: recSize < 8 || (ulong)reader.Position - 8 + (uint)recSize > reader.Length
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoReader.cs,Read,The following statement contains a magic number: alignmentSize > 3
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoReader.cs,Read,The following statement contains a magic number: var nextRecPos = reader.Position - 8 + (uint)recSize;
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoReader.cs,Read,The following statement contains a magic number: ulong recPosEnd = (ulong)reader.Position - 8 + (uint)recSize - (uint)alignmentSize;
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoReader.cs,Read,The following statement contains a magic number: reader.CanRead(8U)
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoReader.cs,ReadRecord,The following statement contains a magic number: switch (recKind) {  			case PdbCustomDebugInfoKind.UsingGroups:  				count = reader.ReadUInt16();  				if (count < 0)  					return null;  				var usingCountRec = new PdbUsingGroupsCustomDebugInfo(count);  				for (int i = 0; i < count; i++)  					usingCountRec.UsingCounts.Add(reader.ReadUInt16());  				return usingCountRec;    			case PdbCustomDebugInfoKind.ForwardMethodInfo:  				method = module.ResolveToken(reader.ReadUInt32()' gpContext) as IMethodDefOrRef;  				if (method is null)  					return null;  				return new PdbForwardMethodInfoCustomDebugInfo(method);    			case PdbCustomDebugInfoKind.ForwardModuleInfo:  				method = module.ResolveToken(reader.ReadUInt32()' gpContext) as IMethodDefOrRef;  				if (method is null)  					return null;  				return new PdbForwardModuleInfoCustomDebugInfo(method);    			case PdbCustomDebugInfoKind.StateMachineHoistedLocalScopes:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				if (count < 0)  					return null;  				var smScope = new PdbStateMachineHoistedLocalScopesCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					uint startOffset = reader.ReadUInt32();  					uint endOffset = reader.ReadUInt32();  					if (startOffset > endOffset)  						return null;  					// Try to detect synthesized locals' whose start==end==0. The problem is that endOffset  					// read from the PDB is inclusive (add 1 to get 'end')' so a synthesized local and a  					// local at [0' 1) will be encoded the same {0' 0}.  					if (endOffset == 0)  						smScope.Scopes.Add(new StateMachineHoistedLocalScope());  					else {  						var start = GetInstruction(startOffset);  						var end = GetInstruction(endOffset + 1);  						if (start is null)  							return null;  						smScope.Scopes.Add(new StateMachineHoistedLocalScope(start' end));  					}  				}  				return smScope;    			case PdbCustomDebugInfoKind.StateMachineTypeName:  				var name = ReadUnicodeZ(recPosEnd' needZeroChar: true);  				if (name is null)  					return null;  				var type = GetNestedType(name);  				if (type is null)  					return null;  				return new PdbStateMachineTypeNameCustomDebugInfo(type);    			case PdbCustomDebugInfoKind.DynamicLocals:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				const int dynLocalRecSize = 64 + 4 + 4 + 2 * 64;  				if (reader.Position + (ulong)(uint)count * dynLocalRecSize > recPosEnd)  					return null;  				var dynLocListRec = new PdbDynamicLocalsCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					reader.Position += 64;  					int flagsCount = reader.ReadInt32();  					if ((uint)flagsCount > 64)  						return null;  					var dynLocRec = new PdbDynamicLocal(flagsCount);  					var afterPos = reader.Position;    					reader.Position -= 64 + 4;  					for (int j = 0; j < flagsCount; j++)  						dynLocRec.Flags.Add(reader.ReadByte());  					reader.Position = afterPos;    					localIndex = reader.ReadInt32();  					// 'const' locals have index -1 but they're encoded as 0 by Roslyn  					if (localIndex != 0 && (uint)localIndex >= (uint)bodyOpt.Variables.Count)  						return null;    					var nameEndPos = reader.Position + 2 * 64;  					name = ReadUnicodeZ(nameEndPos' needZeroChar: false);  					reader.Position = nameEndPos;    					local = localIndex < bodyOpt.Variables.Count ? bodyOpt.Variables[localIndex] : null;  					// Roslyn writes 0 to localIndex if it's a 'const' local' try to undo that now  					if (localIndex == 0 && !(local is null) && local.Name != name)  						local = null;  					if (!(local is null) && local.Name == name)  						name = null;  					dynLocRec.Name = name;  					dynLocRec.Local = local;  					dynLocListRec.Locals.Add(dynLocRec);  				}  				return dynLocListRec;    			case PdbCustomDebugInfoKind.EditAndContinueLocalSlotMap:  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbEditAndContinueLocalSlotMapCustomDebugInfo(data);    			case PdbCustomDebugInfoKind.EditAndContinueLambdaMap:  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbEditAndContinueLambdaMapCustomDebugInfo(data);    			case PdbCustomDebugInfoKind.TupleElementNames:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				if (count < 0)  					return null;  				var tupleListRec = new PdbTupleElementNamesCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					int nameCount = reader.ReadInt32();  					if ((uint)nameCount >= 10000)  						return null;  					var tupleInfo = new PdbTupleElementNames(nameCount);    					for (int j = 0; j < nameCount; j++) {  						var s = ReadUTF8Z(recPosEnd);  						if (s is null)  							return null;  						tupleInfo.TupleElementNames.Add(s);  					}    					localIndex = reader.ReadInt32();  					uint scopeStart = reader.ReadUInt32();  					uint scopeEnd = reader.ReadUInt32();  					name = ReadUTF8Z(recPosEnd);  					if (name is null)  						return null;  					Debug.Assert(localIndex >= -1);  					// -1 = 'const' local. Only 'const' locals have a scope  					Debug.Assert((localIndex == -1) ^ (scopeStart == 0 && scopeEnd == 0));    					if (localIndex == -1) {  						local = null;  						tupleInfo.ScopeStart = GetInstruction(scopeStart);  						tupleInfo.ScopeEnd = GetInstruction(scopeEnd);  						if (tupleInfo.ScopeStart is null)  							return null;  					}  					else {  						if ((uint)localIndex >= (uint)bodyOpt.Variables.Count)  							return null;  						local = bodyOpt.Variables[localIndex];  					}    					if (!(local is null) && local.Name == name)  						name = null;  					tupleInfo.Local = local;  					tupleInfo.Name = name;    					tupleListRec.Names.Add(tupleInfo);  				}  				return tupleListRec;    			default:  				Debug.Fail("Unknown custom debug info kind: 0x" + ((int)recKind).ToString("X"));  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbUnknownCustomDebugInfo(recKind' data);  			}
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoReader.cs,ReadRecord,The following statement contains a magic number: switch (recKind) {  			case PdbCustomDebugInfoKind.UsingGroups:  				count = reader.ReadUInt16();  				if (count < 0)  					return null;  				var usingCountRec = new PdbUsingGroupsCustomDebugInfo(count);  				for (int i = 0; i < count; i++)  					usingCountRec.UsingCounts.Add(reader.ReadUInt16());  				return usingCountRec;    			case PdbCustomDebugInfoKind.ForwardMethodInfo:  				method = module.ResolveToken(reader.ReadUInt32()' gpContext) as IMethodDefOrRef;  				if (method is null)  					return null;  				return new PdbForwardMethodInfoCustomDebugInfo(method);    			case PdbCustomDebugInfoKind.ForwardModuleInfo:  				method = module.ResolveToken(reader.ReadUInt32()' gpContext) as IMethodDefOrRef;  				if (method is null)  					return null;  				return new PdbForwardModuleInfoCustomDebugInfo(method);    			case PdbCustomDebugInfoKind.StateMachineHoistedLocalScopes:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				if (count < 0)  					return null;  				var smScope = new PdbStateMachineHoistedLocalScopesCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					uint startOffset = reader.ReadUInt32();  					uint endOffset = reader.ReadUInt32();  					if (startOffset > endOffset)  						return null;  					// Try to detect synthesized locals' whose start==end==0. The problem is that endOffset  					// read from the PDB is inclusive (add 1 to get 'end')' so a synthesized local and a  					// local at [0' 1) will be encoded the same {0' 0}.  					if (endOffset == 0)  						smScope.Scopes.Add(new StateMachineHoistedLocalScope());  					else {  						var start = GetInstruction(startOffset);  						var end = GetInstruction(endOffset + 1);  						if (start is null)  							return null;  						smScope.Scopes.Add(new StateMachineHoistedLocalScope(start' end));  					}  				}  				return smScope;    			case PdbCustomDebugInfoKind.StateMachineTypeName:  				var name = ReadUnicodeZ(recPosEnd' needZeroChar: true);  				if (name is null)  					return null;  				var type = GetNestedType(name);  				if (type is null)  					return null;  				return new PdbStateMachineTypeNameCustomDebugInfo(type);    			case PdbCustomDebugInfoKind.DynamicLocals:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				const int dynLocalRecSize = 64 + 4 + 4 + 2 * 64;  				if (reader.Position + (ulong)(uint)count * dynLocalRecSize > recPosEnd)  					return null;  				var dynLocListRec = new PdbDynamicLocalsCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					reader.Position += 64;  					int flagsCount = reader.ReadInt32();  					if ((uint)flagsCount > 64)  						return null;  					var dynLocRec = new PdbDynamicLocal(flagsCount);  					var afterPos = reader.Position;    					reader.Position -= 64 + 4;  					for (int j = 0; j < flagsCount; j++)  						dynLocRec.Flags.Add(reader.ReadByte());  					reader.Position = afterPos;    					localIndex = reader.ReadInt32();  					// 'const' locals have index -1 but they're encoded as 0 by Roslyn  					if (localIndex != 0 && (uint)localIndex >= (uint)bodyOpt.Variables.Count)  						return null;    					var nameEndPos = reader.Position + 2 * 64;  					name = ReadUnicodeZ(nameEndPos' needZeroChar: false);  					reader.Position = nameEndPos;    					local = localIndex < bodyOpt.Variables.Count ? bodyOpt.Variables[localIndex] : null;  					// Roslyn writes 0 to localIndex if it's a 'const' local' try to undo that now  					if (localIndex == 0 && !(local is null) && local.Name != name)  						local = null;  					if (!(local is null) && local.Name == name)  						name = null;  					dynLocRec.Name = name;  					dynLocRec.Local = local;  					dynLocListRec.Locals.Add(dynLocRec);  				}  				return dynLocListRec;    			case PdbCustomDebugInfoKind.EditAndContinueLocalSlotMap:  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbEditAndContinueLocalSlotMapCustomDebugInfo(data);    			case PdbCustomDebugInfoKind.EditAndContinueLambdaMap:  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbEditAndContinueLambdaMapCustomDebugInfo(data);    			case PdbCustomDebugInfoKind.TupleElementNames:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				if (count < 0)  					return null;  				var tupleListRec = new PdbTupleElementNamesCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					int nameCount = reader.ReadInt32();  					if ((uint)nameCount >= 10000)  						return null;  					var tupleInfo = new PdbTupleElementNames(nameCount);    					for (int j = 0; j < nameCount; j++) {  						var s = ReadUTF8Z(recPosEnd);  						if (s is null)  							return null;  						tupleInfo.TupleElementNames.Add(s);  					}    					localIndex = reader.ReadInt32();  					uint scopeStart = reader.ReadUInt32();  					uint scopeEnd = reader.ReadUInt32();  					name = ReadUTF8Z(recPosEnd);  					if (name is null)  						return null;  					Debug.Assert(localIndex >= -1);  					// -1 = 'const' local. Only 'const' locals have a scope  					Debug.Assert((localIndex == -1) ^ (scopeStart == 0 && scopeEnd == 0));    					if (localIndex == -1) {  						local = null;  						tupleInfo.ScopeStart = GetInstruction(scopeStart);  						tupleInfo.ScopeEnd = GetInstruction(scopeEnd);  						if (tupleInfo.ScopeStart is null)  							return null;  					}  					else {  						if ((uint)localIndex >= (uint)bodyOpt.Variables.Count)  							return null;  						local = bodyOpt.Variables[localIndex];  					}    					if (!(local is null) && local.Name == name)  						name = null;  					tupleInfo.Local = local;  					tupleInfo.Name = name;    					tupleListRec.Names.Add(tupleInfo);  				}  				return tupleListRec;    			default:  				Debug.Fail("Unknown custom debug info kind: 0x" + ((int)recKind).ToString("X"));  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbUnknownCustomDebugInfo(recKind' data);  			}
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoReader.cs,ReadRecord,The following statement contains a magic number: switch (recKind) {  			case PdbCustomDebugInfoKind.UsingGroups:  				count = reader.ReadUInt16();  				if (count < 0)  					return null;  				var usingCountRec = new PdbUsingGroupsCustomDebugInfo(count);  				for (int i = 0; i < count; i++)  					usingCountRec.UsingCounts.Add(reader.ReadUInt16());  				return usingCountRec;    			case PdbCustomDebugInfoKind.ForwardMethodInfo:  				method = module.ResolveToken(reader.ReadUInt32()' gpContext) as IMethodDefOrRef;  				if (method is null)  					return null;  				return new PdbForwardMethodInfoCustomDebugInfo(method);    			case PdbCustomDebugInfoKind.ForwardModuleInfo:  				method = module.ResolveToken(reader.ReadUInt32()' gpContext) as IMethodDefOrRef;  				if (method is null)  					return null;  				return new PdbForwardModuleInfoCustomDebugInfo(method);    			case PdbCustomDebugInfoKind.StateMachineHoistedLocalScopes:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				if (count < 0)  					return null;  				var smScope = new PdbStateMachineHoistedLocalScopesCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					uint startOffset = reader.ReadUInt32();  					uint endOffset = reader.ReadUInt32();  					if (startOffset > endOffset)  						return null;  					// Try to detect synthesized locals' whose start==end==0. The problem is that endOffset  					// read from the PDB is inclusive (add 1 to get 'end')' so a synthesized local and a  					// local at [0' 1) will be encoded the same {0' 0}.  					if (endOffset == 0)  						smScope.Scopes.Add(new StateMachineHoistedLocalScope());  					else {  						var start = GetInstruction(startOffset);  						var end = GetInstruction(endOffset + 1);  						if (start is null)  							return null;  						smScope.Scopes.Add(new StateMachineHoistedLocalScope(start' end));  					}  				}  				return smScope;    			case PdbCustomDebugInfoKind.StateMachineTypeName:  				var name = ReadUnicodeZ(recPosEnd' needZeroChar: true);  				if (name is null)  					return null;  				var type = GetNestedType(name);  				if (type is null)  					return null;  				return new PdbStateMachineTypeNameCustomDebugInfo(type);    			case PdbCustomDebugInfoKind.DynamicLocals:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				const int dynLocalRecSize = 64 + 4 + 4 + 2 * 64;  				if (reader.Position + (ulong)(uint)count * dynLocalRecSize > recPosEnd)  					return null;  				var dynLocListRec = new PdbDynamicLocalsCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					reader.Position += 64;  					int flagsCount = reader.ReadInt32();  					if ((uint)flagsCount > 64)  						return null;  					var dynLocRec = new PdbDynamicLocal(flagsCount);  					var afterPos = reader.Position;    					reader.Position -= 64 + 4;  					for (int j = 0; j < flagsCount; j++)  						dynLocRec.Flags.Add(reader.ReadByte());  					reader.Position = afterPos;    					localIndex = reader.ReadInt32();  					// 'const' locals have index -1 but they're encoded as 0 by Roslyn  					if (localIndex != 0 && (uint)localIndex >= (uint)bodyOpt.Variables.Count)  						return null;    					var nameEndPos = reader.Position + 2 * 64;  					name = ReadUnicodeZ(nameEndPos' needZeroChar: false);  					reader.Position = nameEndPos;    					local = localIndex < bodyOpt.Variables.Count ? bodyOpt.Variables[localIndex] : null;  					// Roslyn writes 0 to localIndex if it's a 'const' local' try to undo that now  					if (localIndex == 0 && !(local is null) && local.Name != name)  						local = null;  					if (!(local is null) && local.Name == name)  						name = null;  					dynLocRec.Name = name;  					dynLocRec.Local = local;  					dynLocListRec.Locals.Add(dynLocRec);  				}  				return dynLocListRec;    			case PdbCustomDebugInfoKind.EditAndContinueLocalSlotMap:  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbEditAndContinueLocalSlotMapCustomDebugInfo(data);    			case PdbCustomDebugInfoKind.EditAndContinueLambdaMap:  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbEditAndContinueLambdaMapCustomDebugInfo(data);    			case PdbCustomDebugInfoKind.TupleElementNames:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				if (count < 0)  					return null;  				var tupleListRec = new PdbTupleElementNamesCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					int nameCount = reader.ReadInt32();  					if ((uint)nameCount >= 10000)  						return null;  					var tupleInfo = new PdbTupleElementNames(nameCount);    					for (int j = 0; j < nameCount; j++) {  						var s = ReadUTF8Z(recPosEnd);  						if (s is null)  							return null;  						tupleInfo.TupleElementNames.Add(s);  					}    					localIndex = reader.ReadInt32();  					uint scopeStart = reader.ReadUInt32();  					uint scopeEnd = reader.ReadUInt32();  					name = ReadUTF8Z(recPosEnd);  					if (name is null)  						return null;  					Debug.Assert(localIndex >= -1);  					// -1 = 'const' local. Only 'const' locals have a scope  					Debug.Assert((localIndex == -1) ^ (scopeStart == 0 && scopeEnd == 0));    					if (localIndex == -1) {  						local = null;  						tupleInfo.ScopeStart = GetInstruction(scopeStart);  						tupleInfo.ScopeEnd = GetInstruction(scopeEnd);  						if (tupleInfo.ScopeStart is null)  							return null;  					}  					else {  						if ((uint)localIndex >= (uint)bodyOpt.Variables.Count)  							return null;  						local = bodyOpt.Variables[localIndex];  					}    					if (!(local is null) && local.Name == name)  						name = null;  					tupleInfo.Local = local;  					tupleInfo.Name = name;    					tupleListRec.Names.Add(tupleInfo);  				}  				return tupleListRec;    			default:  				Debug.Fail("Unknown custom debug info kind: 0x" + ((int)recKind).ToString("X"));  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbUnknownCustomDebugInfo(recKind' data);  			}
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoReader.cs,ReadRecord,The following statement contains a magic number: switch (recKind) {  			case PdbCustomDebugInfoKind.UsingGroups:  				count = reader.ReadUInt16();  				if (count < 0)  					return null;  				var usingCountRec = new PdbUsingGroupsCustomDebugInfo(count);  				for (int i = 0; i < count; i++)  					usingCountRec.UsingCounts.Add(reader.ReadUInt16());  				return usingCountRec;    			case PdbCustomDebugInfoKind.ForwardMethodInfo:  				method = module.ResolveToken(reader.ReadUInt32()' gpContext) as IMethodDefOrRef;  				if (method is null)  					return null;  				return new PdbForwardMethodInfoCustomDebugInfo(method);    			case PdbCustomDebugInfoKind.ForwardModuleInfo:  				method = module.ResolveToken(reader.ReadUInt32()' gpContext) as IMethodDefOrRef;  				if (method is null)  					return null;  				return new PdbForwardModuleInfoCustomDebugInfo(method);    			case PdbCustomDebugInfoKind.StateMachineHoistedLocalScopes:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				if (count < 0)  					return null;  				var smScope = new PdbStateMachineHoistedLocalScopesCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					uint startOffset = reader.ReadUInt32();  					uint endOffset = reader.ReadUInt32();  					if (startOffset > endOffset)  						return null;  					// Try to detect synthesized locals' whose start==end==0. The problem is that endOffset  					// read from the PDB is inclusive (add 1 to get 'end')' so a synthesized local and a  					// local at [0' 1) will be encoded the same {0' 0}.  					if (endOffset == 0)  						smScope.Scopes.Add(new StateMachineHoistedLocalScope());  					else {  						var start = GetInstruction(startOffset);  						var end = GetInstruction(endOffset + 1);  						if (start is null)  							return null;  						smScope.Scopes.Add(new StateMachineHoistedLocalScope(start' end));  					}  				}  				return smScope;    			case PdbCustomDebugInfoKind.StateMachineTypeName:  				var name = ReadUnicodeZ(recPosEnd' needZeroChar: true);  				if (name is null)  					return null;  				var type = GetNestedType(name);  				if (type is null)  					return null;  				return new PdbStateMachineTypeNameCustomDebugInfo(type);    			case PdbCustomDebugInfoKind.DynamicLocals:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				const int dynLocalRecSize = 64 + 4 + 4 + 2 * 64;  				if (reader.Position + (ulong)(uint)count * dynLocalRecSize > recPosEnd)  					return null;  				var dynLocListRec = new PdbDynamicLocalsCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					reader.Position += 64;  					int flagsCount = reader.ReadInt32();  					if ((uint)flagsCount > 64)  						return null;  					var dynLocRec = new PdbDynamicLocal(flagsCount);  					var afterPos = reader.Position;    					reader.Position -= 64 + 4;  					for (int j = 0; j < flagsCount; j++)  						dynLocRec.Flags.Add(reader.ReadByte());  					reader.Position = afterPos;    					localIndex = reader.ReadInt32();  					// 'const' locals have index -1 but they're encoded as 0 by Roslyn  					if (localIndex != 0 && (uint)localIndex >= (uint)bodyOpt.Variables.Count)  						return null;    					var nameEndPos = reader.Position + 2 * 64;  					name = ReadUnicodeZ(nameEndPos' needZeroChar: false);  					reader.Position = nameEndPos;    					local = localIndex < bodyOpt.Variables.Count ? bodyOpt.Variables[localIndex] : null;  					// Roslyn writes 0 to localIndex if it's a 'const' local' try to undo that now  					if (localIndex == 0 && !(local is null) && local.Name != name)  						local = null;  					if (!(local is null) && local.Name == name)  						name = null;  					dynLocRec.Name = name;  					dynLocRec.Local = local;  					dynLocListRec.Locals.Add(dynLocRec);  				}  				return dynLocListRec;    			case PdbCustomDebugInfoKind.EditAndContinueLocalSlotMap:  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbEditAndContinueLocalSlotMapCustomDebugInfo(data);    			case PdbCustomDebugInfoKind.EditAndContinueLambdaMap:  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbEditAndContinueLambdaMapCustomDebugInfo(data);    			case PdbCustomDebugInfoKind.TupleElementNames:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				if (count < 0)  					return null;  				var tupleListRec = new PdbTupleElementNamesCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					int nameCount = reader.ReadInt32();  					if ((uint)nameCount >= 10000)  						return null;  					var tupleInfo = new PdbTupleElementNames(nameCount);    					for (int j = 0; j < nameCount; j++) {  						var s = ReadUTF8Z(recPosEnd);  						if (s is null)  							return null;  						tupleInfo.TupleElementNames.Add(s);  					}    					localIndex = reader.ReadInt32();  					uint scopeStart = reader.ReadUInt32();  					uint scopeEnd = reader.ReadUInt32();  					name = ReadUTF8Z(recPosEnd);  					if (name is null)  						return null;  					Debug.Assert(localIndex >= -1);  					// -1 = 'const' local. Only 'const' locals have a scope  					Debug.Assert((localIndex == -1) ^ (scopeStart == 0 && scopeEnd == 0));    					if (localIndex == -1) {  						local = null;  						tupleInfo.ScopeStart = GetInstruction(scopeStart);  						tupleInfo.ScopeEnd = GetInstruction(scopeEnd);  						if (tupleInfo.ScopeStart is null)  							return null;  					}  					else {  						if ((uint)localIndex >= (uint)bodyOpt.Variables.Count)  							return null;  						local = bodyOpt.Variables[localIndex];  					}    					if (!(local is null) && local.Name == name)  						name = null;  					tupleInfo.Local = local;  					tupleInfo.Name = name;    					tupleListRec.Names.Add(tupleInfo);  				}  				return tupleListRec;    			default:  				Debug.Fail("Unknown custom debug info kind: 0x" + ((int)recKind).ToString("X"));  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbUnknownCustomDebugInfo(recKind' data);  			}
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoReader.cs,ReadRecord,The following statement contains a magic number: switch (recKind) {  			case PdbCustomDebugInfoKind.UsingGroups:  				count = reader.ReadUInt16();  				if (count < 0)  					return null;  				var usingCountRec = new PdbUsingGroupsCustomDebugInfo(count);  				for (int i = 0; i < count; i++)  					usingCountRec.UsingCounts.Add(reader.ReadUInt16());  				return usingCountRec;    			case PdbCustomDebugInfoKind.ForwardMethodInfo:  				method = module.ResolveToken(reader.ReadUInt32()' gpContext) as IMethodDefOrRef;  				if (method is null)  					return null;  				return new PdbForwardMethodInfoCustomDebugInfo(method);    			case PdbCustomDebugInfoKind.ForwardModuleInfo:  				method = module.ResolveToken(reader.ReadUInt32()' gpContext) as IMethodDefOrRef;  				if (method is null)  					return null;  				return new PdbForwardModuleInfoCustomDebugInfo(method);    			case PdbCustomDebugInfoKind.StateMachineHoistedLocalScopes:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				if (count < 0)  					return null;  				var smScope = new PdbStateMachineHoistedLocalScopesCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					uint startOffset = reader.ReadUInt32();  					uint endOffset = reader.ReadUInt32();  					if (startOffset > endOffset)  						return null;  					// Try to detect synthesized locals' whose start==end==0. The problem is that endOffset  					// read from the PDB is inclusive (add 1 to get 'end')' so a synthesized local and a  					// local at [0' 1) will be encoded the same {0' 0}.  					if (endOffset == 0)  						smScope.Scopes.Add(new StateMachineHoistedLocalScope());  					else {  						var start = GetInstruction(startOffset);  						var end = GetInstruction(endOffset + 1);  						if (start is null)  							return null;  						smScope.Scopes.Add(new StateMachineHoistedLocalScope(start' end));  					}  				}  				return smScope;    			case PdbCustomDebugInfoKind.StateMachineTypeName:  				var name = ReadUnicodeZ(recPosEnd' needZeroChar: true);  				if (name is null)  					return null;  				var type = GetNestedType(name);  				if (type is null)  					return null;  				return new PdbStateMachineTypeNameCustomDebugInfo(type);    			case PdbCustomDebugInfoKind.DynamicLocals:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				const int dynLocalRecSize = 64 + 4 + 4 + 2 * 64;  				if (reader.Position + (ulong)(uint)count * dynLocalRecSize > recPosEnd)  					return null;  				var dynLocListRec = new PdbDynamicLocalsCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					reader.Position += 64;  					int flagsCount = reader.ReadInt32();  					if ((uint)flagsCount > 64)  						return null;  					var dynLocRec = new PdbDynamicLocal(flagsCount);  					var afterPos = reader.Position;    					reader.Position -= 64 + 4;  					for (int j = 0; j < flagsCount; j++)  						dynLocRec.Flags.Add(reader.ReadByte());  					reader.Position = afterPos;    					localIndex = reader.ReadInt32();  					// 'const' locals have index -1 but they're encoded as 0 by Roslyn  					if (localIndex != 0 && (uint)localIndex >= (uint)bodyOpt.Variables.Count)  						return null;    					var nameEndPos = reader.Position + 2 * 64;  					name = ReadUnicodeZ(nameEndPos' needZeroChar: false);  					reader.Position = nameEndPos;    					local = localIndex < bodyOpt.Variables.Count ? bodyOpt.Variables[localIndex] : null;  					// Roslyn writes 0 to localIndex if it's a 'const' local' try to undo that now  					if (localIndex == 0 && !(local is null) && local.Name != name)  						local = null;  					if (!(local is null) && local.Name == name)  						name = null;  					dynLocRec.Name = name;  					dynLocRec.Local = local;  					dynLocListRec.Locals.Add(dynLocRec);  				}  				return dynLocListRec;    			case PdbCustomDebugInfoKind.EditAndContinueLocalSlotMap:  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbEditAndContinueLocalSlotMapCustomDebugInfo(data);    			case PdbCustomDebugInfoKind.EditAndContinueLambdaMap:  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbEditAndContinueLambdaMapCustomDebugInfo(data);    			case PdbCustomDebugInfoKind.TupleElementNames:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				if (count < 0)  					return null;  				var tupleListRec = new PdbTupleElementNamesCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					int nameCount = reader.ReadInt32();  					if ((uint)nameCount >= 10000)  						return null;  					var tupleInfo = new PdbTupleElementNames(nameCount);    					for (int j = 0; j < nameCount; j++) {  						var s = ReadUTF8Z(recPosEnd);  						if (s is null)  							return null;  						tupleInfo.TupleElementNames.Add(s);  					}    					localIndex = reader.ReadInt32();  					uint scopeStart = reader.ReadUInt32();  					uint scopeEnd = reader.ReadUInt32();  					name = ReadUTF8Z(recPosEnd);  					if (name is null)  						return null;  					Debug.Assert(localIndex >= -1);  					// -1 = 'const' local. Only 'const' locals have a scope  					Debug.Assert((localIndex == -1) ^ (scopeStart == 0 && scopeEnd == 0));    					if (localIndex == -1) {  						local = null;  						tupleInfo.ScopeStart = GetInstruction(scopeStart);  						tupleInfo.ScopeEnd = GetInstruction(scopeEnd);  						if (tupleInfo.ScopeStart is null)  							return null;  					}  					else {  						if ((uint)localIndex >= (uint)bodyOpt.Variables.Count)  							return null;  						local = bodyOpt.Variables[localIndex];  					}    					if (!(local is null) && local.Name == name)  						name = null;  					tupleInfo.Local = local;  					tupleInfo.Name = name;    					tupleListRec.Names.Add(tupleInfo);  				}  				return tupleListRec;    			default:  				Debug.Fail("Unknown custom debug info kind: 0x" + ((int)recKind).ToString("X"));  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbUnknownCustomDebugInfo(recKind' data);  			}
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoReader.cs,ReadRecord,The following statement contains a magic number: switch (recKind) {  			case PdbCustomDebugInfoKind.UsingGroups:  				count = reader.ReadUInt16();  				if (count < 0)  					return null;  				var usingCountRec = new PdbUsingGroupsCustomDebugInfo(count);  				for (int i = 0; i < count; i++)  					usingCountRec.UsingCounts.Add(reader.ReadUInt16());  				return usingCountRec;    			case PdbCustomDebugInfoKind.ForwardMethodInfo:  				method = module.ResolveToken(reader.ReadUInt32()' gpContext) as IMethodDefOrRef;  				if (method is null)  					return null;  				return new PdbForwardMethodInfoCustomDebugInfo(method);    			case PdbCustomDebugInfoKind.ForwardModuleInfo:  				method = module.ResolveToken(reader.ReadUInt32()' gpContext) as IMethodDefOrRef;  				if (method is null)  					return null;  				return new PdbForwardModuleInfoCustomDebugInfo(method);    			case PdbCustomDebugInfoKind.StateMachineHoistedLocalScopes:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				if (count < 0)  					return null;  				var smScope = new PdbStateMachineHoistedLocalScopesCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					uint startOffset = reader.ReadUInt32();  					uint endOffset = reader.ReadUInt32();  					if (startOffset > endOffset)  						return null;  					// Try to detect synthesized locals' whose start==end==0. The problem is that endOffset  					// read from the PDB is inclusive (add 1 to get 'end')' so a synthesized local and a  					// local at [0' 1) will be encoded the same {0' 0}.  					if (endOffset == 0)  						smScope.Scopes.Add(new StateMachineHoistedLocalScope());  					else {  						var start = GetInstruction(startOffset);  						var end = GetInstruction(endOffset + 1);  						if (start is null)  							return null;  						smScope.Scopes.Add(new StateMachineHoistedLocalScope(start' end));  					}  				}  				return smScope;    			case PdbCustomDebugInfoKind.StateMachineTypeName:  				var name = ReadUnicodeZ(recPosEnd' needZeroChar: true);  				if (name is null)  					return null;  				var type = GetNestedType(name);  				if (type is null)  					return null;  				return new PdbStateMachineTypeNameCustomDebugInfo(type);    			case PdbCustomDebugInfoKind.DynamicLocals:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				const int dynLocalRecSize = 64 + 4 + 4 + 2 * 64;  				if (reader.Position + (ulong)(uint)count * dynLocalRecSize > recPosEnd)  					return null;  				var dynLocListRec = new PdbDynamicLocalsCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					reader.Position += 64;  					int flagsCount = reader.ReadInt32();  					if ((uint)flagsCount > 64)  						return null;  					var dynLocRec = new PdbDynamicLocal(flagsCount);  					var afterPos = reader.Position;    					reader.Position -= 64 + 4;  					for (int j = 0; j < flagsCount; j++)  						dynLocRec.Flags.Add(reader.ReadByte());  					reader.Position = afterPos;    					localIndex = reader.ReadInt32();  					// 'const' locals have index -1 but they're encoded as 0 by Roslyn  					if (localIndex != 0 && (uint)localIndex >= (uint)bodyOpt.Variables.Count)  						return null;    					var nameEndPos = reader.Position + 2 * 64;  					name = ReadUnicodeZ(nameEndPos' needZeroChar: false);  					reader.Position = nameEndPos;    					local = localIndex < bodyOpt.Variables.Count ? bodyOpt.Variables[localIndex] : null;  					// Roslyn writes 0 to localIndex if it's a 'const' local' try to undo that now  					if (localIndex == 0 && !(local is null) && local.Name != name)  						local = null;  					if (!(local is null) && local.Name == name)  						name = null;  					dynLocRec.Name = name;  					dynLocRec.Local = local;  					dynLocListRec.Locals.Add(dynLocRec);  				}  				return dynLocListRec;    			case PdbCustomDebugInfoKind.EditAndContinueLocalSlotMap:  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbEditAndContinueLocalSlotMapCustomDebugInfo(data);    			case PdbCustomDebugInfoKind.EditAndContinueLambdaMap:  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbEditAndContinueLambdaMapCustomDebugInfo(data);    			case PdbCustomDebugInfoKind.TupleElementNames:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				if (count < 0)  					return null;  				var tupleListRec = new PdbTupleElementNamesCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					int nameCount = reader.ReadInt32();  					if ((uint)nameCount >= 10000)  						return null;  					var tupleInfo = new PdbTupleElementNames(nameCount);    					for (int j = 0; j < nameCount; j++) {  						var s = ReadUTF8Z(recPosEnd);  						if (s is null)  							return null;  						tupleInfo.TupleElementNames.Add(s);  					}    					localIndex = reader.ReadInt32();  					uint scopeStart = reader.ReadUInt32();  					uint scopeEnd = reader.ReadUInt32();  					name = ReadUTF8Z(recPosEnd);  					if (name is null)  						return null;  					Debug.Assert(localIndex >= -1);  					// -1 = 'const' local. Only 'const' locals have a scope  					Debug.Assert((localIndex == -1) ^ (scopeStart == 0 && scopeEnd == 0));    					if (localIndex == -1) {  						local = null;  						tupleInfo.ScopeStart = GetInstruction(scopeStart);  						tupleInfo.ScopeEnd = GetInstruction(scopeEnd);  						if (tupleInfo.ScopeStart is null)  							return null;  					}  					else {  						if ((uint)localIndex >= (uint)bodyOpt.Variables.Count)  							return null;  						local = bodyOpt.Variables[localIndex];  					}    					if (!(local is null) && local.Name == name)  						name = null;  					tupleInfo.Local = local;  					tupleInfo.Name = name;    					tupleListRec.Names.Add(tupleInfo);  				}  				return tupleListRec;    			default:  				Debug.Fail("Unknown custom debug info kind: 0x" + ((int)recKind).ToString("X"));  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbUnknownCustomDebugInfo(recKind' data);  			}
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoReader.cs,ReadRecord,The following statement contains a magic number: switch (recKind) {  			case PdbCustomDebugInfoKind.UsingGroups:  				count = reader.ReadUInt16();  				if (count < 0)  					return null;  				var usingCountRec = new PdbUsingGroupsCustomDebugInfo(count);  				for (int i = 0; i < count; i++)  					usingCountRec.UsingCounts.Add(reader.ReadUInt16());  				return usingCountRec;    			case PdbCustomDebugInfoKind.ForwardMethodInfo:  				method = module.ResolveToken(reader.ReadUInt32()' gpContext) as IMethodDefOrRef;  				if (method is null)  					return null;  				return new PdbForwardMethodInfoCustomDebugInfo(method);    			case PdbCustomDebugInfoKind.ForwardModuleInfo:  				method = module.ResolveToken(reader.ReadUInt32()' gpContext) as IMethodDefOrRef;  				if (method is null)  					return null;  				return new PdbForwardModuleInfoCustomDebugInfo(method);    			case PdbCustomDebugInfoKind.StateMachineHoistedLocalScopes:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				if (count < 0)  					return null;  				var smScope = new PdbStateMachineHoistedLocalScopesCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					uint startOffset = reader.ReadUInt32();  					uint endOffset = reader.ReadUInt32();  					if (startOffset > endOffset)  						return null;  					// Try to detect synthesized locals' whose start==end==0. The problem is that endOffset  					// read from the PDB is inclusive (add 1 to get 'end')' so a synthesized local and a  					// local at [0' 1) will be encoded the same {0' 0}.  					if (endOffset == 0)  						smScope.Scopes.Add(new StateMachineHoistedLocalScope());  					else {  						var start = GetInstruction(startOffset);  						var end = GetInstruction(endOffset + 1);  						if (start is null)  							return null;  						smScope.Scopes.Add(new StateMachineHoistedLocalScope(start' end));  					}  				}  				return smScope;    			case PdbCustomDebugInfoKind.StateMachineTypeName:  				var name = ReadUnicodeZ(recPosEnd' needZeroChar: true);  				if (name is null)  					return null;  				var type = GetNestedType(name);  				if (type is null)  					return null;  				return new PdbStateMachineTypeNameCustomDebugInfo(type);    			case PdbCustomDebugInfoKind.DynamicLocals:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				const int dynLocalRecSize = 64 + 4 + 4 + 2 * 64;  				if (reader.Position + (ulong)(uint)count * dynLocalRecSize > recPosEnd)  					return null;  				var dynLocListRec = new PdbDynamicLocalsCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					reader.Position += 64;  					int flagsCount = reader.ReadInt32();  					if ((uint)flagsCount > 64)  						return null;  					var dynLocRec = new PdbDynamicLocal(flagsCount);  					var afterPos = reader.Position;    					reader.Position -= 64 + 4;  					for (int j = 0; j < flagsCount; j++)  						dynLocRec.Flags.Add(reader.ReadByte());  					reader.Position = afterPos;    					localIndex = reader.ReadInt32();  					// 'const' locals have index -1 but they're encoded as 0 by Roslyn  					if (localIndex != 0 && (uint)localIndex >= (uint)bodyOpt.Variables.Count)  						return null;    					var nameEndPos = reader.Position + 2 * 64;  					name = ReadUnicodeZ(nameEndPos' needZeroChar: false);  					reader.Position = nameEndPos;    					local = localIndex < bodyOpt.Variables.Count ? bodyOpt.Variables[localIndex] : null;  					// Roslyn writes 0 to localIndex if it's a 'const' local' try to undo that now  					if (localIndex == 0 && !(local is null) && local.Name != name)  						local = null;  					if (!(local is null) && local.Name == name)  						name = null;  					dynLocRec.Name = name;  					dynLocRec.Local = local;  					dynLocListRec.Locals.Add(dynLocRec);  				}  				return dynLocListRec;    			case PdbCustomDebugInfoKind.EditAndContinueLocalSlotMap:  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbEditAndContinueLocalSlotMapCustomDebugInfo(data);    			case PdbCustomDebugInfoKind.EditAndContinueLambdaMap:  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbEditAndContinueLambdaMapCustomDebugInfo(data);    			case PdbCustomDebugInfoKind.TupleElementNames:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				if (count < 0)  					return null;  				var tupleListRec = new PdbTupleElementNamesCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					int nameCount = reader.ReadInt32();  					if ((uint)nameCount >= 10000)  						return null;  					var tupleInfo = new PdbTupleElementNames(nameCount);    					for (int j = 0; j < nameCount; j++) {  						var s = ReadUTF8Z(recPosEnd);  						if (s is null)  							return null;  						tupleInfo.TupleElementNames.Add(s);  					}    					localIndex = reader.ReadInt32();  					uint scopeStart = reader.ReadUInt32();  					uint scopeEnd = reader.ReadUInt32();  					name = ReadUTF8Z(recPosEnd);  					if (name is null)  						return null;  					Debug.Assert(localIndex >= -1);  					// -1 = 'const' local. Only 'const' locals have a scope  					Debug.Assert((localIndex == -1) ^ (scopeStart == 0 && scopeEnd == 0));    					if (localIndex == -1) {  						local = null;  						tupleInfo.ScopeStart = GetInstruction(scopeStart);  						tupleInfo.ScopeEnd = GetInstruction(scopeEnd);  						if (tupleInfo.ScopeStart is null)  							return null;  					}  					else {  						if ((uint)localIndex >= (uint)bodyOpt.Variables.Count)  							return null;  						local = bodyOpt.Variables[localIndex];  					}    					if (!(local is null) && local.Name == name)  						name = null;  					tupleInfo.Local = local;  					tupleInfo.Name = name;    					tupleListRec.Names.Add(tupleInfo);  				}  				return tupleListRec;    			default:  				Debug.Fail("Unknown custom debug info kind: 0x" + ((int)recKind).ToString("X"));  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbUnknownCustomDebugInfo(recKind' data);  			}
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoReader.cs,ReadRecord,The following statement contains a magic number: switch (recKind) {  			case PdbCustomDebugInfoKind.UsingGroups:  				count = reader.ReadUInt16();  				if (count < 0)  					return null;  				var usingCountRec = new PdbUsingGroupsCustomDebugInfo(count);  				for (int i = 0; i < count; i++)  					usingCountRec.UsingCounts.Add(reader.ReadUInt16());  				return usingCountRec;    			case PdbCustomDebugInfoKind.ForwardMethodInfo:  				method = module.ResolveToken(reader.ReadUInt32()' gpContext) as IMethodDefOrRef;  				if (method is null)  					return null;  				return new PdbForwardMethodInfoCustomDebugInfo(method);    			case PdbCustomDebugInfoKind.ForwardModuleInfo:  				method = module.ResolveToken(reader.ReadUInt32()' gpContext) as IMethodDefOrRef;  				if (method is null)  					return null;  				return new PdbForwardModuleInfoCustomDebugInfo(method);    			case PdbCustomDebugInfoKind.StateMachineHoistedLocalScopes:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				if (count < 0)  					return null;  				var smScope = new PdbStateMachineHoistedLocalScopesCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					uint startOffset = reader.ReadUInt32();  					uint endOffset = reader.ReadUInt32();  					if (startOffset > endOffset)  						return null;  					// Try to detect synthesized locals' whose start==end==0. The problem is that endOffset  					// read from the PDB is inclusive (add 1 to get 'end')' so a synthesized local and a  					// local at [0' 1) will be encoded the same {0' 0}.  					if (endOffset == 0)  						smScope.Scopes.Add(new StateMachineHoistedLocalScope());  					else {  						var start = GetInstruction(startOffset);  						var end = GetInstruction(endOffset + 1);  						if (start is null)  							return null;  						smScope.Scopes.Add(new StateMachineHoistedLocalScope(start' end));  					}  				}  				return smScope;    			case PdbCustomDebugInfoKind.StateMachineTypeName:  				var name = ReadUnicodeZ(recPosEnd' needZeroChar: true);  				if (name is null)  					return null;  				var type = GetNestedType(name);  				if (type is null)  					return null;  				return new PdbStateMachineTypeNameCustomDebugInfo(type);    			case PdbCustomDebugInfoKind.DynamicLocals:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				const int dynLocalRecSize = 64 + 4 + 4 + 2 * 64;  				if (reader.Position + (ulong)(uint)count * dynLocalRecSize > recPosEnd)  					return null;  				var dynLocListRec = new PdbDynamicLocalsCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					reader.Position += 64;  					int flagsCount = reader.ReadInt32();  					if ((uint)flagsCount > 64)  						return null;  					var dynLocRec = new PdbDynamicLocal(flagsCount);  					var afterPos = reader.Position;    					reader.Position -= 64 + 4;  					for (int j = 0; j < flagsCount; j++)  						dynLocRec.Flags.Add(reader.ReadByte());  					reader.Position = afterPos;    					localIndex = reader.ReadInt32();  					// 'const' locals have index -1 but they're encoded as 0 by Roslyn  					if (localIndex != 0 && (uint)localIndex >= (uint)bodyOpt.Variables.Count)  						return null;    					var nameEndPos = reader.Position + 2 * 64;  					name = ReadUnicodeZ(nameEndPos' needZeroChar: false);  					reader.Position = nameEndPos;    					local = localIndex < bodyOpt.Variables.Count ? bodyOpt.Variables[localIndex] : null;  					// Roslyn writes 0 to localIndex if it's a 'const' local' try to undo that now  					if (localIndex == 0 && !(local is null) && local.Name != name)  						local = null;  					if (!(local is null) && local.Name == name)  						name = null;  					dynLocRec.Name = name;  					dynLocRec.Local = local;  					dynLocListRec.Locals.Add(dynLocRec);  				}  				return dynLocListRec;    			case PdbCustomDebugInfoKind.EditAndContinueLocalSlotMap:  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbEditAndContinueLocalSlotMapCustomDebugInfo(data);    			case PdbCustomDebugInfoKind.EditAndContinueLambdaMap:  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbEditAndContinueLambdaMapCustomDebugInfo(data);    			case PdbCustomDebugInfoKind.TupleElementNames:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				if (count < 0)  					return null;  				var tupleListRec = new PdbTupleElementNamesCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					int nameCount = reader.ReadInt32();  					if ((uint)nameCount >= 10000)  						return null;  					var tupleInfo = new PdbTupleElementNames(nameCount);    					for (int j = 0; j < nameCount; j++) {  						var s = ReadUTF8Z(recPosEnd);  						if (s is null)  							return null;  						tupleInfo.TupleElementNames.Add(s);  					}    					localIndex = reader.ReadInt32();  					uint scopeStart = reader.ReadUInt32();  					uint scopeEnd = reader.ReadUInt32();  					name = ReadUTF8Z(recPosEnd);  					if (name is null)  						return null;  					Debug.Assert(localIndex >= -1);  					// -1 = 'const' local. Only 'const' locals have a scope  					Debug.Assert((localIndex == -1) ^ (scopeStart == 0 && scopeEnd == 0));    					if (localIndex == -1) {  						local = null;  						tupleInfo.ScopeStart = GetInstruction(scopeStart);  						tupleInfo.ScopeEnd = GetInstruction(scopeEnd);  						if (tupleInfo.ScopeStart is null)  							return null;  					}  					else {  						if ((uint)localIndex >= (uint)bodyOpt.Variables.Count)  							return null;  						local = bodyOpt.Variables[localIndex];  					}    					if (!(local is null) && local.Name == name)  						name = null;  					tupleInfo.Local = local;  					tupleInfo.Name = name;    					tupleListRec.Names.Add(tupleInfo);  				}  				return tupleListRec;    			default:  				Debug.Fail("Unknown custom debug info kind: 0x" + ((int)recKind).ToString("X"));  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbUnknownCustomDebugInfo(recKind' data);  			}
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoReader.cs,ReadRecord,The following statement contains a magic number: switch (recKind) {  			case PdbCustomDebugInfoKind.UsingGroups:  				count = reader.ReadUInt16();  				if (count < 0)  					return null;  				var usingCountRec = new PdbUsingGroupsCustomDebugInfo(count);  				for (int i = 0; i < count; i++)  					usingCountRec.UsingCounts.Add(reader.ReadUInt16());  				return usingCountRec;    			case PdbCustomDebugInfoKind.ForwardMethodInfo:  				method = module.ResolveToken(reader.ReadUInt32()' gpContext) as IMethodDefOrRef;  				if (method is null)  					return null;  				return new PdbForwardMethodInfoCustomDebugInfo(method);    			case PdbCustomDebugInfoKind.ForwardModuleInfo:  				method = module.ResolveToken(reader.ReadUInt32()' gpContext) as IMethodDefOrRef;  				if (method is null)  					return null;  				return new PdbForwardModuleInfoCustomDebugInfo(method);    			case PdbCustomDebugInfoKind.StateMachineHoistedLocalScopes:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				if (count < 0)  					return null;  				var smScope = new PdbStateMachineHoistedLocalScopesCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					uint startOffset = reader.ReadUInt32();  					uint endOffset = reader.ReadUInt32();  					if (startOffset > endOffset)  						return null;  					// Try to detect synthesized locals' whose start==end==0. The problem is that endOffset  					// read from the PDB is inclusive (add 1 to get 'end')' so a synthesized local and a  					// local at [0' 1) will be encoded the same {0' 0}.  					if (endOffset == 0)  						smScope.Scopes.Add(new StateMachineHoistedLocalScope());  					else {  						var start = GetInstruction(startOffset);  						var end = GetInstruction(endOffset + 1);  						if (start is null)  							return null;  						smScope.Scopes.Add(new StateMachineHoistedLocalScope(start' end));  					}  				}  				return smScope;    			case PdbCustomDebugInfoKind.StateMachineTypeName:  				var name = ReadUnicodeZ(recPosEnd' needZeroChar: true);  				if (name is null)  					return null;  				var type = GetNestedType(name);  				if (type is null)  					return null;  				return new PdbStateMachineTypeNameCustomDebugInfo(type);    			case PdbCustomDebugInfoKind.DynamicLocals:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				const int dynLocalRecSize = 64 + 4 + 4 + 2 * 64;  				if (reader.Position + (ulong)(uint)count * dynLocalRecSize > recPosEnd)  					return null;  				var dynLocListRec = new PdbDynamicLocalsCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					reader.Position += 64;  					int flagsCount = reader.ReadInt32();  					if ((uint)flagsCount > 64)  						return null;  					var dynLocRec = new PdbDynamicLocal(flagsCount);  					var afterPos = reader.Position;    					reader.Position -= 64 + 4;  					for (int j = 0; j < flagsCount; j++)  						dynLocRec.Flags.Add(reader.ReadByte());  					reader.Position = afterPos;    					localIndex = reader.ReadInt32();  					// 'const' locals have index -1 but they're encoded as 0 by Roslyn  					if (localIndex != 0 && (uint)localIndex >= (uint)bodyOpt.Variables.Count)  						return null;    					var nameEndPos = reader.Position + 2 * 64;  					name = ReadUnicodeZ(nameEndPos' needZeroChar: false);  					reader.Position = nameEndPos;    					local = localIndex < bodyOpt.Variables.Count ? bodyOpt.Variables[localIndex] : null;  					// Roslyn writes 0 to localIndex if it's a 'const' local' try to undo that now  					if (localIndex == 0 && !(local is null) && local.Name != name)  						local = null;  					if (!(local is null) && local.Name == name)  						name = null;  					dynLocRec.Name = name;  					dynLocRec.Local = local;  					dynLocListRec.Locals.Add(dynLocRec);  				}  				return dynLocListRec;    			case PdbCustomDebugInfoKind.EditAndContinueLocalSlotMap:  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbEditAndContinueLocalSlotMapCustomDebugInfo(data);    			case PdbCustomDebugInfoKind.EditAndContinueLambdaMap:  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbEditAndContinueLambdaMapCustomDebugInfo(data);    			case PdbCustomDebugInfoKind.TupleElementNames:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				if (count < 0)  					return null;  				var tupleListRec = new PdbTupleElementNamesCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					int nameCount = reader.ReadInt32();  					if ((uint)nameCount >= 10000)  						return null;  					var tupleInfo = new PdbTupleElementNames(nameCount);    					for (int j = 0; j < nameCount; j++) {  						var s = ReadUTF8Z(recPosEnd);  						if (s is null)  							return null;  						tupleInfo.TupleElementNames.Add(s);  					}    					localIndex = reader.ReadInt32();  					uint scopeStart = reader.ReadUInt32();  					uint scopeEnd = reader.ReadUInt32();  					name = ReadUTF8Z(recPosEnd);  					if (name is null)  						return null;  					Debug.Assert(localIndex >= -1);  					// -1 = 'const' local. Only 'const' locals have a scope  					Debug.Assert((localIndex == -1) ^ (scopeStart == 0 && scopeEnd == 0));    					if (localIndex == -1) {  						local = null;  						tupleInfo.ScopeStart = GetInstruction(scopeStart);  						tupleInfo.ScopeEnd = GetInstruction(scopeEnd);  						if (tupleInfo.ScopeStart is null)  							return null;  					}  					else {  						if ((uint)localIndex >= (uint)bodyOpt.Variables.Count)  							return null;  						local = bodyOpt.Variables[localIndex];  					}    					if (!(local is null) && local.Name == name)  						name = null;  					tupleInfo.Local = local;  					tupleInfo.Name = name;    					tupleListRec.Names.Add(tupleInfo);  				}  				return tupleListRec;    			default:  				Debug.Fail("Unknown custom debug info kind: 0x" + ((int)recKind).ToString("X"));  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbUnknownCustomDebugInfo(recKind' data);  			}
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoReader.cs,ReadRecord,The following statement contains a magic number: switch (recKind) {  			case PdbCustomDebugInfoKind.UsingGroups:  				count = reader.ReadUInt16();  				if (count < 0)  					return null;  				var usingCountRec = new PdbUsingGroupsCustomDebugInfo(count);  				for (int i = 0; i < count; i++)  					usingCountRec.UsingCounts.Add(reader.ReadUInt16());  				return usingCountRec;    			case PdbCustomDebugInfoKind.ForwardMethodInfo:  				method = module.ResolveToken(reader.ReadUInt32()' gpContext) as IMethodDefOrRef;  				if (method is null)  					return null;  				return new PdbForwardMethodInfoCustomDebugInfo(method);    			case PdbCustomDebugInfoKind.ForwardModuleInfo:  				method = module.ResolveToken(reader.ReadUInt32()' gpContext) as IMethodDefOrRef;  				if (method is null)  					return null;  				return new PdbForwardModuleInfoCustomDebugInfo(method);    			case PdbCustomDebugInfoKind.StateMachineHoistedLocalScopes:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				if (count < 0)  					return null;  				var smScope = new PdbStateMachineHoistedLocalScopesCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					uint startOffset = reader.ReadUInt32();  					uint endOffset = reader.ReadUInt32();  					if (startOffset > endOffset)  						return null;  					// Try to detect synthesized locals' whose start==end==0. The problem is that endOffset  					// read from the PDB is inclusive (add 1 to get 'end')' so a synthesized local and a  					// local at [0' 1) will be encoded the same {0' 0}.  					if (endOffset == 0)  						smScope.Scopes.Add(new StateMachineHoistedLocalScope());  					else {  						var start = GetInstruction(startOffset);  						var end = GetInstruction(endOffset + 1);  						if (start is null)  							return null;  						smScope.Scopes.Add(new StateMachineHoistedLocalScope(start' end));  					}  				}  				return smScope;    			case PdbCustomDebugInfoKind.StateMachineTypeName:  				var name = ReadUnicodeZ(recPosEnd' needZeroChar: true);  				if (name is null)  					return null;  				var type = GetNestedType(name);  				if (type is null)  					return null;  				return new PdbStateMachineTypeNameCustomDebugInfo(type);    			case PdbCustomDebugInfoKind.DynamicLocals:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				const int dynLocalRecSize = 64 + 4 + 4 + 2 * 64;  				if (reader.Position + (ulong)(uint)count * dynLocalRecSize > recPosEnd)  					return null;  				var dynLocListRec = new PdbDynamicLocalsCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					reader.Position += 64;  					int flagsCount = reader.ReadInt32();  					if ((uint)flagsCount > 64)  						return null;  					var dynLocRec = new PdbDynamicLocal(flagsCount);  					var afterPos = reader.Position;    					reader.Position -= 64 + 4;  					for (int j = 0; j < flagsCount; j++)  						dynLocRec.Flags.Add(reader.ReadByte());  					reader.Position = afterPos;    					localIndex = reader.ReadInt32();  					// 'const' locals have index -1 but they're encoded as 0 by Roslyn  					if (localIndex != 0 && (uint)localIndex >= (uint)bodyOpt.Variables.Count)  						return null;    					var nameEndPos = reader.Position + 2 * 64;  					name = ReadUnicodeZ(nameEndPos' needZeroChar: false);  					reader.Position = nameEndPos;    					local = localIndex < bodyOpt.Variables.Count ? bodyOpt.Variables[localIndex] : null;  					// Roslyn writes 0 to localIndex if it's a 'const' local' try to undo that now  					if (localIndex == 0 && !(local is null) && local.Name != name)  						local = null;  					if (!(local is null) && local.Name == name)  						name = null;  					dynLocRec.Name = name;  					dynLocRec.Local = local;  					dynLocListRec.Locals.Add(dynLocRec);  				}  				return dynLocListRec;    			case PdbCustomDebugInfoKind.EditAndContinueLocalSlotMap:  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbEditAndContinueLocalSlotMapCustomDebugInfo(data);    			case PdbCustomDebugInfoKind.EditAndContinueLambdaMap:  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbEditAndContinueLambdaMapCustomDebugInfo(data);    			case PdbCustomDebugInfoKind.TupleElementNames:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				if (count < 0)  					return null;  				var tupleListRec = new PdbTupleElementNamesCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					int nameCount = reader.ReadInt32();  					if ((uint)nameCount >= 10000)  						return null;  					var tupleInfo = new PdbTupleElementNames(nameCount);    					for (int j = 0; j < nameCount; j++) {  						var s = ReadUTF8Z(recPosEnd);  						if (s is null)  							return null;  						tupleInfo.TupleElementNames.Add(s);  					}    					localIndex = reader.ReadInt32();  					uint scopeStart = reader.ReadUInt32();  					uint scopeEnd = reader.ReadUInt32();  					name = ReadUTF8Z(recPosEnd);  					if (name is null)  						return null;  					Debug.Assert(localIndex >= -1);  					// -1 = 'const' local. Only 'const' locals have a scope  					Debug.Assert((localIndex == -1) ^ (scopeStart == 0 && scopeEnd == 0));    					if (localIndex == -1) {  						local = null;  						tupleInfo.ScopeStart = GetInstruction(scopeStart);  						tupleInfo.ScopeEnd = GetInstruction(scopeEnd);  						if (tupleInfo.ScopeStart is null)  							return null;  					}  					else {  						if ((uint)localIndex >= (uint)bodyOpt.Variables.Count)  							return null;  						local = bodyOpt.Variables[localIndex];  					}    					if (!(local is null) && local.Name == name)  						name = null;  					tupleInfo.Local = local;  					tupleInfo.Name = name;    					tupleListRec.Names.Add(tupleInfo);  				}  				return tupleListRec;    			default:  				Debug.Fail("Unknown custom debug info kind: 0x" + ((int)recKind).ToString("X"));  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbUnknownCustomDebugInfo(recKind' data);  			}
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoReader.cs,ReadRecord,The following statement contains a magic number: switch (recKind) {  			case PdbCustomDebugInfoKind.UsingGroups:  				count = reader.ReadUInt16();  				if (count < 0)  					return null;  				var usingCountRec = new PdbUsingGroupsCustomDebugInfo(count);  				for (int i = 0; i < count; i++)  					usingCountRec.UsingCounts.Add(reader.ReadUInt16());  				return usingCountRec;    			case PdbCustomDebugInfoKind.ForwardMethodInfo:  				method = module.ResolveToken(reader.ReadUInt32()' gpContext) as IMethodDefOrRef;  				if (method is null)  					return null;  				return new PdbForwardMethodInfoCustomDebugInfo(method);    			case PdbCustomDebugInfoKind.ForwardModuleInfo:  				method = module.ResolveToken(reader.ReadUInt32()' gpContext) as IMethodDefOrRef;  				if (method is null)  					return null;  				return new PdbForwardModuleInfoCustomDebugInfo(method);    			case PdbCustomDebugInfoKind.StateMachineHoistedLocalScopes:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				if (count < 0)  					return null;  				var smScope = new PdbStateMachineHoistedLocalScopesCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					uint startOffset = reader.ReadUInt32();  					uint endOffset = reader.ReadUInt32();  					if (startOffset > endOffset)  						return null;  					// Try to detect synthesized locals' whose start==end==0. The problem is that endOffset  					// read from the PDB is inclusive (add 1 to get 'end')' so a synthesized local and a  					// local at [0' 1) will be encoded the same {0' 0}.  					if (endOffset == 0)  						smScope.Scopes.Add(new StateMachineHoistedLocalScope());  					else {  						var start = GetInstruction(startOffset);  						var end = GetInstruction(endOffset + 1);  						if (start is null)  							return null;  						smScope.Scopes.Add(new StateMachineHoistedLocalScope(start' end));  					}  				}  				return smScope;    			case PdbCustomDebugInfoKind.StateMachineTypeName:  				var name = ReadUnicodeZ(recPosEnd' needZeroChar: true);  				if (name is null)  					return null;  				var type = GetNestedType(name);  				if (type is null)  					return null;  				return new PdbStateMachineTypeNameCustomDebugInfo(type);    			case PdbCustomDebugInfoKind.DynamicLocals:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				const int dynLocalRecSize = 64 + 4 + 4 + 2 * 64;  				if (reader.Position + (ulong)(uint)count * dynLocalRecSize > recPosEnd)  					return null;  				var dynLocListRec = new PdbDynamicLocalsCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					reader.Position += 64;  					int flagsCount = reader.ReadInt32();  					if ((uint)flagsCount > 64)  						return null;  					var dynLocRec = new PdbDynamicLocal(flagsCount);  					var afterPos = reader.Position;    					reader.Position -= 64 + 4;  					for (int j = 0; j < flagsCount; j++)  						dynLocRec.Flags.Add(reader.ReadByte());  					reader.Position = afterPos;    					localIndex = reader.ReadInt32();  					// 'const' locals have index -1 but they're encoded as 0 by Roslyn  					if (localIndex != 0 && (uint)localIndex >= (uint)bodyOpt.Variables.Count)  						return null;    					var nameEndPos = reader.Position + 2 * 64;  					name = ReadUnicodeZ(nameEndPos' needZeroChar: false);  					reader.Position = nameEndPos;    					local = localIndex < bodyOpt.Variables.Count ? bodyOpt.Variables[localIndex] : null;  					// Roslyn writes 0 to localIndex if it's a 'const' local' try to undo that now  					if (localIndex == 0 && !(local is null) && local.Name != name)  						local = null;  					if (!(local is null) && local.Name == name)  						name = null;  					dynLocRec.Name = name;  					dynLocRec.Local = local;  					dynLocListRec.Locals.Add(dynLocRec);  				}  				return dynLocListRec;    			case PdbCustomDebugInfoKind.EditAndContinueLocalSlotMap:  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbEditAndContinueLocalSlotMapCustomDebugInfo(data);    			case PdbCustomDebugInfoKind.EditAndContinueLambdaMap:  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbEditAndContinueLambdaMapCustomDebugInfo(data);    			case PdbCustomDebugInfoKind.TupleElementNames:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				if (count < 0)  					return null;  				var tupleListRec = new PdbTupleElementNamesCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					int nameCount = reader.ReadInt32();  					if ((uint)nameCount >= 10000)  						return null;  					var tupleInfo = new PdbTupleElementNames(nameCount);    					for (int j = 0; j < nameCount; j++) {  						var s = ReadUTF8Z(recPosEnd);  						if (s is null)  							return null;  						tupleInfo.TupleElementNames.Add(s);  					}    					localIndex = reader.ReadInt32();  					uint scopeStart = reader.ReadUInt32();  					uint scopeEnd = reader.ReadUInt32();  					name = ReadUTF8Z(recPosEnd);  					if (name is null)  						return null;  					Debug.Assert(localIndex >= -1);  					// -1 = 'const' local. Only 'const' locals have a scope  					Debug.Assert((localIndex == -1) ^ (scopeStart == 0 && scopeEnd == 0));    					if (localIndex == -1) {  						local = null;  						tupleInfo.ScopeStart = GetInstruction(scopeStart);  						tupleInfo.ScopeEnd = GetInstruction(scopeEnd);  						if (tupleInfo.ScopeStart is null)  							return null;  					}  					else {  						if ((uint)localIndex >= (uint)bodyOpt.Variables.Count)  							return null;  						local = bodyOpt.Variables[localIndex];  					}    					if (!(local is null) && local.Name == name)  						name = null;  					tupleInfo.Local = local;  					tupleInfo.Name = name;    					tupleListRec.Names.Add(tupleInfo);  				}  				return tupleListRec;    			default:  				Debug.Fail("Unknown custom debug info kind: 0x" + ((int)recKind).ToString("X"));  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbUnknownCustomDebugInfo(recKind' data);  			}
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoReader.cs,ReadRecord,The following statement contains a magic number: switch (recKind) {  			case PdbCustomDebugInfoKind.UsingGroups:  				count = reader.ReadUInt16();  				if (count < 0)  					return null;  				var usingCountRec = new PdbUsingGroupsCustomDebugInfo(count);  				for (int i = 0; i < count; i++)  					usingCountRec.UsingCounts.Add(reader.ReadUInt16());  				return usingCountRec;    			case PdbCustomDebugInfoKind.ForwardMethodInfo:  				method = module.ResolveToken(reader.ReadUInt32()' gpContext) as IMethodDefOrRef;  				if (method is null)  					return null;  				return new PdbForwardMethodInfoCustomDebugInfo(method);    			case PdbCustomDebugInfoKind.ForwardModuleInfo:  				method = module.ResolveToken(reader.ReadUInt32()' gpContext) as IMethodDefOrRef;  				if (method is null)  					return null;  				return new PdbForwardModuleInfoCustomDebugInfo(method);    			case PdbCustomDebugInfoKind.StateMachineHoistedLocalScopes:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				if (count < 0)  					return null;  				var smScope = new PdbStateMachineHoistedLocalScopesCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					uint startOffset = reader.ReadUInt32();  					uint endOffset = reader.ReadUInt32();  					if (startOffset > endOffset)  						return null;  					// Try to detect synthesized locals' whose start==end==0. The problem is that endOffset  					// read from the PDB is inclusive (add 1 to get 'end')' so a synthesized local and a  					// local at [0' 1) will be encoded the same {0' 0}.  					if (endOffset == 0)  						smScope.Scopes.Add(new StateMachineHoistedLocalScope());  					else {  						var start = GetInstruction(startOffset);  						var end = GetInstruction(endOffset + 1);  						if (start is null)  							return null;  						smScope.Scopes.Add(new StateMachineHoistedLocalScope(start' end));  					}  				}  				return smScope;    			case PdbCustomDebugInfoKind.StateMachineTypeName:  				var name = ReadUnicodeZ(recPosEnd' needZeroChar: true);  				if (name is null)  					return null;  				var type = GetNestedType(name);  				if (type is null)  					return null;  				return new PdbStateMachineTypeNameCustomDebugInfo(type);    			case PdbCustomDebugInfoKind.DynamicLocals:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				const int dynLocalRecSize = 64 + 4 + 4 + 2 * 64;  				if (reader.Position + (ulong)(uint)count * dynLocalRecSize > recPosEnd)  					return null;  				var dynLocListRec = new PdbDynamicLocalsCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					reader.Position += 64;  					int flagsCount = reader.ReadInt32();  					if ((uint)flagsCount > 64)  						return null;  					var dynLocRec = new PdbDynamicLocal(flagsCount);  					var afterPos = reader.Position;    					reader.Position -= 64 + 4;  					for (int j = 0; j < flagsCount; j++)  						dynLocRec.Flags.Add(reader.ReadByte());  					reader.Position = afterPos;    					localIndex = reader.ReadInt32();  					// 'const' locals have index -1 but they're encoded as 0 by Roslyn  					if (localIndex != 0 && (uint)localIndex >= (uint)bodyOpt.Variables.Count)  						return null;    					var nameEndPos = reader.Position + 2 * 64;  					name = ReadUnicodeZ(nameEndPos' needZeroChar: false);  					reader.Position = nameEndPos;    					local = localIndex < bodyOpt.Variables.Count ? bodyOpt.Variables[localIndex] : null;  					// Roslyn writes 0 to localIndex if it's a 'const' local' try to undo that now  					if (localIndex == 0 && !(local is null) && local.Name != name)  						local = null;  					if (!(local is null) && local.Name == name)  						name = null;  					dynLocRec.Name = name;  					dynLocRec.Local = local;  					dynLocListRec.Locals.Add(dynLocRec);  				}  				return dynLocListRec;    			case PdbCustomDebugInfoKind.EditAndContinueLocalSlotMap:  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbEditAndContinueLocalSlotMapCustomDebugInfo(data);    			case PdbCustomDebugInfoKind.EditAndContinueLambdaMap:  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbEditAndContinueLambdaMapCustomDebugInfo(data);    			case PdbCustomDebugInfoKind.TupleElementNames:  				if (bodyOpt is null)  					return null;  				count = reader.ReadInt32();  				if (count < 0)  					return null;  				var tupleListRec = new PdbTupleElementNamesCustomDebugInfo(count);  				for (int i = 0; i < count; i++) {  					int nameCount = reader.ReadInt32();  					if ((uint)nameCount >= 10000)  						return null;  					var tupleInfo = new PdbTupleElementNames(nameCount);    					for (int j = 0; j < nameCount; j++) {  						var s = ReadUTF8Z(recPosEnd);  						if (s is null)  							return null;  						tupleInfo.TupleElementNames.Add(s);  					}    					localIndex = reader.ReadInt32();  					uint scopeStart = reader.ReadUInt32();  					uint scopeEnd = reader.ReadUInt32();  					name = ReadUTF8Z(recPosEnd);  					if (name is null)  						return null;  					Debug.Assert(localIndex >= -1);  					// -1 = 'const' local. Only 'const' locals have a scope  					Debug.Assert((localIndex == -1) ^ (scopeStart == 0 && scopeEnd == 0));    					if (localIndex == -1) {  						local = null;  						tupleInfo.ScopeStart = GetInstruction(scopeStart);  						tupleInfo.ScopeEnd = GetInstruction(scopeEnd);  						if (tupleInfo.ScopeStart is null)  							return null;  					}  					else {  						if ((uint)localIndex >= (uint)bodyOpt.Variables.Count)  							return null;  						local = bodyOpt.Variables[localIndex];  					}    					if (!(local is null) && local.Name == name)  						name = null;  					tupleInfo.Local = local;  					tupleInfo.Name = name;    					tupleListRec.Names.Add(tupleInfo);  				}  				return tupleListRec;    			default:  				Debug.Fail("Unknown custom debug info kind: 0x" + ((int)recKind).ToString("X"));  				data = reader.ReadBytes((int)(recPosEnd - reader.Position));  				return new PdbUnknownCustomDebugInfo(recKind' data);  			}
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoReader.cs,GetNestedType,The following statement contains a magic number: typeName.StartsWith(name) && typeName.Length >= name.Length + 2
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoReader.cs,GetInstruction,The following statement contains a magic number: int i = (lo + hi) / 2;
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoWriter.cs,Write,The following statement contains a magic number: switch (info.Kind) {  				case PdbCustomDebugInfoKind.UsingGroups:  					var usingRec = info as PdbUsingGroupsCustomDebugInfo;  					if (usingRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					count = usingRec.UsingCounts.Count;  					if (count > ushort.MaxValue) {  						Error("UsingCounts contains more than 0xFFFF elements");  						return null;  					}  					writer.WriteUInt16((ushort)count);  					for (j = 0; j < count; j++)  						writer.WriteUInt16(usingRec.UsingCounts[j]);  					break;    				case PdbCustomDebugInfoKind.ForwardMethodInfo:  					var fwdMethodRec = info as PdbForwardMethodInfoCustomDebugInfo;  					if (fwdMethodRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					token = GetMethodToken(fwdMethodRec.Method);  					if (token == 0)  						return null;  					writer.WriteUInt32(token);  					break;    				case PdbCustomDebugInfoKind.ForwardModuleInfo:  					var fwdModRec = info as PdbForwardModuleInfoCustomDebugInfo;  					if (fwdModRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					token = GetMethodToken(fwdModRec.Method);  					if (token == 0)  						return null;  					writer.WriteUInt32(token);  					break;    				case PdbCustomDebugInfoKind.StateMachineHoistedLocalScopes:  					var smLocalScopesRec = info as PdbStateMachineHoistedLocalScopesCustomDebugInfo;  					if (smLocalScopesRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					count = smLocalScopesRec.Scopes.Count;  					writer.WriteInt32(count);  					for (j = 0; j < count; j++) {  						var scope = smLocalScopesRec.Scopes[j];  						if (scope.IsSynthesizedLocal) {  							writer.WriteInt32(0);  							writer.WriteInt32(0);  						}  						else {  							writer.WriteUInt32(GetInstructionOffset(scope.Start' nullIsEndOfMethod: false));  							writer.WriteUInt32(GetInstructionOffset(scope.End' nullIsEndOfMethod: true) - 1);  						}  					}  					break;    				case PdbCustomDebugInfoKind.StateMachineTypeName:  					var smTypeRec = info as PdbStateMachineTypeNameCustomDebugInfo;  					if (smTypeRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					var type = smTypeRec.Type;  					if (type is null) {  						Error("State machine type is null");  						return null;  					}  					WriteUnicodeZ(MetadataNameToRoslynName(type.Name));  					break;    				case PdbCustomDebugInfoKind.DynamicLocals:  					var dynLocListRec = info as PdbDynamicLocalsCustomDebugInfo;  					if (dynLocListRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					count = dynLocListRec.Locals.Count;  					writer.WriteInt32(count);  					for (j = 0; j < count; j++) {  						var dynLoc = dynLocListRec.Locals[j];  						if (dynLoc is null) {  							Error("Dynamic local is null");  							return null;  						}  						if (dynLoc.Flags.Count > 64) {  							Error("Dynamic local flags is longer than 64 bytes");  							return null;  						}  						var name = dynLoc.Name;  						if (name is null)  							name = string.Empty;  						if (name.Length > 64) {  							Error("Dynamic local name is longer than 64 chars");  							return null;  						}  						if (name.IndexOf('\0') >= 0) {  							Error("Dynamic local name contains a NUL char");  							return null;  						}    						for (k = 0; k < dynLoc.Flags.Count; k++)  							writer.WriteByte(dynLoc.Flags[k]);  						while (k++ < 64)  							writer.WriteByte(0);  						writer.WriteInt32(dynLoc.Flags.Count);    						if (dynLoc.Local is null)  							writer.WriteInt32(0);  						else  							writer.WriteInt32(dynLoc.Local.Index);    						for (k = 0; k < name.Length; k++)  							writer.WriteUInt16(name[k]);  						while (k++ < 64)  							writer.WriteUInt16(0);  					}  					break;    				case PdbCustomDebugInfoKind.EditAndContinueLocalSlotMap:  					var encLocalMapRec = info as PdbEditAndContinueLocalSlotMapCustomDebugInfo;  					if (encLocalMapRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					writer.WriteBytes(encLocalMapRec.Data);  					break;    				case PdbCustomDebugInfoKind.EditAndContinueLambdaMap:  					var encLambdaRec = info as PdbEditAndContinueLambdaMapCustomDebugInfo;  					if (encLambdaRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					writer.WriteBytes(encLambdaRec.Data);  					break;    				case PdbCustomDebugInfoKind.TupleElementNames:  					var tupleListRec = info as PdbTupleElementNamesCustomDebugInfo;  					if (tupleListRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					count = tupleListRec.Names.Count;  					writer.WriteInt32(count);  					for (j = 0; j < count; j++) {  						var tupleInfo = tupleListRec.Names[j];  						if (tupleInfo is null) {  							Error("Tuple name info is null");  							return null;  						}  						writer.WriteInt32(tupleInfo.TupleElementNames.Count);  						for (k = 0; k < tupleInfo.TupleElementNames.Count; k++)  							WriteUTF8Z(tupleInfo.TupleElementNames[k]);    						if (tupleInfo.Local is null) {  							writer.WriteInt32(-1);  							writer.WriteUInt32(GetInstructionOffset(tupleInfo.ScopeStart' nullIsEndOfMethod: false));  							writer.WriteUInt32(GetInstructionOffset(tupleInfo.ScopeEnd' nullIsEndOfMethod: true));  						}  						else {  							writer.WriteInt32(tupleInfo.Local.Index);  							writer.WriteInt64(0L);  						}  						WriteUTF8Z(tupleInfo.Name);  					}  					break;    				default:  					var unkRec = info as PdbUnknownCustomDebugInfo;  					if (unkRec is null) {  						Error("Unsupported custom debug info class {0}"' info.GetType());  						return null;  					}  					writer.WriteBytes(unkRec.Data);  					break;  				}
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoWriter.cs,Write,The following statement contains a magic number: switch (info.Kind) {  				case PdbCustomDebugInfoKind.UsingGroups:  					var usingRec = info as PdbUsingGroupsCustomDebugInfo;  					if (usingRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					count = usingRec.UsingCounts.Count;  					if (count > ushort.MaxValue) {  						Error("UsingCounts contains more than 0xFFFF elements");  						return null;  					}  					writer.WriteUInt16((ushort)count);  					for (j = 0; j < count; j++)  						writer.WriteUInt16(usingRec.UsingCounts[j]);  					break;    				case PdbCustomDebugInfoKind.ForwardMethodInfo:  					var fwdMethodRec = info as PdbForwardMethodInfoCustomDebugInfo;  					if (fwdMethodRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					token = GetMethodToken(fwdMethodRec.Method);  					if (token == 0)  						return null;  					writer.WriteUInt32(token);  					break;    				case PdbCustomDebugInfoKind.ForwardModuleInfo:  					var fwdModRec = info as PdbForwardModuleInfoCustomDebugInfo;  					if (fwdModRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					token = GetMethodToken(fwdModRec.Method);  					if (token == 0)  						return null;  					writer.WriteUInt32(token);  					break;    				case PdbCustomDebugInfoKind.StateMachineHoistedLocalScopes:  					var smLocalScopesRec = info as PdbStateMachineHoistedLocalScopesCustomDebugInfo;  					if (smLocalScopesRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					count = smLocalScopesRec.Scopes.Count;  					writer.WriteInt32(count);  					for (j = 0; j < count; j++) {  						var scope = smLocalScopesRec.Scopes[j];  						if (scope.IsSynthesizedLocal) {  							writer.WriteInt32(0);  							writer.WriteInt32(0);  						}  						else {  							writer.WriteUInt32(GetInstructionOffset(scope.Start' nullIsEndOfMethod: false));  							writer.WriteUInt32(GetInstructionOffset(scope.End' nullIsEndOfMethod: true) - 1);  						}  					}  					break;    				case PdbCustomDebugInfoKind.StateMachineTypeName:  					var smTypeRec = info as PdbStateMachineTypeNameCustomDebugInfo;  					if (smTypeRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					var type = smTypeRec.Type;  					if (type is null) {  						Error("State machine type is null");  						return null;  					}  					WriteUnicodeZ(MetadataNameToRoslynName(type.Name));  					break;    				case PdbCustomDebugInfoKind.DynamicLocals:  					var dynLocListRec = info as PdbDynamicLocalsCustomDebugInfo;  					if (dynLocListRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					count = dynLocListRec.Locals.Count;  					writer.WriteInt32(count);  					for (j = 0; j < count; j++) {  						var dynLoc = dynLocListRec.Locals[j];  						if (dynLoc is null) {  							Error("Dynamic local is null");  							return null;  						}  						if (dynLoc.Flags.Count > 64) {  							Error("Dynamic local flags is longer than 64 bytes");  							return null;  						}  						var name = dynLoc.Name;  						if (name is null)  							name = string.Empty;  						if (name.Length > 64) {  							Error("Dynamic local name is longer than 64 chars");  							return null;  						}  						if (name.IndexOf('\0') >= 0) {  							Error("Dynamic local name contains a NUL char");  							return null;  						}    						for (k = 0; k < dynLoc.Flags.Count; k++)  							writer.WriteByte(dynLoc.Flags[k]);  						while (k++ < 64)  							writer.WriteByte(0);  						writer.WriteInt32(dynLoc.Flags.Count);    						if (dynLoc.Local is null)  							writer.WriteInt32(0);  						else  							writer.WriteInt32(dynLoc.Local.Index);    						for (k = 0; k < name.Length; k++)  							writer.WriteUInt16(name[k]);  						while (k++ < 64)  							writer.WriteUInt16(0);  					}  					break;    				case PdbCustomDebugInfoKind.EditAndContinueLocalSlotMap:  					var encLocalMapRec = info as PdbEditAndContinueLocalSlotMapCustomDebugInfo;  					if (encLocalMapRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					writer.WriteBytes(encLocalMapRec.Data);  					break;    				case PdbCustomDebugInfoKind.EditAndContinueLambdaMap:  					var encLambdaRec = info as PdbEditAndContinueLambdaMapCustomDebugInfo;  					if (encLambdaRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					writer.WriteBytes(encLambdaRec.Data);  					break;    				case PdbCustomDebugInfoKind.TupleElementNames:  					var tupleListRec = info as PdbTupleElementNamesCustomDebugInfo;  					if (tupleListRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					count = tupleListRec.Names.Count;  					writer.WriteInt32(count);  					for (j = 0; j < count; j++) {  						var tupleInfo = tupleListRec.Names[j];  						if (tupleInfo is null) {  							Error("Tuple name info is null");  							return null;  						}  						writer.WriteInt32(tupleInfo.TupleElementNames.Count);  						for (k = 0; k < tupleInfo.TupleElementNames.Count; k++)  							WriteUTF8Z(tupleInfo.TupleElementNames[k]);    						if (tupleInfo.Local is null) {  							writer.WriteInt32(-1);  							writer.WriteUInt32(GetInstructionOffset(tupleInfo.ScopeStart' nullIsEndOfMethod: false));  							writer.WriteUInt32(GetInstructionOffset(tupleInfo.ScopeEnd' nullIsEndOfMethod: true));  						}  						else {  							writer.WriteInt32(tupleInfo.Local.Index);  							writer.WriteInt64(0L);  						}  						WriteUTF8Z(tupleInfo.Name);  					}  					break;    				default:  					var unkRec = info as PdbUnknownCustomDebugInfo;  					if (unkRec is null) {  						Error("Unsupported custom debug info class {0}"' info.GetType());  						return null;  					}  					writer.WriteBytes(unkRec.Data);  					break;  				}
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoWriter.cs,Write,The following statement contains a magic number: switch (info.Kind) {  				case PdbCustomDebugInfoKind.UsingGroups:  					var usingRec = info as PdbUsingGroupsCustomDebugInfo;  					if (usingRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					count = usingRec.UsingCounts.Count;  					if (count > ushort.MaxValue) {  						Error("UsingCounts contains more than 0xFFFF elements");  						return null;  					}  					writer.WriteUInt16((ushort)count);  					for (j = 0; j < count; j++)  						writer.WriteUInt16(usingRec.UsingCounts[j]);  					break;    				case PdbCustomDebugInfoKind.ForwardMethodInfo:  					var fwdMethodRec = info as PdbForwardMethodInfoCustomDebugInfo;  					if (fwdMethodRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					token = GetMethodToken(fwdMethodRec.Method);  					if (token == 0)  						return null;  					writer.WriteUInt32(token);  					break;    				case PdbCustomDebugInfoKind.ForwardModuleInfo:  					var fwdModRec = info as PdbForwardModuleInfoCustomDebugInfo;  					if (fwdModRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					token = GetMethodToken(fwdModRec.Method);  					if (token == 0)  						return null;  					writer.WriteUInt32(token);  					break;    				case PdbCustomDebugInfoKind.StateMachineHoistedLocalScopes:  					var smLocalScopesRec = info as PdbStateMachineHoistedLocalScopesCustomDebugInfo;  					if (smLocalScopesRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					count = smLocalScopesRec.Scopes.Count;  					writer.WriteInt32(count);  					for (j = 0; j < count; j++) {  						var scope = smLocalScopesRec.Scopes[j];  						if (scope.IsSynthesizedLocal) {  							writer.WriteInt32(0);  							writer.WriteInt32(0);  						}  						else {  							writer.WriteUInt32(GetInstructionOffset(scope.Start' nullIsEndOfMethod: false));  							writer.WriteUInt32(GetInstructionOffset(scope.End' nullIsEndOfMethod: true) - 1);  						}  					}  					break;    				case PdbCustomDebugInfoKind.StateMachineTypeName:  					var smTypeRec = info as PdbStateMachineTypeNameCustomDebugInfo;  					if (smTypeRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					var type = smTypeRec.Type;  					if (type is null) {  						Error("State machine type is null");  						return null;  					}  					WriteUnicodeZ(MetadataNameToRoslynName(type.Name));  					break;    				case PdbCustomDebugInfoKind.DynamicLocals:  					var dynLocListRec = info as PdbDynamicLocalsCustomDebugInfo;  					if (dynLocListRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					count = dynLocListRec.Locals.Count;  					writer.WriteInt32(count);  					for (j = 0; j < count; j++) {  						var dynLoc = dynLocListRec.Locals[j];  						if (dynLoc is null) {  							Error("Dynamic local is null");  							return null;  						}  						if (dynLoc.Flags.Count > 64) {  							Error("Dynamic local flags is longer than 64 bytes");  							return null;  						}  						var name = dynLoc.Name;  						if (name is null)  							name = string.Empty;  						if (name.Length > 64) {  							Error("Dynamic local name is longer than 64 chars");  							return null;  						}  						if (name.IndexOf('\0') >= 0) {  							Error("Dynamic local name contains a NUL char");  							return null;  						}    						for (k = 0; k < dynLoc.Flags.Count; k++)  							writer.WriteByte(dynLoc.Flags[k]);  						while (k++ < 64)  							writer.WriteByte(0);  						writer.WriteInt32(dynLoc.Flags.Count);    						if (dynLoc.Local is null)  							writer.WriteInt32(0);  						else  							writer.WriteInt32(dynLoc.Local.Index);    						for (k = 0; k < name.Length; k++)  							writer.WriteUInt16(name[k]);  						while (k++ < 64)  							writer.WriteUInt16(0);  					}  					break;    				case PdbCustomDebugInfoKind.EditAndContinueLocalSlotMap:  					var encLocalMapRec = info as PdbEditAndContinueLocalSlotMapCustomDebugInfo;  					if (encLocalMapRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					writer.WriteBytes(encLocalMapRec.Data);  					break;    				case PdbCustomDebugInfoKind.EditAndContinueLambdaMap:  					var encLambdaRec = info as PdbEditAndContinueLambdaMapCustomDebugInfo;  					if (encLambdaRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					writer.WriteBytes(encLambdaRec.Data);  					break;    				case PdbCustomDebugInfoKind.TupleElementNames:  					var tupleListRec = info as PdbTupleElementNamesCustomDebugInfo;  					if (tupleListRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					count = tupleListRec.Names.Count;  					writer.WriteInt32(count);  					for (j = 0; j < count; j++) {  						var tupleInfo = tupleListRec.Names[j];  						if (tupleInfo is null) {  							Error("Tuple name info is null");  							return null;  						}  						writer.WriteInt32(tupleInfo.TupleElementNames.Count);  						for (k = 0; k < tupleInfo.TupleElementNames.Count; k++)  							WriteUTF8Z(tupleInfo.TupleElementNames[k]);    						if (tupleInfo.Local is null) {  							writer.WriteInt32(-1);  							writer.WriteUInt32(GetInstructionOffset(tupleInfo.ScopeStart' nullIsEndOfMethod: false));  							writer.WriteUInt32(GetInstructionOffset(tupleInfo.ScopeEnd' nullIsEndOfMethod: true));  						}  						else {  							writer.WriteInt32(tupleInfo.Local.Index);  							writer.WriteInt64(0L);  						}  						WriteUTF8Z(tupleInfo.Name);  					}  					break;    				default:  					var unkRec = info as PdbUnknownCustomDebugInfo;  					if (unkRec is null) {  						Error("Unsupported custom debug info class {0}"' info.GetType());  						return null;  					}  					writer.WriteBytes(unkRec.Data);  					break;  				}
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoWriter.cs,Write,The following statement contains a magic number: switch (info.Kind) {  				case PdbCustomDebugInfoKind.UsingGroups:  					var usingRec = info as PdbUsingGroupsCustomDebugInfo;  					if (usingRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					count = usingRec.UsingCounts.Count;  					if (count > ushort.MaxValue) {  						Error("UsingCounts contains more than 0xFFFF elements");  						return null;  					}  					writer.WriteUInt16((ushort)count);  					for (j = 0; j < count; j++)  						writer.WriteUInt16(usingRec.UsingCounts[j]);  					break;    				case PdbCustomDebugInfoKind.ForwardMethodInfo:  					var fwdMethodRec = info as PdbForwardMethodInfoCustomDebugInfo;  					if (fwdMethodRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					token = GetMethodToken(fwdMethodRec.Method);  					if (token == 0)  						return null;  					writer.WriteUInt32(token);  					break;    				case PdbCustomDebugInfoKind.ForwardModuleInfo:  					var fwdModRec = info as PdbForwardModuleInfoCustomDebugInfo;  					if (fwdModRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					token = GetMethodToken(fwdModRec.Method);  					if (token == 0)  						return null;  					writer.WriteUInt32(token);  					break;    				case PdbCustomDebugInfoKind.StateMachineHoistedLocalScopes:  					var smLocalScopesRec = info as PdbStateMachineHoistedLocalScopesCustomDebugInfo;  					if (smLocalScopesRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					count = smLocalScopesRec.Scopes.Count;  					writer.WriteInt32(count);  					for (j = 0; j < count; j++) {  						var scope = smLocalScopesRec.Scopes[j];  						if (scope.IsSynthesizedLocal) {  							writer.WriteInt32(0);  							writer.WriteInt32(0);  						}  						else {  							writer.WriteUInt32(GetInstructionOffset(scope.Start' nullIsEndOfMethod: false));  							writer.WriteUInt32(GetInstructionOffset(scope.End' nullIsEndOfMethod: true) - 1);  						}  					}  					break;    				case PdbCustomDebugInfoKind.StateMachineTypeName:  					var smTypeRec = info as PdbStateMachineTypeNameCustomDebugInfo;  					if (smTypeRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					var type = smTypeRec.Type;  					if (type is null) {  						Error("State machine type is null");  						return null;  					}  					WriteUnicodeZ(MetadataNameToRoslynName(type.Name));  					break;    				case PdbCustomDebugInfoKind.DynamicLocals:  					var dynLocListRec = info as PdbDynamicLocalsCustomDebugInfo;  					if (dynLocListRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					count = dynLocListRec.Locals.Count;  					writer.WriteInt32(count);  					for (j = 0; j < count; j++) {  						var dynLoc = dynLocListRec.Locals[j];  						if (dynLoc is null) {  							Error("Dynamic local is null");  							return null;  						}  						if (dynLoc.Flags.Count > 64) {  							Error("Dynamic local flags is longer than 64 bytes");  							return null;  						}  						var name = dynLoc.Name;  						if (name is null)  							name = string.Empty;  						if (name.Length > 64) {  							Error("Dynamic local name is longer than 64 chars");  							return null;  						}  						if (name.IndexOf('\0') >= 0) {  							Error("Dynamic local name contains a NUL char");  							return null;  						}    						for (k = 0; k < dynLoc.Flags.Count; k++)  							writer.WriteByte(dynLoc.Flags[k]);  						while (k++ < 64)  							writer.WriteByte(0);  						writer.WriteInt32(dynLoc.Flags.Count);    						if (dynLoc.Local is null)  							writer.WriteInt32(0);  						else  							writer.WriteInt32(dynLoc.Local.Index);    						for (k = 0; k < name.Length; k++)  							writer.WriteUInt16(name[k]);  						while (k++ < 64)  							writer.WriteUInt16(0);  					}  					break;    				case PdbCustomDebugInfoKind.EditAndContinueLocalSlotMap:  					var encLocalMapRec = info as PdbEditAndContinueLocalSlotMapCustomDebugInfo;  					if (encLocalMapRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					writer.WriteBytes(encLocalMapRec.Data);  					break;    				case PdbCustomDebugInfoKind.EditAndContinueLambdaMap:  					var encLambdaRec = info as PdbEditAndContinueLambdaMapCustomDebugInfo;  					if (encLambdaRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					writer.WriteBytes(encLambdaRec.Data);  					break;    				case PdbCustomDebugInfoKind.TupleElementNames:  					var tupleListRec = info as PdbTupleElementNamesCustomDebugInfo;  					if (tupleListRec is null) {  						Error("Unsupported custom debug info type {0}"' info.GetType());  						return null;  					}  					count = tupleListRec.Names.Count;  					writer.WriteInt32(count);  					for (j = 0; j < count; j++) {  						var tupleInfo = tupleListRec.Names[j];  						if (tupleInfo is null) {  							Error("Tuple name info is null");  							return null;  						}  						writer.WriteInt32(tupleInfo.TupleElementNames.Count);  						for (k = 0; k < tupleInfo.TupleElementNames.Count; k++)  							WriteUTF8Z(tupleInfo.TupleElementNames[k]);    						if (tupleInfo.Local is null) {  							writer.WriteInt32(-1);  							writer.WriteUInt32(GetInstructionOffset(tupleInfo.ScopeStart' nullIsEndOfMethod: false));  							writer.WriteUInt32(GetInstructionOffset(tupleInfo.ScopeEnd' nullIsEndOfMethod: true));  						}  						else {  							writer.WriteInt32(tupleInfo.Local.Index);  							writer.WriteInt64(0L);  						}  						WriteUTF8Z(tupleInfo.Name);  					}  					break;    				default:  					var unkRec = info as PdbUnknownCustomDebugInfo;  					if (unkRec is null) {  						Error("Unsupported custom debug info class {0}"' info.GetType());  						return null;  					}  					writer.WriteBytes(unkRec.Data);  					break;  				}
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoWriter.cs,Write,The following statement contains a magic number: var alignedLen = (recLen + 3) & ~3;
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoWriter.cs,Write,The following statement contains a magic number: var alignedLen = (recLen + 3) & ~3;
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,PdbCustomDebugInfoWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoWriter.cs,Write,The following statement contains a magic number: writer.Position = recordPos + 3;
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,PseudoCustomDebugInfoFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\PseudoCustomDebugInfoFactory.cs,GetInstruction,The following statement contains a magic number: int i = (lo + hi) / 2;
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,WindowsPdbWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\WindowsPdbWriter.cs,WriteScope,The following statement contains a magic number: recursionCounter >= 1000
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,SequencePointHelper,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\WindowsPdbWriter.cs,Write,The following statement contains a magic number: int newSize = index * 2;
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,SequencePointHelper,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\WindowsPdbWriter.cs,Write,The following statement contains a magic number: newSize = 64;
Magic Number,dnlib.DotNet.Pdb.WindowsPdb,SequencePointHelper,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\WindowsPdb\WindowsPdbWriter.cs,Write,The following statement contains a magic number: newSize < 64
Magic Number,dnlib.DotNet.Resources,ResourceReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Resources\ResourceReader.cs,Read,The following statement contains a magic number: version != 2
Magic Number,dnlib.DotNet.Resources,ResourceReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Resources\ResourceReader.cs,Read,The following statement contains a magic number: reader.Position = (reader.Position + 7) & ~7U;
Magic Number,dnlib.DotNet.Resources,ResourceReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Resources\ResourceReader.cs,Read,The following statement contains a magic number: reader.Position = (reader.Position + 7) & ~7U;
Magic Number,dnlib.DotNet.Resources,ResourceWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Resources\ResourceWriter.cs,Write,The following statement contains a magic number: writer.Write(2);
Magic Number,dnlib.DotNet.Resources,ResourceWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Resources\ResourceWriter.cs,Write,The following statement contains a magic number: int extraBytes = 8 - ((int)writer.BaseStream.Position & 7);
Magic Number,dnlib.DotNet.Resources,ResourceWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Resources\ResourceWriter.cs,Write,The following statement contains a magic number: int extraBytes = 8 - ((int)writer.BaseStream.Position & 7);
Magic Number,dnlib.DotNet.Resources,ResourceWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Resources\ResourceWriter.cs,Write,The following statement contains a magic number: extraBytes != 8
Magic Number,dnlib.DotNet.Resources,ResourceWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Resources\ResourceWriter.cs,Write,The following statement contains a magic number: writer.Write((int)writer.BaseStream.Position + (int)nameOffsetStream.Length + 4);
Magic Number,dnlib.DotNet.Resources,ResourceWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Resources\ResourceWriter.cs,WriteUInt32,The following statement contains a magic number: value >>= 7;
Magic Number,dnlib.DotNet.Resources,ResourceWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Resources\ResourceWriter.cs,Hash,The following statement contains a magic number: val = ((val << 5) + val) ^ (uint)c;
Magic Number,dnlib.DotNet.Writer,ArrayWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ArrayWriter.cs,WriteInt16,The following statement contains a magic number: data[position++] = (byte)(value >> 8);
Magic Number,dnlib.DotNet.Writer,ArrayWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ArrayWriter.cs,WriteUInt16,The following statement contains a magic number: data[position++] = (byte)(value >> 8);
Magic Number,dnlib.DotNet.Writer,ArrayWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ArrayWriter.cs,WriteInt32,The following statement contains a magic number: Debug.Assert(this.position + 4 <= data.Length);
Magic Number,dnlib.DotNet.Writer,ArrayWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ArrayWriter.cs,WriteInt32,The following statement contains a magic number: this.position = position + 4;
Magic Number,dnlib.DotNet.Writer,ArrayWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ArrayWriter.cs,WriteUInt32,The following statement contains a magic number: Debug.Assert(this.position + 4 <= data.Length);
Magic Number,dnlib.DotNet.Writer,ArrayWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ArrayWriter.cs,WriteUInt32,The following statement contains a magic number: this.position = position + 4;
Magic Number,dnlib.DotNet.Writer,ArrayWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ArrayWriter.cs,WriteInt64,The following statement contains a magic number: Debug.Assert(this.position + 8 <= data.Length);
Magic Number,dnlib.DotNet.Writer,ArrayWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ArrayWriter.cs,WriteInt64,The following statement contains a magic number: this.position = position + 8;
Magic Number,dnlib.DotNet.Writer,ArrayWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ArrayWriter.cs,WriteUInt64,The following statement contains a magic number: Debug.Assert(this.position + 8 <= data.Length);
Magic Number,dnlib.DotNet.Writer,ArrayWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ArrayWriter.cs,WriteUInt64,The following statement contains a magic number: this.position = position + 8;
Magic Number,dnlib.DotNet.Writer,ArrayWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ArrayWriter.cs,WriteSingle,The following statement contains a magic number: Debug.Assert(this.position + 4 <= data.Length);
Magic Number,dnlib.DotNet.Writer,ArrayWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ArrayWriter.cs,WriteSingle,The following statement contains a magic number: this.position = position + 4;
Magic Number,dnlib.DotNet.Writer,ArrayWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ArrayWriter.cs,WriteDouble,The following statement contains a magic number: Debug.Assert(this.position + 8 <= data.Length);
Magic Number,dnlib.DotNet.Writer,ArrayWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ArrayWriter.cs,WriteDouble,The following statement contains a magic number: this.position = position + 8;
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteInt16,The following statement contains a magic number: buffer[1] = (byte)(value >> 8);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteInt16,The following statement contains a magic number: stream.Write(buffer' 0' 2);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteUInt16,The following statement contains a magic number: buffer[1] = (byte)(value >> 8);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteUInt16,The following statement contains a magic number: stream.Write(buffer' 0' 2);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteInt32,The following statement contains a magic number: buffer[1] = (byte)(value >> 8);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteInt32,The following statement contains a magic number: buffer[2] = (byte)(value >> 16);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteInt32,The following statement contains a magic number: buffer[2] = (byte)(value >> 16);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteInt32,The following statement contains a magic number: buffer[3] = (byte)(value >> 24);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteInt32,The following statement contains a magic number: buffer[3] = (byte)(value >> 24);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteInt32,The following statement contains a magic number: stream.Write(buffer' 0' 4);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteUInt32,The following statement contains a magic number: buffer[1] = (byte)(value >> 8);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteUInt32,The following statement contains a magic number: buffer[2] = (byte)(value >> 16);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteUInt32,The following statement contains a magic number: buffer[2] = (byte)(value >> 16);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteUInt32,The following statement contains a magic number: buffer[3] = (byte)(value >> 24);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteUInt32,The following statement contains a magic number: buffer[3] = (byte)(value >> 24);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteUInt32,The following statement contains a magic number: stream.Write(buffer' 0' 4);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteInt64,The following statement contains a magic number: buffer[1] = (byte)(value >> 8);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteInt64,The following statement contains a magic number: buffer[2] = (byte)(value >> 16);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteInt64,The following statement contains a magic number: buffer[2] = (byte)(value >> 16);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteInt64,The following statement contains a magic number: buffer[3] = (byte)(value >> 24);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteInt64,The following statement contains a magic number: buffer[3] = (byte)(value >> 24);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteInt64,The following statement contains a magic number: buffer[4] = (byte)(value >> 32);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteInt64,The following statement contains a magic number: buffer[4] = (byte)(value >> 32);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteInt64,The following statement contains a magic number: buffer[5] = (byte)(value >> 40);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteInt64,The following statement contains a magic number: buffer[5] = (byte)(value >> 40);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteInt64,The following statement contains a magic number: buffer[6] = (byte)(value >> 48);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteInt64,The following statement contains a magic number: buffer[6] = (byte)(value >> 48);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteInt64,The following statement contains a magic number: buffer[7] = (byte)(value >> 56);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteInt64,The following statement contains a magic number: buffer[7] = (byte)(value >> 56);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteInt64,The following statement contains a magic number: stream.Write(buffer' 0' 8);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteUInt64,The following statement contains a magic number: buffer[1] = (byte)(value >> 8);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteUInt64,The following statement contains a magic number: buffer[2] = (byte)(value >> 16);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteUInt64,The following statement contains a magic number: buffer[2] = (byte)(value >> 16);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteUInt64,The following statement contains a magic number: buffer[3] = (byte)(value >> 24);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteUInt64,The following statement contains a magic number: buffer[3] = (byte)(value >> 24);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteUInt64,The following statement contains a magic number: buffer[4] = (byte)(value >> 32);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteUInt64,The following statement contains a magic number: buffer[4] = (byte)(value >> 32);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteUInt64,The following statement contains a magic number: buffer[5] = (byte)(value >> 40);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteUInt64,The following statement contains a magic number: buffer[5] = (byte)(value >> 40);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteUInt64,The following statement contains a magic number: buffer[6] = (byte)(value >> 48);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteUInt64,The following statement contains a magic number: buffer[6] = (byte)(value >> 48);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteUInt64,The following statement contains a magic number: buffer[7] = (byte)(value >> 56);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteUInt64,The following statement contains a magic number: buffer[7] = (byte)(value >> 56);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteUInt64,The following statement contains a magic number: stream.Write(buffer' 0' 8);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteSingle,The following statement contains a magic number: buffer[1] = (byte)(tmp >> 8);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteSingle,The following statement contains a magic number: buffer[2] = (byte)(tmp >> 16);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteSingle,The following statement contains a magic number: buffer[2] = (byte)(tmp >> 16);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteSingle,The following statement contains a magic number: buffer[3] = (byte)(tmp >> 24);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteSingle,The following statement contains a magic number: buffer[3] = (byte)(tmp >> 24);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteSingle,The following statement contains a magic number: stream.Write(buffer' 0' 4);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteDouble,The following statement contains a magic number: buffer[1] = (byte)(tmp >> 8);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteDouble,The following statement contains a magic number: buffer[2] = (byte)(tmp >> 16);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteDouble,The following statement contains a magic number: buffer[2] = (byte)(tmp >> 16);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteDouble,The following statement contains a magic number: buffer[3] = (byte)(tmp >> 24);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteDouble,The following statement contains a magic number: buffer[3] = (byte)(tmp >> 24);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteDouble,The following statement contains a magic number: buffer[4] = (byte)(tmp >> 32);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteDouble,The following statement contains a magic number: buffer[4] = (byte)(tmp >> 32);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteDouble,The following statement contains a magic number: buffer[5] = (byte)(tmp >> 40);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteDouble,The following statement contains a magic number: buffer[5] = (byte)(tmp >> 40);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteDouble,The following statement contains a magic number: buffer[6] = (byte)(tmp >> 48);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteDouble,The following statement contains a magic number: buffer[6] = (byte)(tmp >> 48);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteDouble,The following statement contains a magic number: buffer[7] = (byte)(tmp >> 56);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteDouble,The following statement contains a magic number: buffer[7] = (byte)(tmp >> 56);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteDouble,The following statement contains a magic number: stream.Write(buffer' 0' 8);
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,WriteCompressedInt32,The following statement contains a magic number: uint sign = (uint)value >> 31;
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,GetCompressedUInt32Length,The following statement contains a magic number: return 2;
Magic Number,dnlib.DotNet.Writer,DataWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\DataWriter.cs,GetCompressedUInt32Length,The following statement contains a magic number: return 4;
Magic Number,dnlib.DotNet.Writer,Extensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Extensions.cs,WriteZeroes,The following statement contains a magic number: count -= 8;
Magic Number,dnlib.DotNet.Writer,Extensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Extensions.cs,WriteZeroes,The following statement contains a magic number: count >= 8
Magic Number,dnlib.DotNet.Writer,GuidHeap,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\GuidHeap.cs,WriteToImpl,The following statement contains a magic number: offset += 16;
Magic Number,dnlib.DotNet.Writer,GuidHeap,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\GuidHeap.cs,SetRawData,The following statement contains a magic number: rawData is null || rawData.Length != 16
Magic Number,dnlib.DotNet.Writer,GuidHeap,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\GuidHeap.cs,GetAllRawData,The following statement contains a magic number: offset += 16;
Magic Number,dnlib.DotNet.Writer,Hasher,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Hasher.cs,TryGetChecksumAlgorithm,The following statement contains a magic number: switch (checksumName) {  			case "SHA1":  				pdbChecksumAlgorithm = ChecksumAlgorithm.SHA1;  				checksumSize = 20;  				return true;    			case "SHA256":  				pdbChecksumAlgorithm = ChecksumAlgorithm.SHA256;  				checksumSize = 32;  				return true;    			case "SHA384":  				pdbChecksumAlgorithm = ChecksumAlgorithm.SHA384;  				checksumSize = 48;  				return true;    			case "SHA512":  				pdbChecksumAlgorithm = ChecksumAlgorithm.SHA512;  				checksumSize = 64;  				return true;    			default:  				pdbChecksumAlgorithm = 0;  				checksumSize = -1;  				return false;  			}
Magic Number,dnlib.DotNet.Writer,Hasher,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Hasher.cs,TryGetChecksumAlgorithm,The following statement contains a magic number: switch (checksumName) {  			case "SHA1":  				pdbChecksumAlgorithm = ChecksumAlgorithm.SHA1;  				checksumSize = 20;  				return true;    			case "SHA256":  				pdbChecksumAlgorithm = ChecksumAlgorithm.SHA256;  				checksumSize = 32;  				return true;    			case "SHA384":  				pdbChecksumAlgorithm = ChecksumAlgorithm.SHA384;  				checksumSize = 48;  				return true;    			case "SHA512":  				pdbChecksumAlgorithm = ChecksumAlgorithm.SHA512;  				checksumSize = 64;  				return true;    			default:  				pdbChecksumAlgorithm = 0;  				checksumSize = -1;  				return false;  			}
Magic Number,dnlib.DotNet.Writer,Hasher,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Hasher.cs,TryGetChecksumAlgorithm,The following statement contains a magic number: switch (checksumName) {  			case "SHA1":  				pdbChecksumAlgorithm = ChecksumAlgorithm.SHA1;  				checksumSize = 20;  				return true;    			case "SHA256":  				pdbChecksumAlgorithm = ChecksumAlgorithm.SHA256;  				checksumSize = 32;  				return true;    			case "SHA384":  				pdbChecksumAlgorithm = ChecksumAlgorithm.SHA384;  				checksumSize = 48;  				return true;    			case "SHA512":  				pdbChecksumAlgorithm = ChecksumAlgorithm.SHA512;  				checksumSize = 64;  				return true;    			default:  				pdbChecksumAlgorithm = 0;  				checksumSize = -1;  				return false;  			}
Magic Number,dnlib.DotNet.Writer,Hasher,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Hasher.cs,TryGetChecksumAlgorithm,The following statement contains a magic number: switch (checksumName) {  			case "SHA1":  				pdbChecksumAlgorithm = ChecksumAlgorithm.SHA1;  				checksumSize = 20;  				return true;    			case "SHA256":  				pdbChecksumAlgorithm = ChecksumAlgorithm.SHA256;  				checksumSize = 32;  				return true;    			case "SHA384":  				pdbChecksumAlgorithm = ChecksumAlgorithm.SHA384;  				checksumSize = 48;  				return true;    			case "SHA512":  				pdbChecksumAlgorithm = ChecksumAlgorithm.SHA512;  				checksumSize = 64;  				return true;    			default:  				pdbChecksumAlgorithm = 0;  				checksumSize = -1;  				return false;  			}
Magic Number,dnlib.DotNet.Writer,ImportAddressTable,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ImportAddressTable.cs,GetFileLength,The following statement contains a magic number: return is64bit ? 16U : 8;
Magic Number,dnlib.DotNet.Writer,ImportAddressTable,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ImportAddressTable.cs,GetFileLength,The following statement contains a magic number: return is64bit ? 16U : 8;
Magic Number,dnlib.DotNet.Writer,ImportDirectory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ImportDirectory.cs,SetOffset,The following statement contains a magic number: length += is64bit ? 16U : 8;
Magic Number,dnlib.DotNet.Writer,ImportDirectory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ImportDirectory.cs,SetOffset,The following statement contains a magic number: length += is64bit ? 16U : 8;
Magic Number,dnlib.DotNet.Writer,ImportDirectory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ImportDirectory.cs,SetOffset,The following statement contains a magic number: length += 2 + (uint)EntryPointName.Length + 1;
Magic Number,dnlib.DotNet.Writer,ManagedExportsWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ManagedExportsWriter.cs,Initialize,The following statement contains a magic number: vtableFixups.length = (uint)vtables.Count * 8;
Magic Number,dnlib.DotNet.Writer,ManagedExportsWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ManagedExportsWriter.cs,WriteSdataBlob,The following statement contains a magic number: Debug.Assert((writer.Position & 7) == 0);
Magic Number,dnlib.DotNet.Writer,ManagedExportsWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ManagedExportsWriter.cs,WriteSdataBlob,The following statement contains a magic number: var namesBlob = new NamesBlob(1 == 2);
Magic Number,dnlib.DotNet.Writer,ManagedExportsWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ManagedExportsWriter.cs,WriteSdataBlob,The following statement contains a magic number: Debug.Assert((writer.Position & 3) == 0);
Magic Number,dnlib.DotNet.Writer,ManagedExportsWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ManagedExportsWriter.cs,WriteSdataBlob,The following statement contains a magic number: writer.WriteZeroes(funcSize * 4);
Magic Number,dnlib.DotNet.Writer,ManagedExportsWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ManagedExportsWriter.cs,WriteSdataBlob,The following statement contains a magic number: writer.WriteZeroes(sdataBytesInfo.MethodNameOffsets.Length * 4);
Magic Number,dnlib.DotNet.Writer,ManagedExportsWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ManagedExportsWriter.cs,WriteSdataBlob,The following statement contains a magic number: writer.WriteZeroes(sdataBytesInfo.MethodNameOffsets.Length * 2);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns2 = columns[2];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns3 = columns[3];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns4 = columns[4];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns2 = columns[2];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns2 = columns[2];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns3 = columns[3];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns4 = columns[4];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns5 = columns[5];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns2 = columns[2];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns3 = columns[3];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns4 = columns[4];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns5 = columns[5];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns2 = columns[2];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns2 = columns[2];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns2 = columns[2];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns3 = columns[3];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns2 = columns[2];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns2 = columns[2];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns2 = columns[2];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns2 = columns[2];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns2 = columns[2];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns2 = columns[2];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns2 = columns[2];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns2 = columns[2];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns3 = columns[3];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns6 = columns[6];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns7 = columns[7];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns8 = columns[8];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns5 = columns[5];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns6 = columns[6];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns7 = columns[7];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns8 = columns[8];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns3 = columns[3];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns2 = columns[2];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns2 = columns[2];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns3 = columns[3];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns4 = columns[4];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns2 = columns[2];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns3 = columns[3];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns2 = columns[2];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns3 = columns[3];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns4 = columns[4];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: columns.Length >= 5
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns2 = columns[2];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns3 = columns[3];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns2 = columns[2];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns3 = columns[3];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns2 = columns[2];
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: var columns2 = columns[2];
Magic Number,dnlib.DotNet.Writer,Metadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Metadata.cs,InitializeTypeDefsAndMemberDefs,The following statement contains a magic number: const int numNotifyEvents = 5;
Magic Number,dnlib.DotNet.Writer,Metadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Metadata.cs,WriteTypeDefAndMemberDefCustomAttributesAndCustomDebugInfos,The following statement contains a magic number: const int numNotifyEvents = 5;
Magic Number,dnlib.DotNet.Writer,Metadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Metadata.cs,WriteMethodBodies,The following statement contains a magic number: const int numNotifyEvents = 40;
Magic Number,dnlib.DotNet.Writer,MetadataHeader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MetadataHeader.cs,SetOffset,The following statement contains a magic number: length = 16;
Magic Number,dnlib.DotNet.Writer,MetadataHeader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MetadataHeader.cs,SetOffset,The following statement contains a magic number: length = Utils.AlignUp(length' 4);
Magic Number,dnlib.DotNet.Writer,MetadataHeader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MetadataHeader.cs,SetOffset,The following statement contains a magic number: length += 4;
Magic Number,dnlib.DotNet.Writer,MetadataHeader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MetadataHeader.cs,SetOffset,The following statement contains a magic number: length += 8;
Magic Number,dnlib.DotNet.Writer,MetadataHeader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MetadataHeader.cs,SetOffset,The following statement contains a magic number: length = Utils.AlignUp(length' 4);
Magic Number,dnlib.DotNet.Writer,MetadataHeader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MetadataHeader.cs,WriteTo,The following statement contains a magic number: writer.WriteInt32(Utils.AlignUp(s.Length' 4));
Magic Number,dnlib.DotNet.Writer,MetadataHeader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MetadataHeader.cs,WriteTo,The following statement contains a magic number: writer.WriteZeroes(Utils.AlignUp(s.Length' 4) - s.Length);
Magic Number,dnlib.DotNet.Writer,MetadataHeader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MetadataHeader.cs,WriteTo,The following statement contains a magic number: s.Length > 32
Magic Number,dnlib.DotNet.Writer,MetadataHeader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MetadataHeader.cs,WriteTo,The following statement contains a magic number: writer.WriteZeroes(Utils.AlignUp(s.Length' 4) - s.Length);
Magic Number,dnlib.DotNet.Writer,MethodBody,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBody.cs,MethodBody,The following statement contains a magic number: isTiny = (code[0] & 3) == 2;
Magic Number,dnlib.DotNet.Writer,MethodBody,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBody.cs,MethodBody,The following statement contains a magic number: isTiny = (code[0] & 3) == 2;
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBodyWriter.cs,GetFullMethodBody,The following statement contains a magic number: int padding = Utils.AlignUp(code.Length' 4) - code.Length;
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBodyWriter.cs,NeedFatHeader,The following statement contains a magic number: return codeSize > 0x3F ||  					exceptionHandlers.Count > 0 ||  					cilBody.HasVariables ||  					maxStack > 8;
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteFatHeader,The following statement contains a magic number: flags |= 8;
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteFatHeader,The following statement contains a magic number: code = new byte[12 + codeSize];
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteTinyHeader,The following statement contains a magic number: writer.WriteByte((byte)((codeSize << 2) | 2));
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteTinyHeader,The following statement contains a magic number: writer.WriteByte((byte)((codeSize << 2) | 2));
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBodyWriter.cs,NeedFatExceptionClauses,The following statement contains a magic number: exceptionHandlers.Count > 20
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteFatExceptionClauses,The following statement contains a magic number: const int maxExceptionHandlers = (0x00FFFFFF - 4) / 24;
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteFatExceptionClauses,The following statement contains a magic number: const int maxExceptionHandlers = (0x00FFFFFF - 4) / 24;
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteFatExceptionClauses,The following statement contains a magic number: var data = new byte[numExceptionHandlers * 24 + 4];
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteFatExceptionClauses,The following statement contains a magic number: var data = new byte[numExceptionHandlers * 24 + 4];
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteFatExceptionClauses,The following statement contains a magic number: writer.WriteUInt32((((uint)numExceptionHandlers * 24 + 4) << 8) | 0x41);
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteFatExceptionClauses,The following statement contains a magic number: writer.WriteUInt32((((uint)numExceptionHandlers * 24 + 4) << 8) | 0x41);
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteFatExceptionClauses,The following statement contains a magic number: writer.WriteUInt32((((uint)numExceptionHandlers * 24 + 4) << 8) | 0x41);
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteSmallExceptionClauses,The following statement contains a magic number: const int maxExceptionHandlers = (0xFF - 4) / 12;
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteSmallExceptionClauses,The following statement contains a magic number: const int maxExceptionHandlers = (0xFF - 4) / 12;
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteSmallExceptionClauses,The following statement contains a magic number: var data = new byte[numExceptionHandlers * 12 + 4];
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteSmallExceptionClauses,The following statement contains a magic number: var data = new byte[numExceptionHandlers * 12 + 4];
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteSmallExceptionClauses,The following statement contains a magic number: writer.WriteUInt32((((uint)numExceptionHandlers * 12 + 4) << 8) | 1);
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteSmallExceptionClauses,The following statement contains a magic number: writer.WriteUInt32((((uint)numExceptionHandlers * 12 + 4) << 8) | 1);
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteSmallExceptionClauses,The following statement contains a magic number: writer.WriteUInt32((((uint)numExceptionHandlers * 12 + 4) << 8) | 1);
Magic Number,dnlib.DotNet.Writer,MethodBodyWriterBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBodyWriterBase.cs,GetMaxStack,The following statement contains a magic number: maxStack += 8;
Magic Number,dnlib.DotNet.Writer,MethodBodyWriterBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MethodBodyWriterBase.cs,WriteInlineBrTarget,The following statement contains a magic number: uint displ = GetOffset(instr.Operand as Instruction) - (ToInstructionOffset(ref writer) + 4);
Magic Number,dnlib.DotNet.Writer,ModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriter.cs,AddChunksToSections,The following statement contains a magic number: uint pointerAlignment = is64bit ? 8U : 4;
Magic Number,dnlib.DotNet.Writer,ModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriter.cs,AddChunksToSections,The following statement contains a magic number: uint pointerAlignment = is64bit ? 8U : 4;
Magic Number,dnlib.DotNet.Writer,ModuleWriterOptionsBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,ModuleWriterOptionsBase,The following statement contains a magic number: Cor20HeaderOptions.MajorRuntimeVersion = (ushort)(module.Cor20HeaderRuntimeVersion.Value >> 16);
Magic Number,dnlib.DotNet.Writer,ModuleWriterOptionsBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,ModuleWriterOptionsBase,The following statement contains a magic number: MetadataOptions.TablesHeapOptions.MajorVersion = (byte)(module.TablesHeaderVersion.Value >> 8);
Magic Number,dnlib.DotNet.Writer,ModuleWriterOptionsBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,HasMvidSection,The following statement contains a magic number: section.VirtualSize != 16
Magic Number,dnlib.DotNet.Writer,ModuleWriterOptionsBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,HasMvidSection,The following statement contains a magic number: name[0] == '.' && name[1] == 'm' && name[2] == 'v' && name[3] == 'i' && name[4] == 'd' && name[5] == 0
Magic Number,dnlib.DotNet.Writer,ModuleWriterOptionsBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,HasMvidSection,The following statement contains a magic number: name[0] == '.' && name[1] == 'm' && name[2] == 'v' && name[3] == 'i' && name[4] == 'd' && name[5] == 0
Magic Number,dnlib.DotNet.Writer,ModuleWriterOptionsBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,HasMvidSection,The following statement contains a magic number: name[0] == '.' && name[1] == 'm' && name[2] == 'v' && name[3] == 'i' && name[4] == 'd' && name[5] == 0
Magic Number,dnlib.DotNet.Writer,ModuleWriterOptionsBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,HasMvidSection,The following statement contains a magic number: name[0] == '.' && name[1] == 'm' && name[2] == 'v' && name[3] == 'i' && name[4] == 'd' && name[5] == 0
Magic Number,dnlib.DotNet.Writer,ModuleWriterBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,WritePortablePdb,The following statement contains a magic number: var pdbId = new byte[20];
Magic Number,dnlib.DotNet.Writer,ModuleWriterBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,WritePortablePdb,The following statement contains a magic number: checksumBytes.Length < 20
Magic Number,dnlib.DotNet.Writer,ModuleWriterBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,CreateEmbeddedPortablePdbBlob,The following statement contains a magic number: var data = new byte[4 + 4 + compressedData.Length];
Magic Number,dnlib.DotNet.Writer,ModuleWriterBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\ModuleWriterBase.cs,CreateEmbeddedPortablePdbBlob,The following statement contains a magic number: var data = new byte[4 + 4 + compressedData.Length];
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteFile,The following statement contains a magic number: var resourceDataDir = peImage.ImageNTHeaders.OptionalHeader.DataDirectories[2];
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteFile,The following statement contains a magic number: ReuseIfPossible(textSection' imageCor20Header' module.Metadata.PEImage.ImageNTHeaders.OptionalHeader.DataDirectories[14].VirtualAddress' module.Metadata.PEImage.ImageNTHeaders.OptionalHeader.DataDirectories[14].Size' DEFAULT_COR20HEADER_ALIGNMENT);
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteFile,The following statement contains a magic number: ReuseIfPossible(textSection' imageCor20Header' module.Metadata.PEImage.ImageNTHeaders.OptionalHeader.DataDirectories[14].VirtualAddress' module.Metadata.PEImage.ImageNTHeaders.OptionalHeader.DataDirectories[14].Size' DEFAULT_COR20HEADER_ALIGNMENT);
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteFile,The following statement contains a magic number: var debugDataDir = peImage.ImageNTHeaders.OptionalHeader.DataDirectories[6];
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,TryGetRealDebugDirectorySize,The following statement contains a magic number: var debugDataDir = peImage.ImageNTHeaders.OptionalHeader.DataDirectories[6];
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,TryGetRealDebugDirectorySize,The following statement contains a magic number: uint prevEndAligned = (prevEnd + 3) & ~3U;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,TryGetRealDebugDirectorySize,The following statement contains a magic number: uint prevEndAligned = (prevEnd + 3) & ~3U;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: long dataDirOffset = destStreamBaseOffset + (long)peImage.ImageNTHeaders.OptionalHeader.EndOffset - 16 * 8;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: long dataDirOffset = destStreamBaseOffset + (long)peImage.ImageNTHeaders.OptionalHeader.EndOffset - 16 * 8;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: writer.Position += 2;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: writer.Position += 2;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: writer.Position += 4;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: writer.Position += 8;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: writer.Position = dataDirOffset + 2 * 8;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: writer.Position = dataDirOffset + 2 * 8;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: writer.Position = dataDirOffset + 4 * 8;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: writer.Position = dataDirOffset + 4 * 8;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: writer.Position = dataDirOffset + 6 * 8;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: writer.Position = dataDirOffset + 6 * 8;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: writer.Position = dataDirOffset + 14 * 8;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: writer.Position = dataDirOffset + 14 * 8;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteUInt16,The following statement contains a magic number: writer.Position += 2;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteUInt16,The following statement contains a magic number: writer.Position += 2;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteUInt16,The following statement contains a magic number: writer.Position += 2;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteUInt32,The following statement contains a magic number: writer.Position += 4;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteUInt32,The following statement contains a magic number: writer.Position += 4;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteUInt64,The following statement contains a magic number: writer.Position += 8;
Magic Number,dnlib.DotNet.Writer,NetResources,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NetResources.cs,Add,The following statement contains a magic number: length = NextOffset + 4 + reader.Length;
Magic Number,dnlib.DotNet.Writer,NetResources,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NetResources.cs,SetOffset,The following statement contains a magic number: resource.SetOffset(offset + 4' rva + 4);
Magic Number,dnlib.DotNet.Writer,NetResources,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NetResources.cs,SetOffset,The following statement contains a magic number: resource.SetOffset(offset + 4' rva + 4);
Magic Number,dnlib.DotNet.Writer,NetResources,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NetResources.cs,SetOffset,The following statement contains a magic number: uint len = 4 + resource.GetFileLength();
Magic Number,dnlib.DotNet.Writer,NetResources,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NetResources.cs,WriteTo,The following statement contains a magic number: rva2 += 4 + resourceData.GetFileLength();
Magic Number,dnlib.DotNet.Writer,NormalMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\NormalMetadata.cs,AllocateMemberDefRids,The following statement contains a magic number: const int numNotifyEvents = 5;
Magic Number,dnlib.DotNet.Writer,PdbHeap,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PdbHeap.cs,PdbHeap,The following statement contains a magic number: pdbId = new byte[20];
Magic Number,dnlib.DotNet.Writer,PdbHeap,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PdbHeap.cs,PdbHeap,The following statement contains a magic number: typeSystemTableRows = new uint[64];
Magic Number,dnlib.DotNet.Writer,PdbHeap,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PdbHeap.cs,GetRawLength,The following statement contains a magic number: return (uint)(pdbId.Length + 4 + 8 + 4 * typeSystemTablesCount);
Magic Number,dnlib.DotNet.Writer,PdbHeap,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PdbHeap.cs,GetRawLength,The following statement contains a magic number: return (uint)(pdbId.Length + 4 + 8 + 4 * typeSystemTablesCount);
Magic Number,dnlib.DotNet.Writer,PdbHeap,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PdbHeap.cs,GetRawLength,The following statement contains a magic number: return (uint)(pdbId.Length + 4 + 8 + 4 * typeSystemTablesCount);
Magic Number,dnlib.DotNet.Writer,PEHeaders,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PEHeaders.cs,SetOffset,The following statement contains a magic number: length += 4 + 0x14;
Magic Number,dnlib.DotNet.Writer,PEHeaders,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PEHeaders.cs,WriteTo,The following statement contains a magic number: writer.WriteUInt16(options.MajorOperatingSystemVersion ?? 4);
Magic Number,dnlib.DotNet.Writer,PEHeaders,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PEHeaders.cs,WriteTo,The following statement contains a magic number: writer.WriteUInt16(options.MajorSubsystemVersion ?? 4);
Magic Number,dnlib.DotNet.Writer,PESection,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PESection.cs,WriteHeaderTo,The following statement contains a magic number: writer.WriteBytes(Encoding.UTF8.GetBytes(Name + "\0\0\0\0\0\0\0\0")' 0' 8);
Magic Number,dnlib.DotNet.Writer,PreserveTokensMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PreserveTokensMetadata.cs,AllocateMemberDefRids,The following statement contains a magic number: const int numEvents = 5;
Magic Number,dnlib.DotNet.Writer,PreserveTokensMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PreserveTokensMetadata.cs,AllocateMemberDefRids,The following statement contains a magic number: RaiseProgress(Writer.MetadataEvent.AllocateMemberDefRids' 2.0 / numEvents);
Magic Number,dnlib.DotNet.Writer,PreserveTokensMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PreserveTokensMetadata.cs,AllocateMemberDefRids,The following statement contains a magic number: RaiseProgress(Writer.MetadataEvent.AllocateMemberDefRids' 3.0 / numEvents);
Magic Number,dnlib.DotNet.Writer,PreserveTokensMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\PreserveTokensMetadata.cs,AllocateMemberDefRids,The following statement contains a magic number: RaiseProgress(Writer.MetadataEvent.AllocateMemberDefRids' 4.0 / numEvents);
Magic Number,dnlib.DotNet.Writer,RelocDirectory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\RelocDirectory.cs,SetOffset,The following statement contains a magic number: totalSize += (uint)(8 + ((pageList.Count + 1) & ~1) * 2);
Magic Number,dnlib.DotNet.Writer,RelocDirectory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\RelocDirectory.cs,SetOffset,The following statement contains a magic number: totalSize += (uint)(8 + ((pageList.Count + 1) & ~1) * 2);
Magic Number,dnlib.DotNet.Writer,RelocDirectory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\RelocDirectory.cs,SetOffset,The following statement contains a magic number: totalSize += (uint)(8 + ((pageList.Count + 1) & ~1) * 2);
Magic Number,dnlib.DotNet.Writer,RelocDirectory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\RelocDirectory.cs,SetOffset,The following statement contains a magic number: totalSize += (uint)(8 + ((pageList.Count + 1) & ~1) * 2);
Magic Number,dnlib.DotNet.Writer,RelocDirectory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\RelocDirectory.cs,WriteTo,The following statement contains a magic number: writer.WriteUInt32((uint)(8 + ((pageList.Count + 1) & ~1) * 2));
Magic Number,dnlib.DotNet.Writer,RelocDirectory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\RelocDirectory.cs,WriteTo,The following statement contains a magic number: writer.WriteUInt32((uint)(8 + ((pageList.Count + 1) & ~1) * 2));
Magic Number,dnlib.DotNet.Writer,RoslynContentIdProvider,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\RoslynContentIdProvider.cs,GetContentId,The following statement contains a magic number: hash.Length < 20
Magic Number,dnlib.DotNet.Writer,RoslynContentIdProvider,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\RoslynContentIdProvider.cs,GetContentId,The following statement contains a magic number: var guidBytes = new byte[16];
Magic Number,dnlib.DotNet.Writer,RoslynContentIdProvider,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\RoslynContentIdProvider.cs,GetContentId,The following statement contains a magic number: guidBytes[7] = (byte)((guidBytes[7] & 0x0F) | 0x40);
Magic Number,dnlib.DotNet.Writer,RoslynContentIdProvider,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\RoslynContentIdProvider.cs,GetContentId,The following statement contains a magic number: guidBytes[7] = (byte)((guidBytes[7] & 0x0F) | 0x40);
Magic Number,dnlib.DotNet.Writer,RoslynContentIdProvider,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\RoslynContentIdProvider.cs,GetContentId,The following statement contains a magic number: guidBytes[8] = (byte)((guidBytes[8] & 0x3F) | 0x80);
Magic Number,dnlib.DotNet.Writer,RoslynContentIdProvider,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\RoslynContentIdProvider.cs,GetContentId,The following statement contains a magic number: guidBytes[8] = (byte)((guidBytes[8] & 0x3F) | 0x80);
Magic Number,dnlib.DotNet.Writer,RoslynContentIdProvider,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\RoslynContentIdProvider.cs,GetContentId,The following statement contains a magic number: timestamp = 0x80000000 | (uint)((hash[19] << 24) | (hash[18] << 16) | (hash[17] << 8) | hash[16]);
Magic Number,dnlib.DotNet.Writer,RoslynContentIdProvider,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\RoslynContentIdProvider.cs,GetContentId,The following statement contains a magic number: timestamp = 0x80000000 | (uint)((hash[19] << 24) | (hash[18] << 16) | (hash[17] << 8) | hash[16]);
Magic Number,dnlib.DotNet.Writer,RoslynContentIdProvider,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\RoslynContentIdProvider.cs,GetContentId,The following statement contains a magic number: timestamp = 0x80000000 | (uint)((hash[19] << 24) | (hash[18] << 16) | (hash[17] << 8) | hash[16]);
Magic Number,dnlib.DotNet.Writer,RoslynContentIdProvider,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\RoslynContentIdProvider.cs,GetContentId,The following statement contains a magic number: timestamp = 0x80000000 | (uint)((hash[19] << 24) | (hash[18] << 16) | (hash[17] << 8) | hash[16]);
Magic Number,dnlib.DotNet.Writer,RoslynContentIdProvider,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\RoslynContentIdProvider.cs,GetContentId,The following statement contains a magic number: timestamp = 0x80000000 | (uint)((hash[19] << 24) | (hash[18] << 16) | (hash[17] << 8) | hash[16]);
Magic Number,dnlib.DotNet.Writer,RoslynContentIdProvider,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\RoslynContentIdProvider.cs,GetContentId,The following statement contains a magic number: timestamp = 0x80000000 | (uint)((hash[19] << 24) | (hash[18] << 16) | (hash[17] << 8) | hash[16]);
Magic Number,dnlib.DotNet.Writer,RoslynContentIdProvider,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\RoslynContentIdProvider.cs,GetContentId,The following statement contains a magic number: timestamp = 0x80000000 | (uint)((hash[19] << 24) | (hash[18] << 16) | (hash[17] << 8) | hash[16]);
Magic Number,dnlib.DotNet.Writer,TablesHeap,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\TablesHeap.cs,CalculateLength,The following statement contains a magic number: majorVersion = options.MajorVersion ?? 2;
Magic Number,dnlib.DotNet.Writer,TablesHeap,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\TablesHeap.cs,CalculateLength,The following statement contains a magic number: ((majorVersion << 8) | minorVersion) <= 0x100
Magic Number,dnlib.DotNet.Writer,TablesHeap,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\TablesHeap.cs,CalculateLength,The following statement contains a magic number: length = 24;
Magic Number,dnlib.DotNet.Writer,TablesHeap,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\TablesHeap.cs,CalculateLength,The following statement contains a magic number: length += (uint)(4 + mdt.TableInfo.RowSize * mdt.Rows);
Magic Number,dnlib.DotNet.Writer,TablesHeap,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\TablesHeap.cs,CalculateLength,The following statement contains a magic number: length += 4;
Magic Number,dnlib.DotNet.Writer,USHeap,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\USHeap.cs,Populate,The following statement contains a magic number: int stringLen = (int)len / 2;
Magic Number,dnlib.DotNet.Writer,USHeap,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\USHeap.cs,WriteString,The following statement contains a magic number: writer.WriteCompressedUInt32((uint)s.Length * 2 + 1);
Magic Number,dnlib.DotNet.Writer,USHeap,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\USHeap.cs,WriteString,The following statement contains a magic number: c > 0xFF || (1 <= c && c <= 8) || (0x0E <= c && c <= 0x1F) || c == 0x27 || c == 0x2D || c == 0x7F
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,SetOffset,The following statement contains a magic number: rsrcOffset += 16 + (uint)(dir.Directories.Count + dir.Data.Count) * 8;
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,SetOffset,The following statement contains a magic number: rsrcOffset += 16 + (uint)(dir.Directories.Count + dir.Data.Count) * 8;
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,SetOffset,The following statement contains a magic number: rsrcOffset += 16;
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,SetOffset,The following statement contains a magic number: rsrcOffset += 2 + (uint)(s.Length * 2);
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,SetOffset,The following statement contains a magic number: rsrcOffset += 2 + (uint)(s.Length * 2);
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,WriteTo,The following statement contains a magic number: bytes.Length / 2 > ushort.MaxValue
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,WriteTo,The following statement contains a magic number: writer.WriteUInt16((ushort)(bytes.Length / 2));
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,WriteTo,The following statement contains a magic number: offset += 2 + (uint)bytes.Length;
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,WriteTo,The following statement contains a magic number: return 16 + (uint)(named.Count + ids.Count) * 8;
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,WriteTo,The following statement contains a magic number: return 16 + (uint)(named.Count + ids.Count) * 8;
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,WriteTo,The following statement contains a magic number: return 16;
Magic Number,dnlib.IO,AlignedByteArrayDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedByteArrayDataStream.cs,ReadUInt16,The following statement contains a magic number: return (ushort)(data[i++] | (data[i] << 8));
Magic Number,dnlib.IO,AlignedByteArrayDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedByteArrayDataStream.cs,ReadUInt32,The following statement contains a magic number: return data[i++] | ((uint)data[i++] << 8) | ((uint)data[i++] << 16) | ((uint)data[i] << 24);
Magic Number,dnlib.IO,AlignedByteArrayDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedByteArrayDataStream.cs,ReadUInt32,The following statement contains a magic number: return data[i++] | ((uint)data[i++] << 8) | ((uint)data[i++] << 16) | ((uint)data[i] << 24);
Magic Number,dnlib.IO,AlignedByteArrayDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedByteArrayDataStream.cs,ReadUInt32,The following statement contains a magic number: return data[i++] | ((uint)data[i++] << 8) | ((uint)data[i++] << 16) | ((uint)data[i] << 24);
Magic Number,dnlib.IO,AlignedByteArrayDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedByteArrayDataStream.cs,ReadUInt64,The following statement contains a magic number: return data[i++] | ((ulong)data[i++] << 8) | ((ulong)data[i++] << 16) | ((ulong)data[i++] << 24) |  				((ulong)data[i++] << 32) | ((ulong)data[i++] << 40) | ((ulong)data[i++] << 48) | ((ulong)data[i] << 56);
Magic Number,dnlib.IO,AlignedByteArrayDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedByteArrayDataStream.cs,ReadUInt64,The following statement contains a magic number: return data[i++] | ((ulong)data[i++] << 8) | ((ulong)data[i++] << 16) | ((ulong)data[i++] << 24) |  				((ulong)data[i++] << 32) | ((ulong)data[i++] << 40) | ((ulong)data[i++] << 48) | ((ulong)data[i] << 56);
Magic Number,dnlib.IO,AlignedByteArrayDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedByteArrayDataStream.cs,ReadUInt64,The following statement contains a magic number: return data[i++] | ((ulong)data[i++] << 8) | ((ulong)data[i++] << 16) | ((ulong)data[i++] << 24) |  				((ulong)data[i++] << 32) | ((ulong)data[i++] << 40) | ((ulong)data[i++] << 48) | ((ulong)data[i] << 56);
Magic Number,dnlib.IO,AlignedByteArrayDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedByteArrayDataStream.cs,ReadUInt64,The following statement contains a magic number: return data[i++] | ((ulong)data[i++] << 8) | ((ulong)data[i++] << 16) | ((ulong)data[i++] << 24) |  				((ulong)data[i++] << 32) | ((ulong)data[i++] << 40) | ((ulong)data[i++] << 48) | ((ulong)data[i] << 56);
Magic Number,dnlib.IO,AlignedByteArrayDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedByteArrayDataStream.cs,ReadUInt64,The following statement contains a magic number: return data[i++] | ((ulong)data[i++] << 8) | ((ulong)data[i++] << 16) | ((ulong)data[i++] << 24) |  				((ulong)data[i++] << 32) | ((ulong)data[i++] << 40) | ((ulong)data[i++] << 48) | ((ulong)data[i] << 56);
Magic Number,dnlib.IO,AlignedByteArrayDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedByteArrayDataStream.cs,ReadUInt64,The following statement contains a magic number: return data[i++] | ((ulong)data[i++] << 8) | ((ulong)data[i++] << 16) | ((ulong)data[i++] << 24) |  				((ulong)data[i++] << 32) | ((ulong)data[i++] << 40) | ((ulong)data[i++] << 48) | ((ulong)data[i] << 56);
Magic Number,dnlib.IO,AlignedByteArrayDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedByteArrayDataStream.cs,ReadUInt64,The following statement contains a magic number: return data[i++] | ((ulong)data[i++] << 8) | ((ulong)data[i++] << 16) | ((ulong)data[i++] << 24) |  				((ulong)data[i++] << 32) | ((ulong)data[i++] << 40) | ((ulong)data[i++] << 48) | ((ulong)data[i] << 56);
Magic Number,dnlib.IO,AlignedByteArrayDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedByteArrayDataStream.cs,ReadSingle,The following statement contains a magic number: uint value = data[i++] | ((uint)data[i++] << 8) | ((uint)data[i++] << 16) | ((uint)data[i] << 24);
Magic Number,dnlib.IO,AlignedByteArrayDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedByteArrayDataStream.cs,ReadSingle,The following statement contains a magic number: uint value = data[i++] | ((uint)data[i++] << 8) | ((uint)data[i++] << 16) | ((uint)data[i] << 24);
Magic Number,dnlib.IO,AlignedByteArrayDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedByteArrayDataStream.cs,ReadSingle,The following statement contains a magic number: uint value = data[i++] | ((uint)data[i++] << 8) | ((uint)data[i++] << 16) | ((uint)data[i] << 24);
Magic Number,dnlib.IO,AlignedByteArrayDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedByteArrayDataStream.cs,ReadDouble,The following statement contains a magic number: ulong value = data[i++] | ((ulong)data[i++] << 8) | ((ulong)data[i++] << 16) | ((ulong)data[i++] << 24) |  				((ulong)data[i++] << 32) | ((ulong)data[i++] << 40) | ((ulong)data[i++] << 48) | ((ulong)data[i] << 56);
Magic Number,dnlib.IO,AlignedByteArrayDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedByteArrayDataStream.cs,ReadDouble,The following statement contains a magic number: ulong value = data[i++] | ((ulong)data[i++] << 8) | ((ulong)data[i++] << 16) | ((ulong)data[i++] << 24) |  				((ulong)data[i++] << 32) | ((ulong)data[i++] << 40) | ((ulong)data[i++] << 48) | ((ulong)data[i] << 56);
Magic Number,dnlib.IO,AlignedByteArrayDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedByteArrayDataStream.cs,ReadDouble,The following statement contains a magic number: ulong value = data[i++] | ((ulong)data[i++] << 8) | ((ulong)data[i++] << 16) | ((ulong)data[i++] << 24) |  				((ulong)data[i++] << 32) | ((ulong)data[i++] << 40) | ((ulong)data[i++] << 48) | ((ulong)data[i] << 56);
Magic Number,dnlib.IO,AlignedByteArrayDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedByteArrayDataStream.cs,ReadDouble,The following statement contains a magic number: ulong value = data[i++] | ((ulong)data[i++] << 8) | ((ulong)data[i++] << 16) | ((ulong)data[i++] << 24) |  				((ulong)data[i++] << 32) | ((ulong)data[i++] << 40) | ((ulong)data[i++] << 48) | ((ulong)data[i] << 56);
Magic Number,dnlib.IO,AlignedByteArrayDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedByteArrayDataStream.cs,ReadDouble,The following statement contains a magic number: ulong value = data[i++] | ((ulong)data[i++] << 8) | ((ulong)data[i++] << 16) | ((ulong)data[i++] << 24) |  				((ulong)data[i++] << 32) | ((ulong)data[i++] << 40) | ((ulong)data[i++] << 48) | ((ulong)data[i] << 56);
Magic Number,dnlib.IO,AlignedByteArrayDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedByteArrayDataStream.cs,ReadDouble,The following statement contains a magic number: ulong value = data[i++] | ((ulong)data[i++] << 8) | ((ulong)data[i++] << 16) | ((ulong)data[i++] << 24) |  				((ulong)data[i++] << 32) | ((ulong)data[i++] << 40) | ((ulong)data[i++] << 48) | ((ulong)data[i] << 56);
Magic Number,dnlib.IO,AlignedByteArrayDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedByteArrayDataStream.cs,ReadDouble,The following statement contains a magic number: ulong value = data[i++] | ((ulong)data[i++] << 8) | ((ulong)data[i++] << 16) | ((ulong)data[i++] << 24) |  				((ulong)data[i++] << 32) | ((ulong)data[i++] << 40) | ((ulong)data[i++] << 48) | ((ulong)data[i] << 56);
Magic Number,dnlib.IO,AlignedByteArrayDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedByteArrayDataStream.cs,TryGetOffsetOf,The following statement contains a magic number: uint count = (endOffset - offset) / 4;
Magic Number,dnlib.IO,AlignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedNativeMemoryDataStream.cs,ReadBytes,The following statement contains a magic number: int count = length / 4;
Magic Number,dnlib.IO,AlignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedNativeMemoryDataStream.cs,ReadBytes,The following statement contains a magic number: length = length % 4;
Magic Number,dnlib.IO,AlignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedNativeMemoryDataStream.cs,ReadUInt16,The following statement contains a magic number: return (ushort)(*p++ | (*p << 8));
Magic Number,dnlib.IO,AlignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedNativeMemoryDataStream.cs,ReadUInt32,The following statement contains a magic number: return *p++ | ((uint)*p++ << 8) | ((uint)*p++ << 16) | ((uint)*p << 24);
Magic Number,dnlib.IO,AlignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedNativeMemoryDataStream.cs,ReadUInt32,The following statement contains a magic number: return *p++ | ((uint)*p++ << 8) | ((uint)*p++ << 16) | ((uint)*p << 24);
Magic Number,dnlib.IO,AlignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedNativeMemoryDataStream.cs,ReadUInt32,The following statement contains a magic number: return *p++ | ((uint)*p++ << 8) | ((uint)*p++ << 16) | ((uint)*p << 24);
Magic Number,dnlib.IO,AlignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedNativeMemoryDataStream.cs,ReadUInt64,The following statement contains a magic number: return *p++ | ((ulong)*p++ << 8) | ((ulong)*p++ << 16) | ((ulong)*p++ << 24) |  				((ulong)*p++ << 32) | ((ulong)*p++ << 40) | ((ulong)*p++ << 48) | ((ulong)*p << 56);
Magic Number,dnlib.IO,AlignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedNativeMemoryDataStream.cs,ReadUInt64,The following statement contains a magic number: return *p++ | ((ulong)*p++ << 8) | ((ulong)*p++ << 16) | ((ulong)*p++ << 24) |  				((ulong)*p++ << 32) | ((ulong)*p++ << 40) | ((ulong)*p++ << 48) | ((ulong)*p << 56);
Magic Number,dnlib.IO,AlignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedNativeMemoryDataStream.cs,ReadUInt64,The following statement contains a magic number: return *p++ | ((ulong)*p++ << 8) | ((ulong)*p++ << 16) | ((ulong)*p++ << 24) |  				((ulong)*p++ << 32) | ((ulong)*p++ << 40) | ((ulong)*p++ << 48) | ((ulong)*p << 56);
Magic Number,dnlib.IO,AlignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedNativeMemoryDataStream.cs,ReadUInt64,The following statement contains a magic number: return *p++ | ((ulong)*p++ << 8) | ((ulong)*p++ << 16) | ((ulong)*p++ << 24) |  				((ulong)*p++ << 32) | ((ulong)*p++ << 40) | ((ulong)*p++ << 48) | ((ulong)*p << 56);
Magic Number,dnlib.IO,AlignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedNativeMemoryDataStream.cs,ReadUInt64,The following statement contains a magic number: return *p++ | ((ulong)*p++ << 8) | ((ulong)*p++ << 16) | ((ulong)*p++ << 24) |  				((ulong)*p++ << 32) | ((ulong)*p++ << 40) | ((ulong)*p++ << 48) | ((ulong)*p << 56);
Magic Number,dnlib.IO,AlignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedNativeMemoryDataStream.cs,ReadUInt64,The following statement contains a magic number: return *p++ | ((ulong)*p++ << 8) | ((ulong)*p++ << 16) | ((ulong)*p++ << 24) |  				((ulong)*p++ << 32) | ((ulong)*p++ << 40) | ((ulong)*p++ << 48) | ((ulong)*p << 56);
Magic Number,dnlib.IO,AlignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedNativeMemoryDataStream.cs,ReadUInt64,The following statement contains a magic number: return *p++ | ((ulong)*p++ << 8) | ((ulong)*p++ << 16) | ((ulong)*p++ << 24) |  				((ulong)*p++ << 32) | ((ulong)*p++ << 40) | ((ulong)*p++ << 48) | ((ulong)*p << 56);
Magic Number,dnlib.IO,AlignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedNativeMemoryDataStream.cs,ReadSingle,The following statement contains a magic number: uint value = *p++ | ((uint)*p++ << 8) | ((uint)*p++ << 16) | ((uint)*p << 24);
Magic Number,dnlib.IO,AlignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedNativeMemoryDataStream.cs,ReadSingle,The following statement contains a magic number: uint value = *p++ | ((uint)*p++ << 8) | ((uint)*p++ << 16) | ((uint)*p << 24);
Magic Number,dnlib.IO,AlignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedNativeMemoryDataStream.cs,ReadSingle,The following statement contains a magic number: uint value = *p++ | ((uint)*p++ << 8) | ((uint)*p++ << 16) | ((uint)*p << 24);
Magic Number,dnlib.IO,AlignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedNativeMemoryDataStream.cs,ReadDouble,The following statement contains a magic number: ulong value = *p++ | ((ulong)*p++ << 8) | ((ulong)*p++ << 16) | ((ulong)*p++ << 24) |  				((ulong)*p++ << 32) | ((ulong)*p++ << 40) | ((ulong)*p++ << 48) | ((ulong)*p << 56);
Magic Number,dnlib.IO,AlignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedNativeMemoryDataStream.cs,ReadDouble,The following statement contains a magic number: ulong value = *p++ | ((ulong)*p++ << 8) | ((ulong)*p++ << 16) | ((ulong)*p++ << 24) |  				((ulong)*p++ << 32) | ((ulong)*p++ << 40) | ((ulong)*p++ << 48) | ((ulong)*p << 56);
Magic Number,dnlib.IO,AlignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedNativeMemoryDataStream.cs,ReadDouble,The following statement contains a magic number: ulong value = *p++ | ((ulong)*p++ << 8) | ((ulong)*p++ << 16) | ((ulong)*p++ << 24) |  				((ulong)*p++ << 32) | ((ulong)*p++ << 40) | ((ulong)*p++ << 48) | ((ulong)*p << 56);
Magic Number,dnlib.IO,AlignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedNativeMemoryDataStream.cs,ReadDouble,The following statement contains a magic number: ulong value = *p++ | ((ulong)*p++ << 8) | ((ulong)*p++ << 16) | ((ulong)*p++ << 24) |  				((ulong)*p++ << 32) | ((ulong)*p++ << 40) | ((ulong)*p++ << 48) | ((ulong)*p << 56);
Magic Number,dnlib.IO,AlignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedNativeMemoryDataStream.cs,ReadDouble,The following statement contains a magic number: ulong value = *p++ | ((ulong)*p++ << 8) | ((ulong)*p++ << 16) | ((ulong)*p++ << 24) |  				((ulong)*p++ << 32) | ((ulong)*p++ << 40) | ((ulong)*p++ << 48) | ((ulong)*p << 56);
Magic Number,dnlib.IO,AlignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedNativeMemoryDataStream.cs,ReadDouble,The following statement contains a magic number: ulong value = *p++ | ((ulong)*p++ << 8) | ((ulong)*p++ << 16) | ((ulong)*p++ << 24) |  				((ulong)*p++ << 32) | ((ulong)*p++ << 40) | ((ulong)*p++ << 48) | ((ulong)*p << 56);
Magic Number,dnlib.IO,AlignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedNativeMemoryDataStream.cs,ReadDouble,The following statement contains a magic number: ulong value = *p++ | ((ulong)*p++ << 8) | ((ulong)*p++ << 16) | ((ulong)*p++ << 24) |  				((ulong)*p++ << 32) | ((ulong)*p++ << 40) | ((ulong)*p++ << 48) | ((ulong)*p << 56);
Magic Number,dnlib.IO,AlignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\AlignedNativeMemoryDataStream.cs,TryGetOffsetOf,The following statement contains a magic number: uint count = (endOffset - offset) / 4;
Magic Number,dnlib.IO,DataReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\DataReader.cs,ReadUInt16,The following statement contains a magic number: const uint SIZE = 2;
Magic Number,dnlib.IO,DataReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\DataReader.cs,ReadUInt32,The following statement contains a magic number: const uint SIZE = 4;
Magic Number,dnlib.IO,DataReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\DataReader.cs,Unsafe_ReadUInt16,The following statement contains a magic number: const uint SIZE = 2;
Magic Number,dnlib.IO,DataReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\DataReader.cs,Unsafe_ReadUInt32,The following statement contains a magic number: const uint SIZE = 4;
Magic Number,dnlib.IO,DataReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\DataReader.cs,ReadUInt64,The following statement contains a magic number: const uint SIZE = 8;
Magic Number,dnlib.IO,DataReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\DataReader.cs,ReadSingle,The following statement contains a magic number: const uint SIZE = 4;
Magic Number,dnlib.IO,DataReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\DataReader.cs,ReadDouble,The following statement contains a magic number: const uint SIZE = 8;
Magic Number,dnlib.IO,DataReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\DataReader.cs,ReadGuid,The following statement contains a magic number: const uint SIZE = 16;
Magic Number,dnlib.IO,DataReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\DataReader.cs,ReadDecimal,The following statement contains a magic number: var bits = new int[4] {  				ReadInt32()'	// lo  				ReadInt32()'	// mid  				ReadInt32()'	// hi  				ReadInt32()'	// flags  			};
Magic Number,dnlib.IO,DataReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\DataReader.cs,ReadUtf16String,The following statement contains a magic number: uint length = (uint)chars * 2;
Magic Number,dnlib.IO,DataReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\DataReader.cs,TryReadCompressedUInt32,The following statement contains a magic number: bytesLeft < 2
Magic Number,dnlib.IO,DataReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\DataReader.cs,TryReadCompressedUInt32,The following statement contains a magic number: value = (uint)(((b & 0x3F) << 8) | stream.ReadByte(currentOffset++));
Magic Number,dnlib.IO,DataReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\DataReader.cs,TryReadCompressedUInt32,The following statement contains a magic number: bytesLeft < 4
Magic Number,dnlib.IO,DataReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\DataReader.cs,TryReadCompressedUInt32,The following statement contains a magic number: value = (uint)(((b & 0x1F) << 24) | (stream.ReadByte(currentOffset++) << 16) |  					(stream.ReadByte(currentOffset++) << 8) | stream.ReadByte(currentOffset++));
Magic Number,dnlib.IO,DataReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\DataReader.cs,TryReadCompressedUInt32,The following statement contains a magic number: value = (uint)(((b & 0x1F) << 24) | (stream.ReadByte(currentOffset++) << 16) |  					(stream.ReadByte(currentOffset++) << 8) | stream.ReadByte(currentOffset++));
Magic Number,dnlib.IO,DataReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\DataReader.cs,TryReadCompressedUInt32,The following statement contains a magic number: value = (uint)(((b & 0x1F) << 24) | (stream.ReadByte(currentOffset++) << 16) |  					(stream.ReadByte(currentOffset++) << 8) | stream.ReadByte(currentOffset++));
Magic Number,dnlib.IO,DataReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\DataReader.cs,TryReadCompressedInt32,The following statement contains a magic number: bytesLeft < 2
Magic Number,dnlib.IO,DataReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\DataReader.cs,TryReadCompressedInt32,The following statement contains a magic number: uint tmp = (uint)(((b & 0x3F) << 8) | stream.ReadByte(currentOffset++));
Magic Number,dnlib.IO,DataReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\DataReader.cs,TryReadCompressedInt32,The following statement contains a magic number: bytesLeft < 4
Magic Number,dnlib.IO,DataReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\DataReader.cs,TryReadCompressedInt32,The following statement contains a magic number: uint tmp = (uint)(((b & 0x1F) << 24) | (stream.ReadByte(currentOffset++) << 16) |  						(stream.ReadByte(currentOffset++) << 8) | stream.ReadByte(currentOffset++));
Magic Number,dnlib.IO,DataReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\DataReader.cs,TryReadCompressedInt32,The following statement contains a magic number: uint tmp = (uint)(((b & 0x1F) << 24) | (stream.ReadByte(currentOffset++) << 16) |  						(stream.ReadByte(currentOffset++) << 8) | stream.ReadByte(currentOffset++));
Magic Number,dnlib.IO,DataReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\DataReader.cs,TryReadCompressedInt32,The following statement contains a magic number: uint tmp = (uint)(((b & 0x1F) << 24) | (stream.ReadByte(currentOffset++) << 16) |  						(stream.ReadByte(currentOffset++) << 8) | stream.ReadByte(currentOffset++));
Magic Number,dnlib.IO,DataReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\DataReader.cs,Read7BitEncodedUInt32,The following statement contains a magic number: bits += 7;
Magic Number,dnlib.IO,DataReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\DataReader.cs,Read7BitEncodedUInt32,The following statement contains a magic number: i < 5
Magic Number,dnlib.IO,DataReaderFactoryFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\DataReaderFactoryFactory.cs,DataReaderFactoryFactory,The following statement contains a magic number: p == 4 || p == 6 || p == 128
Magic Number,dnlib.IO,DataReaderFactoryFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\DataReaderFactoryFactory.cs,DataReaderFactoryFactory,The following statement contains a magic number: p == 4 || p == 6 || p == 128
Magic Number,dnlib.IO,DataReaderFactoryFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\DataReaderFactoryFactory.cs,DataReaderFactoryFactory,The following statement contains a magic number: p == 4 || p == 6 || p == 128
Magic Number,dnlib.IO,Windows,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\MemoryMappedDataReaderFactory.cs,Mmap,The following statement contains a magic number: var fileSize = ((long)sizeHi << 32) | sizeLo;
Magic Number,dnlib.IO,Unix,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\MemoryMappedDataReaderFactory.cs,Mmap,The following statement contains a magic number: IntPtr.Size == 4
Magic Number,dnlib.IO,UnalignedByteArrayDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\UnalignedByteArrayDataStream.cs,ReadUInt16,The following statement contains a magic number: return (ushort)(data[i++] | (data[i] << 8));
Magic Number,dnlib.IO,UnalignedByteArrayDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\UnalignedByteArrayDataStream.cs,TryGetOffsetOf,The following statement contains a magic number: uint count = (endOffset - offset) / 4;
Magic Number,dnlib.IO,UnalignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\UnalignedNativeMemoryDataStream.cs,ReadBytes,The following statement contains a magic number: int count = length / 4;
Magic Number,dnlib.IO,UnalignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\UnalignedNativeMemoryDataStream.cs,ReadBytes,The following statement contains a magic number: length = length % 4;
Magic Number,dnlib.IO,UnalignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\UnalignedNativeMemoryDataStream.cs,ReadBytes,The following statement contains a magic number: pd += 4;
Magic Number,dnlib.IO,UnalignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\UnalignedNativeMemoryDataStream.cs,ReadBytes,The following statement contains a magic number: ps += 4;
Magic Number,dnlib.IO,UnalignedNativeMemoryDataStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\UnalignedNativeMemoryDataStream.cs,TryGetOffsetOf,The following statement contains a magic number: uint count = (endOffset - offset) / 4;
Magic Number,dnlib.PE,ImageNTHeaders,D:\research\architectureSmells\repos\0xd4d_dnlib\src\PE\ImageNTHeaders.cs,CreateImageOptionalHeader,The following statement contains a magic number: reader.Position -= 2;
Magic Number,dnlib.PE,ImageOptionalHeader32,D:\research\architectureSmells\repos\0xd4d_dnlib\src\PE\ImageOptionalHeader32.cs,ImageOptionalHeader32,The following statement contains a magic number: len + 8 <= totalSize
Magic Number,dnlib.PE,ImageOptionalHeader64,D:\research\architectureSmells\repos\0xd4d_dnlib\src\PE\ImageOptionalHeader64.cs,ImageOptionalHeader64,The following statement contains a magic number: len + 8 <= totalSize
Magic Number,dnlib.PE,ImageSectionHeader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\PE\ImageSectionHeader.cs,ImageSectionHeader,The following statement contains a magic number: name = reader.ReadBytes(8);
Magic Number,dnlib.PE,PEExtensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\PE\IPEImage.cs,CalculatePECheckSum,The following statement contains a magic number: const int ChecksumFieldSize = 4;
Magic Number,dnlib.PE,PEExtensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\PE\IPEImage.cs,CalculatePECheckSum,The following statement contains a magic number: return (uint)cks + (uint)(cks >> 32);
Magic Number,dnlib.PE,PEExtensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\PE\IPEImage.cs,CalculatePECheckSum,The following statement contains a magic number: checkSum += buffer[i++] | ((uint)buffer[i++] << 8);
Magic Number,dnlib.PE,PEExtensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\PE\IPEImage.cs,CalculatePECheckSum,The following statement contains a magic number: checkSum = (ushort)(checkSum + (checkSum >> 16));
Magic Number,dnlib.PE,PEImage,D:\research\architectureSmells\repos\0xd4d_dnlib\src\PE\PEImage.cs,Initialize,The following statement contains a magic number: win32Resources.ReadOriginalValue = () => {  				var dataDir = peInfo.ImageNTHeaders.OptionalHeader.DataDirectories[2];  				if (dataDir.VirtualAddress == 0 || dataDir.Size == 0)  					return null;  				return new Win32ResourcesPE(this);  			};
Magic Number,dnlib.PE,PEImage,D:\research\architectureSmells\repos\0xd4d_dnlib\src\PE\PEImage.cs,ReadImageDebugDirectories,The following statement contains a magic number: var dataDir = ImageNTHeaders.OptionalHeader.DataDirectories[6];
Magic Number,dnlib.PE,ProcessorArchUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\PE\ProcessorArchUtils.cs,GetProcessCpuArchitectureCore,The following statement contains a magic number: return IntPtr.Size == 4 ? Machine.I386 : Machine.AMD64;
Magic Number,dnlib.PE,RuntimeInformationUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\PE\ProcessorArchUtils.cs,TryGetArchitecture,The following statement contains a magic number: switch (architecture) {  				case 0: // Architecture.X86  					Debug.Assert(IntPtr.Size == 4);  					machine = Machine.I386;  					return true;    				case 1: // Architecture.X64  					Debug.Assert(IntPtr.Size == 8);  					machine = Machine.AMD64;  					return true;    				case 2: // Architecture.Arm  					Debug.Assert(IntPtr.Size == 4);  					machine = Machine.ARMNT;  					return true;    				case 3: // Architecture.Arm64  					Debug.Assert(IntPtr.Size == 8);  					machine = Machine.ARM64;  					return true;    				default:  					Debug.Fail($"Unknown process architecture: {architecture}");  					machine = 0;  					return false;  				}
Magic Number,dnlib.PE,RuntimeInformationUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\PE\ProcessorArchUtils.cs,TryGetArchitecture,The following statement contains a magic number: switch (architecture) {  				case 0: // Architecture.X86  					Debug.Assert(IntPtr.Size == 4);  					machine = Machine.I386;  					return true;    				case 1: // Architecture.X64  					Debug.Assert(IntPtr.Size == 8);  					machine = Machine.AMD64;  					return true;    				case 2: // Architecture.Arm  					Debug.Assert(IntPtr.Size == 4);  					machine = Machine.ARMNT;  					return true;    				case 3: // Architecture.Arm64  					Debug.Assert(IntPtr.Size == 8);  					machine = Machine.ARM64;  					return true;    				default:  					Debug.Fail($"Unknown process architecture: {architecture}");  					machine = 0;  					return false;  				}
Magic Number,dnlib.PE,RuntimeInformationUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\PE\ProcessorArchUtils.cs,TryGetArchitecture,The following statement contains a magic number: switch (architecture) {  				case 0: // Architecture.X86  					Debug.Assert(IntPtr.Size == 4);  					machine = Machine.I386;  					return true;    				case 1: // Architecture.X64  					Debug.Assert(IntPtr.Size == 8);  					machine = Machine.AMD64;  					return true;    				case 2: // Architecture.Arm  					Debug.Assert(IntPtr.Size == 4);  					machine = Machine.ARMNT;  					return true;    				case 3: // Architecture.Arm64  					Debug.Assert(IntPtr.Size == 8);  					machine = Machine.ARM64;  					return true;    				default:  					Debug.Fail($"Unknown process architecture: {architecture}");  					machine = 0;  					return false;  				}
Magic Number,dnlib.PE,RuntimeInformationUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\PE\ProcessorArchUtils.cs,TryGetArchitecture,The following statement contains a magic number: switch (architecture) {  				case 0: // Architecture.X86  					Debug.Assert(IntPtr.Size == 4);  					machine = Machine.I386;  					return true;    				case 1: // Architecture.X64  					Debug.Assert(IntPtr.Size == 8);  					machine = Machine.AMD64;  					return true;    				case 2: // Architecture.Arm  					Debug.Assert(IntPtr.Size == 4);  					machine = Machine.ARMNT;  					return true;    				case 3: // Architecture.Arm64  					Debug.Assert(IntPtr.Size == 8);  					machine = Machine.ARM64;  					return true;    				default:  					Debug.Fail($"Unknown process architecture: {architecture}");  					machine = 0;  					return false;  				}
Magic Number,dnlib.PE,RuntimeInformationUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\PE\ProcessorArchUtils.cs,TryGetArchitecture,The following statement contains a magic number: switch (architecture) {  				case 0: // Architecture.X86  					Debug.Assert(IntPtr.Size == 4);  					machine = Machine.I386;  					return true;    				case 1: // Architecture.X64  					Debug.Assert(IntPtr.Size == 8);  					machine = Machine.AMD64;  					return true;    				case 2: // Architecture.Arm  					Debug.Assert(IntPtr.Size == 4);  					machine = Machine.ARMNT;  					return true;    				case 3: // Architecture.Arm64  					Debug.Assert(IntPtr.Size == 8);  					machine = Machine.ARM64;  					return true;    				default:  					Debug.Fail($"Unknown process architecture: {architecture}");  					machine = 0;  					return false;  				}
Magic Number,dnlib.PE,RuntimeInformationUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\PE\ProcessorArchUtils.cs,TryGetArchitecture,The following statement contains a magic number: switch (architecture) {  				case 0: // Architecture.X86  					Debug.Assert(IntPtr.Size == 4);  					machine = Machine.I386;  					return true;    				case 1: // Architecture.X64  					Debug.Assert(IntPtr.Size == 8);  					machine = Machine.AMD64;  					return true;    				case 2: // Architecture.Arm  					Debug.Assert(IntPtr.Size == 4);  					machine = Machine.ARMNT;  					return true;    				case 3: // Architecture.Arm64  					Debug.Assert(IntPtr.Size == 8);  					machine = Machine.ARM64;  					return true;    				default:  					Debug.Fail($"Unknown process architecture: {architecture}");  					machine = 0;  					return false;  				}
Magic Number,dnlib.PE,WindowsUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\PE\ProcessorArchUtils.cs,TryGetProcessCpuArchitecture,The following statement contains a magic number: switch ((ProcessorArchitecture)sysInfo.wProcessorArchitecture) {  						case ProcessorArchitecture.INTEL:  							Debug.Assert(IntPtr.Size == 4);  							machine = Machine.I386;  							return true;    						case ProcessorArchitecture.ARM:  							Debug.Assert(IntPtr.Size == 4);  							machine = Machine.ARMNT;  							return true;    						case ProcessorArchitecture.IA64:  							Debug.Assert(IntPtr.Size == 8);  							machine = Machine.IA64;  							return true;    						case ProcessorArchitecture.AMD64:  							Debug.Assert(IntPtr.Size == 8);  							machine = Machine.AMD64;  							return true;    						case ProcessorArchitecture.ARM64:  							Debug.Assert(IntPtr.Size == 8);  							machine = Machine.ARM64;  							return true;    						case ProcessorArchitecture.UNKNOWN:  						default:  							break;  						}
Magic Number,dnlib.PE,WindowsUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\PE\ProcessorArchUtils.cs,TryGetProcessCpuArchitecture,The following statement contains a magic number: switch ((ProcessorArchitecture)sysInfo.wProcessorArchitecture) {  						case ProcessorArchitecture.INTEL:  							Debug.Assert(IntPtr.Size == 4);  							machine = Machine.I386;  							return true;    						case ProcessorArchitecture.ARM:  							Debug.Assert(IntPtr.Size == 4);  							machine = Machine.ARMNT;  							return true;    						case ProcessorArchitecture.IA64:  							Debug.Assert(IntPtr.Size == 8);  							machine = Machine.IA64;  							return true;    						case ProcessorArchitecture.AMD64:  							Debug.Assert(IntPtr.Size == 8);  							machine = Machine.AMD64;  							return true;    						case ProcessorArchitecture.ARM64:  							Debug.Assert(IntPtr.Size == 8);  							machine = Machine.ARM64;  							return true;    						case ProcessorArchitecture.UNKNOWN:  						default:  							break;  						}
Magic Number,dnlib.PE,WindowsUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\PE\ProcessorArchUtils.cs,TryGetProcessCpuArchitecture,The following statement contains a magic number: switch ((ProcessorArchitecture)sysInfo.wProcessorArchitecture) {  						case ProcessorArchitecture.INTEL:  							Debug.Assert(IntPtr.Size == 4);  							machine = Machine.I386;  							return true;    						case ProcessorArchitecture.ARM:  							Debug.Assert(IntPtr.Size == 4);  							machine = Machine.ARMNT;  							return true;    						case ProcessorArchitecture.IA64:  							Debug.Assert(IntPtr.Size == 8);  							machine = Machine.IA64;  							return true;    						case ProcessorArchitecture.AMD64:  							Debug.Assert(IntPtr.Size == 8);  							machine = Machine.AMD64;  							return true;    						case ProcessorArchitecture.ARM64:  							Debug.Assert(IntPtr.Size == 8);  							machine = Machine.ARM64;  							return true;    						case ProcessorArchitecture.UNKNOWN:  						default:  							break;  						}
Magic Number,dnlib.PE,WindowsUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\PE\ProcessorArchUtils.cs,TryGetProcessCpuArchitecture,The following statement contains a magic number: switch ((ProcessorArchitecture)sysInfo.wProcessorArchitecture) {  						case ProcessorArchitecture.INTEL:  							Debug.Assert(IntPtr.Size == 4);  							machine = Machine.I386;  							return true;    						case ProcessorArchitecture.ARM:  							Debug.Assert(IntPtr.Size == 4);  							machine = Machine.ARMNT;  							return true;    						case ProcessorArchitecture.IA64:  							Debug.Assert(IntPtr.Size == 8);  							machine = Machine.IA64;  							return true;    						case ProcessorArchitecture.AMD64:  							Debug.Assert(IntPtr.Size == 8);  							machine = Machine.AMD64;  							return true;    						case ProcessorArchitecture.ARM64:  							Debug.Assert(IntPtr.Size == 8);  							machine = Machine.ARM64;  							return true;    						case ProcessorArchitecture.UNKNOWN:  						default:  							break;  						}
Magic Number,dnlib.PE,WindowsUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\PE\ProcessorArchUtils.cs,TryGetProcessCpuArchitecture,The following statement contains a magic number: switch ((ProcessorArchitecture)sysInfo.wProcessorArchitecture) {  						case ProcessorArchitecture.INTEL:  							Debug.Assert(IntPtr.Size == 4);  							machine = Machine.I386;  							return true;    						case ProcessorArchitecture.ARM:  							Debug.Assert(IntPtr.Size == 4);  							machine = Machine.ARMNT;  							return true;    						case ProcessorArchitecture.IA64:  							Debug.Assert(IntPtr.Size == 8);  							machine = Machine.IA64;  							return true;    						case ProcessorArchitecture.AMD64:  							Debug.Assert(IntPtr.Size == 8);  							machine = Machine.AMD64;  							return true;    						case ProcessorArchitecture.ARM64:  							Debug.Assert(IntPtr.Size == 8);  							machine = Machine.ARM64;  							return true;    						case ProcessorArchitecture.UNKNOWN:  						default:  							break;  						}
Magic Number,dnlib.W32Resources,ResourceDirectoryPE,D:\research\architectureSmells\repos\0xd4d_dnlib\src\W32Resources\ResourceDirectory.cs,Initialize,The following statement contains a magic number: depth > MAX_DIR_DEPTH || !reader.CanRead(16U)
Magic Number,dnlib.W32Resources,ResourceDirectoryPE,D:\research\architectureSmells\repos\0xd4d_dnlib\src\W32Resources\ResourceDirectory.cs,Initialize,The following statement contains a magic number: !reader.CanRead((uint)total * 8)
Magic Number,dnlib.W32Resources,ResourceDirectoryPE,D:\research\architectureSmells\repos\0xd4d_dnlib\src\W32Resources\ResourceDirectory.cs,ReadString,The following statement contains a magic number: !reader.CanRead(2U)
Magic Number,dnlib.W32Resources,ResourceDirectoryPE,D:\research\architectureSmells\repos\0xd4d_dnlib\src\W32Resources\ResourceDirectory.cs,ReadString,The following statement contains a magic number: int sizeInBytes = size * 2;
Magic Number,dnlib.W32Resources,ResourceDirectoryPE,D:\research\architectureSmells\repos\0xd4d_dnlib\src\W32Resources\ResourceDirectory.cs,ReadString,The following statement contains a magic number: return reader.ReadUtf16String(sizeInBytes / 2);
Magic Number,dnlib.W32Resources,ResourceDirectoryPE,D:\research\architectureSmells\repos\0xd4d_dnlib\src\W32Resources\ResourceDirectory.cs,ReadResourceData,The following statement contains a magic number: reader.CanRead(16U)
Missing Default,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\AssemblyHashAlgorithm.cs,GetCorLibTypeSig,The following switch statement is missing a default case: switch (name) {  			case "Void":	return self.Void;  			case "Boolean":	return self.Boolean;  			case "Char":	return self.Char;  			case "SByte":	return self.SByte;  			case "Byte":	return self.Byte;  			case "Int16":	return self.Int16;  			case "UInt16":	return self.UInt16;  			case "Int32":	return self.Int32;  			case "UInt32":	return self.UInt32;  			case "Int64":	return self.Int64;  			case "UInt64":	return self.UInt64;  			case "Single":	return self.Single;  			case "Double":	return self.Double;  			case "String":	return self.String;  			case "TypedReference": return self.TypedReference;  			case "IntPtr":	return self.IntPtr;  			case "UIntPtr":	return self.UIntPtr;  			case "Object":	return self.Object;  			}
Missing Default,dnlib.DotNet,FullNameFactory,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\FullNameFactory.cs,AddIdentifier,The following switch statement is missing a default case: switch (c) {  					case ''':  					case '+':  					case '&':  					case '*':  					case '[':  					case ']':  					case '\\':  						sb.Append('\\');  						break;  					}
Missing Default,dnlib.DotNet,MemberFinder,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MemberFinder.cs,Add,The following switch statement is missing a default case: switch (instr.OpCode.OperandType) {  				case OperandType.InlineTok:  				case OperandType.InlineType:  				case OperandType.InlineMethod:  				case OperandType.InlineField:  					Push(instr.Operand);  					break;    				case OperandType.InlineSig:  					Add(instr.Operand as CallingConventionSig);  					break;    				case OperandType.InlineVar:  				case OperandType.ShortInlineVar:  					var local = instr.Operand as Local;  					if (!(local is null)) {  						Add(local);  						break;  					}  					var arg = instr.Operand as Parameter;  					if (!(arg is null)) {  						Add(arg);  						break;  					}  					break;  				}
Missing Default,dnlib.DotNet,MemberFinder,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MemberFinder.cs,Add,The following switch statement is missing a default case: switch (mt.NativeType) {  			case NativeType.SafeArray:  				Add(((SafeArrayMarshalType)mt).UserDefinedSubType);  				break;    			case NativeType.CustomMarshaler:  				Add(((CustomMarshalType)mt).CustomMarshaler);  				break;  			}
Missing Default,dnlib.DotNet,ModuleDef,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDef.cs,GetPointerSize,The following switch statement is missing a default case: switch (flags & (ComImageFlags.Bit32Required | ComImageFlags.Bit32Preferred)) {  			case 0:  				// Machine and ILOnly flag should be checked  				break;    			case ComImageFlags.Bit32Preferred:  				// Illegal  				break;    			case ComImageFlags.Bit32Required:  				// x86 image (32-bit process)  				return 4;    			case ComImageFlags.Bit32Required | ComImageFlags.Bit32Preferred:  				// Platform neutral but prefers to be 32-bit  				return prefer32bitPointerSize;  			}
Missing Default,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,ResolveToken,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.Module:			return ResolveModule(rid);  			case Table.TypeRef:			return ResolveTypeRef(rid);  			case Table.TypeDef:			return ResolveTypeDef(rid);  			case Table.Field:			return ResolveField(rid);  			case Table.Method:			return ResolveMethod(rid);  			case Table.Param:			return ResolveParam(rid);  			case Table.InterfaceImpl:	return ResolveInterfaceImpl(rid' gpContext);  			case Table.MemberRef:		return ResolveMemberRef(rid' gpContext);  			case Table.Constant:		return ResolveConstant(rid);  			case Table.DeclSecurity:	return ResolveDeclSecurity(rid);  			case Table.ClassLayout:		return ResolveClassLayout(rid);  			case Table.StandAloneSig:	return ResolveStandAloneSig(rid' gpContext);  			case Table.Event:			return ResolveEvent(rid);  			case Table.Property:		return ResolveProperty(rid);  			case Table.ModuleRef:		return ResolveModuleRef(rid);  			case Table.TypeSpec:		return ResolveTypeSpec(rid' gpContext);  			case Table.ImplMap:			return ResolveImplMap(rid);  			case Table.Assembly:		return ResolveAssembly(rid);  			case Table.AssemblyRef:		return ResolveAssemblyRef(rid);  			case Table.File:			return ResolveFile(rid);  			case Table.ExportedType:	return ResolveExportedType(rid);  			case Table.ManifestResource:return ResolveManifestResource(rid);  			case Table.GenericParam:	return ResolveGenericParam(rid);  			case Table.MethodSpec:		return ResolveMethodSpec(rid' gpContext);  			case Table.GenericParamConstraint: return ResolveGenericParamConstraint(rid' gpContext);  			}
Missing Default,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,ResolveTypeDefOrRef,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.TypeDef:		return ResolveTypeDef(rid);  			case Table.TypeRef:		return ResolveTypeRef(rid);  			case Table.TypeSpec:	return ResolveTypeSpec(rid' gpContext);  			}
Missing Default,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,ResolveHasConstant,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.Field:	return ResolveField(rid);  			case Table.Param:	return ResolveParam(rid);  			case Table.Property:return ResolveProperty(rid);  			}
Missing Default,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,ResolveHasCustomAttribute,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.Method:		return ResolveMethod(rid);  			case Table.Field:		return ResolveField(rid);  			case Table.TypeRef:		return ResolveTypeRef(rid);  			case Table.TypeDef:		return ResolveTypeDef(rid);  			case Table.Param:		return ResolveParam(rid);  			case Table.InterfaceImpl: return ResolveInterfaceImpl(rid' gpContext);  			case Table.MemberRef:	return ResolveMemberRef(rid' gpContext);  			case Table.Module:		return ResolveModule(rid);  			case Table.DeclSecurity:return ResolveDeclSecurity(rid);  			case Table.Property:	return ResolveProperty(rid);  			case Table.Event:		return ResolveEvent(rid);  			case Table.StandAloneSig: return ResolveStandAloneSig(rid' gpContext);  			case Table.ModuleRef:	return ResolveModuleRef(rid);  			case Table.TypeSpec:	return ResolveTypeSpec(rid' gpContext);  			case Table.Assembly:	return ResolveAssembly(rid);  			case Table.AssemblyRef:	return ResolveAssemblyRef(rid);  			case Table.File:		return ResolveFile(rid);  			case Table.ExportedType:return ResolveExportedType(rid);  			case Table.ManifestResource: return ResolveManifestResource(rid);  			case Table.GenericParam:return ResolveGenericParam(rid);  			case Table.MethodSpec:	return ResolveMethodSpec(rid' gpContext);  			case Table.GenericParamConstraint: return ResolveGenericParamConstraint(rid' gpContext);  			}
Missing Default,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,ResolveHasFieldMarshal,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.Field:	return ResolveField(rid);  			case Table.Param:	return ResolveParam(rid);  			}
Missing Default,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,ResolveHasDeclSecurity,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.TypeDef:		return ResolveTypeDef(rid);  			case Table.Method:		return ResolveMethod(rid);  			case Table.Assembly:	return ResolveAssembly(rid);  			}
Missing Default,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,ResolveMemberRefParent,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.TypeDef:		return ResolveTypeDef(rid);  			case Table.TypeRef:		return ResolveTypeRef(rid);  			case Table.ModuleRef:	return ResolveModuleRef(rid);  			case Table.Method:		return ResolveMethod(rid);  			case Table.TypeSpec:	return ResolveTypeSpec(rid' gpContext);  			}
Missing Default,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,ResolveHasSemantic,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.Event:		return ResolveEvent(rid);  			case Table.Property:	return ResolveProperty(rid);  			}
Missing Default,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,ResolveMethodDefOrRef,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.Method:		return ResolveMethod(rid);  			case Table.MemberRef:	return ResolveMemberRef(rid' gpContext);  			}
Missing Default,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,ResolveMemberForwarded,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.Field:	return ResolveField(rid);  			case Table.Method:	return ResolveMethod(rid);  			}
Missing Default,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,ResolveImplementation,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.File:			return ResolveFile(rid);  			case Table.AssemblyRef:		return ResolveAssemblyRef(rid);  			case Table.ExportedType:	return ResolveExportedType(rid);  			}
Missing Default,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,ResolveCustomAttributeType,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.Method:		return ResolveMethod(rid);  			case Table.MemberRef:	return ResolveMemberRef(rid' gpContext);  			}
Missing Default,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,ResolveResolutionScope,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.Module:		return ResolveModule(rid);  			case Table.ModuleRef:	return ResolveModuleRef(rid);  			case Table.AssemblyRef:	return ResolveAssemblyRef(rid);  			case Table.TypeRef:		return ResolveTypeRef(rid);  			}
Missing Default,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,ResolveTypeOrMethodDef,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.TypeDef:	return ResolveTypeDef(rid);  			case Table.Method:	return ResolveMethod(rid);  			}
Missing Default,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\ModuleDefMD.cs,ReadBlob,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.Field:  				if (!TablesStream.TryReadFieldRow(rid' out var fieldRow))  					break;  				return BlobStream.Read(fieldRow.Signature);    			case Table.Method:  				if (!TablesStream.TryReadMethodRow(rid' out var methodRow))  					break;  				return BlobStream.Read(methodRow.Signature);    			case Table.MemberRef:  				if (!TablesStream.TryReadMemberRefRow(rid' out var mrRow))  					break;  				return BlobStream.Read(mrRow.Signature);    			case Table.Constant:  				if (!TablesStream.TryReadConstantRow(rid' out var constRow))  					break;  				return BlobStream.Read(constRow.Value);    			case Table.CustomAttribute:  				if (!TablesStream.TryReadCustomAttributeRow(rid' out var caRow))  					break;  				return BlobStream.Read(caRow.Value);    			case Table.FieldMarshal:  				if (!TablesStream.TryReadFieldMarshalRow(rid' out var fmRow))  					break;  				return BlobStream.Read(fmRow.NativeType);    			case Table.DeclSecurity:  				if (!TablesStream.TryReadDeclSecurityRow(rid' out var dsRow))  					break;  				return BlobStream.Read(dsRow.PermissionSet);    			case Table.StandAloneSig:  				if (!TablesStream.TryReadStandAloneSigRow(rid' out var sasRow))  					break;  				return BlobStream.Read(sasRow.Signature);    			case Table.Property:  				if (!TablesStream.TryReadPropertyRow(rid' out var propRow))  					break;  				return BlobStream.Read(propRow.Type);    			case Table.TypeSpec:  				if (!TablesStream.TryReadTypeSpecRow(rid' out var tsRow))  					break;  				return BlobStream.Read(tsRow.Signature);    			case Table.Assembly:  				if (!TablesStream.TryReadAssemblyRow(rid' out var asmRow))  					break;  				return BlobStream.Read(asmRow.PublicKey);    			case Table.AssemblyRef:  				// HashValue is also in the #Blob but the user has to read it some other way  				if (!TablesStream.TryReadAssemblyRefRow(rid' out var asmRefRow))  					break;  				return BlobStream.Read(asmRefRow.PublicKeyOrToken);    			case Table.File:  				if (!TablesStream.TryReadFileRow(rid' out var fileRow))  					break;  				return BlobStream.Read(fileRow.HashValue);    			case Table.MethodSpec:  				if (!TablesStream.TryReadMethodSpecRow(rid' out var msRow))  					break;  				return BlobStream.Read(msRow.Instantiation);  			}
Missing Default,dnlib.DotNet,ReflectionTypeNameParser,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\TypeNameParser.cs,ReadAssemblyRef,The following switch statement is missing a default case: switch (key.ToUpperInvariant()) {  				case "VERSION":  					asmRef.Version = Utils.ParseVersion(value);  					break;    				case "CONTENTTYPE":  					if (value.Equals("WindowsRuntime"' StringComparison.OrdinalIgnoreCase))  						asmRef.ContentType = AssemblyAttributes.ContentType_WindowsRuntime;  					else  						asmRef.ContentType = AssemblyAttributes.ContentType_Default;  					break;    				case "RETARGETABLE":  					if (value.Equals("Yes"' StringComparison.OrdinalIgnoreCase))  						asmRef.IsRetargetable = true;  					else  						asmRef.IsRetargetable = false;  					break;    				case "PUBLICKEY":  					if (value.Equals("null"' StringComparison.OrdinalIgnoreCase) ||  						value.Equals("neutral"' StringComparison.OrdinalIgnoreCase))  						asmRef.PublicKeyOrToken = new PublicKey();  					else  						asmRef.PublicKeyOrToken = PublicKeyBase.CreatePublicKey(Utils.ParseBytes(value));  					break;    				case "PUBLICKEYTOKEN":  					if (value.Equals("null"' StringComparison.OrdinalIgnoreCase) ||  						value.Equals("neutral"' StringComparison.OrdinalIgnoreCase))  						asmRef.PublicKeyOrToken = new PublicKeyToken();  					else  						asmRef.PublicKeyOrToken = PublicKeyBase.CreatePublicKeyToken(Utils.ParseBytes(value));  					break;    				case "CULTURE":  				case "LANGUAGE":  					if (value.Equals("neutral"' StringComparison.OrdinalIgnoreCase))  						asmRef.Culture = UTF8String.Empty;  					else  						asmRef.Culture = value;  					break;  				}
Missing Default,dnlib.DotNet.Emit,DynamicMethodBodyReader,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\DynamicMethodBodyReader.cs,ResolveTypeDefOrRef,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.TypeDef:  			case Table.TypeRef:  			case Table.TypeSpec:  				return module.ResolveToken(token) as ITypeDefOrRef;  			}
Missing Default,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,CreateLdcI4,The following switch statement is missing a default case: switch (value) {  			case -1:return OpCodes.Ldc_I4_M1.ToInstruction();  			case 0: return OpCodes.Ldc_I4_0.ToInstruction();  			case 1: return OpCodes.Ldc_I4_1.ToInstruction();  			case 2: return OpCodes.Ldc_I4_2.ToInstruction();  			case 3: return OpCodes.Ldc_I4_3.ToInstruction();  			case 4: return OpCodes.Ldc_I4_4.ToInstruction();  			case 5: return OpCodes.Ldc_I4_5.ToInstruction();  			case 6: return OpCodes.Ldc_I4_6.ToInstruction();  			case 7: return OpCodes.Ldc_I4_7.ToInstruction();  			case 8: return OpCodes.Ldc_I4_8.ToInstruction();  			}
Missing Default,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\Instruction.cs,GetParameterIndex,The following switch statement is missing a default case: switch (OpCode.Code) {  			case Code.Ldarg_0: return 0;  			case Code.Ldarg_1: return 1;  			case Code.Ldarg_2: return 2;  			case Code.Ldarg_3: return 3;    			case Code.Starg:  			case Code.Starg_S:  			case Code.Ldarga:  			case Code.Ldarga_S:  			case Code.Ldarg:  			case Code.Ldarg_S:  				var parameter = Operand as Parameter;  				if (!(parameter is null))  					return parameter.Index;  				break;  			}
Missing Default,dnlib.DotNet.Emit,MethodBodyReaderBase,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodBodyReaderBase.cs,FixBranches,The following switch statement is missing a default case: switch (instr.OpCode.OperandType) {  				case OperandType.InlineBrTarget:  				case OperandType.ShortInlineBrTarget:  					instr.Operand = GetInstruction((uint)instr.Operand);  					break;    				case OperandType.InlineSwitch:  					var uintTargets = (IList<uint>)instr.Operand;  					var targets = new Instruction[uintTargets.Count];  					for (int j = 0; j < uintTargets.Count; j++)  						targets[j] = GetInstruction(uintTargets[j]);  					instr.Operand = targets;  					break;  				}
Missing Default,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following switch statement is missing a default case: switch (instr.OpCode.Code) {  				case Code.Beq_S:  					instr.OpCode = OpCodes.Beq;  					break;    				case Code.Bge_S:  					instr.OpCode = OpCodes.Bge;  					break;    				case Code.Bge_Un_S:  					instr.OpCode = OpCodes.Bge_Un;  					break;    				case Code.Bgt_S:  					instr.OpCode = OpCodes.Bgt;  					break;    				case Code.Bgt_Un_S:  					instr.OpCode = OpCodes.Bgt_Un;  					break;    				case Code.Ble_S:  					instr.OpCode = OpCodes.Ble;  					break;    				case Code.Ble_Un_S:  					instr.OpCode = OpCodes.Ble_Un;  					break;    				case Code.Blt_S:  					instr.OpCode = OpCodes.Blt;  					break;    				case Code.Blt_Un_S:  					instr.OpCode = OpCodes.Blt_Un;  					break;    				case Code.Bne_Un_S:  					instr.OpCode = OpCodes.Bne_Un;  					break;    				case Code.Br_S:  					instr.OpCode = OpCodes.Br;  					break;    				case Code.Brfalse_S:  					instr.OpCode = OpCodes.Brfalse;  					break;    				case Code.Brtrue_S:  					instr.OpCode = OpCodes.Brtrue;  					break;    				case Code.Ldarg_0:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 0);  					break;    				case Code.Ldarg_1:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 1);  					break;    				case Code.Ldarg_2:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 2);  					break;    				case Code.Ldarg_3:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 3);  					break;    				case Code.Ldarg_S:  					instr.OpCode = OpCodes.Ldarg;  					break;    				case Code.Ldarga_S:  					instr.OpCode = OpCodes.Ldarga;  					break;    				case Code.Ldc_I4_0:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 0;  					break;    				case Code.Ldc_I4_1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 1;  					break;    				case Code.Ldc_I4_2:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 2;  					break;    				case Code.Ldc_I4_3:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 3;  					break;    				case Code.Ldc_I4_4:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 4;  					break;    				case Code.Ldc_I4_5:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 5;  					break;    				case Code.Ldc_I4_6:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 6;  					break;    				case Code.Ldc_I4_7:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 7;  					break;    				case Code.Ldc_I4_8:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 8;  					break;    				case Code.Ldc_I4_M1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = -1;  					break;    				case Code.Ldc_I4_S:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldloc_0:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Ldloc_1:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Ldloc_2:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Ldloc_3:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Ldloc_S:  					instr.OpCode = OpCodes.Ldloc;  					break;    				case Code.Ldloca_S:  					instr.OpCode = OpCodes.Ldloca;  					break;    				case Code.Leave_S:  					instr.OpCode = OpCodes.Leave;  					break;    				case Code.Starg_S:  					instr.OpCode = OpCodes.Starg;  					break;    				case Code.Stloc_0:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Stloc_1:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Stloc_2:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Stloc_3:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Stloc_S:  					instr.OpCode = OpCodes.Stloc;  					break;  				}
Missing Default,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyBranches,The following switch statement is missing a default case: switch (instr.OpCode.Code) {  				case Code.Beq_S:	instr.OpCode = OpCodes.Beq; break;  				case Code.Bge_S:	instr.OpCode = OpCodes.Bge; break;  				case Code.Bgt_S:	instr.OpCode = OpCodes.Bgt; break;  				case Code.Ble_S:	instr.OpCode = OpCodes.Ble; break;  				case Code.Blt_S:	instr.OpCode = OpCodes.Blt; break;  				case Code.Bne_Un_S:	instr.OpCode = OpCodes.Bne_Un; break;  				case Code.Bge_Un_S:	instr.OpCode = OpCodes.Bge_Un; break;  				case Code.Bgt_Un_S:	instr.OpCode = OpCodes.Bgt_Un; break;  				case Code.Ble_Un_S:	instr.OpCode = OpCodes.Ble_Un; break;  				case Code.Blt_Un_S:	instr.OpCode = OpCodes.Blt_Un; break;  				case Code.Br_S:		instr.OpCode = OpCodes.Br; break;  				case Code.Brfalse_S:instr.OpCode = OpCodes.Brfalse; break;  				case Code.Brtrue_S:	instr.OpCode = OpCodes.Brtrue; break;  				case Code.Leave_S:	instr.OpCode = OpCodes.Leave; break;  				}
Missing Default,dnlib.DotNet.MD,CompressedMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\CompressedMetadata.cs,InitializeInternal,The following switch statement is missing a default case: switch (sh.Name) {  					case "#Strings":  						if (stringsStream is null) {  							stringsStream = new StringsStream(mdReaderFactory' metadataBaseOffset' sh);  							newAllStreams.Add(stringsStream);  							continue;  						}  						break;    					case "#US":  						if (usStream is null) {  							usStream = new USStream(mdReaderFactory' metadataBaseOffset' sh);  							newAllStreams.Add(usStream);  							continue;  						}  						break;    					case "#Blob":  						if (blobStream is null) {  							blobStream = new BlobStream(mdReaderFactory' metadataBaseOffset' sh);  							newAllStreams.Add(blobStream);  							continue;  						}  						break;    					case "#GUID":  						if (guidStream is null) {  							guidStream = new GuidStream(mdReaderFactory' metadataBaseOffset' sh);  							newAllStreams.Add(guidStream);  							continue;  						}  						break;    					case "#~":  						if (tablesStream is null) {  							tablesStream = new TablesStream(mdReaderFactory' metadataBaseOffset' sh' runtime);  							newAllStreams.Add(tablesStream);  							continue;  						}  						break;    					case "#Pdb":  						if (isStandalonePortablePdb && pdbStream is null) {  							pdbStream = new PdbStream(mdReaderFactory' metadataBaseOffset' sh);  							newAllStreams.Add(pdbStream);  							continue;  						}  						break;  					}
Missing Default,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following switch statement is missing a default case: switch (columnSize) {  				case ColumnSize.Byte:	return 1;  				case ColumnSize.Int16:	return 2;  				case ColumnSize.UInt16:	return 2;  				case ColumnSize.Int32:	return 4;  				case ColumnSize.UInt32:	return 4;  				case ColumnSize.Strings:return bigStrings ? 4 : 2;  				case ColumnSize.GUID:	return bigGuid ? 4 : 2;  				case ColumnSize.Blob:	return bigBlob ? 4 : 2;  				}
Missing Default,dnlib.DotNet.MD,ENCMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\ENCMetadata.cs,InitializeInternal,The following switch statement is missing a default case: switch (sh.Name) {  						case "#Strings":  							if (stringsStream is null) {  								stringsStream = new StringsStream(mdReaderFactory' metadataBaseOffset' sh);  								newAllStreams.Add(stringsStream);  								continue;  							}  							break;    						case "#US":  							if (usStream is null) {  								usStream = new USStream(mdReaderFactory' metadataBaseOffset' sh);  								newAllStreams.Add(usStream);  								continue;  							}  							break;    						case "#Blob":  							if (blobStream is null) {  								blobStream = new BlobStream(mdReaderFactory' metadataBaseOffset' sh);  								newAllStreams.Add(blobStream);  								continue;  							}  							break;    						case "#GUID":  							if (guidStream is null) {  								guidStream = new GuidStream(mdReaderFactory' metadataBaseOffset' sh);  								newAllStreams.Add(guidStream);  								continue;  							}  							break;    						case "#~":  						case "#-":  							if (tablesStream is null) {  								tablesStream = new TablesStream(mdReaderFactory' metadataBaseOffset' sh' runtime);  								newAllStreams.Add(tablesStream);  								continue;  							}  							break;    						case "#Pdb":  							if (isStandalonePortablePdb && pdbStream is null) {  								pdbStream = new PdbStream(mdReaderFactory' metadataBaseOffset' sh);  								newAllStreams.Add(pdbStream);  								continue;  							}  							break;  						}
Missing Default,dnlib.DotNet.MD,ENCMetadata,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\MD\ENCMetadata.cs,InitializeInternal,The following switch statement is missing a default case: switch (sh.Name.ToUpperInvariant()) {  						case "#STRINGS":  							if (stringsStream is null) {  								stringsStream = new StringsStream(mdReaderFactory' metadataBaseOffset' sh);  								allStreams.Add(stringsStream);  								continue;  							}  							break;    						case "#US":  							if (usStream is null) {  								usStream = new USStream(mdReaderFactory' metadataBaseOffset' sh);  								allStreams.Add(usStream);  								continue;  							}  							break;    						case "#BLOB":  							if (blobStream is null) {  								blobStream = new BlobStream(mdReaderFactory' metadataBaseOffset' sh);  								allStreams.Add(blobStream);  								continue;  							}  							break;    						case "#GUID":  							if (guidStream is null) {  								guidStream = new GuidStream(mdReaderFactory' metadataBaseOffset' sh);  								allStreams.Add(guidStream);  								continue;  							}  							break;    						case "#~":  // Only if #Schema is used  						case "#-":  							if (tablesStream is null) {  								tablesStream = new TablesStream(mdReaderFactory' metadataBaseOffset' sh' runtime);  								allStreams.Add(tablesStream);  								continue;  							}  							break;    						case "#PDB":  							// Case sensitive comparison since it's a stream that's not read by the CLR'  							// only by other libraries eg. System.Reflection.Metadata.  							if (isStandalonePortablePdb && pdbStream is null && sh.Name == "#Pdb") {  								pdbStream = new PdbStream(mdReaderFactory' metadataBaseOffset' sh);  								allStreams.Add(pdbStream);  								continue;  							}  							break;  						}
Missing Default,dnlib.DotNet.Pdb.Dss,DataReaderIStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\DataReaderIStream.cs,Seek,The following switch statement is missing a default case: switch ((STREAM_SEEK)dwOrigin) {  			case STREAM_SEEK.SET:  				reader.Position = (uint)dlibMove;  				break;    			case STREAM_SEEK.CUR:  				reader.Position = (uint)(reader.Position + dlibMove);  				break;    			case STREAM_SEEK.END:  				reader.Position = (uint)(reader.Length + dlibMove);  				break;  			}
Missing Default,dnlib.DotNet.Pdb.Dss,StreamIStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Pdb\Dss\StreamIStream.cs,Seek,The following switch statement is missing a default case: switch ((STREAM_SEEK)dwOrigin) {  			case STREAM_SEEK.SET:  				stream.Position = dlibMove;  				break;    			case STREAM_SEEK.CUR:  				stream.Position += dlibMove;  				break;    			case STREAM_SEEK.END:  				stream.Position = stream.Length + dlibMove;  				break;  			}
Missing Default,dnlib.DotNet.Writer,CustomAttributeWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,ToUInt64,The following switch statement is missing a default case: switch (Type.GetTypeCode(o.GetType())) {  			case TypeCode.Boolean:  				result = (bool)o ? 1UL : 0UL;  				return true;    			case TypeCode.Char:  				result = (ushort)(char)o;  				return true;    			case TypeCode.SByte:  				result = (ulong)(sbyte)o;  				return true;    			case TypeCode.Byte:  				result = (byte)o;  				return true;    			case TypeCode.Int16:  				result = (ulong)(short)o;  				return true;    			case TypeCode.UInt16:  				result = (ushort)o;  				return true;    			case TypeCode.Int32:  				result = (ulong)(int)o;  				return true;    			case TypeCode.UInt32:  				result = (uint)o;  				return true;    			case TypeCode.Int64:  				result = (ulong)(long)o;  				return true;    			case TypeCode.UInt64:  				result = (ulong)o;  				return true;    			case TypeCode.Single:  				result = (ulong)(float)o;  				return true;    			case TypeCode.Double:  				result = (ulong)(double)o;  				return true;  			}
Missing Default,dnlib.DotNet.Writer,CustomAttributeWriter,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,ToDouble,The following switch statement is missing a default case: switch (Type.GetTypeCode(o.GetType())) {  			case TypeCode.Boolean:  				result = (bool)o ? 1 : 0;  				return true;    			case TypeCode.Char:  				result = (ushort)(char)o;  				return true;    			case TypeCode.SByte:  				result = (sbyte)o;  				return true;    			case TypeCode.Byte:  				result = (byte)o;  				return true;    			case TypeCode.Int16:  				result = (short)o;  				return true;    			case TypeCode.UInt16:  				result = (ushort)o;  				return true;    			case TypeCode.Int32:  				result = (int)o;  				return true;    			case TypeCode.UInt32:  				result = (uint)o;  				return true;    			case TypeCode.Int64:  				result = (long)o;  				return true;    			case TypeCode.UInt64:  				result = (ulong)o;  				return true;    			case TypeCode.Single:  				result = (float)o;  				return true;    			case TypeCode.Double:  				result = (double)o;  				return true;  			}
Missing Default,dnlib.DotNet.Writer,MaxStackCalculator,D:\research\architectureSmells\repos\0xd4d_dnlib\src\DotNet\Writer\MaxStackCalculator.cs,Calculate,The following switch statement is missing a default case: switch (opCode.FlowControl) {  				case FlowControl.Branch:  					WriteStack(instr.Operand as Instruction' stack);  					resetStack = true;  					break;    				case FlowControl.Call:  					if (code == Code.Jmp)  						resetStack = true;  					break;    				case FlowControl.Cond_Branch:  					if (code == Code.Switch) {  						if (instr.Operand is IList<Instruction> targets) {  							for (int j = 0; j < targets.Count; j++)  								WriteStack(targets[j]' stack);  						}  					}  					else  						WriteStack(instr.Operand as Instruction' stack);  					break;    				case FlowControl.Return:  				case FlowControl.Throw:  					resetStack = true;  					break;  				}
Missing Default,dnlib.IO,DataReaderStream,D:\research\architectureSmells\repos\0xd4d_dnlib\src\IO\DataReaderStream.cs,Seek,The following switch statement is missing a default case: switch (origin) {  			case SeekOrigin.Begin:		Position = offset; break;  			case SeekOrigin.Current:	Position += offset; break;  			case SeekOrigin.End:		Position = Length + offset; break;  			}
