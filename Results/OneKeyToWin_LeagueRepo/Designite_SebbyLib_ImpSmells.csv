Implementation smell,Namespace,Class,File,Method,Description
Long Method,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPrediction,The method has 64 lines of code.
Long Method,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetHitChance,The method has 60 lines of code.
Long Method,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,The method has 82 lines of code.
Long Method,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,UnitTracker,The method has 141 lines of code.
Long Method,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPrediction,The method has 87 lines of code.
Long Method,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The method has 142 lines of code.
Long Method,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The method has 86 lines of code.
Long Method,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The method has 66 lines of code.
Long Method,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,UnitTracker,The method has 141 lines of code.
Complex Method,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,Obj_AI_Base_OnProcessSpellCast,Cyclomatic complexity of the method is 7
Complex Method,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,MoveTo,Cyclomatic complexity of the method is 9
Complex Method,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Orbwalk,Cyclomatic complexity of the method is 9
Complex Method,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,OnProcessSpell,Cyclomatic complexity of the method is 7
Complex Method,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPrediction,Cyclomatic complexity of the method is 16
Complex Method,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetHitChance,Cyclomatic complexity of the method is 18
Complex Method,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,Cyclomatic complexity of the method is 13
Complex Method,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,Cyclomatic complexity of the method is 21
Complex Method,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPrediction,Cyclomatic complexity of the method is 21
Complex Method,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,Cyclomatic complexity of the method is 28
Complex Method,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetWallPoint,Cyclomatic complexity of the method is 11
Complex Method,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,Cyclomatic complexity of the method is 14
Complex Method,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,Cyclomatic complexity of the method is 21
Long Parameter List,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,DrawTriangleOKTW,The method has 4 parameters.
Long Parameter List,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,DrawLineRectangle,The method has 5 parameters.
Long Parameter List,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,MoveTo,The method has 5 parameters.
Long Parameter List,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Orbwalk,The method has 6 parameters.
Long Parameter List,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPrediction,The method has 4 parameters.
Long Parameter List,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPrediction,The method has 5 parameters.
Long Parameter List,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPrediction,The method has 4 parameters.
Long Parameter List,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPrediction,The method has 5 parameters.
Long Statement,SebbyLib,Cache,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Cache.cs,GetMinions,The length of the statement  "		return MinionsListNeutral.Where (minion => CanReturn (minion' from' range)).OrderByDescending (minion => minion.MaxHealth).ToList (); " is 133.
Long Statement,SebbyLib,HealthPrediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\HealthPrediction.cs,Game_OnGameUpdate,The length of the statement  "	ActiveAttacks.ToList ().Where (pair => pair.Value.StartTick < Utils.GameTimeTickCount - 3000).ToList ().ForEach (pair => ActiveAttacks.Remove (pair.Key)); " is 154.
Long Statement,SebbyLib,HealthPrediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\HealthPrediction.cs,ObjAiBaseOnOnProcessSpellCast,The length of the statement  "	if (sender.Team != ObjectManager.Player.Team || !sender.IsValidTarget (3000' false) || !Orbwalking.IsAutoAttack (args.SData.Name) || !(args.Target is Obj_AI_Base)) { " is 165.
Long Statement,SebbyLib,HealthPrediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\HealthPrediction.cs,ObjAiBaseOnOnProcessSpellCast,The length of the statement  "	var attackData = new PredictedDamage (sender' target' sender.ServerPosition' Utils.GameTimeTickCount - Game.Ping / 2' sender.AttackCastDelay * 1000' sender.AttackDelay * 1000 - (sender is Obj_AI_Turret ? 70 : 0)' sender.IsMelee ? int.MaxValue : (int)args.SData.MissileSpeed' (float)sender.GetAutoAttackDamage (target' true)); " is 325.
Long Statement,SebbyLib,HealthPrediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\HealthPrediction.cs,GetHealthPrediction,The length of the statement  "		if (!attack.Processed && attack.Target.IsValidTarget (float.MaxValue' false) && attack.Target.NetworkId == unit.NetworkId) { " is 124.
Long Statement,SebbyLib,HealthPrediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\HealthPrediction.cs,GetHealthPrediction,The length of the statement  "			float bonding = Math.Max (attack.Target.BoundingRadius' unit.Distance (attack.StartPos) - attack.Source.BoundingRadius); " is 120.
Long Statement,SebbyLib,HealthPrediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\HealthPrediction.cs,LaneClearHealthPrediction,The length of the statement  "		if (Utils.GameTimeTickCount - 100 <= attack.StartTick + attack.AnimationTime && attack.Target.IsValidTarget (float.MaxValue' false) && attack.Source.IsValidTarget (float.MaxValue' false) && attack.Target.NetworkId == unit.NetworkId) { " is 234.
Long Statement,SebbyLib,HealthPrediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\HealthPrediction.cs,LaneClearHealthPrediction,The length of the statement  "				if (fromT >= Utils.GameTimeTickCount && (fromT + attack.Delay + Math.Max (0' unit.Distance (attack.Source) - attack.Source.BoundingRadius / 2) / attack.ProjectileSpeed < toT)) { " is 177.
Long Statement,SebbyLib,HealthPrediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\HealthPrediction.cs,TurretAggroStartTick,The length of the statement  "	var ActiveTurret = ActiveAttacks.Values.FirstOrDefault (m => (m.Source is Obj_AI_Turret) && m.Target.NetworkId == minion.NetworkId); " is 132.
Long Statement,SebbyLib,HealthPrediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\HealthPrediction.cs,GetAggroTurret,The length of the statement  "	var ActiveTurret = ActiveAttacks.Values.FirstOrDefault (m => (m.Source is Obj_AI_Turret) && m.Target.NetworkId == minion.NetworkId); " is 132.
Long Statement,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,Obj_AI_Base_OnDamage,The length of the statement  "		IncomingDamageList.RemoveAll (damage => time < damage.Time || ((int)damage.Damage == (int)args.Damage && damage.TargetNetworkId == sender.NetworkId)); " is 150.
Long Statement,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,GetIncomingDamage,The length of the statement  "	foreach (var damage in IncomingDamageList.Where (damage => damage.TargetNetworkId == target.NetworkId && Game.Time - time < damage.Time)) { " is 139.
Long Statement,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,ShouldWait,The length of the statement  "	return Cache.GetMinions (Player.Position' 0).Any (minion => HealthPrediction.LaneClearHealthPrediction (minion' attackCalc' 30) <= Player.GetAutoAttackDamage (minion)); " is 168.
Long Statement,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,IsSpellHeroCollision,The length of the statement  "	foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (QWER.Range + QWER.Width' true' QWER.RangeCheckFrom) && t.NetworkId != hero.NetworkId)) { " is 166.
Long Statement,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,IsSpellHeroCollision,The length of the statement  "		if (prediction.UnitPosition.To2D ().Distance (QWER.From.To2D ()' QWER.GetPrediction (t).CastPosition.To2D ()' true' true) <= powCalc) { " is 135.
Long Statement,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,IsSpellHeroCollision,The length of the statement  "		} else if (prediction.UnitPosition.To2D ().Distance (QWER.From.To2D ()' t.ServerPosition.To2D ()' true' true) <= powCalc) { " is 123.
Long Statement,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,CanHitSkillShot,The length of the statement  "			if (pred.To2D ().Distance (args.End.To2D ()' args.Start.To2D ()' true' true) <= powCalc || target.ServerPosition.To2D ().Distance (args.End.To2D ()' args.Start.To2D ()' true' true) <= powCalc) { " is 194.
Long Statement,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,CanHitSkillShot,The length of the statement  "		} else if (target.Distance (args.End) < 50 + target.BoundingRadius || pred.Distance (args.End) < 50 + target.BoundingRadius) { " is 126.
Long Statement,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,GetKsDamage,The length of the statement  "	//totalDmg += (float)Player.CalcDamage(t' Damage.DamageType.Magical' 10 * Player.Level + 0.1 * Player.FlatMagicDamageMod + 0.3 * Player.FlatPhysicalDamageMod); " is 159.
Long Statement,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,ValidUlt,The length of the statement  "	if (target.HasBuffOfType (BuffType.PhysicalImmunity) || target.HasBuffOfType (BuffType.SpellImmunity) || target.IsZombie || target.IsInvulnerable || target.HasBuffOfType (BuffType.Invulnerability) || target.HasBuff ("kindredrnodeathbuff") || target.HasBuffOfType (BuffType.SpellShield) || target.Health - GetIncomingDamage (target) < 1) " is 336.
Long Statement,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,CanMove,The length of the statement  "	if (target.MoveSpeed < 50 || target.IsStunned || target.HasBuffOfType (BuffType.Stun) || target.HasBuffOfType (BuffType.Fear) || target.HasBuffOfType (BuffType.Snare) || target.HasBuffOfType (BuffType.Knockup) || target.HasBuff ("Recall") || target.HasBuffOfType (BuffType.Knockback) || target.HasBuffOfType (BuffType.Charm) || target.HasBuffOfType (BuffType.Taunt) || target.HasBuffOfType (BuffType.Suppression)) { " is 415.
Long Statement,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,GetPassiveTime,The length of the statement  "	return target.Buffs.OrderByDescending (buff => buff.EndTime - Game.Time).Where (buff => buff.Name.ToLower () == buffName.ToLower ()).Select (buff => buff.EndTime).FirstOrDefault () - Game.Time; " is 193.
Long Statement,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,GetTrapPos,The length of the statement  "	foreach (var enemy in HeroManager.Enemies.Where (enemy => enemy.IsValid && enemy.Distance (Player.ServerPosition) < range && (enemy.HasBuff ("zhonyasringshield") || enemy.HasBuff ("BardRStasis")))) { " is 199.
Long Statement,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,GetTrapPos,The length of the statement  "	foreach (var obj in ObjectManager.Get<Obj_GeneralParticleEmitter> ().Where (obj => obj.IsValid && obj.Position.Distance (Player.Position) < range)) { " is 149.
Long Statement,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,GetTrapPos,The length of the statement  "		if (name.Contains ("GateMarker_red.troy".ToLower ()) || name.Contains ("global_ss_teleport_target_red.troy".ToLower ()) || name.Contains ("R_indicator_red.troy".ToLower ())) " is 173.
Long Statement,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,DrawLineRectangle,The length of the statement  "	var rStartPos = Drawing.WorldToScreen (new Vector3 (rightStartPos.X' rightStartPos.Y' ObjectManager.Player.Position.Z)); " is 120.
Long Statement,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,CirclePoints,The length of the statement  "		var point = new Vector3 (position.X + radius * (float)Math.Cos (angle)' position.Y + radius * (float)Math.Sin (angle)' position.Z); " is 131.
Long Statement,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,Obj_AI_Base_OnProcessSpellCast,The length of the statement  "		if (targed.Type == GameObjectType.obj_AI_Hero && targed.Team != sender.Team && (sender.IsMelee || !args.SData.IsAutoAttack ())) { " is 129.
Long Statement,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,Obj_AI_Base_OnProcessSpellCast,The length of the statement  "		foreach (var champion in ChampionList.Where (champion => !champion.IsDead && champion.IsVisible && champion.Team != sender.Team && champion.Distance (sender) < 2000)) { " is 168.
Long Statement,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,IsAutoAttack,The length of the statement  "	return (name.ToLower ().Contains ("attack") && !NoAttacks.Contains (name.ToLower ())) || Attacks.Contains (name.ToLower ()); " is 124.
Long Statement,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,InAutoAttackRange,The length of the statement  "		return Vector2.DistanceSquared (Prediction.Prediction.GetPrediction (hero' 0).CastPosition.To2D ()' Player.Position.To2D ()) <= myRange * myRange; " is 146.
Long Statement,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,InAutoAttackRange,The length of the statement  "	return Vector2.DistanceSquared (target is Obj_AI_Base ? ((Obj_AI_Base)target).ServerPosition.To2D () : target.Position.To2D ()' Player.ServerPosition.To2D ()) <= myRange * myRange; " is 180.
Long Statement,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,GetMyProjectileSpeed,The length of the statement  "	return IsMelee (Player) || _championName == "Azir" || _championName == "Thresh" || _championName == "Velkoz" || _championName == "Viktor" && Player.HasBuff ("ViktorPowerTransferReturn") ? float.MaxValue : Player.BasicAttack.MissileSpeed; " is 237.
Long Statement,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,CanAttack,The length of the statement  "		if (Utils.GameTimeTickCount + Game.Ping / 2 + 25 >= LastAATick + attackDelay && Player.HasBuff ("GravesBasicAttackAmmo1")) { " is 124.
Long Statement,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,CanMove,The length of the statement  "	return NoCancelChamps.Contains (_championName) || (Utils.GameTimeTickCount + Game.Ping / 2 >= LastAATick + Player.AttackCastDelay * 1000 + extraWindup + localExtraWindup); " is 171.
Long Statement,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,MoveTo,The length of the statement  "		point = playerPosition.Extend (position' randomizeMinDistance ? (_random.NextFloat (0.6f' 1) + 0.2f) * _minDistance : _minDistance); " is 132.
Long Statement,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Orbwalk,The length of the statement  "			if (Orbwalker.LimitAttackSpeed && (Player.AttackDelay < 1 / 2.6f) && _autoattackCounter % 3 != 0 && !CanMove (500' true)) { " is 123.
Long Statement,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPrediction,The length of the statement  "	if (Math.Abs (input.Range - float.MaxValue) > float.Epsilon && input.Unit.Distance (input.RangeCheckFrom' true) > Math.Pow (input.Range * 1.5' 2)) { " is 148.
Long Statement,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPrediction,The length of the statement  "		if (result.Hitchance >= HitChance.High && input.RangeCheckFrom.Distance (input.Unit.Position' true) > Math.Pow (input.Range + input.RealRadius * 3 / 4' 2)) { " is 157.
Long Statement,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPrediction,The length of the statement  "		if (input.RangeCheckFrom.Distance (result.UnitPosition' true) > Math.Pow (input.Range + (input.Type == SkillshotType.SkillshotCircle ? input.RealRadius : 0)' 2)) { " is 163.
Long Statement,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPrediction,The length of the statement  "		/* This does not need to be handled for the updated predictions' but left as a reference.*/if (input.RangeCheckFrom.Distance (result.CastPosition' true) > Math.Pow (input.Range' 2)) { " is 183.
Long Statement,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPrediction,The length of the statement  "				result.CastPosition = input.RangeCheckFrom + input.Range * (result.UnitPosition - input.RangeCheckFrom).To2D ().Normalized ().To3D (); " is 134.
Long Statement,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetHitChance,The length of the statement  "	var delay = input.Delay + (Math.Abs (input.Speed - float.MaxValue) > float.Epsilon ? hero.Distance (input.From) / input.Speed : 0); " is 131.
Long Statement,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetHitChance,The length of the statement  "	if (input.Type == SkillshotType.SkillshotCircle && UnitTracker.GetLastNewPathTime (input.Unit) < 0.1d && hero.Distance (wayPoint) > fixRange) { " is 143.
Long Statement,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetDashingPrediction,The length of the statement  "		if (dashPred.Hitchance >= HitChance.High && dashPred.UnitPosition.To2D ().Distance (input.Unit.Position.To2D ()' endP' true) < 200) { " is 133.
Long Statement,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetImmobilePrediction,The length of the statement  "	/*timeToReachTargetPosition - remainingImmobileT + input.RealRadius / input.Unit.MoveSpeed < 0.4d ? HitChance.High : HitChance.Medium*/}; " is 137.
Long Statement,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,UnitIsImmobileUntil,The length of the statement  "	var result = unit.Buffs.Where (buff => buff.IsActive && Game.Time <= buff.EndTime && (buff.Type == BuffType.Charm || buff.Type == BuffType.Knockup || buff.Type == BuffType.Stun || buff.Type == BuffType.Suppression || buff.Type == BuffType.Snare || buff.Type == BuffType.Fear || buff.Type == BuffType.Taunt || buff.Type == BuffType.Knockback)).Aggregate (0d' (current' buff) => Math.Max (current' buff.EndTime)); " is 411.
Long Statement,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,The length of the statement  "				var p = a + direction * ((i == path.Count - 2) ? Math.Min (tDistance + input.RealRadius' d) : (tDistance + input.RealRadius)); " is 126.
Long Statement,SebbyLib.Movement,AoePrediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPossibleTargets,The length of the statement  "	foreach (var enemy in HeroManager.Enemies.FindAll (h => h.NetworkId != originalUnit.NetworkId && h.IsValidTarget ((input.Range + 200 + input.RealRadius)' true' input.RangeCheckFrom))) { " is 185.
Long Statement,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The length of the statement  "						if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) { " is 154.
Long Statement,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The length of the statement  "				foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) { " is 160.
Long Statement,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The length of the statement  "					if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) { " is 157.
Long Statement,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,Obj_AI_Base_OnProcessSpellCast,The length of the statement  "			UnitTrackerInfoList.Find (x => x.NetworkId == sender.NetworkId).SpecialSpellFinishTick = Utils.TickCount + (int)(foundSpell.duration * 1000); " is 141.
Long Statement,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,SpamSamePlace,The length of the statement  "	if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [1].Time < 0.2f && TrackerUnit.PathBank [2].Time + 0.1f < Game.Time && TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) < 100) { " is 215.
Long Statement,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,PathCalc,The length of the statement  "	if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [0].Time < 0.4f && Game.Time - TrackerUnit.PathBank [2].Time < 0.1 && TrackerUnit.PathBank [2].Position.Distance (unit.Position) < 300 && TrackerUnit.PathBank [1].Position.Distance (unit.Position) < 300 && TrackerUnit.PathBank [0].Position.Distance (unit.Position) < 300) { " is 330.
Long Statement,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,PathCalc,The length of the statement  "		if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) > dis && TrackerUnit.PathBank [0].Position.Distance (TrackerUnit.PathBank [1].Position) > dis) " is 177.
Long Statement,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPrediction,The length of the statement  "	if (Math.Abs (input.Range - float.MaxValue) > float.Epsilon && input.Unit.Distance (input.RangeCheckFrom' true) > Math.Pow (input.Range * 1.5' 2)) { " is 148.
Long Statement,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPrediction,The length of the statement  "		if (result.Hitchance >= HitChance.High && input.RangeCheckFrom.Distance (input.Unit.Position' true) > Math.Pow (input.Range + input.RealRadius * 3 / 4' 2)) { " is 157.
Long Statement,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPrediction,The length of the statement  "		if (input.RangeCheckFrom.Distance (result.UnitPosition' true) > Math.Pow (input.Range + (input.Type == SkillshotType.SkillshotCircle ? input.RealRadius : 0)' 2)) { " is 163.
Long Statement,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPrediction,The length of the statement  "		/* This does not need to be handled for the updated predictions' but left as a reference.*/if (input.RangeCheckFrom.Distance (result.CastPosition' true) > Math.Pow (input.Range' 2)) { " is 183.
Long Statement,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPrediction,The length of the statement  "				result.CastPosition = input.RangeCheckFrom + input.Range * (result.UnitPosition - input.RangeCheckFrom).To2D ().Normalized ().To3D (); " is 134.
Long Statement,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPrediction,The length of the statement  "		OktwCommon.debug (input.Radius + " RES Ways: " + input.Unit.GetWaypoints ().Count + " W " + input.Unit.IsWindingUp + " D " + distanceUnitToWaypoint + " T " + UnitTracker.GetLastNewPathTime (input.Unit) + " " + result.Hitchance); " is 228.
Long Statement,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The length of the statement  "	if (UnitTracker.GetSpecialSpellEndTime (input.Unit) > 100 || input.Unit.HasBuff ("Recall") || (UnitTracker.GetLastStopMoveTime (input.Unit) < 100 && input.Unit.IsRooted)) { " is 172.
Long Statement,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The length of the statement  "	if (totalDelay - input.Radius / 2 / input.Speed > 0.6 && (input.Unit.IsWindingUp || !input.Unit.CanMove || input.Unit.IsRooted)) { " is 130.
Long Statement,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The length of the statement  "		if (getAngle < 20 || getAngle > 160 || (getAngle > 130 && distanceUnitToWaypoint > 400) || OktwCommon.IsMovingInSameDirection (ObjectManager.Player' input.Unit)) { " is 163.
Long Statement,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetDashingPrediction,The length of the statement  "		if (dashPred.Hitchance >= HitChance.High && dashPred.UnitPosition.To2D ().Distance (input.Unit.Position.To2D ()' endP' true) < 200) { " is 133.
Long Statement,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetImmobilePrediction,The length of the statement  "	/*timeToReachTargetPosition - remainingImmobileT + input.RealRadius / input.Unit.MoveSpeed < 0.4d ? HitChance.High : HitChance.Medium*/}; " is 137.
Long Statement,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,UnitIsImmobileUntil,The length of the statement  "	var result = unit.Buffs.Where (buff => buff.IsActive && Game.Time <= buff.EndTime && (buff.Type == BuffType.Charm || buff.Type == BuffType.Knockup || buff.Type == BuffType.Stun || buff.Type == BuffType.Suppression || buff.Type == BuffType.Snare || buff.Type == BuffType.Fear || buff.Type == BuffType.Taunt || buff.Type == BuffType.Knockback)).Aggregate (0d' (current' buff) => Math.Max (current' buff.EndTime)); " is 411.
Long Statement,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The length of the statement  "				var p = a + direction * ((i == path.Count - 2) ? Math.Min (tDistance + input.RealRadius' d) : (tDistance + input.RealRadius)); " is 126.
Long Statement,SebbyLib.Prediction,AoePrediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPossibleTargets,The length of the statement  "	foreach (var enemy in HeroManager.Enemies.FindAll (h => h.NetworkId != originalUnit.NetworkId && h.IsValidTarget ((input.Range + 200 + input.RealRadius)' true' input.RangeCheckFrom))) { " is 185.
Long Statement,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The length of the statement  "						if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) { " is 154.
Long Statement,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The length of the statement  "				foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) { " is 160.
Long Statement,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The length of the statement  "					if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) { " is 157.
Long Statement,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,Obj_AI_Base_OnProcessSpellCast,The length of the statement  "				UnitTrackerInfoList.Find (x => x.NetworkId == sender.NetworkId).SpecialSpellFinishTick = Utils.TickCount + (int)(foundSpell.duration * 1000); " is 141.
Long Statement,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,SpamSamePlace,The length of the statement  "	if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [1].Time < 180 && Utils.TickCount - TrackerUnit.PathBank [2].Time < 90) { " is 130.
Complex Conditional,SebbyLib,Cache,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Cache.cs,CanReturn,The conditional expression  "minion != null && minion.IsValid && !minion.IsDead && minion.IsVisible && minion.IsTargetable"  is complex.
Complex Conditional,SebbyLib,HealthPrediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\HealthPrediction.cs,ObjAiBaseOnOnProcessSpellCast,The conditional expression  "sender.Team != ObjectManager.Player.Team || !sender.IsValidTarget (3000' false) || !Orbwalking.IsAutoAttack (args.SData.Name) || !(args.Target is Obj_AI_Base)"  is complex.
Complex Conditional,SebbyLib,HealthPrediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\HealthPrediction.cs,LaneClearHealthPrediction,The conditional expression  "Utils.GameTimeTickCount - 100 <= attack.StartTick + attack.AnimationTime && attack.Target.IsValidTarget (float.MaxValue' false) && attack.Source.IsValidTarget (float.MaxValue' false) && attack.Target.NetworkId == unit.NetworkId"  is complex.
Complex Conditional,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,ValidUlt,The conditional expression  "target.HasBuffOfType (BuffType.PhysicalImmunity) || target.HasBuffOfType (BuffType.SpellImmunity) || target.IsZombie || target.IsInvulnerable || target.HasBuffOfType (BuffType.Invulnerability) || target.HasBuff ("kindredrnodeathbuff") || target.HasBuffOfType (BuffType.SpellShield) || target.Health - GetIncomingDamage (target) < 1"  is complex.
Complex Conditional,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,CanMove,The conditional expression  "target.MoveSpeed < 50 || target.IsStunned || target.HasBuffOfType (BuffType.Stun) || target.HasBuffOfType (BuffType.Fear) || target.HasBuffOfType (BuffType.Snare) || target.HasBuffOfType (BuffType.Knockup) || target.HasBuff ("Recall") || target.HasBuffOfType (BuffType.Knockback) || target.HasBuffOfType (BuffType.Charm) || target.HasBuffOfType (BuffType.Taunt) || target.HasBuffOfType (BuffType.Suppression)"  is complex.
Complex Conditional,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,Obj_AI_Base_OnProcessSpellCast,The conditional expression  "targed.Type == GameObjectType.obj_AI_Hero && targed.Team != sender.Team && (sender.IsMelee || !args.SData.IsAutoAttack ())"  is complex.
Complex Conditional,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,Obj_AI_Base_OnProcessSpellCast,The conditional expression  "!sender.IsEnemy || sender.IsMinion || args.SData.IsAutoAttack () || sender.Type != GameObjectType.obj_AI_Hero"  is complex.
Complex Conditional,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Orbwalk,The conditional expression  "Orbwalker.LimitAttackSpeed && (Player.AttackDelay < 1 / 2.6f) && _autoattackCounter % 3 != 0 && !CanMove (500' true)"  is complex.
Complex Conditional,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,SpellbookOnStopCast,The conditional expression  "spellbook.Owner.IsValid && spellbook.Owner.IsMe && args.DestroyMissile && args.StopAnimation"  is complex.
Complex Conditional,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,OnProcessSpell,The conditional expression  "unit.IsMe && (Spell.Target is Obj_AI_Base || Spell.Target is Obj_BarracksDampener || Spell.Target is Obj_HQ)"  is complex.
Complex Conditional,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,PathCalc,The conditional expression  "TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [0].Time < 0.4f && Game.Time - TrackerUnit.PathBank [2].Time < 0.1 && TrackerUnit.PathBank [2].Position.Distance (unit.Position) < 300 && TrackerUnit.PathBank [1].Position.Distance (unit.Position) < 300 && TrackerUnit.PathBank [0].Position.Distance (unit.Position) < 300"  is complex.
Complex Conditional,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The conditional expression  "UnitTracker.GetSpecialSpellEndTime (input.Unit) > 100 || input.Unit.HasBuff ("Recall") || (UnitTracker.GetLastStopMoveTime (input.Unit) < 100 && input.Unit.IsRooted)"  is complex.
Complex Conditional,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The conditional expression  "totalDelay - input.Radius / 2 / input.Speed > 0.6 && (input.Unit.IsWindingUp || !input.Unit.CanMove || input.Unit.IsRooted)"  is complex.
Complex Conditional,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The conditional expression  "getAngle < 20 || getAngle > 160 || (getAngle > 130 && distanceUnitToWaypoint > 400) || OktwCommon.IsMovingInSameDirection (ObjectManager.Player' input.Unit)"  is complex.
Magic Number,SebbyLib,Cache,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Cache.cs,AddMinionObject,The following statement contains a magic number: if (minion.MaxHealth >= 225) {  	if (minion.Team == GameObjectTeam.Neutral) {  		MinionsListNeutral.Add (minion);  	} else if (minion.MaxMana == 0 && minion.MaxHealth >= 250) {  		if (minion.Team == GameObjectTeam.Unknown)  			return;  		else if (minion.Team != ObjectManager.Player.Team)  			MinionsListEnemy.Add (minion);  		else if (minion.Team == ObjectManager.Player.Team)  			MinionsListAlly.Add (minion);  	}  }  
Magic Number,SebbyLib,Cache,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Cache.cs,AddMinionObject,The following statement contains a magic number: if (minion.MaxHealth >= 225) {  	if (minion.Team == GameObjectTeam.Neutral) {  		MinionsListNeutral.Add (minion);  	} else if (minion.MaxMana == 0 && minion.MaxHealth >= 250) {  		if (minion.Team == GameObjectTeam.Unknown)  			return;  		else if (minion.Team != ObjectManager.Player.Team)  			MinionsListEnemy.Add (minion);  		else if (minion.Team == ObjectManager.Player.Team)  			MinionsListAlly.Add (minion);  	}  }  
Magic Number,SebbyLib,Cache,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Cache.cs,AddMinionObject,The following statement contains a magic number: if (minion.Team == GameObjectTeam.Neutral) {  	MinionsListNeutral.Add (minion);  } else if (minion.MaxMana == 0 && minion.MaxHealth >= 250) {  	if (minion.Team == GameObjectTeam.Unknown)  		return;  	else if (minion.Team != ObjectManager.Player.Team)  		MinionsListEnemy.Add (minion);  	else if (minion.Team == ObjectManager.Player.Team)  		MinionsListAlly.Add (minion);  }  
Magic Number,SebbyLib,Cache,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Cache.cs,AddMinionObject,The following statement contains a magic number: if (minion.MaxMana == 0 && minion.MaxHealth >= 250) {  	if (minion.Team == GameObjectTeam.Unknown)  		return;  	else if (minion.Team != ObjectManager.Player.Team)  		MinionsListEnemy.Add (minion);  	else if (minion.Team == ObjectManager.Player.Team)  		MinionsListAlly.Add (minion);  }  
Magic Number,SebbyLib,HealthPrediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\HealthPrediction.cs,Game_OnGameUpdate,The following statement contains a magic number: ActiveAttacks.ToList ().Where (pair => pair.Value.StartTick < Utils.GameTimeTickCount - 3000).ToList ().ForEach (pair => ActiveAttacks.Remove (pair.Key));  
Magic Number,SebbyLib,HealthPrediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\HealthPrediction.cs,ObjAiBaseOnOnProcessSpellCast,The following statement contains a magic number: if (sender.Team != ObjectManager.Player.Team || !sender.IsValidTarget (3000' false) || !Orbwalking.IsAutoAttack (args.SData.Name) || !(args.Target is Obj_AI_Base)) {  	return;  }  
Magic Number,SebbyLib,HealthPrediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\HealthPrediction.cs,GetHealthPrediction,The following statement contains a magic number: foreach (var attack in ActiveAttacks.Values) {  	var attackDamage = 0f;  	if (!attack.Processed && attack.Target.IsValidTarget (float.MaxValue' false) && attack.Target.NetworkId == unit.NetworkId) {  		float bonding = Math.Max (attack.Target.BoundingRadius' unit.Distance (attack.StartPos) - attack.Source.BoundingRadius);  		if (attack.Source.IsMelee) {  			bonding = 0;  		}  		var landTime = attack.StartTick + attack.Delay + 1000 * bonding / attack.ProjectileSpeed + delay;  		if (/*Utils.GameTimeTickCount < landTime - delay &&*/landTime < Utils.GameTimeTickCount + time) {  			attackDamage = attack.Damage;  		}  	}  	predictedDamage += attackDamage;  }  
Magic Number,SebbyLib,HealthPrediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\HealthPrediction.cs,GetHealthPrediction,The following statement contains a magic number: if (!attack.Processed && attack.Target.IsValidTarget (float.MaxValue' false) && attack.Target.NetworkId == unit.NetworkId) {  	float bonding = Math.Max (attack.Target.BoundingRadius' unit.Distance (attack.StartPos) - attack.Source.BoundingRadius);  	if (attack.Source.IsMelee) {  		bonding = 0;  	}  	var landTime = attack.StartTick + attack.Delay + 1000 * bonding / attack.ProjectileSpeed + delay;  	if (/*Utils.GameTimeTickCount < landTime - delay &&*/landTime < Utils.GameTimeTickCount + time) {  		attackDamage = attack.Damage;  	}  }  
Magic Number,SebbyLib,HealthPrediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\HealthPrediction.cs,LaneClearHealthPrediction,The following statement contains a magic number: foreach (var attack in ActiveAttacks.Values) {  	var n = 0;  	if (Utils.GameTimeTickCount - 100 <= attack.StartTick + attack.AnimationTime && attack.Target.IsValidTarget (float.MaxValue' false) && attack.Source.IsValidTarget (float.MaxValue' false) && attack.Target.NetworkId == unit.NetworkId) {  		var fromT = attack.StartTick;  		var toT = Utils.GameTimeTickCount + time;  		while (fromT < toT) {  			if (fromT >= Utils.GameTimeTickCount && (fromT + attack.Delay + Math.Max (0' unit.Distance (attack.Source) - attack.Source.BoundingRadius / 2) / attack.ProjectileSpeed < toT)) {  				n++;  			}  			fromT += (int)attack.AnimationTime;  		}  	}  	predictedDamage += n * attack.Damage;  }  
Magic Number,SebbyLib,HealthPrediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\HealthPrediction.cs,LaneClearHealthPrediction,The following statement contains a magic number: foreach (var attack in ActiveAttacks.Values) {  	var n = 0;  	if (Utils.GameTimeTickCount - 100 <= attack.StartTick + attack.AnimationTime && attack.Target.IsValidTarget (float.MaxValue' false) && attack.Source.IsValidTarget (float.MaxValue' false) && attack.Target.NetworkId == unit.NetworkId) {  		var fromT = attack.StartTick;  		var toT = Utils.GameTimeTickCount + time;  		while (fromT < toT) {  			if (fromT >= Utils.GameTimeTickCount && (fromT + attack.Delay + Math.Max (0' unit.Distance (attack.Source) - attack.Source.BoundingRadius / 2) / attack.ProjectileSpeed < toT)) {  				n++;  			}  			fromT += (int)attack.AnimationTime;  		}  	}  	predictedDamage += n * attack.Damage;  }  
Magic Number,SebbyLib,HealthPrediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\HealthPrediction.cs,LaneClearHealthPrediction,The following statement contains a magic number: if (Utils.GameTimeTickCount - 100 <= attack.StartTick + attack.AnimationTime && attack.Target.IsValidTarget (float.MaxValue' false) && attack.Source.IsValidTarget (float.MaxValue' false) && attack.Target.NetworkId == unit.NetworkId) {  	var fromT = attack.StartTick;  	var toT = Utils.GameTimeTickCount + time;  	while (fromT < toT) {  		if (fromT >= Utils.GameTimeTickCount && (fromT + attack.Delay + Math.Max (0' unit.Distance (attack.Source) - attack.Source.BoundingRadius / 2) / attack.ProjectileSpeed < toT)) {  			n++;  		}  		fromT += (int)attack.AnimationTime;  	}  }  
Magic Number,SebbyLib,HealthPrediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\HealthPrediction.cs,LaneClearHealthPrediction,The following statement contains a magic number: if (Utils.GameTimeTickCount - 100 <= attack.StartTick + attack.AnimationTime && attack.Target.IsValidTarget (float.MaxValue' false) && attack.Source.IsValidTarget (float.MaxValue' false) && attack.Target.NetworkId == unit.NetworkId) {  	var fromT = attack.StartTick;  	var toT = Utils.GameTimeTickCount + time;  	while (fromT < toT) {  		if (fromT >= Utils.GameTimeTickCount && (fromT + attack.Delay + Math.Max (0' unit.Distance (attack.Source) - attack.Source.BoundingRadius / 2) / attack.ProjectileSpeed < toT)) {  			n++;  		}  		fromT += (int)attack.AnimationTime;  	}  }  
Magic Number,SebbyLib,HealthPrediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\HealthPrediction.cs,LaneClearHealthPrediction,The following statement contains a magic number: while (fromT < toT) {  	if (fromT >= Utils.GameTimeTickCount && (fromT + attack.Delay + Math.Max (0' unit.Distance (attack.Source) - attack.Source.BoundingRadius / 2) / attack.ProjectileSpeed < toT)) {  		n++;  	}  	fromT += (int)attack.AnimationTime;  }  
Magic Number,SebbyLib,HealthPrediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\HealthPrediction.cs,LaneClearHealthPrediction,The following statement contains a magic number: if (fromT >= Utils.GameTimeTickCount && (fromT + attack.Delay + Math.Max (0' unit.Distance (attack.Source) - attack.Source.BoundingRadius / 2) / attack.ProjectileSpeed < toT)) {  	n++;  }  
Magic Number,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,Obj_AI_Base_OnDamage,The following statement contains a magic number: if (sender is Obj_AI_Hero) {  	float time = Game.Time - 2;  	IncomingDamageList.RemoveAll (damage => time < damage.Time || ((int)damage.Damage == (int)args.Damage && damage.TargetNetworkId == sender.NetworkId));  }  
Magic Number,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,CanHarras,The following statement contains a magic number: if (!Player.IsWindingUp && !Player.UnderTurret (true) && Orbwalking.CanMove (50))  	return true;  else  	return false;  
Magic Number,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,ShouldWait,The following statement contains a magic number: return Cache.GetMinions (Player.Position' 0).Any (minion => HealthPrediction.LaneClearHealthPrediction (minion' attackCalc' 30) <= Player.GetAutoAttackDamage (minion));  
Magic Number,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,GetEchoLudenDamage,The following statement contains a magic number: if (Player.HasBuff ("itemmagicshankcharge")) {  	if (Player.GetBuff ("itemmagicshankcharge").Count == 100) {  		totalDamage += (float)Player.CalcDamage (target' Damage.DamageType.Magical' 100 + 0.1 * Player.FlatMagicDamageMod);  	}  }  
Magic Number,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,GetEchoLudenDamage,The following statement contains a magic number: if (Player.HasBuff ("itemmagicshankcharge")) {  	if (Player.GetBuff ("itemmagicshankcharge").Count == 100) {  		totalDamage += (float)Player.CalcDamage (target' Damage.DamageType.Magical' 100 + 0.1 * Player.FlatMagicDamageMod);  	}  }  
Magic Number,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,GetEchoLudenDamage,The following statement contains a magic number: if (Player.HasBuff ("itemmagicshankcharge")) {  	if (Player.GetBuff ("itemmagicshankcharge").Count == 100) {  		totalDamage += (float)Player.CalcDamage (target' Damage.DamageType.Magical' 100 + 0.1 * Player.FlatMagicDamageMod);  	}  }  
Magic Number,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,GetEchoLudenDamage,The following statement contains a magic number: if (Player.GetBuff ("itemmagicshankcharge").Count == 100) {  	totalDamage += (float)Player.CalcDamage (target' Damage.DamageType.Magical' 100 + 0.1 * Player.FlatMagicDamageMod);  }  
Magic Number,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,GetEchoLudenDamage,The following statement contains a magic number: if (Player.GetBuff ("itemmagicshankcharge").Count == 100) {  	totalDamage += (float)Player.CalcDamage (target' Damage.DamageType.Magical' 100 + 0.1 * Player.FlatMagicDamageMod);  }  
Magic Number,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,GetEchoLudenDamage,The following statement contains a magic number: if (Player.GetBuff ("itemmagicshankcharge").Count == 100) {  	totalDamage += (float)Player.CalcDamage (target' Damage.DamageType.Magical' 100 + 0.1 * Player.FlatMagicDamageMod);  }  
Magic Number,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,GetEchoLudenDamage,The following statement contains a magic number: totalDamage += (float)Player.CalcDamage (target' Damage.DamageType.Magical' 100 + 0.1 * Player.FlatMagicDamageMod);  
Magic Number,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,GetEchoLudenDamage,The following statement contains a magic number: totalDamage += (float)Player.CalcDamage (target' Damage.DamageType.Magical' 100 + 0.1 * Player.FlatMagicDamageMod);  
Magic Number,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,IsSpellHeroCollision,The following statement contains a magic number: foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (QWER.Range + QWER.Width' true' QWER.RangeCheckFrom) && t.NetworkId != hero.NetworkId)) {  	var prediction = QWER.GetPrediction (hero);  	var powCalc = Math.Pow ((QWER.Width + extraWith + hero.BoundingRadius)' 2);  	if (prediction.UnitPosition.To2D ().Distance (QWER.From.To2D ()' QWER.GetPrediction (t).CastPosition.To2D ()' true' true) <= powCalc) {  		return true;  	} else if (prediction.UnitPosition.To2D ().Distance (QWER.From.To2D ()' t.ServerPosition.To2D ()' true' true) <= powCalc) {  		return true;  	}  }  
Magic Number,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,CanHitSkillShot,The following statement contains a magic number: if (args.Target == null && target.IsValidTarget (float.MaxValue' false)) {  	var pred = Prediction.Prediction.GetPrediction (target' 0.25f).CastPosition;  	if (pred == null)  		return false;  	if (args.SData.LineWidth > 0) {  		var powCalc = Math.Pow (args.SData.LineWidth + target.BoundingRadius' 2);  		if (pred.To2D ().Distance (args.End.To2D ()' args.Start.To2D ()' true' true) <= powCalc || target.ServerPosition.To2D ().Distance (args.End.To2D ()' args.Start.To2D ()' true' true) <= powCalc) {  			return true;  		}  	} else if (target.Distance (args.End) < 50 + target.BoundingRadius || pred.Distance (args.End) < 50 + target.BoundingRadius) {  		return true;  	}  }  
Magic Number,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,CanHitSkillShot,The following statement contains a magic number: if (args.Target == null && target.IsValidTarget (float.MaxValue' false)) {  	var pred = Prediction.Prediction.GetPrediction (target' 0.25f).CastPosition;  	if (pred == null)  		return false;  	if (args.SData.LineWidth > 0) {  		var powCalc = Math.Pow (args.SData.LineWidth + target.BoundingRadius' 2);  		if (pred.To2D ().Distance (args.End.To2D ()' args.Start.To2D ()' true' true) <= powCalc || target.ServerPosition.To2D ().Distance (args.End.To2D ()' args.Start.To2D ()' true' true) <= powCalc) {  			return true;  		}  	} else if (target.Distance (args.End) < 50 + target.BoundingRadius || pred.Distance (args.End) < 50 + target.BoundingRadius) {  		return true;  	}  }  
Magic Number,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,CanHitSkillShot,The following statement contains a magic number: if (args.Target == null && target.IsValidTarget (float.MaxValue' false)) {  	var pred = Prediction.Prediction.GetPrediction (target' 0.25f).CastPosition;  	if (pred == null)  		return false;  	if (args.SData.LineWidth > 0) {  		var powCalc = Math.Pow (args.SData.LineWidth + target.BoundingRadius' 2);  		if (pred.To2D ().Distance (args.End.To2D ()' args.Start.To2D ()' true' true) <= powCalc || target.ServerPosition.To2D ().Distance (args.End.To2D ()' args.Start.To2D ()' true' true) <= powCalc) {  			return true;  		}  	} else if (target.Distance (args.End) < 50 + target.BoundingRadius || pred.Distance (args.End) < 50 + target.BoundingRadius) {  		return true;  	}  }  
Magic Number,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,CanHitSkillShot,The following statement contains a magic number: if (args.SData.LineWidth > 0) {  	var powCalc = Math.Pow (args.SData.LineWidth + target.BoundingRadius' 2);  	if (pred.To2D ().Distance (args.End.To2D ()' args.Start.To2D ()' true' true) <= powCalc || target.ServerPosition.To2D ().Distance (args.End.To2D ()' args.Start.To2D ()' true' true) <= powCalc) {  		return true;  	}  } else if (target.Distance (args.End) < 50 + target.BoundingRadius || pred.Distance (args.End) < 50 + target.BoundingRadius) {  	return true;  }  
Magic Number,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,CanHitSkillShot,The following statement contains a magic number: if (args.SData.LineWidth > 0) {  	var powCalc = Math.Pow (args.SData.LineWidth + target.BoundingRadius' 2);  	if (pred.To2D ().Distance (args.End.To2D ()' args.Start.To2D ()' true' true) <= powCalc || target.ServerPosition.To2D ().Distance (args.End.To2D ()' args.Start.To2D ()' true' true) <= powCalc) {  		return true;  	}  } else if (target.Distance (args.End) < 50 + target.BoundingRadius || pred.Distance (args.End) < 50 + target.BoundingRadius) {  	return true;  }  
Magic Number,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,CanHitSkillShot,The following statement contains a magic number: if (args.SData.LineWidth > 0) {  	var powCalc = Math.Pow (args.SData.LineWidth + target.BoundingRadius' 2);  	if (pred.To2D ().Distance (args.End.To2D ()' args.Start.To2D ()' true' true) <= powCalc || target.ServerPosition.To2D ().Distance (args.End.To2D ()' args.Start.To2D ()' true' true) <= powCalc) {  		return true;  	}  } else if (target.Distance (args.End) < 50 + target.BoundingRadius || pred.Distance (args.End) < 50 + target.BoundingRadius) {  	return true;  }  
Magic Number,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,CanHitSkillShot,The following statement contains a magic number: if (target.Distance (args.End) < 50 + target.BoundingRadius || pred.Distance (args.End) < 50 + target.BoundingRadius) {  	return true;  }  
Magic Number,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,CanHitSkillShot,The following statement contains a magic number: if (target.Distance (args.End) < 50 + target.BoundingRadius || pred.Distance (args.End) < 50 + target.BoundingRadius) {  	return true;  }  
Magic Number,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,CanMove,The following statement contains a magic number: if (target.MoveSpeed < 50 || target.IsStunned || target.HasBuffOfType (BuffType.Stun) || target.HasBuffOfType (BuffType.Fear) || target.HasBuffOfType (BuffType.Snare) || target.HasBuffOfType (BuffType.Knockup) || target.HasBuff ("Recall") || target.HasBuffOfType (BuffType.Knockback) || target.HasBuffOfType (BuffType.Charm) || target.HasBuffOfType (BuffType.Taunt) || target.HasBuffOfType (BuffType.Suppression)) {  	return false;  } else  	return true;  
Magic Number,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,IsMovingInSameDirection,The following statement contains a magic number: if (getAngle < 25)  	return true;  else  	return false;  
Magic Number,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,CollisionYasuo,The following statement contains a magic number: if (Game.Time - yasuoWall.CastTime > 4)  	return false;  
Magic Number,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,CirclePoints,The following statement contains a magic number: for (var i = 1; i <= CircleLineSegmentN; i++) {  	var angle = i * 2 * Math.PI / CircleLineSegmentN;  	var point = new Vector3 (position.X + radius * (float)Math.Cos (angle)' position.Y + radius * (float)Math.Sin (angle)' position.Z);  	points.Add (point);  }  
Magic Number,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,Game_OnWndProc,The following statement contains a magic number: if (args.Msg == 123 && blockMove) {  	blockMove = false;  	blockAttack = false;  	Orbwalking.Attack = true;  	Orbwalking.Move = true;  	Player.IssueOrder (GameObjectOrder.MoveTo' Game.CursorPos);  }  
Magic Number,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,Obj_AI_Base_OnProcessSpellCast,The following statement contains a magic number: if (targed != null) {  	if (targed.Type == GameObjectType.obj_AI_Hero && targed.Team != sender.Team && (sender.IsMelee || !args.SData.IsAutoAttack ())) {  		IncomingDamageList.Add (new UnitIncomingDamage {  			Damage = sender.GetSpellDamage (targed' args.SData.Name)'  			TargetNetworkId = args.Target.NetworkId'  			Time = Game.Time'  			Skillshot = false  		});  	}  } else {  	foreach (var champion in ChampionList.Where (champion => !champion.IsDead && champion.IsVisible && champion.Team != sender.Team && champion.Distance (sender) < 2000)) {  		if (CanHitSkillShot (champion' args)) {  			IncomingDamageList.Add (new UnitIncomingDamage {  				Damage = sender.GetSpellDamage (champion' args.SData.Name)'  				TargetNetworkId = champion.NetworkId'  				Time = Game.Time'  				Skillshot = true  			});  		}  	}  	if (!YasuoInGame)  		return;  	if (!sender.IsEnemy || sender.IsMinion || args.SData.IsAutoAttack () || sender.Type != GameObjectType.obj_AI_Hero)  		return;  	if (args.SData.Name == "YasuoWMovingWall") {  		yasuoWall.CastTime = Game.Time;  		yasuoWall.CastPosition = sender.Position.Extend (args.End' 400);  		yasuoWall.YasuoPosition = sender.Position;  		yasuoWall.WallLvl = sender.Spellbook.Spells [1].Level;  	}  }  
Magic Number,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,Obj_AI_Base_OnProcessSpellCast,The following statement contains a magic number: if (targed != null) {  	if (targed.Type == GameObjectType.obj_AI_Hero && targed.Team != sender.Team && (sender.IsMelee || !args.SData.IsAutoAttack ())) {  		IncomingDamageList.Add (new UnitIncomingDamage {  			Damage = sender.GetSpellDamage (targed' args.SData.Name)'  			TargetNetworkId = args.Target.NetworkId'  			Time = Game.Time'  			Skillshot = false  		});  	}  } else {  	foreach (var champion in ChampionList.Where (champion => !champion.IsDead && champion.IsVisible && champion.Team != sender.Team && champion.Distance (sender) < 2000)) {  		if (CanHitSkillShot (champion' args)) {  			IncomingDamageList.Add (new UnitIncomingDamage {  				Damage = sender.GetSpellDamage (champion' args.SData.Name)'  				TargetNetworkId = champion.NetworkId'  				Time = Game.Time'  				Skillshot = true  			});  		}  	}  	if (!YasuoInGame)  		return;  	if (!sender.IsEnemy || sender.IsMinion || args.SData.IsAutoAttack () || sender.Type != GameObjectType.obj_AI_Hero)  		return;  	if (args.SData.Name == "YasuoWMovingWall") {  		yasuoWall.CastTime = Game.Time;  		yasuoWall.CastPosition = sender.Position.Extend (args.End' 400);  		yasuoWall.YasuoPosition = sender.Position;  		yasuoWall.WallLvl = sender.Spellbook.Spells [1].Level;  	}  }  
Magic Number,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,Obj_AI_Base_OnProcessSpellCast,The following statement contains a magic number: foreach (var champion in ChampionList.Where (champion => !champion.IsDead && champion.IsVisible && champion.Team != sender.Team && champion.Distance (sender) < 2000)) {  	if (CanHitSkillShot (champion' args)) {  		IncomingDamageList.Add (new UnitIncomingDamage {  			Damage = sender.GetSpellDamage (champion' args.SData.Name)'  			TargetNetworkId = champion.NetworkId'  			Time = Game.Time'  			Skillshot = true  		});  	}  }  
Magic Number,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,Obj_AI_Base_OnProcessSpellCast,The following statement contains a magic number: if (args.SData.Name == "YasuoWMovingWall") {  	yasuoWall.CastTime = Game.Time;  	yasuoWall.CastPosition = sender.Position.Extend (args.End' 400);  	yasuoWall.YasuoPosition = sender.Position;  	yasuoWall.WallLvl = sender.Spellbook.Spells [1].Level;  }  
Magic Number,SebbyLib,OktwCommon,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\OktwCommon.cs,Obj_AI_Base_OnProcessSpellCast,The following statement contains a magic number: yasuoWall.CastPosition = sender.Position.Extend (args.End' 400);  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Obj_AI_Base_OnDelete,The following statement contains a magic number: if (DelayOnFire != 0 && missile != null && Player.AttackDelay > 1 / 2f) {  	if (missile.SpellCaster.IsMe && missile.SData.IsAutoAttack () && DelayOnFireId == missile.Target.NetworkId) {  		var x = Utils.TickCount - DelayOnFire;  		if (x < 110 - Game.Ping / 2) {  			BrainFarmInt -= 2;  		} else if (x > 130 - Game.Ping / 2) {  			BrainFarmInt += 2;  		}  		//Console.WriteLine(missile.Target.BoundingRadius + " dis2 " + (missile.Position.Distance(missile.Target.Position)));  	}  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Obj_AI_Base_OnDelete,The following statement contains a magic number: if (DelayOnFire != 0 && missile != null && Player.AttackDelay > 1 / 2f) {  	if (missile.SpellCaster.IsMe && missile.SData.IsAutoAttack () && DelayOnFireId == missile.Target.NetworkId) {  		var x = Utils.TickCount - DelayOnFire;  		if (x < 110 - Game.Ping / 2) {  			BrainFarmInt -= 2;  		} else if (x > 130 - Game.Ping / 2) {  			BrainFarmInt += 2;  		}  		//Console.WriteLine(missile.Target.BoundingRadius + " dis2 " + (missile.Position.Distance(missile.Target.Position)));  	}  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Obj_AI_Base_OnDelete,The following statement contains a magic number: if (DelayOnFire != 0 && missile != null && Player.AttackDelay > 1 / 2f) {  	if (missile.SpellCaster.IsMe && missile.SData.IsAutoAttack () && DelayOnFireId == missile.Target.NetworkId) {  		var x = Utils.TickCount - DelayOnFire;  		if (x < 110 - Game.Ping / 2) {  			BrainFarmInt -= 2;  		} else if (x > 130 - Game.Ping / 2) {  			BrainFarmInt += 2;  		}  		//Console.WriteLine(missile.Target.BoundingRadius + " dis2 " + (missile.Position.Distance(missile.Target.Position)));  	}  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Obj_AI_Base_OnDelete,The following statement contains a magic number: if (DelayOnFire != 0 && missile != null && Player.AttackDelay > 1 / 2f) {  	if (missile.SpellCaster.IsMe && missile.SData.IsAutoAttack () && DelayOnFireId == missile.Target.NetworkId) {  		var x = Utils.TickCount - DelayOnFire;  		if (x < 110 - Game.Ping / 2) {  			BrainFarmInt -= 2;  		} else if (x > 130 - Game.Ping / 2) {  			BrainFarmInt += 2;  		}  		//Console.WriteLine(missile.Target.BoundingRadius + " dis2 " + (missile.Position.Distance(missile.Target.Position)));  	}  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Obj_AI_Base_OnDelete,The following statement contains a magic number: if (DelayOnFire != 0 && missile != null && Player.AttackDelay > 1 / 2f) {  	if (missile.SpellCaster.IsMe && missile.SData.IsAutoAttack () && DelayOnFireId == missile.Target.NetworkId) {  		var x = Utils.TickCount - DelayOnFire;  		if (x < 110 - Game.Ping / 2) {  			BrainFarmInt -= 2;  		} else if (x > 130 - Game.Ping / 2) {  			BrainFarmInt += 2;  		}  		//Console.WriteLine(missile.Target.BoundingRadius + " dis2 " + (missile.Position.Distance(missile.Target.Position)));  	}  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Obj_AI_Base_OnDelete,The following statement contains a magic number: if (DelayOnFire != 0 && missile != null && Player.AttackDelay > 1 / 2f) {  	if (missile.SpellCaster.IsMe && missile.SData.IsAutoAttack () && DelayOnFireId == missile.Target.NetworkId) {  		var x = Utils.TickCount - DelayOnFire;  		if (x < 110 - Game.Ping / 2) {  			BrainFarmInt -= 2;  		} else if (x > 130 - Game.Ping / 2) {  			BrainFarmInt += 2;  		}  		//Console.WriteLine(missile.Target.BoundingRadius + " dis2 " + (missile.Position.Distance(missile.Target.Position)));  	}  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Obj_AI_Base_OnDelete,The following statement contains a magic number: if (missile.SpellCaster.IsMe && missile.SData.IsAutoAttack () && DelayOnFireId == missile.Target.NetworkId) {  	var x = Utils.TickCount - DelayOnFire;  	if (x < 110 - Game.Ping / 2) {  		BrainFarmInt -= 2;  	} else if (x > 130 - Game.Ping / 2) {  		BrainFarmInt += 2;  	}  	//Console.WriteLine(missile.Target.BoundingRadius + " dis2 " + (missile.Position.Distance(missile.Target.Position)));  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Obj_AI_Base_OnDelete,The following statement contains a magic number: if (missile.SpellCaster.IsMe && missile.SData.IsAutoAttack () && DelayOnFireId == missile.Target.NetworkId) {  	var x = Utils.TickCount - DelayOnFire;  	if (x < 110 - Game.Ping / 2) {  		BrainFarmInt -= 2;  	} else if (x > 130 - Game.Ping / 2) {  		BrainFarmInt += 2;  	}  	//Console.WriteLine(missile.Target.BoundingRadius + " dis2 " + (missile.Position.Distance(missile.Target.Position)));  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Obj_AI_Base_OnDelete,The following statement contains a magic number: if (missile.SpellCaster.IsMe && missile.SData.IsAutoAttack () && DelayOnFireId == missile.Target.NetworkId) {  	var x = Utils.TickCount - DelayOnFire;  	if (x < 110 - Game.Ping / 2) {  		BrainFarmInt -= 2;  	} else if (x > 130 - Game.Ping / 2) {  		BrainFarmInt += 2;  	}  	//Console.WriteLine(missile.Target.BoundingRadius + " dis2 " + (missile.Position.Distance(missile.Target.Position)));  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Obj_AI_Base_OnDelete,The following statement contains a magic number: if (missile.SpellCaster.IsMe && missile.SData.IsAutoAttack () && DelayOnFireId == missile.Target.NetworkId) {  	var x = Utils.TickCount - DelayOnFire;  	if (x < 110 - Game.Ping / 2) {  		BrainFarmInt -= 2;  	} else if (x > 130 - Game.Ping / 2) {  		BrainFarmInt += 2;  	}  	//Console.WriteLine(missile.Target.BoundingRadius + " dis2 " + (missile.Position.Distance(missile.Target.Position)));  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Obj_AI_Base_OnDelete,The following statement contains a magic number: if (missile.SpellCaster.IsMe && missile.SData.IsAutoAttack () && DelayOnFireId == missile.Target.NetworkId) {  	var x = Utils.TickCount - DelayOnFire;  	if (x < 110 - Game.Ping / 2) {  		BrainFarmInt -= 2;  	} else if (x > 130 - Game.Ping / 2) {  		BrainFarmInt += 2;  	}  	//Console.WriteLine(missile.Target.BoundingRadius + " dis2 " + (missile.Position.Distance(missile.Target.Position)));  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Obj_AI_Base_OnDelete,The following statement contains a magic number: if (missile.SpellCaster.IsMe && missile.SData.IsAutoAttack () && DelayOnFireId == missile.Target.NetworkId) {  	var x = Utils.TickCount - DelayOnFire;  	if (x < 110 - Game.Ping / 2) {  		BrainFarmInt -= 2;  	} else if (x > 130 - Game.Ping / 2) {  		BrainFarmInt += 2;  	}  	//Console.WriteLine(missile.Target.BoundingRadius + " dis2 " + (missile.Position.Distance(missile.Target.Position)));  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Obj_AI_Base_OnDelete,The following statement contains a magic number: if (x < 110 - Game.Ping / 2) {  	BrainFarmInt -= 2;  } else if (x > 130 - Game.Ping / 2) {  	BrainFarmInt += 2;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Obj_AI_Base_OnDelete,The following statement contains a magic number: if (x < 110 - Game.Ping / 2) {  	BrainFarmInt -= 2;  } else if (x > 130 - Game.Ping / 2) {  	BrainFarmInt += 2;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Obj_AI_Base_OnDelete,The following statement contains a magic number: if (x < 110 - Game.Ping / 2) {  	BrainFarmInt -= 2;  } else if (x > 130 - Game.Ping / 2) {  	BrainFarmInt += 2;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Obj_AI_Base_OnDelete,The following statement contains a magic number: if (x < 110 - Game.Ping / 2) {  	BrainFarmInt -= 2;  } else if (x > 130 - Game.Ping / 2) {  	BrainFarmInt += 2;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Obj_AI_Base_OnDelete,The following statement contains a magic number: if (x < 110 - Game.Ping / 2) {  	BrainFarmInt -= 2;  } else if (x > 130 - Game.Ping / 2) {  	BrainFarmInt += 2;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Obj_AI_Base_OnDelete,The following statement contains a magic number: if (x < 110 - Game.Ping / 2) {  	BrainFarmInt -= 2;  } else if (x > 130 - Game.Ping / 2) {  	BrainFarmInt += 2;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Obj_AI_Base_OnDelete,The following statement contains a magic number: BrainFarmInt -= 2;  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Obj_AI_Base_OnDelete,The following statement contains a magic number: if (x > 130 - Game.Ping / 2) {  	BrainFarmInt += 2;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Obj_AI_Base_OnDelete,The following statement contains a magic number: if (x > 130 - Game.Ping / 2) {  	BrainFarmInt += 2;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Obj_AI_Base_OnDelete,The following statement contains a magic number: if (x > 130 - Game.Ping / 2) {  	BrainFarmInt += 2;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Obj_AI_Base_OnDelete,The following statement contains a magic number: BrainFarmInt += 2;  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,GetRealAutoAttackRange,The following statement contains a magic number: if (target.IsValidTarget ()) {  	var aiBase = target as Obj_AI_Base;  	if (aiBase != null && Player.ChampionName == "Caitlyn") {  		if (aiBase.HasBuff ("caitlynyordletrapinternal")) {  			result += 650;  		}  	}  	return result + target.BoundingRadius;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,GetRealAutoAttackRange,The following statement contains a magic number: if (aiBase != null && Player.ChampionName == "Caitlyn") {  	if (aiBase.HasBuff ("caitlynyordletrapinternal")) {  		result += 650;  	}  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,GetRealAutoAttackRange,The following statement contains a magic number: if (aiBase.HasBuff ("caitlynyordletrapinternal")) {  	result += 650;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,GetRealAutoAttackRange,The following statement contains a magic number: result += 650;  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,CanAttack,The following statement contains a magic number: if (Player.ChampionName == "Graves") {  	var attackDelay = 1.0740296828d * 1000 * Player.AttackDelay - 716.2381256175d;  	if (Utils.GameTimeTickCount + Game.Ping / 2 + 25 >= LastAATick + attackDelay && Player.HasBuff ("GravesBasicAttackAmmo1")) {  		return true;  	}  	return false;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,CanAttack,The following statement contains a magic number: if (Player.ChampionName == "Graves") {  	var attackDelay = 1.0740296828d * 1000 * Player.AttackDelay - 716.2381256175d;  	if (Utils.GameTimeTickCount + Game.Ping / 2 + 25 >= LastAATick + attackDelay && Player.HasBuff ("GravesBasicAttackAmmo1")) {  		return true;  	}  	return false;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,CanAttack,The following statement contains a magic number: if (Player.ChampionName == "Graves") {  	var attackDelay = 1.0740296828d * 1000 * Player.AttackDelay - 716.2381256175d;  	if (Utils.GameTimeTickCount + Game.Ping / 2 + 25 >= LastAATick + attackDelay && Player.HasBuff ("GravesBasicAttackAmmo1")) {  		return true;  	}  	return false;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,CanAttack,The following statement contains a magic number: if (Utils.GameTimeTickCount + Game.Ping / 2 + 25 >= LastAATick + attackDelay && Player.HasBuff ("GravesBasicAttackAmmo1")) {  	return true;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,CanAttack,The following statement contains a magic number: if (Utils.GameTimeTickCount + Game.Ping / 2 + 25 >= LastAATick + attackDelay && Player.HasBuff ("GravesBasicAttackAmmo1")) {  	return true;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,CanAttack,The following statement contains a magic number: return Utils.GameTimeTickCount + Game.Ping / 2 + 25 >= LastAATick + Player.AttackDelay * 1000;  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,CanAttack,The following statement contains a magic number: return Utils.GameTimeTickCount + Game.Ping / 2 + 25 >= LastAATick + Player.AttackDelay * 1000;  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,CanAttack,The following statement contains a magic number: return Utils.GameTimeTickCount + Game.Ping / 2 + 25 >= LastAATick + Player.AttackDelay * 1000;  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,CanMove,The following statement contains a magic number: if (_championName == "Rengar" && (Player.HasBuff ("rengarqbase") || Player.HasBuff ("rengarqemp"))) {  	localExtraWindup = 200;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,CanMove,The following statement contains a magic number: localExtraWindup = 200;  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,CanMove,The following statement contains a magic number: return NoCancelChamps.Contains (_championName) || (Utils.GameTimeTickCount + Game.Ping / 2 >= LastAATick + Player.AttackCastDelay * 1000 + extraWindup + localExtraWindup);  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,CanMove,The following statement contains a magic number: return NoCancelChamps.Contains (_championName) || (Utils.GameTimeTickCount + Game.Ping / 2 >= LastAATick + Player.AttackCastDelay * 1000 + extraWindup + localExtraWindup);  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,MoveTo,The following statement contains a magic number: if (playerPosition.Distance (position' true) < holdAreaRadius * holdAreaRadius) {  	if (Player.Path.Length > 0) {  		Player.IssueOrder (GameObjectOrder.Stop' playerPosition);  		LastMoveCommandPosition = playerPosition;  		LastMoveCommandT = Utils.GameTimeTickCount - 70;  	}  	return;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,MoveTo,The following statement contains a magic number: if (Player.Path.Length > 0) {  	Player.IssueOrder (GameObjectOrder.Stop' playerPosition);  	LastMoveCommandPosition = playerPosition;  	LastMoveCommandT = Utils.GameTimeTickCount - 70;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,MoveTo,The following statement contains a magic number: LastMoveCommandT = Utils.GameTimeTickCount - 70;  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,MoveTo,The following statement contains a magic number: if (Player.Distance (point' true) < 150 * 150) {  	point = playerPosition.Extend (position' randomizeMinDistance ? (_random.NextFloat (0.6f' 1) + 0.2f) * _minDistance : _minDistance);  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,MoveTo,The following statement contains a magic number: if (Player.Distance (point' true) < 150 * 150) {  	point = playerPosition.Extend (position' randomizeMinDistance ? (_random.NextFloat (0.6f' 1) + 0.2f) * _minDistance : _minDistance);  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,MoveTo,The following statement contains a magic number: if (currentPath.Count > 1 && currentPath.PathLength () > 100) {  	var movePath = Player.GetPath (point);  	if (movePath.Length > 1) {  		var v1 = currentPath [1] - currentPath [0];  		var v2 = movePath [1] - movePath [0];  		angle = v1.AngleBetween (v2.To2D ());  		var distance = movePath.Last ().To2D ().Distance (currentPath.Last ()' true);  		if ((angle < 10 && distance < 500 * 500) || distance < 50 * 50) {  			return;  		}  	}  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,MoveTo,The following statement contains a magic number: if (currentPath.Count > 1 && currentPath.PathLength () > 100) {  	var movePath = Player.GetPath (point);  	if (movePath.Length > 1) {  		var v1 = currentPath [1] - currentPath [0];  		var v2 = movePath [1] - movePath [0];  		angle = v1.AngleBetween (v2.To2D ());  		var distance = movePath.Last ().To2D ().Distance (currentPath.Last ()' true);  		if ((angle < 10 && distance < 500 * 500) || distance < 50 * 50) {  			return;  		}  	}  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,MoveTo,The following statement contains a magic number: if (currentPath.Count > 1 && currentPath.PathLength () > 100) {  	var movePath = Player.GetPath (point);  	if (movePath.Length > 1) {  		var v1 = currentPath [1] - currentPath [0];  		var v2 = movePath [1] - movePath [0];  		angle = v1.AngleBetween (v2.To2D ());  		var distance = movePath.Last ().To2D ().Distance (currentPath.Last ()' true);  		if ((angle < 10 && distance < 500 * 500) || distance < 50 * 50) {  			return;  		}  	}  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,MoveTo,The following statement contains a magic number: if (currentPath.Count > 1 && currentPath.PathLength () > 100) {  	var movePath = Player.GetPath (point);  	if (movePath.Length > 1) {  		var v1 = currentPath [1] - currentPath [0];  		var v2 = movePath [1] - movePath [0];  		angle = v1.AngleBetween (v2.To2D ());  		var distance = movePath.Last ().To2D ().Distance (currentPath.Last ()' true);  		if ((angle < 10 && distance < 500 * 500) || distance < 50 * 50) {  			return;  		}  	}  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,MoveTo,The following statement contains a magic number: if (currentPath.Count > 1 && currentPath.PathLength () > 100) {  	var movePath = Player.GetPath (point);  	if (movePath.Length > 1) {  		var v1 = currentPath [1] - currentPath [0];  		var v2 = movePath [1] - movePath [0];  		angle = v1.AngleBetween (v2.To2D ());  		var distance = movePath.Last ().To2D ().Distance (currentPath.Last ()' true);  		if ((angle < 10 && distance < 500 * 500) || distance < 50 * 50) {  			return;  		}  	}  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,MoveTo,The following statement contains a magic number: if (currentPath.Count > 1 && currentPath.PathLength () > 100) {  	var movePath = Player.GetPath (point);  	if (movePath.Length > 1) {  		var v1 = currentPath [1] - currentPath [0];  		var v2 = movePath [1] - movePath [0];  		angle = v1.AngleBetween (v2.To2D ());  		var distance = movePath.Last ().To2D ().Distance (currentPath.Last ()' true);  		if ((angle < 10 && distance < 500 * 500) || distance < 50 * 50) {  			return;  		}  	}  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,MoveTo,The following statement contains a magic number: if (movePath.Length > 1) {  	var v1 = currentPath [1] - currentPath [0];  	var v2 = movePath [1] - movePath [0];  	angle = v1.AngleBetween (v2.To2D ());  	var distance = movePath.Last ().To2D ().Distance (currentPath.Last ()' true);  	if ((angle < 10 && distance < 500 * 500) || distance < 50 * 50) {  		return;  	}  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,MoveTo,The following statement contains a magic number: if (movePath.Length > 1) {  	var v1 = currentPath [1] - currentPath [0];  	var v2 = movePath [1] - movePath [0];  	angle = v1.AngleBetween (v2.To2D ());  	var distance = movePath.Last ().To2D ().Distance (currentPath.Last ()' true);  	if ((angle < 10 && distance < 500 * 500) || distance < 50 * 50) {  		return;  	}  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,MoveTo,The following statement contains a magic number: if (movePath.Length > 1) {  	var v1 = currentPath [1] - currentPath [0];  	var v2 = movePath [1] - movePath [0];  	angle = v1.AngleBetween (v2.To2D ());  	var distance = movePath.Last ().To2D ().Distance (currentPath.Last ()' true);  	if ((angle < 10 && distance < 500 * 500) || distance < 50 * 50) {  		return;  	}  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,MoveTo,The following statement contains a magic number: if (movePath.Length > 1) {  	var v1 = currentPath [1] - currentPath [0];  	var v2 = movePath [1] - movePath [0];  	angle = v1.AngleBetween (v2.To2D ());  	var distance = movePath.Last ().To2D ().Distance (currentPath.Last ()' true);  	if ((angle < 10 && distance < 500 * 500) || distance < 50 * 50) {  		return;  	}  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,MoveTo,The following statement contains a magic number: if (movePath.Length > 1) {  	var v1 = currentPath [1] - currentPath [0];  	var v2 = movePath [1] - movePath [0];  	angle = v1.AngleBetween (v2.To2D ());  	var distance = movePath.Last ().To2D ().Distance (currentPath.Last ()' true);  	if ((angle < 10 && distance < 500 * 500) || distance < 50 * 50) {  		return;  	}  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,MoveTo,The following statement contains a magic number: if ((angle < 10 && distance < 500 * 500) || distance < 50 * 50) {  	return;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,MoveTo,The following statement contains a magic number: if ((angle < 10 && distance < 500 * 500) || distance < 50 * 50) {  	return;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,MoveTo,The following statement contains a magic number: if ((angle < 10 && distance < 500 * 500) || distance < 50 * 50) {  	return;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,MoveTo,The following statement contains a magic number: if ((angle < 10 && distance < 500 * 500) || distance < 50 * 50) {  	return;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,MoveTo,The following statement contains a magic number: if ((angle < 10 && distance < 500 * 500) || distance < 50 * 50) {  	return;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,MoveTo,The following statement contains a magic number: if (Utils.GameTimeTickCount - LastMoveCommandT < 70 + Math.Min (60' Game.Ping) && !overrideTimer && angle < 60) {  	return;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,MoveTo,The following statement contains a magic number: if (Utils.GameTimeTickCount - LastMoveCommandT < 70 + Math.Min (60' Game.Ping) && !overrideTimer && angle < 60) {  	return;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,MoveTo,The following statement contains a magic number: if (Utils.GameTimeTickCount - LastMoveCommandT < 70 + Math.Min (60' Game.Ping) && !overrideTimer && angle < 60) {  	return;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,MoveTo,The following statement contains a magic number: if (angle >= 60 && Utils.GameTimeTickCount - LastMoveCommandT < 60) {  	return;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,MoveTo,The following statement contains a magic number: if (angle >= 60 && Utils.GameTimeTickCount - LastMoveCommandT < 60) {  	return;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Orbwalk,The following statement contains a magic number: if (Utils.GameTimeTickCount - LastAttackCommandT < 70 + Math.Min (60' Game.Ping)) {  	return;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Orbwalk,The following statement contains a magic number: if (Utils.GameTimeTickCount - LastAttackCommandT < 70 + Math.Min (60' Game.Ping)) {  	return;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Orbwalk,The following statement contains a magic number: try {  	if (target.IsValidTarget () && CanAttack () && Attack) {  		DisableNextAttack = false;  		FireBeforeAttack (target);  		if (!DisableNextAttack) {  			if (!NoCancelChamps.Contains (_championName)) {  				_missileLaunched = false;  			}  			if (Player.IssueOrder (GameObjectOrder.AttackUnit' target)) {  				LastAttackCommandT = Utils.GameTimeTickCount;  				_lastTarget = target;  			}  			return;  		}  	}  	if (CanMove (extraWindup) && Move) {  		if (Orbwalker.LimitAttackSpeed && (Player.AttackDelay < 1 / 2.6f) && _autoattackCounter % 3 != 0 && !CanMove (500' true)) {  			return;  		}  		MoveTo (position' Math.Max (holdAreaRadius' 30)' false' useFixedDistance' randomizeMinDistance);  	}  } catch (Exception e) {  	Console.WriteLine (e.ToString ());  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Orbwalk,The following statement contains a magic number: try {  	if (target.IsValidTarget () && CanAttack () && Attack) {  		DisableNextAttack = false;  		FireBeforeAttack (target);  		if (!DisableNextAttack) {  			if (!NoCancelChamps.Contains (_championName)) {  				_missileLaunched = false;  			}  			if (Player.IssueOrder (GameObjectOrder.AttackUnit' target)) {  				LastAttackCommandT = Utils.GameTimeTickCount;  				_lastTarget = target;  			}  			return;  		}  	}  	if (CanMove (extraWindup) && Move) {  		if (Orbwalker.LimitAttackSpeed && (Player.AttackDelay < 1 / 2.6f) && _autoattackCounter % 3 != 0 && !CanMove (500' true)) {  			return;  		}  		MoveTo (position' Math.Max (holdAreaRadius' 30)' false' useFixedDistance' randomizeMinDistance);  	}  } catch (Exception e) {  	Console.WriteLine (e.ToString ());  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Orbwalk,The following statement contains a magic number: try {  	if (target.IsValidTarget () && CanAttack () && Attack) {  		DisableNextAttack = false;  		FireBeforeAttack (target);  		if (!DisableNextAttack) {  			if (!NoCancelChamps.Contains (_championName)) {  				_missileLaunched = false;  			}  			if (Player.IssueOrder (GameObjectOrder.AttackUnit' target)) {  				LastAttackCommandT = Utils.GameTimeTickCount;  				_lastTarget = target;  			}  			return;  		}  	}  	if (CanMove (extraWindup) && Move) {  		if (Orbwalker.LimitAttackSpeed && (Player.AttackDelay < 1 / 2.6f) && _autoattackCounter % 3 != 0 && !CanMove (500' true)) {  			return;  		}  		MoveTo (position' Math.Max (holdAreaRadius' 30)' false' useFixedDistance' randomizeMinDistance);  	}  } catch (Exception e) {  	Console.WriteLine (e.ToString ());  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Orbwalk,The following statement contains a magic number: if (CanMove (extraWindup) && Move) {  	if (Orbwalker.LimitAttackSpeed && (Player.AttackDelay < 1 / 2.6f) && _autoattackCounter % 3 != 0 && !CanMove (500' true)) {  		return;  	}  	MoveTo (position' Math.Max (holdAreaRadius' 30)' false' useFixedDistance' randomizeMinDistance);  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Orbwalk,The following statement contains a magic number: if (CanMove (extraWindup) && Move) {  	if (Orbwalker.LimitAttackSpeed && (Player.AttackDelay < 1 / 2.6f) && _autoattackCounter % 3 != 0 && !CanMove (500' true)) {  		return;  	}  	MoveTo (position' Math.Max (holdAreaRadius' 30)' false' useFixedDistance' randomizeMinDistance);  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Orbwalk,The following statement contains a magic number: if (CanMove (extraWindup) && Move) {  	if (Orbwalker.LimitAttackSpeed && (Player.AttackDelay < 1 / 2.6f) && _autoattackCounter % 3 != 0 && !CanMove (500' true)) {  		return;  	}  	MoveTo (position' Math.Max (holdAreaRadius' 30)' false' useFixedDistance' randomizeMinDistance);  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Orbwalk,The following statement contains a magic number: if (Orbwalker.LimitAttackSpeed && (Player.AttackDelay < 1 / 2.6f) && _autoattackCounter % 3 != 0 && !CanMove (500' true)) {  	return;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Orbwalk,The following statement contains a magic number: if (Orbwalker.LimitAttackSpeed && (Player.AttackDelay < 1 / 2.6f) && _autoattackCounter % 3 != 0 && !CanMove (500' true)) {  	return;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Orbwalk,The following statement contains a magic number: MoveTo (position' Math.Max (holdAreaRadius' 30)' false' useFixedDistance' randomizeMinDistance);  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Obj_AI_Base_OnDoCast,The following statement contains a magic number: if (sender.IsMe) {  	var ping = Game.Ping;  	if (ping <= 30)//First world problems kappa  	 {  		Utility.DelayAction.Add (30 - ping' () => Obj_AI_Base_OnDoCast_Delayed (sender' args));  		return;  	}  	Obj_AI_Base_OnDoCast_Delayed (sender' args);  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Obj_AI_Base_OnDoCast,The following statement contains a magic number: if (sender.IsMe) {  	var ping = Game.Ping;  	if (ping <= 30)//First world problems kappa  	 {  		Utility.DelayAction.Add (30 - ping' () => Obj_AI_Base_OnDoCast_Delayed (sender' args));  		return;  	}  	Obj_AI_Base_OnDoCast_Delayed (sender' args);  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Obj_AI_Base_OnDoCast,The following statement contains a magic number: if (ping <= 30)//First world problems kappa   {  	Utility.DelayAction.Add (30 - ping' () => Obj_AI_Base_OnDoCast_Delayed (sender' args));  	return;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Obj_AI_Base_OnDoCast,The following statement contains a magic number: if (ping <= 30)//First world problems kappa   {  	Utility.DelayAction.Add (30 - ping' () => Obj_AI_Base_OnDoCast_Delayed (sender' args));  	return;  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,Obj_AI_Base_OnDoCast,The following statement contains a magic number: Utility.DelayAction.Add (30 - ping' () => Obj_AI_Base_OnDoCast_Delayed (sender' args));  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,OnProcessSpell,The following statement contains a magic number: try {  	var spellName = Spell.SData.Name;  	if (unit.IsMe && IsAutoAttackReset (spellName) && Spell.SData.SpellCastTime == 0) {  		ResetAutoAttackTimer ();  	}  	if (!IsAutoAttack (spellName)) {  		return;  	}  	if (unit.IsMe && (Spell.Target is Obj_AI_Base || Spell.Target is Obj_BarracksDampener || Spell.Target is Obj_HQ)) {  		LastAATick = Utils.GameTimeTickCount - Game.Ping / 2;  		_missileLaunched = false;  		LastMoveCommandT = 0;  		_autoattackCounter++;  		if (Spell.Target is Obj_AI_Base) {  			var target = (Obj_AI_Base)Spell.Target;  			if (target.IsValid) {  				FireOnTargetSwitch (target);  				_lastTarget = target;  			}  		}  	}  	FireOnAttack (unit' _lastTarget);  } catch (Exception e) {  	Console.WriteLine (e);  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,OnProcessSpell,The following statement contains a magic number: if (unit.IsMe && (Spell.Target is Obj_AI_Base || Spell.Target is Obj_BarracksDampener || Spell.Target is Obj_HQ)) {  	LastAATick = Utils.GameTimeTickCount - Game.Ping / 2;  	_missileLaunched = false;  	LastMoveCommandT = 0;  	_autoattackCounter++;  	if (Spell.Target is Obj_AI_Base) {  		var target = (Obj_AI_Base)Spell.Target;  		if (target.IsValid) {  			FireOnTargetSwitch (target);  			_lastTarget = target;  		}  	}  }  
Magic Number,SebbyLib,Orbwalking,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Orbwalking.cs,OnProcessSpell,The following statement contains a magic number: LastAATick = Utils.GameTimeTickCount - Game.Ping / 2;  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPrediction,The following statement contains a magic number: if (Math.Abs (input.Range - float.MaxValue) > float.Epsilon && input.Unit.Distance (input.RangeCheckFrom' true) > Math.Pow (input.Range * 1.5' 2)) {  	return new PredictionOutput {  		Input = input  	};  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPrediction,The following statement contains a magic number: if (Math.Abs (input.Range - float.MaxValue) > float.Epsilon && input.Unit.Distance (input.RangeCheckFrom' true) > Math.Pow (input.Range * 1.5' 2)) {  	return new PredictionOutput {  		Input = input  	};  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPrediction,The following statement contains a magic number: if (Math.Abs (input.Range - float.MaxValue) > float.Epsilon) {  	if (result.Hitchance >= HitChance.High && input.RangeCheckFrom.Distance (input.Unit.Position' true) > Math.Pow (input.Range + input.RealRadius * 3 / 4' 2)) {  		result.Hitchance = HitChance.Medium;  	}  	if (input.RangeCheckFrom.Distance (result.UnitPosition' true) > Math.Pow (input.Range + (input.Type == SkillshotType.SkillshotCircle ? input.RealRadius : 0)' 2)) {  		result.Hitchance = HitChance.OutOfRange;  	}  	/* This does not need to be handled for the updated predictions' but left as a reference.*/if (input.RangeCheckFrom.Distance (result.CastPosition' true) > Math.Pow (input.Range' 2)) {  		if (result.Hitchance != HitChance.OutOfRange) {  			result.CastPosition = input.RangeCheckFrom + input.Range * (result.UnitPosition - input.RangeCheckFrom).To2D ().Normalized ().To3D ();  		} else {  			result.Hitchance = HitChance.OutOfRange;  		}  	}  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPrediction,The following statement contains a magic number: if (Math.Abs (input.Range - float.MaxValue) > float.Epsilon) {  	if (result.Hitchance >= HitChance.High && input.RangeCheckFrom.Distance (input.Unit.Position' true) > Math.Pow (input.Range + input.RealRadius * 3 / 4' 2)) {  		result.Hitchance = HitChance.Medium;  	}  	if (input.RangeCheckFrom.Distance (result.UnitPosition' true) > Math.Pow (input.Range + (input.Type == SkillshotType.SkillshotCircle ? input.RealRadius : 0)' 2)) {  		result.Hitchance = HitChance.OutOfRange;  	}  	/* This does not need to be handled for the updated predictions' but left as a reference.*/if (input.RangeCheckFrom.Distance (result.CastPosition' true) > Math.Pow (input.Range' 2)) {  		if (result.Hitchance != HitChance.OutOfRange) {  			result.CastPosition = input.RangeCheckFrom + input.Range * (result.UnitPosition - input.RangeCheckFrom).To2D ().Normalized ().To3D ();  		} else {  			result.Hitchance = HitChance.OutOfRange;  		}  	}  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPrediction,The following statement contains a magic number: if (Math.Abs (input.Range - float.MaxValue) > float.Epsilon) {  	if (result.Hitchance >= HitChance.High && input.RangeCheckFrom.Distance (input.Unit.Position' true) > Math.Pow (input.Range + input.RealRadius * 3 / 4' 2)) {  		result.Hitchance = HitChance.Medium;  	}  	if (input.RangeCheckFrom.Distance (result.UnitPosition' true) > Math.Pow (input.Range + (input.Type == SkillshotType.SkillshotCircle ? input.RealRadius : 0)' 2)) {  		result.Hitchance = HitChance.OutOfRange;  	}  	/* This does not need to be handled for the updated predictions' but left as a reference.*/if (input.RangeCheckFrom.Distance (result.CastPosition' true) > Math.Pow (input.Range' 2)) {  		if (result.Hitchance != HitChance.OutOfRange) {  			result.CastPosition = input.RangeCheckFrom + input.Range * (result.UnitPosition - input.RangeCheckFrom).To2D ().Normalized ().To3D ();  		} else {  			result.Hitchance = HitChance.OutOfRange;  		}  	}  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPrediction,The following statement contains a magic number: if (Math.Abs (input.Range - float.MaxValue) > float.Epsilon) {  	if (result.Hitchance >= HitChance.High && input.RangeCheckFrom.Distance (input.Unit.Position' true) > Math.Pow (input.Range + input.RealRadius * 3 / 4' 2)) {  		result.Hitchance = HitChance.Medium;  	}  	if (input.RangeCheckFrom.Distance (result.UnitPosition' true) > Math.Pow (input.Range + (input.Type == SkillshotType.SkillshotCircle ? input.RealRadius : 0)' 2)) {  		result.Hitchance = HitChance.OutOfRange;  	}  	/* This does not need to be handled for the updated predictions' but left as a reference.*/if (input.RangeCheckFrom.Distance (result.CastPosition' true) > Math.Pow (input.Range' 2)) {  		if (result.Hitchance != HitChance.OutOfRange) {  			result.CastPosition = input.RangeCheckFrom + input.Range * (result.UnitPosition - input.RangeCheckFrom).To2D ().Normalized ().To3D ();  		} else {  			result.Hitchance = HitChance.OutOfRange;  		}  	}  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPrediction,The following statement contains a magic number: if (Math.Abs (input.Range - float.MaxValue) > float.Epsilon) {  	if (result.Hitchance >= HitChance.High && input.RangeCheckFrom.Distance (input.Unit.Position' true) > Math.Pow (input.Range + input.RealRadius * 3 / 4' 2)) {  		result.Hitchance = HitChance.Medium;  	}  	if (input.RangeCheckFrom.Distance (result.UnitPosition' true) > Math.Pow (input.Range + (input.Type == SkillshotType.SkillshotCircle ? input.RealRadius : 0)' 2)) {  		result.Hitchance = HitChance.OutOfRange;  	}  	/* This does not need to be handled for the updated predictions' but left as a reference.*/if (input.RangeCheckFrom.Distance (result.CastPosition' true) > Math.Pow (input.Range' 2)) {  		if (result.Hitchance != HitChance.OutOfRange) {  			result.CastPosition = input.RangeCheckFrom + input.Range * (result.UnitPosition - input.RangeCheckFrom).To2D ().Normalized ().To3D ();  		} else {  			result.Hitchance = HitChance.OutOfRange;  		}  	}  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPrediction,The following statement contains a magic number: if (result.Hitchance >= HitChance.High && input.RangeCheckFrom.Distance (input.Unit.Position' true) > Math.Pow (input.Range + input.RealRadius * 3 / 4' 2)) {  	result.Hitchance = HitChance.Medium;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPrediction,The following statement contains a magic number: if (result.Hitchance >= HitChance.High && input.RangeCheckFrom.Distance (input.Unit.Position' true) > Math.Pow (input.Range + input.RealRadius * 3 / 4' 2)) {  	result.Hitchance = HitChance.Medium;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPrediction,The following statement contains a magic number: if (result.Hitchance >= HitChance.High && input.RangeCheckFrom.Distance (input.Unit.Position' true) > Math.Pow (input.Range + input.RealRadius * 3 / 4' 2)) {  	result.Hitchance = HitChance.Medium;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPrediction,The following statement contains a magic number: if (input.RangeCheckFrom.Distance (result.UnitPosition' true) > Math.Pow (input.Range + (input.Type == SkillshotType.SkillshotCircle ? input.RealRadius : 0)' 2)) {  	result.Hitchance = HitChance.OutOfRange;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPrediction,The following statement contains a magic number: if (input.RangeCheckFrom.Distance (result.CastPosition' true) > Math.Pow (input.Range' 2)) {  	if (result.Hitchance != HitChance.OutOfRange) {  		result.CastPosition = input.RangeCheckFrom + input.Range * (result.UnitPosition - input.RangeCheckFrom).To2D ().Normalized ().To3D ();  	} else {  		result.Hitchance = HitChance.OutOfRange;  	}  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetHitChance,The following statement contains a magic number: if (UnitTracker.GetLastNewPathTime (input.Unit) < 0.1d && hero.Distance (wayPoint) > 100) {  	return HitChance.VeryHigh;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetHitChance,The following statement contains a magic number: if (input.Radius > 70) {  	moveAngle++;  } else if (input.Radius <= 60) {  	moveAngle--;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetHitChance,The following statement contains a magic number: if (input.Radius > 70) {  	moveAngle++;  } else if (input.Radius <= 60) {  	moveAngle--;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetHitChance,The following statement contains a magic number: if (input.Radius <= 60) {  	moveAngle--;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetHitChance,The following statement contains a magic number: if (input.Delay < 0.3) {  	moveAngle++;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetHitChance,The following statement contains a magic number: if (UnitTracker.GetLastNewPathTime (input.Unit) < 0.1d) {  	fixRange = moveArea * 0.3f;  	minPath = 700 + moveArea;  	moveAngle += 1.5;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetHitChance,The following statement contains a magic number: if (UnitTracker.GetLastNewPathTime (input.Unit) < 0.1d) {  	fixRange = moveArea * 0.3f;  	minPath = 700 + moveArea;  	moveAngle += 1.5;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetHitChance,The following statement contains a magic number: minPath = 700 + moveArea;  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetHitChance,The following statement contains a magic number: moveAngle += 1.5;  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetHitChance,The following statement contains a magic number: if (input.Type == SkillshotType.SkillshotCircle) {  	fixRange -= input.Radius / 2;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetHitChance,The following statement contains a magic number: fixRange -= input.Radius / 2;  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetHitChance,The following statement contains a magic number: if (input.From.Distance (wayPoint) <= hero.Distance (input.From)) {  	if (hero.Distance (input.From) > input.Range - fixRange) {  		return HitChance.Medium;  	}  } else if (hero.Distance (wayPoint) > 350) {  	moveAngle += 1.5;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetHitChance,The following statement contains a magic number: if (input.From.Distance (wayPoint) <= hero.Distance (input.From)) {  	if (hero.Distance (input.From) > input.Range - fixRange) {  		return HitChance.Medium;  	}  } else if (hero.Distance (wayPoint) > 350) {  	moveAngle += 1.5;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetHitChance,The following statement contains a magic number: if (hero.Distance (wayPoint) > 350) {  	moveAngle += 1.5;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetHitChance,The following statement contains a magic number: if (hero.Distance (wayPoint) > 350) {  	moveAngle += 1.5;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetHitChance,The following statement contains a magic number: moveAngle += 1.5;  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetHitChance,The following statement contains a magic number: if (hero.Distance (input.From) < 250 || hero.MoveSpeed < 250 || input.From.Distance (wayPoint) < 250) {  	return HitChance.VeryHigh;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetHitChance,The following statement contains a magic number: if (hero.Distance (input.From) < 250 || hero.MoveSpeed < 250 || input.From.Distance (wayPoint) < 250) {  	return HitChance.VeryHigh;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetHitChance,The following statement contains a magic number: if (hero.Distance (input.From) < 250 || hero.MoveSpeed < 250 || input.From.Distance (wayPoint) < 250) {  	return HitChance.VeryHigh;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetHitChance,The following statement contains a magic number: if (hero.HealthPercent < 20 || ObjectManager.Player.HealthPercent < 20) {  	return HitChance.VeryHigh;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetHitChance,The following statement contains a magic number: if (hero.HealthPercent < 20 || ObjectManager.Player.HealthPercent < 20) {  	return HitChance.VeryHigh;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetHitChance,The following statement contains a magic number: if (GetAngle (input.From' input.Unit) < moveAngle && hero.Distance (wayPoint) > 260) {  	return HitChance.VeryHigh;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetDashingPrediction,The following statement contains a magic number: if (!dashData.IsBlink) {  	//Mid air:  	var endP = dashData.Path.Last ();  	var dashPred = GetPositionOnPath (input' new List<Vector2> {  		input.Unit.ServerPosition.To2D ()'  		endP  	}' dashData.Speed);  	if (dashPred.Hitchance >= HitChance.High && dashPred.UnitPosition.To2D ().Distance (input.Unit.Position.To2D ()' endP' true) < 200) {  		dashPred.CastPosition = dashPred.UnitPosition;  		dashPred.Hitchance = HitChance.Dashing;  		return dashPred;  	}  	//At the end of the dash:  	if (dashData.Path.PathLength () > 200) {  		var timeToPoint = input.Delay / 2f + input.From.To2D ().Distance (endP) / input.Speed - 0.25f;  		if (timeToPoint <= input.Unit.Distance (endP) / dashData.Speed + input.RealRadius / input.Unit.MoveSpeed) {  			return new PredictionOutput {  				CastPosition = endP.To3D ()'  				UnitPosition = endP.To3D ()'  				Hitchance = HitChance.Dashing  			};  		}  	}  	result.CastPosition = dashData.Path.Last ().To3D ();  	result.UnitPosition = result.CastPosition;  	//Figure out where the unit is going.  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetDashingPrediction,The following statement contains a magic number: if (!dashData.IsBlink) {  	//Mid air:  	var endP = dashData.Path.Last ();  	var dashPred = GetPositionOnPath (input' new List<Vector2> {  		input.Unit.ServerPosition.To2D ()'  		endP  	}' dashData.Speed);  	if (dashPred.Hitchance >= HitChance.High && dashPred.UnitPosition.To2D ().Distance (input.Unit.Position.To2D ()' endP' true) < 200) {  		dashPred.CastPosition = dashPred.UnitPosition;  		dashPred.Hitchance = HitChance.Dashing;  		return dashPred;  	}  	//At the end of the dash:  	if (dashData.Path.PathLength () > 200) {  		var timeToPoint = input.Delay / 2f + input.From.To2D ().Distance (endP) / input.Speed - 0.25f;  		if (timeToPoint <= input.Unit.Distance (endP) / dashData.Speed + input.RealRadius / input.Unit.MoveSpeed) {  			return new PredictionOutput {  				CastPosition = endP.To3D ()'  				UnitPosition = endP.To3D ()'  				Hitchance = HitChance.Dashing  			};  		}  	}  	result.CastPosition = dashData.Path.Last ().To3D ();  	result.UnitPosition = result.CastPosition;  	//Figure out where the unit is going.  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetDashingPrediction,The following statement contains a magic number: if (dashPred.Hitchance >= HitChance.High && dashPred.UnitPosition.To2D ().Distance (input.Unit.Position.To2D ()' endP' true) < 200) {  	dashPred.CastPosition = dashPred.UnitPosition;  	dashPred.Hitchance = HitChance.Dashing;  	return dashPred;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetDashingPrediction,The following statement contains a magic number: if (dashData.Path.PathLength () > 200) {  	var timeToPoint = input.Delay / 2f + input.From.To2D ().Distance (endP) / input.Speed - 0.25f;  	if (timeToPoint <= input.Unit.Distance (endP) / dashData.Speed + input.RealRadius / input.Unit.MoveSpeed) {  		return new PredictionOutput {  			CastPosition = endP.To3D ()'  			UnitPosition = endP.To3D ()'  			Hitchance = HitChance.Dashing  		};  	}  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetStandardPrediction,The following statement contains a magic number: if (input.Unit.Distance (input.From' true) < 200 * 200) {  	//input.Delay /= 2;  	speed /= 1.5f;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetStandardPrediction,The following statement contains a magic number: if (input.Unit.Distance (input.From' true) < 200 * 200) {  	//input.Delay /= 2;  	speed /= 1.5f;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetAngle,The following statement contains a magic number: if (C == A)  	return 60;  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetAngle,The following statement contains a magic number: return 60;  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetAngle,The following statement contains a magic number: return Math.Cos ((AB + BC - AC) / (2 * Math.Sqrt (AB) * Math.Sqrt (BC))) * 180 / Math.PI;  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetAngle,The following statement contains a magic number: return Math.Cos ((AB + BC - AC) / (2 * Math.Sqrt (AB) * Math.Sqrt (BC))) * 180 / Math.PI;  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,The following statement contains a magic number: if (pLength >= input.Delay * speed - input.RealRadius && Math.Abs (input.Speed - float.MaxValue) < float.Epsilon) {  	var tDistance = input.Delay * speed - input.RealRadius;  	for (var i = 0; i < path.Count - 1; i++) {  		var a = path [i];  		var b = path [i + 1];  		var d = a.Distance (b);  		if (d >= tDistance) {  			var direction = (b - a).Normalized ();  			var cp = a + direction * tDistance;  			var p = a + direction * ((i == path.Count - 2) ? Math.Min (tDistance + input.RealRadius' d) : (tDistance + input.RealRadius));  			return new PredictionOutput {  				Input = input'  				CastPosition = cp.To3D ()'  				UnitPosition = p.To3D ()'  				Hitchance = HitChance.High  			};  		}  		tDistance -= d;  	}  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,The following statement contains a magic number: for (var i = 0; i < path.Count - 1; i++) {  	var a = path [i];  	var b = path [i + 1];  	var d = a.Distance (b);  	if (d >= tDistance) {  		var direction = (b - a).Normalized ();  		var cp = a + direction * tDistance;  		var p = a + direction * ((i == path.Count - 2) ? Math.Min (tDistance + input.RealRadius' d) : (tDistance + input.RealRadius));  		return new PredictionOutput {  			Input = input'  			CastPosition = cp.To3D ()'  			UnitPosition = p.To3D ()'  			Hitchance = HitChance.High  		};  	}  	tDistance -= d;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,The following statement contains a magic number: if (d >= tDistance) {  	var direction = (b - a).Normalized ();  	var cp = a + direction * tDistance;  	var p = a + direction * ((i == path.Count - 2) ? Math.Min (tDistance + input.RealRadius' d) : (tDistance + input.RealRadius));  	return new PredictionOutput {  		Input = input'  		CastPosition = cp.To3D ()'  		UnitPosition = p.To3D ()'  		Hitchance = HitChance.High  	};  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,The following statement contains a magic number: if (pLength >= input.Delay * speed - input.RealRadius && Math.Abs (input.Speed - float.MaxValue) > float.Epsilon) {  	var d = input.Delay * speed - input.RealRadius;  	if (input.Type == SkillshotType.SkillshotLine || input.Type == SkillshotType.SkillshotCone) {  		if (input.From.Distance (input.Unit.ServerPosition' true) < 200 * 200) {  			d = input.Delay * speed;  		}  	}  	path = path.CutPath (d);  	var tT = 0f;  	for (var i = 0; i < path.Count - 1; i++) {  		var a = path [i];  		var b = path [i + 1];  		var tB = a.Distance (b) / speed;  		var direction = (b - a).Normalized ();  		a = a - speed * tT * direction;  		var sol = Geometry.VectorMovementCollision (a' b' speed' input.From.To2D ()' input.Speed' tT);  		var t = (float)sol [0];  		var pos = (Vector2)sol [1];  		if (pos.IsValid () && t >= tT && t <= tT + tB) {  			if (pos.Distance (b' true) < 20)  				break;  			var p = pos + input.RealRadius * direction;  			if (input.Type == SkillshotType.SkillshotLine && false) {  				var alpha = (input.From.To2D () - p).AngleBetween (a - b);  				if (alpha > 30 && alpha < 180 - 30) {  					var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  					var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  					var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  					pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  				}  			}  			return new PredictionOutput {  				Input = input'  				CastPosition = pos.To3D ()'  				UnitPosition = p.To3D ()'  				Hitchance = HitChance.High  			};  		}  		tT += tB;  	}  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,The following statement contains a magic number: if (pLength >= input.Delay * speed - input.RealRadius && Math.Abs (input.Speed - float.MaxValue) > float.Epsilon) {  	var d = input.Delay * speed - input.RealRadius;  	if (input.Type == SkillshotType.SkillshotLine || input.Type == SkillshotType.SkillshotCone) {  		if (input.From.Distance (input.Unit.ServerPosition' true) < 200 * 200) {  			d = input.Delay * speed;  		}  	}  	path = path.CutPath (d);  	var tT = 0f;  	for (var i = 0; i < path.Count - 1; i++) {  		var a = path [i];  		var b = path [i + 1];  		var tB = a.Distance (b) / speed;  		var direction = (b - a).Normalized ();  		a = a - speed * tT * direction;  		var sol = Geometry.VectorMovementCollision (a' b' speed' input.From.To2D ()' input.Speed' tT);  		var t = (float)sol [0];  		var pos = (Vector2)sol [1];  		if (pos.IsValid () && t >= tT && t <= tT + tB) {  			if (pos.Distance (b' true) < 20)  				break;  			var p = pos + input.RealRadius * direction;  			if (input.Type == SkillshotType.SkillshotLine && false) {  				var alpha = (input.From.To2D () - p).AngleBetween (a - b);  				if (alpha > 30 && alpha < 180 - 30) {  					var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  					var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  					var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  					pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  				}  			}  			return new PredictionOutput {  				Input = input'  				CastPosition = pos.To3D ()'  				UnitPosition = p.To3D ()'  				Hitchance = HitChance.High  			};  		}  		tT += tB;  	}  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,The following statement contains a magic number: if (pLength >= input.Delay * speed - input.RealRadius && Math.Abs (input.Speed - float.MaxValue) > float.Epsilon) {  	var d = input.Delay * speed - input.RealRadius;  	if (input.Type == SkillshotType.SkillshotLine || input.Type == SkillshotType.SkillshotCone) {  		if (input.From.Distance (input.Unit.ServerPosition' true) < 200 * 200) {  			d = input.Delay * speed;  		}  	}  	path = path.CutPath (d);  	var tT = 0f;  	for (var i = 0; i < path.Count - 1; i++) {  		var a = path [i];  		var b = path [i + 1];  		var tB = a.Distance (b) / speed;  		var direction = (b - a).Normalized ();  		a = a - speed * tT * direction;  		var sol = Geometry.VectorMovementCollision (a' b' speed' input.From.To2D ()' input.Speed' tT);  		var t = (float)sol [0];  		var pos = (Vector2)sol [1];  		if (pos.IsValid () && t >= tT && t <= tT + tB) {  			if (pos.Distance (b' true) < 20)  				break;  			var p = pos + input.RealRadius * direction;  			if (input.Type == SkillshotType.SkillshotLine && false) {  				var alpha = (input.From.To2D () - p).AngleBetween (a - b);  				if (alpha > 30 && alpha < 180 - 30) {  					var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  					var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  					var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  					pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  				}  			}  			return new PredictionOutput {  				Input = input'  				CastPosition = pos.To3D ()'  				UnitPosition = p.To3D ()'  				Hitchance = HitChance.High  			};  		}  		tT += tB;  	}  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,The following statement contains a magic number: if (pLength >= input.Delay * speed - input.RealRadius && Math.Abs (input.Speed - float.MaxValue) > float.Epsilon) {  	var d = input.Delay * speed - input.RealRadius;  	if (input.Type == SkillshotType.SkillshotLine || input.Type == SkillshotType.SkillshotCone) {  		if (input.From.Distance (input.Unit.ServerPosition' true) < 200 * 200) {  			d = input.Delay * speed;  		}  	}  	path = path.CutPath (d);  	var tT = 0f;  	for (var i = 0; i < path.Count - 1; i++) {  		var a = path [i];  		var b = path [i + 1];  		var tB = a.Distance (b) / speed;  		var direction = (b - a).Normalized ();  		a = a - speed * tT * direction;  		var sol = Geometry.VectorMovementCollision (a' b' speed' input.From.To2D ()' input.Speed' tT);  		var t = (float)sol [0];  		var pos = (Vector2)sol [1];  		if (pos.IsValid () && t >= tT && t <= tT + tB) {  			if (pos.Distance (b' true) < 20)  				break;  			var p = pos + input.RealRadius * direction;  			if (input.Type == SkillshotType.SkillshotLine && false) {  				var alpha = (input.From.To2D () - p).AngleBetween (a - b);  				if (alpha > 30 && alpha < 180 - 30) {  					var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  					var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  					var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  					pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  				}  			}  			return new PredictionOutput {  				Input = input'  				CastPosition = pos.To3D ()'  				UnitPosition = p.To3D ()'  				Hitchance = HitChance.High  			};  		}  		tT += tB;  	}  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,The following statement contains a magic number: if (pLength >= input.Delay * speed - input.RealRadius && Math.Abs (input.Speed - float.MaxValue) > float.Epsilon) {  	var d = input.Delay * speed - input.RealRadius;  	if (input.Type == SkillshotType.SkillshotLine || input.Type == SkillshotType.SkillshotCone) {  		if (input.From.Distance (input.Unit.ServerPosition' true) < 200 * 200) {  			d = input.Delay * speed;  		}  	}  	path = path.CutPath (d);  	var tT = 0f;  	for (var i = 0; i < path.Count - 1; i++) {  		var a = path [i];  		var b = path [i + 1];  		var tB = a.Distance (b) / speed;  		var direction = (b - a).Normalized ();  		a = a - speed * tT * direction;  		var sol = Geometry.VectorMovementCollision (a' b' speed' input.From.To2D ()' input.Speed' tT);  		var t = (float)sol [0];  		var pos = (Vector2)sol [1];  		if (pos.IsValid () && t >= tT && t <= tT + tB) {  			if (pos.Distance (b' true) < 20)  				break;  			var p = pos + input.RealRadius * direction;  			if (input.Type == SkillshotType.SkillshotLine && false) {  				var alpha = (input.From.To2D () - p).AngleBetween (a - b);  				if (alpha > 30 && alpha < 180 - 30) {  					var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  					var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  					var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  					pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  				}  			}  			return new PredictionOutput {  				Input = input'  				CastPosition = pos.To3D ()'  				UnitPosition = p.To3D ()'  				Hitchance = HitChance.High  			};  		}  		tT += tB;  	}  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,The following statement contains a magic number: if (pLength >= input.Delay * speed - input.RealRadius && Math.Abs (input.Speed - float.MaxValue) > float.Epsilon) {  	var d = input.Delay * speed - input.RealRadius;  	if (input.Type == SkillshotType.SkillshotLine || input.Type == SkillshotType.SkillshotCone) {  		if (input.From.Distance (input.Unit.ServerPosition' true) < 200 * 200) {  			d = input.Delay * speed;  		}  	}  	path = path.CutPath (d);  	var tT = 0f;  	for (var i = 0; i < path.Count - 1; i++) {  		var a = path [i];  		var b = path [i + 1];  		var tB = a.Distance (b) / speed;  		var direction = (b - a).Normalized ();  		a = a - speed * tT * direction;  		var sol = Geometry.VectorMovementCollision (a' b' speed' input.From.To2D ()' input.Speed' tT);  		var t = (float)sol [0];  		var pos = (Vector2)sol [1];  		if (pos.IsValid () && t >= tT && t <= tT + tB) {  			if (pos.Distance (b' true) < 20)  				break;  			var p = pos + input.RealRadius * direction;  			if (input.Type == SkillshotType.SkillshotLine && false) {  				var alpha = (input.From.To2D () - p).AngleBetween (a - b);  				if (alpha > 30 && alpha < 180 - 30) {  					var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  					var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  					var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  					pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  				}  			}  			return new PredictionOutput {  				Input = input'  				CastPosition = pos.To3D ()'  				UnitPosition = p.To3D ()'  				Hitchance = HitChance.High  			};  		}  		tT += tB;  	}  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,The following statement contains a magic number: if (input.Type == SkillshotType.SkillshotLine || input.Type == SkillshotType.SkillshotCone) {  	if (input.From.Distance (input.Unit.ServerPosition' true) < 200 * 200) {  		d = input.Delay * speed;  	}  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,The following statement contains a magic number: if (input.Type == SkillshotType.SkillshotLine || input.Type == SkillshotType.SkillshotCone) {  	if (input.From.Distance (input.Unit.ServerPosition' true) < 200 * 200) {  		d = input.Delay * speed;  	}  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,The following statement contains a magic number: if (input.From.Distance (input.Unit.ServerPosition' true) < 200 * 200) {  	d = input.Delay * speed;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,The following statement contains a magic number: if (input.From.Distance (input.Unit.ServerPosition' true) < 200 * 200) {  	d = input.Delay * speed;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,The following statement contains a magic number: for (var i = 0; i < path.Count - 1; i++) {  	var a = path [i];  	var b = path [i + 1];  	var tB = a.Distance (b) / speed;  	var direction = (b - a).Normalized ();  	a = a - speed * tT * direction;  	var sol = Geometry.VectorMovementCollision (a' b' speed' input.From.To2D ()' input.Speed' tT);  	var t = (float)sol [0];  	var pos = (Vector2)sol [1];  	if (pos.IsValid () && t >= tT && t <= tT + tB) {  		if (pos.Distance (b' true) < 20)  			break;  		var p = pos + input.RealRadius * direction;  		if (input.Type == SkillshotType.SkillshotLine && false) {  			var alpha = (input.From.To2D () - p).AngleBetween (a - b);  			if (alpha > 30 && alpha < 180 - 30) {  				var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  				var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  				var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  				pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  			}  		}  		return new PredictionOutput {  			Input = input'  			CastPosition = pos.To3D ()'  			UnitPosition = p.To3D ()'  			Hitchance = HitChance.High  		};  	}  	tT += tB;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,The following statement contains a magic number: for (var i = 0; i < path.Count - 1; i++) {  	var a = path [i];  	var b = path [i + 1];  	var tB = a.Distance (b) / speed;  	var direction = (b - a).Normalized ();  	a = a - speed * tT * direction;  	var sol = Geometry.VectorMovementCollision (a' b' speed' input.From.To2D ()' input.Speed' tT);  	var t = (float)sol [0];  	var pos = (Vector2)sol [1];  	if (pos.IsValid () && t >= tT && t <= tT + tB) {  		if (pos.Distance (b' true) < 20)  			break;  		var p = pos + input.RealRadius * direction;  		if (input.Type == SkillshotType.SkillshotLine && false) {  			var alpha = (input.From.To2D () - p).AngleBetween (a - b);  			if (alpha > 30 && alpha < 180 - 30) {  				var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  				var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  				var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  				pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  			}  		}  		return new PredictionOutput {  			Input = input'  			CastPosition = pos.To3D ()'  			UnitPosition = p.To3D ()'  			Hitchance = HitChance.High  		};  	}  	tT += tB;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,The following statement contains a magic number: for (var i = 0; i < path.Count - 1; i++) {  	var a = path [i];  	var b = path [i + 1];  	var tB = a.Distance (b) / speed;  	var direction = (b - a).Normalized ();  	a = a - speed * tT * direction;  	var sol = Geometry.VectorMovementCollision (a' b' speed' input.From.To2D ()' input.Speed' tT);  	var t = (float)sol [0];  	var pos = (Vector2)sol [1];  	if (pos.IsValid () && t >= tT && t <= tT + tB) {  		if (pos.Distance (b' true) < 20)  			break;  		var p = pos + input.RealRadius * direction;  		if (input.Type == SkillshotType.SkillshotLine && false) {  			var alpha = (input.From.To2D () - p).AngleBetween (a - b);  			if (alpha > 30 && alpha < 180 - 30) {  				var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  				var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  				var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  				pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  			}  		}  		return new PredictionOutput {  			Input = input'  			CastPosition = pos.To3D ()'  			UnitPosition = p.To3D ()'  			Hitchance = HitChance.High  		};  	}  	tT += tB;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,The following statement contains a magic number: for (var i = 0; i < path.Count - 1; i++) {  	var a = path [i];  	var b = path [i + 1];  	var tB = a.Distance (b) / speed;  	var direction = (b - a).Normalized ();  	a = a - speed * tT * direction;  	var sol = Geometry.VectorMovementCollision (a' b' speed' input.From.To2D ()' input.Speed' tT);  	var t = (float)sol [0];  	var pos = (Vector2)sol [1];  	if (pos.IsValid () && t >= tT && t <= tT + tB) {  		if (pos.Distance (b' true) < 20)  			break;  		var p = pos + input.RealRadius * direction;  		if (input.Type == SkillshotType.SkillshotLine && false) {  			var alpha = (input.From.To2D () - p).AngleBetween (a - b);  			if (alpha > 30 && alpha < 180 - 30) {  				var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  				var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  				var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  				pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  			}  		}  		return new PredictionOutput {  			Input = input'  			CastPosition = pos.To3D ()'  			UnitPosition = p.To3D ()'  			Hitchance = HitChance.High  		};  	}  	tT += tB;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,The following statement contains a magic number: if (pos.IsValid () && t >= tT && t <= tT + tB) {  	if (pos.Distance (b' true) < 20)  		break;  	var p = pos + input.RealRadius * direction;  	if (input.Type == SkillshotType.SkillshotLine && false) {  		var alpha = (input.From.To2D () - p).AngleBetween (a - b);  		if (alpha > 30 && alpha < 180 - 30) {  			var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  			var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  			var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  			pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  		}  	}  	return new PredictionOutput {  		Input = input'  		CastPosition = pos.To3D ()'  		UnitPosition = p.To3D ()'  		Hitchance = HitChance.High  	};  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,The following statement contains a magic number: if (pos.IsValid () && t >= tT && t <= tT + tB) {  	if (pos.Distance (b' true) < 20)  		break;  	var p = pos + input.RealRadius * direction;  	if (input.Type == SkillshotType.SkillshotLine && false) {  		var alpha = (input.From.To2D () - p).AngleBetween (a - b);  		if (alpha > 30 && alpha < 180 - 30) {  			var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  			var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  			var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  			pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  		}  	}  	return new PredictionOutput {  		Input = input'  		CastPosition = pos.To3D ()'  		UnitPosition = p.To3D ()'  		Hitchance = HitChance.High  	};  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,The following statement contains a magic number: if (pos.IsValid () && t >= tT && t <= tT + tB) {  	if (pos.Distance (b' true) < 20)  		break;  	var p = pos + input.RealRadius * direction;  	if (input.Type == SkillshotType.SkillshotLine && false) {  		var alpha = (input.From.To2D () - p).AngleBetween (a - b);  		if (alpha > 30 && alpha < 180 - 30) {  			var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  			var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  			var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  			pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  		}  	}  	return new PredictionOutput {  		Input = input'  		CastPosition = pos.To3D ()'  		UnitPosition = p.To3D ()'  		Hitchance = HitChance.High  	};  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,The following statement contains a magic number: if (pos.IsValid () && t >= tT && t <= tT + tB) {  	if (pos.Distance (b' true) < 20)  		break;  	var p = pos + input.RealRadius * direction;  	if (input.Type == SkillshotType.SkillshotLine && false) {  		var alpha = (input.From.To2D () - p).AngleBetween (a - b);  		if (alpha > 30 && alpha < 180 - 30) {  			var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  			var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  			var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  			pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  		}  	}  	return new PredictionOutput {  		Input = input'  		CastPosition = pos.To3D ()'  		UnitPosition = p.To3D ()'  		Hitchance = HitChance.High  	};  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,The following statement contains a magic number: if (pos.Distance (b' true) < 20)  	break;  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,The following statement contains a magic number: if (input.Type == SkillshotType.SkillshotLine && false) {  	var alpha = (input.From.To2D () - p).AngleBetween (a - b);  	if (alpha > 30 && alpha < 180 - 30) {  		var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  		var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  		var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  		pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  	}  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,The following statement contains a magic number: if (input.Type == SkillshotType.SkillshotLine && false) {  	var alpha = (input.From.To2D () - p).AngleBetween (a - b);  	if (alpha > 30 && alpha < 180 - 30) {  		var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  		var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  		var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  		pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  	}  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,The following statement contains a magic number: if (input.Type == SkillshotType.SkillshotLine && false) {  	var alpha = (input.From.To2D () - p).AngleBetween (a - b);  	if (alpha > 30 && alpha < 180 - 30) {  		var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  		var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  		var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  		pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  	}  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,The following statement contains a magic number: if (alpha > 30 && alpha < 180 - 30) {  	var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  	var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  	var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  	pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,The following statement contains a magic number: if (alpha > 30 && alpha < 180 - 30) {  	var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  	var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  	var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  	pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  }  
Magic Number,SebbyLib.Movement,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPositionOnPath,The following statement contains a magic number: if (alpha > 30 && alpha < 180 - 30) {  	var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  	var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  	var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  	pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  }  
Magic Number,SebbyLib.Movement,AoePrediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPossibleTargets,The following statement contains a magic number: foreach (var enemy in HeroManager.Enemies.FindAll (h => h.NetworkId != originalUnit.NetworkId && h.IsValidTarget ((input.Range + 200 + input.RealRadius)' true' input.RangeCheckFrom))) {  	input.Unit = enemy;  	var prediction = Prediction.GetPrediction (input' false' false);  	if (prediction.Hitchance >= HitChance.High) {  		result.Add (new PossibleTarget {  			Position = prediction.UnitPosition.To2D ()'  			Unit = enemy  		});  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var position in positions) {  	foreach (var objectType in input.CollisionObjects) {  		switch (objectType) {  		case CollisionableObjects.Minions:  			foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  				input.Unit = minion;  				var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  				if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else {  					var minionPos = minion.ServerPosition;  					int bonusRadius = 20;  					if (minion.IsMoving) {  						minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  						bonusRadius = 60 + (int)input.Radius;  					}  					if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  						if (MinionIsDead (input' minion' distanceFromToUnit))  							continue;  						else  							return true;  					}  				}  			}  			break;  		case CollisionableObjects.Heroes:  			foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  				input.Unit = hero;  				var prediction = Prediction.GetPrediction (input' false' false);  				if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  					return true;  				}  			}  			break;  		case CollisionableObjects.Walls:  			var step = position.Distance (input.From) / 20;  			for (var i = 0; i < 20; i++) {  				var p = input.From.To2D ().Extend (position.To2D ()' step * i);  				if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  					return true;  				}  			}  			break;  		}  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var position in positions) {  	foreach (var objectType in input.CollisionObjects) {  		switch (objectType) {  		case CollisionableObjects.Minions:  			foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  				input.Unit = minion;  				var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  				if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else {  					var minionPos = minion.ServerPosition;  					int bonusRadius = 20;  					if (minion.IsMoving) {  						minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  						bonusRadius = 60 + (int)input.Radius;  					}  					if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  						if (MinionIsDead (input' minion' distanceFromToUnit))  							continue;  						else  							return true;  					}  				}  			}  			break;  		case CollisionableObjects.Heroes:  			foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  				input.Unit = hero;  				var prediction = Prediction.GetPrediction (input' false' false);  				if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  					return true;  				}  			}  			break;  		case CollisionableObjects.Walls:  			var step = position.Distance (input.From) / 20;  			for (var i = 0; i < 20; i++) {  				var p = input.From.To2D ().Extend (position.To2D ()' step * i);  				if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  					return true;  				}  			}  			break;  		}  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var position in positions) {  	foreach (var objectType in input.CollisionObjects) {  		switch (objectType) {  		case CollisionableObjects.Minions:  			foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  				input.Unit = minion;  				var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  				if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else {  					var minionPos = minion.ServerPosition;  					int bonusRadius = 20;  					if (minion.IsMoving) {  						minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  						bonusRadius = 60 + (int)input.Radius;  					}  					if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  						if (MinionIsDead (input' minion' distanceFromToUnit))  							continue;  						else  							return true;  					}  				}  			}  			break;  		case CollisionableObjects.Heroes:  			foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  				input.Unit = hero;  				var prediction = Prediction.GetPrediction (input' false' false);  				if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  					return true;  				}  			}  			break;  		case CollisionableObjects.Walls:  			var step = position.Distance (input.From) / 20;  			for (var i = 0; i < 20; i++) {  				var p = input.From.To2D ().Extend (position.To2D ()' step * i);  				if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  					return true;  				}  			}  			break;  		}  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var position in positions) {  	foreach (var objectType in input.CollisionObjects) {  		switch (objectType) {  		case CollisionableObjects.Minions:  			foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  				input.Unit = minion;  				var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  				if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else {  					var minionPos = minion.ServerPosition;  					int bonusRadius = 20;  					if (minion.IsMoving) {  						minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  						bonusRadius = 60 + (int)input.Radius;  					}  					if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  						if (MinionIsDead (input' minion' distanceFromToUnit))  							continue;  						else  							return true;  					}  				}  			}  			break;  		case CollisionableObjects.Heroes:  			foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  				input.Unit = hero;  				var prediction = Prediction.GetPrediction (input' false' false);  				if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  					return true;  				}  			}  			break;  		case CollisionableObjects.Walls:  			var step = position.Distance (input.From) / 20;  			for (var i = 0; i < 20; i++) {  				var p = input.From.To2D ().Extend (position.To2D ()' step * i);  				if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  					return true;  				}  			}  			break;  		}  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var position in positions) {  	foreach (var objectType in input.CollisionObjects) {  		switch (objectType) {  		case CollisionableObjects.Minions:  			foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  				input.Unit = minion;  				var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  				if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else {  					var minionPos = minion.ServerPosition;  					int bonusRadius = 20;  					if (minion.IsMoving) {  						minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  						bonusRadius = 60 + (int)input.Radius;  					}  					if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  						if (MinionIsDead (input' minion' distanceFromToUnit))  							continue;  						else  							return true;  					}  				}  			}  			break;  		case CollisionableObjects.Heroes:  			foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  				input.Unit = hero;  				var prediction = Prediction.GetPrediction (input' false' false);  				if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  					return true;  				}  			}  			break;  		case CollisionableObjects.Walls:  			var step = position.Distance (input.From) / 20;  			for (var i = 0; i < 20; i++) {  				var p = input.From.To2D ().Extend (position.To2D ()' step * i);  				if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  					return true;  				}  			}  			break;  		}  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var position in positions) {  	foreach (var objectType in input.CollisionObjects) {  		switch (objectType) {  		case CollisionableObjects.Minions:  			foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  				input.Unit = minion;  				var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  				if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else {  					var minionPos = minion.ServerPosition;  					int bonusRadius = 20;  					if (minion.IsMoving) {  						minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  						bonusRadius = 60 + (int)input.Radius;  					}  					if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  						if (MinionIsDead (input' minion' distanceFromToUnit))  							continue;  						else  							return true;  					}  				}  			}  			break;  		case CollisionableObjects.Heroes:  			foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  				input.Unit = hero;  				var prediction = Prediction.GetPrediction (input' false' false);  				if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  					return true;  				}  			}  			break;  		case CollisionableObjects.Walls:  			var step = position.Distance (input.From) / 20;  			for (var i = 0; i < 20; i++) {  				var p = input.From.To2D ().Extend (position.To2D ()' step * i);  				if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  					return true;  				}  			}  			break;  		}  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var position in positions) {  	foreach (var objectType in input.CollisionObjects) {  		switch (objectType) {  		case CollisionableObjects.Minions:  			foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  				input.Unit = minion;  				var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  				if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else {  					var minionPos = minion.ServerPosition;  					int bonusRadius = 20;  					if (minion.IsMoving) {  						minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  						bonusRadius = 60 + (int)input.Radius;  					}  					if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  						if (MinionIsDead (input' minion' distanceFromToUnit))  							continue;  						else  							return true;  					}  				}  			}  			break;  		case CollisionableObjects.Heroes:  			foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  				input.Unit = hero;  				var prediction = Prediction.GetPrediction (input' false' false);  				if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  					return true;  				}  			}  			break;  		case CollisionableObjects.Walls:  			var step = position.Distance (input.From) / 20;  			for (var i = 0; i < 20; i++) {  				var p = input.From.To2D ().Extend (position.To2D ()' step * i);  				if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  					return true;  				}  			}  			break;  		}  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var position in positions) {  	foreach (var objectType in input.CollisionObjects) {  		switch (objectType) {  		case CollisionableObjects.Minions:  			foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  				input.Unit = minion;  				var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  				if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else {  					var minionPos = minion.ServerPosition;  					int bonusRadius = 20;  					if (minion.IsMoving) {  						minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  						bonusRadius = 60 + (int)input.Radius;  					}  					if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  						if (MinionIsDead (input' minion' distanceFromToUnit))  							continue;  						else  							return true;  					}  				}  			}  			break;  		case CollisionableObjects.Heroes:  			foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  				input.Unit = hero;  				var prediction = Prediction.GetPrediction (input' false' false);  				if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  					return true;  				}  			}  			break;  		case CollisionableObjects.Walls:  			var step = position.Distance (input.From) / 20;  			for (var i = 0; i < 20; i++) {  				var p = input.From.To2D ().Extend (position.To2D ()' step * i);  				if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  					return true;  				}  			}  			break;  		}  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var position in positions) {  	foreach (var objectType in input.CollisionObjects) {  		switch (objectType) {  		case CollisionableObjects.Minions:  			foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  				input.Unit = minion;  				var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  				if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else {  					var minionPos = minion.ServerPosition;  					int bonusRadius = 20;  					if (minion.IsMoving) {  						minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  						bonusRadius = 60 + (int)input.Radius;  					}  					if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  						if (MinionIsDead (input' minion' distanceFromToUnit))  							continue;  						else  							return true;  					}  				}  			}  			break;  		case CollisionableObjects.Heroes:  			foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  				input.Unit = hero;  				var prediction = Prediction.GetPrediction (input' false' false);  				if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  					return true;  				}  			}  			break;  		case CollisionableObjects.Walls:  			var step = position.Distance (input.From) / 20;  			for (var i = 0; i < 20; i++) {  				var p = input.From.To2D ().Extend (position.To2D ()' step * i);  				if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  					return true;  				}  			}  			break;  		}  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var position in positions) {  	foreach (var objectType in input.CollisionObjects) {  		switch (objectType) {  		case CollisionableObjects.Minions:  			foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  				input.Unit = minion;  				var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  				if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else {  					var minionPos = minion.ServerPosition;  					int bonusRadius = 20;  					if (minion.IsMoving) {  						minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  						bonusRadius = 60 + (int)input.Radius;  					}  					if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  						if (MinionIsDead (input' minion' distanceFromToUnit))  							continue;  						else  							return true;  					}  				}  			}  			break;  		case CollisionableObjects.Heroes:  			foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  				input.Unit = hero;  				var prediction = Prediction.GetPrediction (input' false' false);  				if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  					return true;  				}  			}  			break;  		case CollisionableObjects.Walls:  			var step = position.Distance (input.From) / 20;  			for (var i = 0; i < 20; i++) {  				var p = input.From.To2D ().Extend (position.To2D ()' step * i);  				if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  					return true;  				}  			}  			break;  		}  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var position in positions) {  	foreach (var objectType in input.CollisionObjects) {  		switch (objectType) {  		case CollisionableObjects.Minions:  			foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  				input.Unit = minion;  				var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  				if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else {  					var minionPos = minion.ServerPosition;  					int bonusRadius = 20;  					if (minion.IsMoving) {  						minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  						bonusRadius = 60 + (int)input.Radius;  					}  					if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  						if (MinionIsDead (input' minion' distanceFromToUnit))  							continue;  						else  							return true;  					}  				}  			}  			break;  		case CollisionableObjects.Heroes:  			foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  				input.Unit = hero;  				var prediction = Prediction.GetPrediction (input' false' false);  				if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  					return true;  				}  			}  			break;  		case CollisionableObjects.Walls:  			var step = position.Distance (input.From) / 20;  			for (var i = 0; i < 20; i++) {  				var p = input.From.To2D ().Extend (position.To2D ()' step * i);  				if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  					return true;  				}  			}  			break;  		}  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var objectType in input.CollisionObjects) {  	switch (objectType) {  	case CollisionableObjects.Minions:  		foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  			input.Unit = minion;  			var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  			if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else {  				var minionPos = minion.ServerPosition;  				int bonusRadius = 20;  				if (minion.IsMoving) {  					minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  					bonusRadius = 60 + (int)input.Radius;  				}  				if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				}  			}  		}  		break;  	case CollisionableObjects.Heroes:  		foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  			input.Unit = hero;  			var prediction = Prediction.GetPrediction (input' false' false);  			if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  				return true;  			}  		}  		break;  	case CollisionableObjects.Walls:  		var step = position.Distance (input.From) / 20;  		for (var i = 0; i < 20; i++) {  			var p = input.From.To2D ().Extend (position.To2D ()' step * i);  			if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  				return true;  			}  		}  		break;  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var objectType in input.CollisionObjects) {  	switch (objectType) {  	case CollisionableObjects.Minions:  		foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  			input.Unit = minion;  			var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  			if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else {  				var minionPos = minion.ServerPosition;  				int bonusRadius = 20;  				if (minion.IsMoving) {  					minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  					bonusRadius = 60 + (int)input.Radius;  				}  				if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				}  			}  		}  		break;  	case CollisionableObjects.Heroes:  		foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  			input.Unit = hero;  			var prediction = Prediction.GetPrediction (input' false' false);  			if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  				return true;  			}  		}  		break;  	case CollisionableObjects.Walls:  		var step = position.Distance (input.From) / 20;  		for (var i = 0; i < 20; i++) {  			var p = input.From.To2D ().Extend (position.To2D ()' step * i);  			if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  				return true;  			}  		}  		break;  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var objectType in input.CollisionObjects) {  	switch (objectType) {  	case CollisionableObjects.Minions:  		foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  			input.Unit = minion;  			var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  			if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else {  				var minionPos = minion.ServerPosition;  				int bonusRadius = 20;  				if (minion.IsMoving) {  					minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  					bonusRadius = 60 + (int)input.Radius;  				}  				if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				}  			}  		}  		break;  	case CollisionableObjects.Heroes:  		foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  			input.Unit = hero;  			var prediction = Prediction.GetPrediction (input' false' false);  			if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  				return true;  			}  		}  		break;  	case CollisionableObjects.Walls:  		var step = position.Distance (input.From) / 20;  		for (var i = 0; i < 20; i++) {  			var p = input.From.To2D ().Extend (position.To2D ()' step * i);  			if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  				return true;  			}  		}  		break;  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var objectType in input.CollisionObjects) {  	switch (objectType) {  	case CollisionableObjects.Minions:  		foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  			input.Unit = minion;  			var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  			if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else {  				var minionPos = minion.ServerPosition;  				int bonusRadius = 20;  				if (minion.IsMoving) {  					minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  					bonusRadius = 60 + (int)input.Radius;  				}  				if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				}  			}  		}  		break;  	case CollisionableObjects.Heroes:  		foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  			input.Unit = hero;  			var prediction = Prediction.GetPrediction (input' false' false);  			if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  				return true;  			}  		}  		break;  	case CollisionableObjects.Walls:  		var step = position.Distance (input.From) / 20;  		for (var i = 0; i < 20; i++) {  			var p = input.From.To2D ().Extend (position.To2D ()' step * i);  			if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  				return true;  			}  		}  		break;  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var objectType in input.CollisionObjects) {  	switch (objectType) {  	case CollisionableObjects.Minions:  		foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  			input.Unit = minion;  			var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  			if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else {  				var minionPos = minion.ServerPosition;  				int bonusRadius = 20;  				if (minion.IsMoving) {  					minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  					bonusRadius = 60 + (int)input.Radius;  				}  				if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				}  			}  		}  		break;  	case CollisionableObjects.Heroes:  		foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  			input.Unit = hero;  			var prediction = Prediction.GetPrediction (input' false' false);  			if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  				return true;  			}  		}  		break;  	case CollisionableObjects.Walls:  		var step = position.Distance (input.From) / 20;  		for (var i = 0; i < 20; i++) {  			var p = input.From.To2D ().Extend (position.To2D ()' step * i);  			if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  				return true;  			}  		}  		break;  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var objectType in input.CollisionObjects) {  	switch (objectType) {  	case CollisionableObjects.Minions:  		foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  			input.Unit = minion;  			var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  			if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else {  				var minionPos = minion.ServerPosition;  				int bonusRadius = 20;  				if (minion.IsMoving) {  					minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  					bonusRadius = 60 + (int)input.Radius;  				}  				if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				}  			}  		}  		break;  	case CollisionableObjects.Heroes:  		foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  			input.Unit = hero;  			var prediction = Prediction.GetPrediction (input' false' false);  			if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  				return true;  			}  		}  		break;  	case CollisionableObjects.Walls:  		var step = position.Distance (input.From) / 20;  		for (var i = 0; i < 20; i++) {  			var p = input.From.To2D ().Extend (position.To2D ()' step * i);  			if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  				return true;  			}  		}  		break;  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var objectType in input.CollisionObjects) {  	switch (objectType) {  	case CollisionableObjects.Minions:  		foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  			input.Unit = minion;  			var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  			if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else {  				var minionPos = minion.ServerPosition;  				int bonusRadius = 20;  				if (minion.IsMoving) {  					minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  					bonusRadius = 60 + (int)input.Radius;  				}  				if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				}  			}  		}  		break;  	case CollisionableObjects.Heroes:  		foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  			input.Unit = hero;  			var prediction = Prediction.GetPrediction (input' false' false);  			if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  				return true;  			}  		}  		break;  	case CollisionableObjects.Walls:  		var step = position.Distance (input.From) / 20;  		for (var i = 0; i < 20; i++) {  			var p = input.From.To2D ().Extend (position.To2D ()' step * i);  			if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  				return true;  			}  		}  		break;  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var objectType in input.CollisionObjects) {  	switch (objectType) {  	case CollisionableObjects.Minions:  		foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  			input.Unit = minion;  			var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  			if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else {  				var minionPos = minion.ServerPosition;  				int bonusRadius = 20;  				if (minion.IsMoving) {  					minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  					bonusRadius = 60 + (int)input.Radius;  				}  				if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				}  			}  		}  		break;  	case CollisionableObjects.Heroes:  		foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  			input.Unit = hero;  			var prediction = Prediction.GetPrediction (input' false' false);  			if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  				return true;  			}  		}  		break;  	case CollisionableObjects.Walls:  		var step = position.Distance (input.From) / 20;  		for (var i = 0; i < 20; i++) {  			var p = input.From.To2D ().Extend (position.To2D ()' step * i);  			if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  				return true;  			}  		}  		break;  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var objectType in input.CollisionObjects) {  	switch (objectType) {  	case CollisionableObjects.Minions:  		foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  			input.Unit = minion;  			var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  			if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else {  				var minionPos = minion.ServerPosition;  				int bonusRadius = 20;  				if (minion.IsMoving) {  					minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  					bonusRadius = 60 + (int)input.Radius;  				}  				if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				}  			}  		}  		break;  	case CollisionableObjects.Heroes:  		foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  			input.Unit = hero;  			var prediction = Prediction.GetPrediction (input' false' false);  			if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  				return true;  			}  		}  		break;  	case CollisionableObjects.Walls:  		var step = position.Distance (input.From) / 20;  		for (var i = 0; i < 20; i++) {  			var p = input.From.To2D ().Extend (position.To2D ()' step * i);  			if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  				return true;  			}  		}  		break;  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var objectType in input.CollisionObjects) {  	switch (objectType) {  	case CollisionableObjects.Minions:  		foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  			input.Unit = minion;  			var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  			if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else {  				var minionPos = minion.ServerPosition;  				int bonusRadius = 20;  				if (minion.IsMoving) {  					minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  					bonusRadius = 60 + (int)input.Radius;  				}  				if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				}  			}  		}  		break;  	case CollisionableObjects.Heroes:  		foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  			input.Unit = hero;  			var prediction = Prediction.GetPrediction (input' false' false);  			if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  				return true;  			}  		}  		break;  	case CollisionableObjects.Walls:  		var step = position.Distance (input.From) / 20;  		for (var i = 0; i < 20; i++) {  			var p = input.From.To2D ().Extend (position.To2D ()' step * i);  			if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  				return true;  			}  		}  		break;  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var objectType in input.CollisionObjects) {  	switch (objectType) {  	case CollisionableObjects.Minions:  		foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  			input.Unit = minion;  			var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  			if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else {  				var minionPos = minion.ServerPosition;  				int bonusRadius = 20;  				if (minion.IsMoving) {  					minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  					bonusRadius = 60 + (int)input.Radius;  				}  				if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				}  			}  		}  		break;  	case CollisionableObjects.Heroes:  		foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  			input.Unit = hero;  			var prediction = Prediction.GetPrediction (input' false' false);  			if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  				return true;  			}  		}  		break;  	case CollisionableObjects.Walls:  		var step = position.Distance (input.From) / 20;  		for (var i = 0; i < 20; i++) {  			var p = input.From.To2D ().Extend (position.To2D ()' step * i);  			if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  				return true;  			}  		}  		break;  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: switch (objectType) {  case CollisionableObjects.Minions:  	foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  		input.Unit = minion;  		var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  		if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else {  			var minionPos = minion.ServerPosition;  			int bonusRadius = 20;  			if (minion.IsMoving) {  				minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  				bonusRadius = 60 + (int)input.Radius;  			}  			if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			}  		}  	}  	break;  case CollisionableObjects.Heroes:  	foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  		input.Unit = hero;  		var prediction = Prediction.GetPrediction (input' false' false);  		if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  			return true;  		}  	}  	break;  case CollisionableObjects.Walls:  	var step = position.Distance (input.From) / 20;  	for (var i = 0; i < 20; i++) {  		var p = input.From.To2D ().Extend (position.To2D ()' step * i);  		if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  			return true;  		}  	}  	break;  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: switch (objectType) {  case CollisionableObjects.Minions:  	foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  		input.Unit = minion;  		var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  		if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else {  			var minionPos = minion.ServerPosition;  			int bonusRadius = 20;  			if (minion.IsMoving) {  				minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  				bonusRadius = 60 + (int)input.Radius;  			}  			if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			}  		}  	}  	break;  case CollisionableObjects.Heroes:  	foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  		input.Unit = hero;  		var prediction = Prediction.GetPrediction (input' false' false);  		if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  			return true;  		}  	}  	break;  case CollisionableObjects.Walls:  	var step = position.Distance (input.From) / 20;  	for (var i = 0; i < 20; i++) {  		var p = input.From.To2D ().Extend (position.To2D ()' step * i);  		if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  			return true;  		}  	}  	break;  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: switch (objectType) {  case CollisionableObjects.Minions:  	foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  		input.Unit = minion;  		var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  		if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else {  			var minionPos = minion.ServerPosition;  			int bonusRadius = 20;  			if (minion.IsMoving) {  				minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  				bonusRadius = 60 + (int)input.Radius;  			}  			if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			}  		}  	}  	break;  case CollisionableObjects.Heroes:  	foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  		input.Unit = hero;  		var prediction = Prediction.GetPrediction (input' false' false);  		if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  			return true;  		}  	}  	break;  case CollisionableObjects.Walls:  	var step = position.Distance (input.From) / 20;  	for (var i = 0; i < 20; i++) {  		var p = input.From.To2D ().Extend (position.To2D ()' step * i);  		if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  			return true;  		}  	}  	break;  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: switch (objectType) {  case CollisionableObjects.Minions:  	foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  		input.Unit = minion;  		var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  		if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else {  			var minionPos = minion.ServerPosition;  			int bonusRadius = 20;  			if (minion.IsMoving) {  				minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  				bonusRadius = 60 + (int)input.Radius;  			}  			if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			}  		}  	}  	break;  case CollisionableObjects.Heroes:  	foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  		input.Unit = hero;  		var prediction = Prediction.GetPrediction (input' false' false);  		if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  			return true;  		}  	}  	break;  case CollisionableObjects.Walls:  	var step = position.Distance (input.From) / 20;  	for (var i = 0; i < 20; i++) {  		var p = input.From.To2D ().Extend (position.To2D ()' step * i);  		if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  			return true;  		}  	}  	break;  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: switch (objectType) {  case CollisionableObjects.Minions:  	foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  		input.Unit = minion;  		var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  		if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else {  			var minionPos = minion.ServerPosition;  			int bonusRadius = 20;  			if (minion.IsMoving) {  				minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  				bonusRadius = 60 + (int)input.Radius;  			}  			if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			}  		}  	}  	break;  case CollisionableObjects.Heroes:  	foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  		input.Unit = hero;  		var prediction = Prediction.GetPrediction (input' false' false);  		if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  			return true;  		}  	}  	break;  case CollisionableObjects.Walls:  	var step = position.Distance (input.From) / 20;  	for (var i = 0; i < 20; i++) {  		var p = input.From.To2D ().Extend (position.To2D ()' step * i);  		if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  			return true;  		}  	}  	break;  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: switch (objectType) {  case CollisionableObjects.Minions:  	foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  		input.Unit = minion;  		var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  		if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else {  			var minionPos = minion.ServerPosition;  			int bonusRadius = 20;  			if (minion.IsMoving) {  				minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  				bonusRadius = 60 + (int)input.Radius;  			}  			if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			}  		}  	}  	break;  case CollisionableObjects.Heroes:  	foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  		input.Unit = hero;  		var prediction = Prediction.GetPrediction (input' false' false);  		if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  			return true;  		}  	}  	break;  case CollisionableObjects.Walls:  	var step = position.Distance (input.From) / 20;  	for (var i = 0; i < 20; i++) {  		var p = input.From.To2D ().Extend (position.To2D ()' step * i);  		if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  			return true;  		}  	}  	break;  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: switch (objectType) {  case CollisionableObjects.Minions:  	foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  		input.Unit = minion;  		var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  		if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else {  			var minionPos = minion.ServerPosition;  			int bonusRadius = 20;  			if (minion.IsMoving) {  				minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  				bonusRadius = 60 + (int)input.Radius;  			}  			if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			}  		}  	}  	break;  case CollisionableObjects.Heroes:  	foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  		input.Unit = hero;  		var prediction = Prediction.GetPrediction (input' false' false);  		if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  			return true;  		}  	}  	break;  case CollisionableObjects.Walls:  	var step = position.Distance (input.From) / 20;  	for (var i = 0; i < 20; i++) {  		var p = input.From.To2D ().Extend (position.To2D ()' step * i);  		if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  			return true;  		}  	}  	break;  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: switch (objectType) {  case CollisionableObjects.Minions:  	foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  		input.Unit = minion;  		var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  		if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else {  			var minionPos = minion.ServerPosition;  			int bonusRadius = 20;  			if (minion.IsMoving) {  				minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  				bonusRadius = 60 + (int)input.Radius;  			}  			if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			}  		}  	}  	break;  case CollisionableObjects.Heroes:  	foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  		input.Unit = hero;  		var prediction = Prediction.GetPrediction (input' false' false);  		if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  			return true;  		}  	}  	break;  case CollisionableObjects.Walls:  	var step = position.Distance (input.From) / 20;  	for (var i = 0; i < 20; i++) {  		var p = input.From.To2D ().Extend (position.To2D ()' step * i);  		if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  			return true;  		}  	}  	break;  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: switch (objectType) {  case CollisionableObjects.Minions:  	foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  		input.Unit = minion;  		var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  		if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else {  			var minionPos = minion.ServerPosition;  			int bonusRadius = 20;  			if (minion.IsMoving) {  				minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  				bonusRadius = 60 + (int)input.Radius;  			}  			if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			}  		}  	}  	break;  case CollisionableObjects.Heroes:  	foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  		input.Unit = hero;  		var prediction = Prediction.GetPrediction (input' false' false);  		if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  			return true;  		}  	}  	break;  case CollisionableObjects.Walls:  	var step = position.Distance (input.From) / 20;  	for (var i = 0; i < 20; i++) {  		var p = input.From.To2D ().Extend (position.To2D ()' step * i);  		if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  			return true;  		}  	}  	break;  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: switch (objectType) {  case CollisionableObjects.Minions:  	foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  		input.Unit = minion;  		var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  		if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else {  			var minionPos = minion.ServerPosition;  			int bonusRadius = 20;  			if (minion.IsMoving) {  				minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  				bonusRadius = 60 + (int)input.Radius;  			}  			if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			}  		}  	}  	break;  case CollisionableObjects.Heroes:  	foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  		input.Unit = hero;  		var prediction = Prediction.GetPrediction (input' false' false);  		if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  			return true;  		}  	}  	break;  case CollisionableObjects.Walls:  	var step = position.Distance (input.From) / 20;  	for (var i = 0; i < 20; i++) {  		var p = input.From.To2D ().Extend (position.To2D ()' step * i);  		if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  			return true;  		}  	}  	break;  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: switch (objectType) {  case CollisionableObjects.Minions:  	foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  		input.Unit = minion;  		var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  		if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else {  			var minionPos = minion.ServerPosition;  			int bonusRadius = 20;  			if (minion.IsMoving) {  				minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  				bonusRadius = 60 + (int)input.Radius;  			}  			if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			}  		}  	}  	break;  case CollisionableObjects.Heroes:  	foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  		input.Unit = hero;  		var prediction = Prediction.GetPrediction (input' false' false);  		if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  			return true;  		}  	}  	break;  case CollisionableObjects.Walls:  	var step = position.Distance (input.From) / 20;  	for (var i = 0; i < 20; i++) {  		var p = input.From.To2D ().Extend (position.To2D ()' step * i);  		if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  			return true;  		}  	}  	break;  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  	input.Unit = minion;  	var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  	if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	} else {  		var minionPos = minion.ServerPosition;  		int bonusRadius = 20;  		if (minion.IsMoving) {  			minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  			bonusRadius = 60 + (int)input.Radius;  		}  		if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		}  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  	input.Unit = minion;  	var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  	if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	} else {  		var minionPos = minion.ServerPosition;  		int bonusRadius = 20;  		if (minion.IsMoving) {  			minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  			bonusRadius = 60 + (int)input.Radius;  		}  		if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		}  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  	input.Unit = minion;  	var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  	if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	} else {  		var minionPos = minion.ServerPosition;  		int bonusRadius = 20;  		if (minion.IsMoving) {  			minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  			bonusRadius = 60 + (int)input.Radius;  		}  		if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		}  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  	input.Unit = minion;  	var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  	if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	} else {  		var minionPos = minion.ServerPosition;  		int bonusRadius = 20;  		if (minion.IsMoving) {  			minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  			bonusRadius = 60 + (int)input.Radius;  		}  		if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		}  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  	input.Unit = minion;  	var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  	if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	} else {  		var minionPos = minion.ServerPosition;  		int bonusRadius = 20;  		if (minion.IsMoving) {  			minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  			bonusRadius = 60 + (int)input.Radius;  		}  		if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		}  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  	if (MinionIsDead (input' minion' distanceFromToUnit))  		continue;  	else  		return true;  } else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  	if (MinionIsDead (input' minion' distanceFromToUnit))  		continue;  	else  		return true;  } else {  	var minionPos = minion.ServerPosition;  	int bonusRadius = 20;  	if (minion.IsMoving) {  		minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  		bonusRadius = 60 + (int)input.Radius;  	}  	if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  	if (MinionIsDead (input' minion' distanceFromToUnit))  		continue;  	else  		return true;  } else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  	if (MinionIsDead (input' minion' distanceFromToUnit))  		continue;  	else  		return true;  } else {  	var minionPos = minion.ServerPosition;  	int bonusRadius = 20;  	if (minion.IsMoving) {  		minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  		bonusRadius = 60 + (int)input.Radius;  	}  	if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  	if (MinionIsDead (input' minion' distanceFromToUnit))  		continue;  	else  		return true;  } else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  	if (MinionIsDead (input' minion' distanceFromToUnit))  		continue;  	else  		return true;  } else {  	var minionPos = minion.ServerPosition;  	int bonusRadius = 20;  	if (minion.IsMoving) {  		minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  		bonusRadius = 60 + (int)input.Radius;  	}  	if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  	if (MinionIsDead (input' minion' distanceFromToUnit))  		continue;  	else  		return true;  } else {  	var minionPos = minion.ServerPosition;  	int bonusRadius = 20;  	if (minion.IsMoving) {  		minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  		bonusRadius = 60 + (int)input.Radius;  	}  	if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  	if (MinionIsDead (input' minion' distanceFromToUnit))  		continue;  	else  		return true;  } else {  	var minionPos = minion.ServerPosition;  	int bonusRadius = 20;  	if (minion.IsMoving) {  		minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  		bonusRadius = 60 + (int)input.Radius;  	}  	if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  	if (MinionIsDead (input' minion' distanceFromToUnit))  		continue;  	else  		return true;  } else {  	var minionPos = minion.ServerPosition;  	int bonusRadius = 20;  	if (minion.IsMoving) {  		minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  		bonusRadius = 60 + (int)input.Radius;  	}  	if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: if (minion.IsMoving) {  	minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  	bonusRadius = 60 + (int)input.Radius;  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: bonusRadius = 60 + (int)input.Radius;  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  	if (MinionIsDead (input' minion' distanceFromToUnit))  		continue;  	else  		return true;  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  	input.Unit = hero;  	var prediction = Prediction.GetPrediction (input' false' false);  	if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  		return true;  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  	input.Unit = hero;  	var prediction = Prediction.GetPrediction (input' false' false);  	if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  		return true;  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  	input.Unit = hero;  	var prediction = Prediction.GetPrediction (input' false' false);  	if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  		return true;  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  	input.Unit = hero;  	var prediction = Prediction.GetPrediction (input' false' false);  	if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  		return true;  	}  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  	return true;  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  	return true;  }  
Magic Number,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following statement contains a magic number: for (var i = 0; i < 20; i++) {  	var p = input.From.To2D ().Extend (position.To2D ()' step * i);  	if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  		return true;  	}  }  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,UnitTracker,The following statement contains a magic number: spells.Add (new Spells () {  	name = "consume"'  	duration = 0.5  });  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,UnitTracker,The following statement contains a magic number: spells.Add (new Spells () {  	name = "staticfield"'  	duration = 0.5  });  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,UnitTracker,The following statement contains a magic number: spells.Add (new Spells () {  	name = "cassiopeiapetrifyinggaze"'  	duration = 0.5  });  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,UnitTracker,The following statement contains a magic number: spells.Add (new Spells () {  	name = "jinxw"'  	duration = 0.6  });  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,UnitTracker,The following statement contains a magic number: spells.Add (new Spells () {  	name = "jinxr"'  	duration = 0.6  });  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,UnitTracker,The following statement contains a magic number: spells.Add (new Spells () {  	name = "threshe"'  	duration = 0.4  });  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,UnitTracker,The following statement contains a magic number: spells.Add (new Spells () {  	name = "threshrpenta"'  	duration = 0.75  });  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,UnitTracker,The following statement contains a magic number: spells.Add (new Spells () {  	name = "threshq"'  	duration = 0.75  });  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,UnitTracker,The following statement contains a magic number: spells.Add (new Spells () {  	name = "lucianq"'  	duration = 0.5  });  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,UnitTracker,The following statement contains a magic number: spells.Add (new Spells () {  	name = "caitlynpiltoverpeacemaker"'  	duration = 0.5  });  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,UnitTracker,The following statement contains a magic number: spells.Add (new Spells () {  	name = "velkozr"'  	duration = 0.5  });  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,UnitTracker,The following statement contains a magic number: spells.Add (new Spells () {  	name = "jhinr"'  	duration = 2  });  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,Obj_AI_Hero_OnNewPath,The following statement contains a magic number: if (info.PathBank.Count > 3)  	info.PathBank.Remove (info.PathBank.First ());  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,Obj_AI_Base_OnProcessSpellCast,The following statement contains a magic number: if (args.SData.IsAutoAttack ())  	UnitTrackerInfoList.Find (x => x.NetworkId == sender.NetworkId).AaTick = Utils.TickCount;  else {  	var foundSpell = spells.Find (x => args.SData.Name.ToLower () == x.name.ToLower ());  	if (foundSpell != null) {  		UnitTrackerInfoList.Find (x => x.NetworkId == sender.NetworkId).SpecialSpellFinishTick = Utils.TickCount + (int)(foundSpell.duration * 1000);  	}  }  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,Obj_AI_Base_OnProcessSpellCast,The following statement contains a magic number: if (foundSpell != null) {  	UnitTrackerInfoList.Find (x => x.NetworkId == sender.NetworkId).SpecialSpellFinishTick = Utils.TickCount + (int)(foundSpell.duration * 1000);  }  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,Obj_AI_Base_OnProcessSpellCast,The following statement contains a magic number: UnitTrackerInfoList.Find (x => x.NetworkId == sender.NetworkId).SpecialSpellFinishTick = Utils.TickCount + (int)(foundSpell.duration * 1000);  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,SpamSamePlace,The following statement contains a magic number: if (TrackerUnit.PathBank.Count < 3)  	return false;  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,SpamSamePlace,The following statement contains a magic number: if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [1].Time < 0.2f && TrackerUnit.PathBank [2].Time + 0.1f < Game.Time && TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) < 100) {  	return true;  } else  	return false;  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,SpamSamePlace,The following statement contains a magic number: if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [1].Time < 0.2f && TrackerUnit.PathBank [2].Time + 0.1f < Game.Time && TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) < 100) {  	return true;  } else  	return false;  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,SpamSamePlace,The following statement contains a magic number: if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [1].Time < 0.2f && TrackerUnit.PathBank [2].Time + 0.1f < Game.Time && TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) < 100) {  	return true;  } else  	return false;  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,SpamSamePlace,The following statement contains a magic number: if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [1].Time < 0.2f && TrackerUnit.PathBank [2].Time + 0.1f < Game.Time && TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) < 100) {  	return true;  } else  	return false;  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,PathCalc,The following statement contains a magic number: if (TrackerUnit.PathBank.Count < 3)  	return false;  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,PathCalc,The following statement contains a magic number: if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [0].Time < 0.4f && Game.Time - TrackerUnit.PathBank [2].Time < 0.1 && TrackerUnit.PathBank [2].Position.Distance (unit.Position) < 300 && TrackerUnit.PathBank [1].Position.Distance (unit.Position) < 300 && TrackerUnit.PathBank [0].Position.Distance (unit.Position) < 300) {  	var dis = unit.Distance (TrackerUnit.PathBank [2].Position);  	if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) > dis && TrackerUnit.PathBank [0].Position.Distance (TrackerUnit.PathBank [1].Position) > dis)  		return true;  	else  		return false;  } else  	return false;  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,PathCalc,The following statement contains a magic number: if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [0].Time < 0.4f && Game.Time - TrackerUnit.PathBank [2].Time < 0.1 && TrackerUnit.PathBank [2].Position.Distance (unit.Position) < 300 && TrackerUnit.PathBank [1].Position.Distance (unit.Position) < 300 && TrackerUnit.PathBank [0].Position.Distance (unit.Position) < 300) {  	var dis = unit.Distance (TrackerUnit.PathBank [2].Position);  	if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) > dis && TrackerUnit.PathBank [0].Position.Distance (TrackerUnit.PathBank [1].Position) > dis)  		return true;  	else  		return false;  } else  	return false;  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,PathCalc,The following statement contains a magic number: if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [0].Time < 0.4f && Game.Time - TrackerUnit.PathBank [2].Time < 0.1 && TrackerUnit.PathBank [2].Position.Distance (unit.Position) < 300 && TrackerUnit.PathBank [1].Position.Distance (unit.Position) < 300 && TrackerUnit.PathBank [0].Position.Distance (unit.Position) < 300) {  	var dis = unit.Distance (TrackerUnit.PathBank [2].Position);  	if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) > dis && TrackerUnit.PathBank [0].Position.Distance (TrackerUnit.PathBank [1].Position) > dis)  		return true;  	else  		return false;  } else  	return false;  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,PathCalc,The following statement contains a magic number: if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [0].Time < 0.4f && Game.Time - TrackerUnit.PathBank [2].Time < 0.1 && TrackerUnit.PathBank [2].Position.Distance (unit.Position) < 300 && TrackerUnit.PathBank [1].Position.Distance (unit.Position) < 300 && TrackerUnit.PathBank [0].Position.Distance (unit.Position) < 300) {  	var dis = unit.Distance (TrackerUnit.PathBank [2].Position);  	if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) > dis && TrackerUnit.PathBank [0].Position.Distance (TrackerUnit.PathBank [1].Position) > dis)  		return true;  	else  		return false;  } else  	return false;  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,PathCalc,The following statement contains a magic number: if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [0].Time < 0.4f && Game.Time - TrackerUnit.PathBank [2].Time < 0.1 && TrackerUnit.PathBank [2].Position.Distance (unit.Position) < 300 && TrackerUnit.PathBank [1].Position.Distance (unit.Position) < 300 && TrackerUnit.PathBank [0].Position.Distance (unit.Position) < 300) {  	var dis = unit.Distance (TrackerUnit.PathBank [2].Position);  	if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) > dis && TrackerUnit.PathBank [0].Position.Distance (TrackerUnit.PathBank [1].Position) > dis)  		return true;  	else  		return false;  } else  	return false;  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,PathCalc,The following statement contains a magic number: if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [0].Time < 0.4f && Game.Time - TrackerUnit.PathBank [2].Time < 0.1 && TrackerUnit.PathBank [2].Position.Distance (unit.Position) < 300 && TrackerUnit.PathBank [1].Position.Distance (unit.Position) < 300 && TrackerUnit.PathBank [0].Position.Distance (unit.Position) < 300) {  	var dis = unit.Distance (TrackerUnit.PathBank [2].Position);  	if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) > dis && TrackerUnit.PathBank [0].Position.Distance (TrackerUnit.PathBank [1].Position) > dis)  		return true;  	else  		return false;  } else  	return false;  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,PathCalc,The following statement contains a magic number: if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [0].Time < 0.4f && Game.Time - TrackerUnit.PathBank [2].Time < 0.1 && TrackerUnit.PathBank [2].Position.Distance (unit.Position) < 300 && TrackerUnit.PathBank [1].Position.Distance (unit.Position) < 300 && TrackerUnit.PathBank [0].Position.Distance (unit.Position) < 300) {  	var dis = unit.Distance (TrackerUnit.PathBank [2].Position);  	if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) > dis && TrackerUnit.PathBank [0].Position.Distance (TrackerUnit.PathBank [1].Position) > dis)  		return true;  	else  		return false;  } else  	return false;  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,PathCalc,The following statement contains a magic number: if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [0].Time < 0.4f && Game.Time - TrackerUnit.PathBank [2].Time < 0.1 && TrackerUnit.PathBank [2].Position.Distance (unit.Position) < 300 && TrackerUnit.PathBank [1].Position.Distance (unit.Position) < 300 && TrackerUnit.PathBank [0].Position.Distance (unit.Position) < 300) {  	var dis = unit.Distance (TrackerUnit.PathBank [2].Position);  	if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) > dis && TrackerUnit.PathBank [0].Position.Distance (TrackerUnit.PathBank [1].Position) > dis)  		return true;  	else  		return false;  } else  	return false;  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,PathCalc,The following statement contains a magic number: if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [0].Time < 0.4f && Game.Time - TrackerUnit.PathBank [2].Time < 0.1 && TrackerUnit.PathBank [2].Position.Distance (unit.Position) < 300 && TrackerUnit.PathBank [1].Position.Distance (unit.Position) < 300 && TrackerUnit.PathBank [0].Position.Distance (unit.Position) < 300) {  	var dis = unit.Distance (TrackerUnit.PathBank [2].Position);  	if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) > dis && TrackerUnit.PathBank [0].Position.Distance (TrackerUnit.PathBank [1].Position) > dis)  		return true;  	else  		return false;  } else  	return false;  
Magic Number,SebbyLib.Movement,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,PathCalc,The following statement contains a magic number: if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) > dis && TrackerUnit.PathBank [0].Position.Distance (TrackerUnit.PathBank [1].Position) > dis)  	return true;  else  	return false;  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPrediction,The following statement contains a magic number: if (Math.Abs (input.Range - float.MaxValue) > float.Epsilon && input.Unit.Distance (input.RangeCheckFrom' true) > Math.Pow (input.Range * 1.5' 2)) {  	return new PredictionOutput {  		Input = input  	};  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPrediction,The following statement contains a magic number: if (Math.Abs (input.Range - float.MaxValue) > float.Epsilon && input.Unit.Distance (input.RangeCheckFrom' true) > Math.Pow (input.Range * 1.5' 2)) {  	return new PredictionOutput {  		Input = input  	};  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPrediction,The following statement contains a magic number: if (input.Unit is Obj_AI_Hero && input.Radius > 1 && result.Hitchance <= HitChance.VeryHigh) {  	var moveOutWall = input.Unit.BoundingRadius + input.Radius / 2 + 10;  	if (input.Type == SkillshotType.SkillshotCircle)  		moveOutWall = input.Unit.BoundingRadius;  	var wallPoint = GetWallPoint (result.CastPosition' moveOutWall);  	if (!wallPoint.IsZero) {  		result.CastPosition = wallPoint.Extend (result.CastPosition' moveOutWall);  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPrediction,The following statement contains a magic number: if (input.Unit is Obj_AI_Hero && input.Radius > 1 && result.Hitchance <= HitChance.VeryHigh) {  	var moveOutWall = input.Unit.BoundingRadius + input.Radius / 2 + 10;  	if (input.Type == SkillshotType.SkillshotCircle)  		moveOutWall = input.Unit.BoundingRadius;  	var wallPoint = GetWallPoint (result.CastPosition' moveOutWall);  	if (!wallPoint.IsZero) {  		result.CastPosition = wallPoint.Extend (result.CastPosition' moveOutWall);  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPrediction,The following statement contains a magic number: if (Math.Abs (input.Range - float.MaxValue) > float.Epsilon) {  	if (result.Hitchance >= HitChance.High && input.RangeCheckFrom.Distance (input.Unit.Position' true) > Math.Pow (input.Range + input.RealRadius * 3 / 4' 2)) {  		result.Hitchance = HitChance.Medium;  	}  	if (input.RangeCheckFrom.Distance (result.UnitPosition' true) > Math.Pow (input.Range + (input.Type == SkillshotType.SkillshotCircle ? input.RealRadius : 0)' 2)) {  		result.Hitchance = HitChance.OutOfRange;  	}  	/* This does not need to be handled for the updated predictions' but left as a reference.*/if (input.RangeCheckFrom.Distance (result.CastPosition' true) > Math.Pow (input.Range' 2)) {  		if (result.Hitchance != HitChance.OutOfRange) {  			result.CastPosition = input.RangeCheckFrom + input.Range * (result.UnitPosition - input.RangeCheckFrom).To2D ().Normalized ().To3D ();  		} else {  			result.Hitchance = HitChance.OutOfRange;  		}  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPrediction,The following statement contains a magic number: if (Math.Abs (input.Range - float.MaxValue) > float.Epsilon) {  	if (result.Hitchance >= HitChance.High && input.RangeCheckFrom.Distance (input.Unit.Position' true) > Math.Pow (input.Range + input.RealRadius * 3 / 4' 2)) {  		result.Hitchance = HitChance.Medium;  	}  	if (input.RangeCheckFrom.Distance (result.UnitPosition' true) > Math.Pow (input.Range + (input.Type == SkillshotType.SkillshotCircle ? input.RealRadius : 0)' 2)) {  		result.Hitchance = HitChance.OutOfRange;  	}  	/* This does not need to be handled for the updated predictions' but left as a reference.*/if (input.RangeCheckFrom.Distance (result.CastPosition' true) > Math.Pow (input.Range' 2)) {  		if (result.Hitchance != HitChance.OutOfRange) {  			result.CastPosition = input.RangeCheckFrom + input.Range * (result.UnitPosition - input.RangeCheckFrom).To2D ().Normalized ().To3D ();  		} else {  			result.Hitchance = HitChance.OutOfRange;  		}  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPrediction,The following statement contains a magic number: if (Math.Abs (input.Range - float.MaxValue) > float.Epsilon) {  	if (result.Hitchance >= HitChance.High && input.RangeCheckFrom.Distance (input.Unit.Position' true) > Math.Pow (input.Range + input.RealRadius * 3 / 4' 2)) {  		result.Hitchance = HitChance.Medium;  	}  	if (input.RangeCheckFrom.Distance (result.UnitPosition' true) > Math.Pow (input.Range + (input.Type == SkillshotType.SkillshotCircle ? input.RealRadius : 0)' 2)) {  		result.Hitchance = HitChance.OutOfRange;  	}  	/* This does not need to be handled for the updated predictions' but left as a reference.*/if (input.RangeCheckFrom.Distance (result.CastPosition' true) > Math.Pow (input.Range' 2)) {  		if (result.Hitchance != HitChance.OutOfRange) {  			result.CastPosition = input.RangeCheckFrom + input.Range * (result.UnitPosition - input.RangeCheckFrom).To2D ().Normalized ().To3D ();  		} else {  			result.Hitchance = HitChance.OutOfRange;  		}  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPrediction,The following statement contains a magic number: if (Math.Abs (input.Range - float.MaxValue) > float.Epsilon) {  	if (result.Hitchance >= HitChance.High && input.RangeCheckFrom.Distance (input.Unit.Position' true) > Math.Pow (input.Range + input.RealRadius * 3 / 4' 2)) {  		result.Hitchance = HitChance.Medium;  	}  	if (input.RangeCheckFrom.Distance (result.UnitPosition' true) > Math.Pow (input.Range + (input.Type == SkillshotType.SkillshotCircle ? input.RealRadius : 0)' 2)) {  		result.Hitchance = HitChance.OutOfRange;  	}  	/* This does not need to be handled for the updated predictions' but left as a reference.*/if (input.RangeCheckFrom.Distance (result.CastPosition' true) > Math.Pow (input.Range' 2)) {  		if (result.Hitchance != HitChance.OutOfRange) {  			result.CastPosition = input.RangeCheckFrom + input.Range * (result.UnitPosition - input.RangeCheckFrom).To2D ().Normalized ().To3D ();  		} else {  			result.Hitchance = HitChance.OutOfRange;  		}  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPrediction,The following statement contains a magic number: if (Math.Abs (input.Range - float.MaxValue) > float.Epsilon) {  	if (result.Hitchance >= HitChance.High && input.RangeCheckFrom.Distance (input.Unit.Position' true) > Math.Pow (input.Range + input.RealRadius * 3 / 4' 2)) {  		result.Hitchance = HitChance.Medium;  	}  	if (input.RangeCheckFrom.Distance (result.UnitPosition' true) > Math.Pow (input.Range + (input.Type == SkillshotType.SkillshotCircle ? input.RealRadius : 0)' 2)) {  		result.Hitchance = HitChance.OutOfRange;  	}  	/* This does not need to be handled for the updated predictions' but left as a reference.*/if (input.RangeCheckFrom.Distance (result.CastPosition' true) > Math.Pow (input.Range' 2)) {  		if (result.Hitchance != HitChance.OutOfRange) {  			result.CastPosition = input.RangeCheckFrom + input.Range * (result.UnitPosition - input.RangeCheckFrom).To2D ().Normalized ().To3D ();  		} else {  			result.Hitchance = HitChance.OutOfRange;  		}  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPrediction,The following statement contains a magic number: if (result.Hitchance >= HitChance.High && input.RangeCheckFrom.Distance (input.Unit.Position' true) > Math.Pow (input.Range + input.RealRadius * 3 / 4' 2)) {  	result.Hitchance = HitChance.Medium;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPrediction,The following statement contains a magic number: if (result.Hitchance >= HitChance.High && input.RangeCheckFrom.Distance (input.Unit.Position' true) > Math.Pow (input.Range + input.RealRadius * 3 / 4' 2)) {  	result.Hitchance = HitChance.Medium;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPrediction,The following statement contains a magic number: if (result.Hitchance >= HitChance.High && input.RangeCheckFrom.Distance (input.Unit.Position' true) > Math.Pow (input.Range + input.RealRadius * 3 / 4' 2)) {  	result.Hitchance = HitChance.Medium;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPrediction,The following statement contains a magic number: if (input.RangeCheckFrom.Distance (result.UnitPosition' true) > Math.Pow (input.Range + (input.Type == SkillshotType.SkillshotCircle ? input.RealRadius : 0)' 2)) {  	result.Hitchance = HitChance.OutOfRange;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPrediction,The following statement contains a magic number: if (input.RangeCheckFrom.Distance (result.CastPosition' true) > Math.Pow (input.Range' 2)) {  	if (result.Hitchance != HitChance.OutOfRange) {  		result.CastPosition = input.RangeCheckFrom + input.Range * (result.UnitPosition - input.RangeCheckFrom).To2D ().Normalized ().To3D ();  	} else {  		result.Hitchance = HitChance.OutOfRange;  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPrediction,The following statement contains a magic number: if (result.Hitchance >= HitChance.VeryHigh && input.Unit is Obj_AI_Hero && input.Radius > 1) {  	var lastWaypiont = input.Unit.GetWaypoints ().Last ().To3D ();  	var distanceUnitToWaypoint = lastWaypiont.Distance (input.Unit.ServerPosition);  	var distanceFromToUnit = input.From.Distance (input.Unit.ServerPosition);  	var distanceFromToWaypoint = lastWaypiont.Distance (input.From);  	float speedDelay = distanceFromToUnit / input.Speed;  	if (Math.Abs (input.Speed - float.MaxValue) < float.Epsilon)  		speedDelay = 0;  	float totalDelay = speedDelay + input.Delay;  	float moveArea = input.Unit.MoveSpeed * totalDelay;  	float fixRange = moveArea * 0.35f;  	float pathMinLen = 800 + moveArea;  	OktwCommon.debug (input.Radius + " RES Ways: " + input.Unit.GetWaypoints ().Count + " W " + input.Unit.IsWindingUp + " D " + distanceUnitToWaypoint + " T " + UnitTracker.GetLastNewPathTime (input.Unit) + " " + result.Hitchance);  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (UnitTracker.GetSpecialSpellEndTime (input.Unit) > 100 || input.Unit.HasBuff ("Recall") || (UnitTracker.GetLastStopMoveTime (input.Unit) < 100 && input.Unit.IsRooted)) {  	OktwCommon.debug ("CAN'T MOVE SPELLS");  	result.Hitchance = HitChance.VeryHigh;  	result.CastPosition = input.Unit.Position;  	return result;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (UnitTracker.GetSpecialSpellEndTime (input.Unit) > 100 || input.Unit.HasBuff ("Recall") || (UnitTracker.GetLastStopMoveTime (input.Unit) < 100 && input.Unit.IsRooted)) {  	OktwCommon.debug ("CAN'T MOVE SPELLS");  	result.Hitchance = HitChance.VeryHigh;  	result.CastPosition = input.Unit.Position;  	return result;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (UnitTracker.GetLastVisableTime (input.Unit) < 100) {  	OktwCommon.debug ("PRED: NEW VISABLE");  	result.Hitchance = HitChance.Medium;  	return result;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (input.Type == SkillshotType.SkillshotCircle) {  	fixRange -= input.Radius / 2;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: fixRange -= input.Radius / 2;  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (totalDelay - input.Radius / 2 / input.Speed > 0.6 && (input.Unit.IsWindingUp || !input.Unit.CanMove || input.Unit.IsRooted)) {  	OktwCommon.debug ("PRED: After CC detection " + totalDelay);  	result.Hitchance = HitChance.High;  	return result;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (totalDelay - input.Radius / 2 / input.Speed > 0.6 && (input.Unit.IsWindingUp || !input.Unit.CanMove || input.Unit.IsRooted)) {  	OktwCommon.debug ("PRED: After CC detection " + totalDelay);  	result.Hitchance = HitChance.High;  	return result;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (distanceUnitToWaypoint > 0) {  	// RUN IN LANE DETECTION ///////////////////////////////////////////////////////////////////////////////////   	if (getAngle < 20 || getAngle > 160 || (getAngle > 130 && distanceUnitToWaypoint > 400) || OktwCommon.IsMovingInSameDirection (ObjectManager.Player' input.Unit)) {  		OktwCommon.debug ("PRED: ANGLE " + getAngle);  		result.Hitchance = HitChance.VeryHigh;  		return result;  	}  	// WALL LOGIC  ///////////////////////////////////////////////////////////////////////////////////  	var points = OktwCommon.CirclePoints (15' 350' input.Unit.Position).Where (x => x.IsWall ());  	if (points.Count () > 2) {  		var runOutWall = true;  		foreach (var point in points) {  			if (input.Unit.Position.Distance (point) > lastWaypiont.Distance (point)) {  				runOutWall = false;  			}  		}  		if (runOutWall) {  			OktwCommon.debug ("PRED: RUN OUT WALL");  			result.Hitchance = HitChance.VeryHigh;  			return result;  		}  	} else if (UnitTracker.GetLastNewPathTime (input.Unit) > 250 && input.Delay < 0.3) {  		// LONG TIME ///////////////////////////////////////////////////////////////////////////////////  		OktwCommon.debug ("PRED: LONG TIME");  		result.Hitchance = HitChance.VeryHigh;  		return result;  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (distanceUnitToWaypoint > 0) {  	// RUN IN LANE DETECTION ///////////////////////////////////////////////////////////////////////////////////   	if (getAngle < 20 || getAngle > 160 || (getAngle > 130 && distanceUnitToWaypoint > 400) || OktwCommon.IsMovingInSameDirection (ObjectManager.Player' input.Unit)) {  		OktwCommon.debug ("PRED: ANGLE " + getAngle);  		result.Hitchance = HitChance.VeryHigh;  		return result;  	}  	// WALL LOGIC  ///////////////////////////////////////////////////////////////////////////////////  	var points = OktwCommon.CirclePoints (15' 350' input.Unit.Position).Where (x => x.IsWall ());  	if (points.Count () > 2) {  		var runOutWall = true;  		foreach (var point in points) {  			if (input.Unit.Position.Distance (point) > lastWaypiont.Distance (point)) {  				runOutWall = false;  			}  		}  		if (runOutWall) {  			OktwCommon.debug ("PRED: RUN OUT WALL");  			result.Hitchance = HitChance.VeryHigh;  			return result;  		}  	} else if (UnitTracker.GetLastNewPathTime (input.Unit) > 250 && input.Delay < 0.3) {  		// LONG TIME ///////////////////////////////////////////////////////////////////////////////////  		OktwCommon.debug ("PRED: LONG TIME");  		result.Hitchance = HitChance.VeryHigh;  		return result;  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (distanceUnitToWaypoint > 0) {  	// RUN IN LANE DETECTION ///////////////////////////////////////////////////////////////////////////////////   	if (getAngle < 20 || getAngle > 160 || (getAngle > 130 && distanceUnitToWaypoint > 400) || OktwCommon.IsMovingInSameDirection (ObjectManager.Player' input.Unit)) {  		OktwCommon.debug ("PRED: ANGLE " + getAngle);  		result.Hitchance = HitChance.VeryHigh;  		return result;  	}  	// WALL LOGIC  ///////////////////////////////////////////////////////////////////////////////////  	var points = OktwCommon.CirclePoints (15' 350' input.Unit.Position).Where (x => x.IsWall ());  	if (points.Count () > 2) {  		var runOutWall = true;  		foreach (var point in points) {  			if (input.Unit.Position.Distance (point) > lastWaypiont.Distance (point)) {  				runOutWall = false;  			}  		}  		if (runOutWall) {  			OktwCommon.debug ("PRED: RUN OUT WALL");  			result.Hitchance = HitChance.VeryHigh;  			return result;  		}  	} else if (UnitTracker.GetLastNewPathTime (input.Unit) > 250 && input.Delay < 0.3) {  		// LONG TIME ///////////////////////////////////////////////////////////////////////////////////  		OktwCommon.debug ("PRED: LONG TIME");  		result.Hitchance = HitChance.VeryHigh;  		return result;  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (distanceUnitToWaypoint > 0) {  	// RUN IN LANE DETECTION ///////////////////////////////////////////////////////////////////////////////////   	if (getAngle < 20 || getAngle > 160 || (getAngle > 130 && distanceUnitToWaypoint > 400) || OktwCommon.IsMovingInSameDirection (ObjectManager.Player' input.Unit)) {  		OktwCommon.debug ("PRED: ANGLE " + getAngle);  		result.Hitchance = HitChance.VeryHigh;  		return result;  	}  	// WALL LOGIC  ///////////////////////////////////////////////////////////////////////////////////  	var points = OktwCommon.CirclePoints (15' 350' input.Unit.Position).Where (x => x.IsWall ());  	if (points.Count () > 2) {  		var runOutWall = true;  		foreach (var point in points) {  			if (input.Unit.Position.Distance (point) > lastWaypiont.Distance (point)) {  				runOutWall = false;  			}  		}  		if (runOutWall) {  			OktwCommon.debug ("PRED: RUN OUT WALL");  			result.Hitchance = HitChance.VeryHigh;  			return result;  		}  	} else if (UnitTracker.GetLastNewPathTime (input.Unit) > 250 && input.Delay < 0.3) {  		// LONG TIME ///////////////////////////////////////////////////////////////////////////////////  		OktwCommon.debug ("PRED: LONG TIME");  		result.Hitchance = HitChance.VeryHigh;  		return result;  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (distanceUnitToWaypoint > 0) {  	// RUN IN LANE DETECTION ///////////////////////////////////////////////////////////////////////////////////   	if (getAngle < 20 || getAngle > 160 || (getAngle > 130 && distanceUnitToWaypoint > 400) || OktwCommon.IsMovingInSameDirection (ObjectManager.Player' input.Unit)) {  		OktwCommon.debug ("PRED: ANGLE " + getAngle);  		result.Hitchance = HitChance.VeryHigh;  		return result;  	}  	// WALL LOGIC  ///////////////////////////////////////////////////////////////////////////////////  	var points = OktwCommon.CirclePoints (15' 350' input.Unit.Position).Where (x => x.IsWall ());  	if (points.Count () > 2) {  		var runOutWall = true;  		foreach (var point in points) {  			if (input.Unit.Position.Distance (point) > lastWaypiont.Distance (point)) {  				runOutWall = false;  			}  		}  		if (runOutWall) {  			OktwCommon.debug ("PRED: RUN OUT WALL");  			result.Hitchance = HitChance.VeryHigh;  			return result;  		}  	} else if (UnitTracker.GetLastNewPathTime (input.Unit) > 250 && input.Delay < 0.3) {  		// LONG TIME ///////////////////////////////////////////////////////////////////////////////////  		OktwCommon.debug ("PRED: LONG TIME");  		result.Hitchance = HitChance.VeryHigh;  		return result;  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (distanceUnitToWaypoint > 0) {  	// RUN IN LANE DETECTION ///////////////////////////////////////////////////////////////////////////////////   	if (getAngle < 20 || getAngle > 160 || (getAngle > 130 && distanceUnitToWaypoint > 400) || OktwCommon.IsMovingInSameDirection (ObjectManager.Player' input.Unit)) {  		OktwCommon.debug ("PRED: ANGLE " + getAngle);  		result.Hitchance = HitChance.VeryHigh;  		return result;  	}  	// WALL LOGIC  ///////////////////////////////////////////////////////////////////////////////////  	var points = OktwCommon.CirclePoints (15' 350' input.Unit.Position).Where (x => x.IsWall ());  	if (points.Count () > 2) {  		var runOutWall = true;  		foreach (var point in points) {  			if (input.Unit.Position.Distance (point) > lastWaypiont.Distance (point)) {  				runOutWall = false;  			}  		}  		if (runOutWall) {  			OktwCommon.debug ("PRED: RUN OUT WALL");  			result.Hitchance = HitChance.VeryHigh;  			return result;  		}  	} else if (UnitTracker.GetLastNewPathTime (input.Unit) > 250 && input.Delay < 0.3) {  		// LONG TIME ///////////////////////////////////////////////////////////////////////////////////  		OktwCommon.debug ("PRED: LONG TIME");  		result.Hitchance = HitChance.VeryHigh;  		return result;  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (distanceUnitToWaypoint > 0) {  	// RUN IN LANE DETECTION ///////////////////////////////////////////////////////////////////////////////////   	if (getAngle < 20 || getAngle > 160 || (getAngle > 130 && distanceUnitToWaypoint > 400) || OktwCommon.IsMovingInSameDirection (ObjectManager.Player' input.Unit)) {  		OktwCommon.debug ("PRED: ANGLE " + getAngle);  		result.Hitchance = HitChance.VeryHigh;  		return result;  	}  	// WALL LOGIC  ///////////////////////////////////////////////////////////////////////////////////  	var points = OktwCommon.CirclePoints (15' 350' input.Unit.Position).Where (x => x.IsWall ());  	if (points.Count () > 2) {  		var runOutWall = true;  		foreach (var point in points) {  			if (input.Unit.Position.Distance (point) > lastWaypiont.Distance (point)) {  				runOutWall = false;  			}  		}  		if (runOutWall) {  			OktwCommon.debug ("PRED: RUN OUT WALL");  			result.Hitchance = HitChance.VeryHigh;  			return result;  		}  	} else if (UnitTracker.GetLastNewPathTime (input.Unit) > 250 && input.Delay < 0.3) {  		// LONG TIME ///////////////////////////////////////////////////////////////////////////////////  		OktwCommon.debug ("PRED: LONG TIME");  		result.Hitchance = HitChance.VeryHigh;  		return result;  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (distanceUnitToWaypoint > 0) {  	// RUN IN LANE DETECTION ///////////////////////////////////////////////////////////////////////////////////   	if (getAngle < 20 || getAngle > 160 || (getAngle > 130 && distanceUnitToWaypoint > 400) || OktwCommon.IsMovingInSameDirection (ObjectManager.Player' input.Unit)) {  		OktwCommon.debug ("PRED: ANGLE " + getAngle);  		result.Hitchance = HitChance.VeryHigh;  		return result;  	}  	// WALL LOGIC  ///////////////////////////////////////////////////////////////////////////////////  	var points = OktwCommon.CirclePoints (15' 350' input.Unit.Position).Where (x => x.IsWall ());  	if (points.Count () > 2) {  		var runOutWall = true;  		foreach (var point in points) {  			if (input.Unit.Position.Distance (point) > lastWaypiont.Distance (point)) {  				runOutWall = false;  			}  		}  		if (runOutWall) {  			OktwCommon.debug ("PRED: RUN OUT WALL");  			result.Hitchance = HitChance.VeryHigh;  			return result;  		}  	} else if (UnitTracker.GetLastNewPathTime (input.Unit) > 250 && input.Delay < 0.3) {  		// LONG TIME ///////////////////////////////////////////////////////////////////////////////////  		OktwCommon.debug ("PRED: LONG TIME");  		result.Hitchance = HitChance.VeryHigh;  		return result;  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (distanceUnitToWaypoint > 0) {  	// RUN IN LANE DETECTION ///////////////////////////////////////////////////////////////////////////////////   	if (getAngle < 20 || getAngle > 160 || (getAngle > 130 && distanceUnitToWaypoint > 400) || OktwCommon.IsMovingInSameDirection (ObjectManager.Player' input.Unit)) {  		OktwCommon.debug ("PRED: ANGLE " + getAngle);  		result.Hitchance = HitChance.VeryHigh;  		return result;  	}  	// WALL LOGIC  ///////////////////////////////////////////////////////////////////////////////////  	var points = OktwCommon.CirclePoints (15' 350' input.Unit.Position).Where (x => x.IsWall ());  	if (points.Count () > 2) {  		var runOutWall = true;  		foreach (var point in points) {  			if (input.Unit.Position.Distance (point) > lastWaypiont.Distance (point)) {  				runOutWall = false;  			}  		}  		if (runOutWall) {  			OktwCommon.debug ("PRED: RUN OUT WALL");  			result.Hitchance = HitChance.VeryHigh;  			return result;  		}  	} else if (UnitTracker.GetLastNewPathTime (input.Unit) > 250 && input.Delay < 0.3) {  		// LONG TIME ///////////////////////////////////////////////////////////////////////////////////  		OktwCommon.debug ("PRED: LONG TIME");  		result.Hitchance = HitChance.VeryHigh;  		return result;  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (getAngle < 20 || getAngle > 160 || (getAngle > 130 && distanceUnitToWaypoint > 400) || OktwCommon.IsMovingInSameDirection (ObjectManager.Player' input.Unit)) {  	OktwCommon.debug ("PRED: ANGLE " + getAngle);  	result.Hitchance = HitChance.VeryHigh;  	return result;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (getAngle < 20 || getAngle > 160 || (getAngle > 130 && distanceUnitToWaypoint > 400) || OktwCommon.IsMovingInSameDirection (ObjectManager.Player' input.Unit)) {  	OktwCommon.debug ("PRED: ANGLE " + getAngle);  	result.Hitchance = HitChance.VeryHigh;  	return result;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (getAngle < 20 || getAngle > 160 || (getAngle > 130 && distanceUnitToWaypoint > 400) || OktwCommon.IsMovingInSameDirection (ObjectManager.Player' input.Unit)) {  	OktwCommon.debug ("PRED: ANGLE " + getAngle);  	result.Hitchance = HitChance.VeryHigh;  	return result;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (getAngle < 20 || getAngle > 160 || (getAngle > 130 && distanceUnitToWaypoint > 400) || OktwCommon.IsMovingInSameDirection (ObjectManager.Player' input.Unit)) {  	OktwCommon.debug ("PRED: ANGLE " + getAngle);  	result.Hitchance = HitChance.VeryHigh;  	return result;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (points.Count () > 2) {  	var runOutWall = true;  	foreach (var point in points) {  		if (input.Unit.Position.Distance (point) > lastWaypiont.Distance (point)) {  			runOutWall = false;  		}  	}  	if (runOutWall) {  		OktwCommon.debug ("PRED: RUN OUT WALL");  		result.Hitchance = HitChance.VeryHigh;  		return result;  	}  } else if (UnitTracker.GetLastNewPathTime (input.Unit) > 250 && input.Delay < 0.3) {  	// LONG TIME ///////////////////////////////////////////////////////////////////////////////////  	OktwCommon.debug ("PRED: LONG TIME");  	result.Hitchance = HitChance.VeryHigh;  	return result;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (points.Count () > 2) {  	var runOutWall = true;  	foreach (var point in points) {  		if (input.Unit.Position.Distance (point) > lastWaypiont.Distance (point)) {  			runOutWall = false;  		}  	}  	if (runOutWall) {  		OktwCommon.debug ("PRED: RUN OUT WALL");  		result.Hitchance = HitChance.VeryHigh;  		return result;  	}  } else if (UnitTracker.GetLastNewPathTime (input.Unit) > 250 && input.Delay < 0.3) {  	// LONG TIME ///////////////////////////////////////////////////////////////////////////////////  	OktwCommon.debug ("PRED: LONG TIME");  	result.Hitchance = HitChance.VeryHigh;  	return result;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (points.Count () > 2) {  	var runOutWall = true;  	foreach (var point in points) {  		if (input.Unit.Position.Distance (point) > lastWaypiont.Distance (point)) {  			runOutWall = false;  		}  	}  	if (runOutWall) {  		OktwCommon.debug ("PRED: RUN OUT WALL");  		result.Hitchance = HitChance.VeryHigh;  		return result;  	}  } else if (UnitTracker.GetLastNewPathTime (input.Unit) > 250 && input.Delay < 0.3) {  	// LONG TIME ///////////////////////////////////////////////////////////////////////////////////  	OktwCommon.debug ("PRED: LONG TIME");  	result.Hitchance = HitChance.VeryHigh;  	return result;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (UnitTracker.GetLastNewPathTime (input.Unit) > 250 && input.Delay < 0.3) {  	// LONG TIME ///////////////////////////////////////////////////////////////////////////////////  	OktwCommon.debug ("PRED: LONG TIME");  	result.Hitchance = HitChance.VeryHigh;  	return result;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (UnitTracker.GetLastNewPathTime (input.Unit) > 250 && input.Delay < 0.3) {  	// LONG TIME ///////////////////////////////////////////////////////////////////////////////////  	OktwCommon.debug ("PRED: LONG TIME");  	result.Hitchance = HitChance.VeryHigh;  	return result;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (distanceUnitToWaypoint > 0 && distanceUnitToWaypoint < 100) {  	OktwCommon.debug ("PRED: SHORT CLICK DETECTION");  	result.Hitchance = HitChance.Medium;  	return result;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (input.Unit.GetWaypoints ().Count == 1) {  	if (UnitTracker.GetLastAutoAttackTime (input.Unit) < 0.1d && totalDelay < 0.7) {  		OktwCommon.debug ("PRED: AA try");  		result.Hitchance = HitChance.VeryHigh;  		return result;  	}  	if (input.Unit.IsWindingUp) {  		result.Hitchance = HitChance.High;  		return result;  	} else if (UnitTracker.GetLastStopMoveTime (input.Unit) < 800) {  		//OktwCommon.debug("PRED: STOP HIGH");  		result.Hitchance = HitChance.High;  		return result;  	} else {  		OktwCommon.debug ("PRED: STOP LOGIC");  		result.Hitchance = HitChance.VeryHigh;  		return result;  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (input.Unit.GetWaypoints ().Count == 1) {  	if (UnitTracker.GetLastAutoAttackTime (input.Unit) < 0.1d && totalDelay < 0.7) {  		OktwCommon.debug ("PRED: AA try");  		result.Hitchance = HitChance.VeryHigh;  		return result;  	}  	if (input.Unit.IsWindingUp) {  		result.Hitchance = HitChance.High;  		return result;  	} else if (UnitTracker.GetLastStopMoveTime (input.Unit) < 800) {  		//OktwCommon.debug("PRED: STOP HIGH");  		result.Hitchance = HitChance.High;  		return result;  	} else {  		OktwCommon.debug ("PRED: STOP LOGIC");  		result.Hitchance = HitChance.VeryHigh;  		return result;  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (UnitTracker.GetLastAutoAttackTime (input.Unit) < 0.1d && totalDelay < 0.7) {  	OktwCommon.debug ("PRED: AA try");  	result.Hitchance = HitChance.VeryHigh;  	return result;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (input.Unit.IsWindingUp) {  	result.Hitchance = HitChance.High;  	return result;  } else if (UnitTracker.GetLastStopMoveTime (input.Unit) < 800) {  	//OktwCommon.debug("PRED: STOP HIGH");  	result.Hitchance = HitChance.High;  	return result;  } else {  	OktwCommon.debug ("PRED: STOP LOGIC");  	result.Hitchance = HitChance.VeryHigh;  	return result;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (UnitTracker.GetLastStopMoveTime (input.Unit) < 800) {  	//OktwCommon.debug("PRED: STOP HIGH");  	result.Hitchance = HitChance.High;  	return result;  } else {  	OktwCommon.debug ("PRED: STOP LOGIC");  	result.Hitchance = HitChance.VeryHigh;  	return result;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (distanceFromToUnit < 250) {  	OktwCommon.debug ("PRED: SPECIAL CASES NEAR");  	result.Hitchance = HitChance.VeryHigh;  	return result;  } else if (input.Unit.MoveSpeed < 250) {  	OktwCommon.debug ("PRED: SPECIAL CASES SLOW");  	result.Hitchance = HitChance.VeryHigh;  	return result;  } else if (distanceFromToWaypoint < 250) {  	OktwCommon.debug ("PRED: SPECIAL CASES ON WAY");  	result.Hitchance = HitChance.VeryHigh;  	return result;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (distanceFromToUnit < 250) {  	OktwCommon.debug ("PRED: SPECIAL CASES NEAR");  	result.Hitchance = HitChance.VeryHigh;  	return result;  } else if (input.Unit.MoveSpeed < 250) {  	OktwCommon.debug ("PRED: SPECIAL CASES SLOW");  	result.Hitchance = HitChance.VeryHigh;  	return result;  } else if (distanceFromToWaypoint < 250) {  	OktwCommon.debug ("PRED: SPECIAL CASES ON WAY");  	result.Hitchance = HitChance.VeryHigh;  	return result;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (distanceFromToUnit < 250) {  	OktwCommon.debug ("PRED: SPECIAL CASES NEAR");  	result.Hitchance = HitChance.VeryHigh;  	return result;  } else if (input.Unit.MoveSpeed < 250) {  	OktwCommon.debug ("PRED: SPECIAL CASES SLOW");  	result.Hitchance = HitChance.VeryHigh;  	return result;  } else if (distanceFromToWaypoint < 250) {  	OktwCommon.debug ("PRED: SPECIAL CASES ON WAY");  	result.Hitchance = HitChance.VeryHigh;  	return result;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (input.Unit.MoveSpeed < 250) {  	OktwCommon.debug ("PRED: SPECIAL CASES SLOW");  	result.Hitchance = HitChance.VeryHigh;  	return result;  } else if (distanceFromToWaypoint < 250) {  	OktwCommon.debug ("PRED: SPECIAL CASES ON WAY");  	result.Hitchance = HitChance.VeryHigh;  	return result;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (input.Unit.MoveSpeed < 250) {  	OktwCommon.debug ("PRED: SPECIAL CASES SLOW");  	result.Hitchance = HitChance.VeryHigh;  	return result;  } else if (distanceFromToWaypoint < 250) {  	OktwCommon.debug ("PRED: SPECIAL CASES ON WAY");  	result.Hitchance = HitChance.VeryHigh;  	return result;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (distanceFromToWaypoint < 250) {  	OktwCommon.debug ("PRED: SPECIAL CASES ON WAY");  	result.Hitchance = HitChance.VeryHigh;  	return result;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (input.Unit.HealthPercent < 20 || ObjectManager.Player.HealthPercent < 20) {  	result.Hitchance = HitChance.VeryHigh;  	OktwCommon.debug ("Low hp");  	return result;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (input.Unit.HealthPercent < 20 || ObjectManager.Player.HealthPercent < 20) {  	result.Hitchance = HitChance.VeryHigh;  	OktwCommon.debug ("Low hp");  	return result;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (input.Type == SkillshotType.SkillshotCircle) {  	if (UnitTracker.GetLastNewPathTime (input.Unit) < 100 && distanceUnitToWaypoint > fixRange) {  		OktwCommon.debug ("PRED: CIRCLE NEW PATH");  		result.Hitchance = HitChance.VeryHigh;  		return result;  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,WayPointAnalysis,The following statement contains a magic number: if (UnitTracker.GetLastNewPathTime (input.Unit) < 100 && distanceUnitToWaypoint > fixRange) {  	OktwCommon.debug ("PRED: CIRCLE NEW PATH");  	result.Hitchance = HitChance.VeryHigh;  	return result;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetDashingPrediction,The following statement contains a magic number: if (!dashData.IsBlink) {  	//Mid air:  	var endP = dashData.Path.Last ();  	var dashPred = GetPositionOnPath (input' new List<Vector2> {  		input.Unit.ServerPosition.To2D ()'  		endP  	}' dashData.Speed);  	if (dashPred.Hitchance >= HitChance.High && dashPred.UnitPosition.To2D ().Distance (input.Unit.Position.To2D ()' endP' true) < 200) {  		dashPred.CastPosition = dashPred.UnitPosition;  		dashPred.Hitchance = HitChance.Dashing;  		return dashPred;  	}  	//At the end of the dash:  	if (dashData.Path.PathLength () > 200) {  		var timeToPoint = input.Delay / 2f + input.From.To2D ().Distance (endP) / input.Speed - 0.25f;  		if (timeToPoint <= input.Unit.Distance (endP) / dashData.Speed + input.RealRadius / input.Unit.MoveSpeed) {  			return new PredictionOutput {  				CastPosition = endP.To3D ()'  				UnitPosition = endP.To3D ()'  				Hitchance = HitChance.Dashing  			};  		}  	}  	result.CastPosition = dashData.Path.Last ().To3D ();  	result.UnitPosition = result.CastPosition;  	//Figure out where the unit is going.  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetDashingPrediction,The following statement contains a magic number: if (!dashData.IsBlink) {  	//Mid air:  	var endP = dashData.Path.Last ();  	var dashPred = GetPositionOnPath (input' new List<Vector2> {  		input.Unit.ServerPosition.To2D ()'  		endP  	}' dashData.Speed);  	if (dashPred.Hitchance >= HitChance.High && dashPred.UnitPosition.To2D ().Distance (input.Unit.Position.To2D ()' endP' true) < 200) {  		dashPred.CastPosition = dashPred.UnitPosition;  		dashPred.Hitchance = HitChance.Dashing;  		return dashPred;  	}  	//At the end of the dash:  	if (dashData.Path.PathLength () > 200) {  		var timeToPoint = input.Delay / 2f + input.From.To2D ().Distance (endP) / input.Speed - 0.25f;  		if (timeToPoint <= input.Unit.Distance (endP) / dashData.Speed + input.RealRadius / input.Unit.MoveSpeed) {  			return new PredictionOutput {  				CastPosition = endP.To3D ()'  				UnitPosition = endP.To3D ()'  				Hitchance = HitChance.Dashing  			};  		}  	}  	result.CastPosition = dashData.Path.Last ().To3D ();  	result.UnitPosition = result.CastPosition;  	//Figure out where the unit is going.  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetDashingPrediction,The following statement contains a magic number: if (dashPred.Hitchance >= HitChance.High && dashPred.UnitPosition.To2D ().Distance (input.Unit.Position.To2D ()' endP' true) < 200) {  	dashPred.CastPosition = dashPred.UnitPosition;  	dashPred.Hitchance = HitChance.Dashing;  	return dashPred;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetDashingPrediction,The following statement contains a magic number: if (dashData.Path.PathLength () > 200) {  	var timeToPoint = input.Delay / 2f + input.From.To2D ().Distance (endP) / input.Speed - 0.25f;  	if (timeToPoint <= input.Unit.Distance (endP) / dashData.Speed + input.RealRadius / input.Unit.MoveSpeed) {  		return new PredictionOutput {  			CastPosition = endP.To3D ()'  			UnitPosition = endP.To3D ()'  			Hitchance = HitChance.Dashing  		};  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetWallPoint,The following statement contains a magic number: if (!first.IsZero && !last.IsZero) {  	var finnaly = new Vector3 ((last.X + first.X) / 2' (last.Y + first.Y) / 2' (last.Z + first.Z) / 2);  	return finnaly;  } else  	return Vector3.Zero;  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetWallPoint,The following statement contains a magic number: if (!first.IsZero && !last.IsZero) {  	var finnaly = new Vector3 ((last.X + first.X) / 2' (last.Y + first.Y) / 2' (last.Z + first.Z) / 2);  	return finnaly;  } else  	return Vector3.Zero;  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetWallPoint,The following statement contains a magic number: if (!first.IsZero && !last.IsZero) {  	var finnaly = new Vector3 ((last.X + first.X) / 2' (last.Y + first.Y) / 2' (last.Z + first.Z) / 2);  	return finnaly;  } else  	return Vector3.Zero;  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The following statement contains a magic number: if (input.Unit.Distance (input.From' true) < 250 * 250) {  	//input.Delay /= 2;  	speed /= 1.5f;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The following statement contains a magic number: if (input.Unit.Distance (input.From' true) < 250 * 250) {  	//input.Delay /= 2;  	speed /= 1.5f;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The following statement contains a magic number: if (pLength >= tDistance && Math.Abs (input.Speed - float.MaxValue) < float.Epsilon) {  	for (var i = 0; i < path.Count - 1; i++) {  		var a = path [i];  		var b = path [i + 1];  		var d = a.Distance (b);  		if (d >= tDistance) {  			var direction = (b - a).Normalized ();  			var cp = a + direction * tDistance;  			var p = a + direction * ((i == path.Count - 2) ? Math.Min (tDistance + input.RealRadius' d) : (tDistance + input.RealRadius));  			return new PredictionOutput {  				Input = input'  				CastPosition = cp.To3D ()'  				UnitPosition = p.To3D ()'  				Hitchance = HitChance.High  			};  		}  		tDistance -= d;  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The following statement contains a magic number: for (var i = 0; i < path.Count - 1; i++) {  	var a = path [i];  	var b = path [i + 1];  	var d = a.Distance (b);  	if (d >= tDistance) {  		var direction = (b - a).Normalized ();  		var cp = a + direction * tDistance;  		var p = a + direction * ((i == path.Count - 2) ? Math.Min (tDistance + input.RealRadius' d) : (tDistance + input.RealRadius));  		return new PredictionOutput {  			Input = input'  			CastPosition = cp.To3D ()'  			UnitPosition = p.To3D ()'  			Hitchance = HitChance.High  		};  	}  	tDistance -= d;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The following statement contains a magic number: if (d >= tDistance) {  	var direction = (b - a).Normalized ();  	var cp = a + direction * tDistance;  	var p = a + direction * ((i == path.Count - 2) ? Math.Min (tDistance + input.RealRadius' d) : (tDistance + input.RealRadius));  	return new PredictionOutput {  		Input = input'  		CastPosition = cp.To3D ()'  		UnitPosition = p.To3D ()'  		Hitchance = HitChance.High  	};  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The following statement contains a magic number: if (pLength >= tDistance && Math.Abs (input.Speed - float.MaxValue) > float.Epsilon) {  	var d = tDistance;  	if (input.Type == SkillshotType.SkillshotLine || input.Type == SkillshotType.SkillshotCone) {  		if (input.From.Distance (input.Unit.ServerPosition' true) < 200 * 200) {  			d = input.Delay * speed;  		}  	}  	path = path.CutPath (d);  	var tT = 0f;  	for (var i = 0; i < path.Count - 1; i++) {  		var a = path [i];  		var b = path [i + 1];  		var tB = a.Distance (b) / speed;  		var direction = (b - a).Normalized ();  		a = a - speed * tT * direction;  		var sol = Geometry.VectorMovementCollision (a' b' speed' input.From.To2D ()' input.Speed' tT);  		var t = (float)sol [0];  		var pos = (Vector2)sol [1];  		if (pos.IsValid () && t >= tT && t <= tT + tB) {  			if (pos.Distance (b' true) < 20)  				break;  			var p = pos + input.RealRadius * direction;  			if (input.Type == SkillshotType.SkillshotLine && false) {  				var alpha = (input.From.To2D () - p).AngleBetween (a - b);  				if (alpha > 30 && alpha < 180 - 30) {  					var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  					var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  					var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  					pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  				}  			}  			return new PredictionOutput {  				Input = input'  				CastPosition = pos.To3D ()'  				UnitPosition = p.To3D ()'  				Hitchance = HitChance.High  			};  		}  		tT += tB;  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The following statement contains a magic number: if (pLength >= tDistance && Math.Abs (input.Speed - float.MaxValue) > float.Epsilon) {  	var d = tDistance;  	if (input.Type == SkillshotType.SkillshotLine || input.Type == SkillshotType.SkillshotCone) {  		if (input.From.Distance (input.Unit.ServerPosition' true) < 200 * 200) {  			d = input.Delay * speed;  		}  	}  	path = path.CutPath (d);  	var tT = 0f;  	for (var i = 0; i < path.Count - 1; i++) {  		var a = path [i];  		var b = path [i + 1];  		var tB = a.Distance (b) / speed;  		var direction = (b - a).Normalized ();  		a = a - speed * tT * direction;  		var sol = Geometry.VectorMovementCollision (a' b' speed' input.From.To2D ()' input.Speed' tT);  		var t = (float)sol [0];  		var pos = (Vector2)sol [1];  		if (pos.IsValid () && t >= tT && t <= tT + tB) {  			if (pos.Distance (b' true) < 20)  				break;  			var p = pos + input.RealRadius * direction;  			if (input.Type == SkillshotType.SkillshotLine && false) {  				var alpha = (input.From.To2D () - p).AngleBetween (a - b);  				if (alpha > 30 && alpha < 180 - 30) {  					var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  					var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  					var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  					pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  				}  			}  			return new PredictionOutput {  				Input = input'  				CastPosition = pos.To3D ()'  				UnitPosition = p.To3D ()'  				Hitchance = HitChance.High  			};  		}  		tT += tB;  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The following statement contains a magic number: if (pLength >= tDistance && Math.Abs (input.Speed - float.MaxValue) > float.Epsilon) {  	var d = tDistance;  	if (input.Type == SkillshotType.SkillshotLine || input.Type == SkillshotType.SkillshotCone) {  		if (input.From.Distance (input.Unit.ServerPosition' true) < 200 * 200) {  			d = input.Delay * speed;  		}  	}  	path = path.CutPath (d);  	var tT = 0f;  	for (var i = 0; i < path.Count - 1; i++) {  		var a = path [i];  		var b = path [i + 1];  		var tB = a.Distance (b) / speed;  		var direction = (b - a).Normalized ();  		a = a - speed * tT * direction;  		var sol = Geometry.VectorMovementCollision (a' b' speed' input.From.To2D ()' input.Speed' tT);  		var t = (float)sol [0];  		var pos = (Vector2)sol [1];  		if (pos.IsValid () && t >= tT && t <= tT + tB) {  			if (pos.Distance (b' true) < 20)  				break;  			var p = pos + input.RealRadius * direction;  			if (input.Type == SkillshotType.SkillshotLine && false) {  				var alpha = (input.From.To2D () - p).AngleBetween (a - b);  				if (alpha > 30 && alpha < 180 - 30) {  					var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  					var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  					var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  					pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  				}  			}  			return new PredictionOutput {  				Input = input'  				CastPosition = pos.To3D ()'  				UnitPosition = p.To3D ()'  				Hitchance = HitChance.High  			};  		}  		tT += tB;  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The following statement contains a magic number: if (pLength >= tDistance && Math.Abs (input.Speed - float.MaxValue) > float.Epsilon) {  	var d = tDistance;  	if (input.Type == SkillshotType.SkillshotLine || input.Type == SkillshotType.SkillshotCone) {  		if (input.From.Distance (input.Unit.ServerPosition' true) < 200 * 200) {  			d = input.Delay * speed;  		}  	}  	path = path.CutPath (d);  	var tT = 0f;  	for (var i = 0; i < path.Count - 1; i++) {  		var a = path [i];  		var b = path [i + 1];  		var tB = a.Distance (b) / speed;  		var direction = (b - a).Normalized ();  		a = a - speed * tT * direction;  		var sol = Geometry.VectorMovementCollision (a' b' speed' input.From.To2D ()' input.Speed' tT);  		var t = (float)sol [0];  		var pos = (Vector2)sol [1];  		if (pos.IsValid () && t >= tT && t <= tT + tB) {  			if (pos.Distance (b' true) < 20)  				break;  			var p = pos + input.RealRadius * direction;  			if (input.Type == SkillshotType.SkillshotLine && false) {  				var alpha = (input.From.To2D () - p).AngleBetween (a - b);  				if (alpha > 30 && alpha < 180 - 30) {  					var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  					var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  					var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  					pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  				}  			}  			return new PredictionOutput {  				Input = input'  				CastPosition = pos.To3D ()'  				UnitPosition = p.To3D ()'  				Hitchance = HitChance.High  			};  		}  		tT += tB;  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The following statement contains a magic number: if (pLength >= tDistance && Math.Abs (input.Speed - float.MaxValue) > float.Epsilon) {  	var d = tDistance;  	if (input.Type == SkillshotType.SkillshotLine || input.Type == SkillshotType.SkillshotCone) {  		if (input.From.Distance (input.Unit.ServerPosition' true) < 200 * 200) {  			d = input.Delay * speed;  		}  	}  	path = path.CutPath (d);  	var tT = 0f;  	for (var i = 0; i < path.Count - 1; i++) {  		var a = path [i];  		var b = path [i + 1];  		var tB = a.Distance (b) / speed;  		var direction = (b - a).Normalized ();  		a = a - speed * tT * direction;  		var sol = Geometry.VectorMovementCollision (a' b' speed' input.From.To2D ()' input.Speed' tT);  		var t = (float)sol [0];  		var pos = (Vector2)sol [1];  		if (pos.IsValid () && t >= tT && t <= tT + tB) {  			if (pos.Distance (b' true) < 20)  				break;  			var p = pos + input.RealRadius * direction;  			if (input.Type == SkillshotType.SkillshotLine && false) {  				var alpha = (input.From.To2D () - p).AngleBetween (a - b);  				if (alpha > 30 && alpha < 180 - 30) {  					var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  					var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  					var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  					pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  				}  			}  			return new PredictionOutput {  				Input = input'  				CastPosition = pos.To3D ()'  				UnitPosition = p.To3D ()'  				Hitchance = HitChance.High  			};  		}  		tT += tB;  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The following statement contains a magic number: if (pLength >= tDistance && Math.Abs (input.Speed - float.MaxValue) > float.Epsilon) {  	var d = tDistance;  	if (input.Type == SkillshotType.SkillshotLine || input.Type == SkillshotType.SkillshotCone) {  		if (input.From.Distance (input.Unit.ServerPosition' true) < 200 * 200) {  			d = input.Delay * speed;  		}  	}  	path = path.CutPath (d);  	var tT = 0f;  	for (var i = 0; i < path.Count - 1; i++) {  		var a = path [i];  		var b = path [i + 1];  		var tB = a.Distance (b) / speed;  		var direction = (b - a).Normalized ();  		a = a - speed * tT * direction;  		var sol = Geometry.VectorMovementCollision (a' b' speed' input.From.To2D ()' input.Speed' tT);  		var t = (float)sol [0];  		var pos = (Vector2)sol [1];  		if (pos.IsValid () && t >= tT && t <= tT + tB) {  			if (pos.Distance (b' true) < 20)  				break;  			var p = pos + input.RealRadius * direction;  			if (input.Type == SkillshotType.SkillshotLine && false) {  				var alpha = (input.From.To2D () - p).AngleBetween (a - b);  				if (alpha > 30 && alpha < 180 - 30) {  					var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  					var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  					var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  					pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  				}  			}  			return new PredictionOutput {  				Input = input'  				CastPosition = pos.To3D ()'  				UnitPosition = p.To3D ()'  				Hitchance = HitChance.High  			};  		}  		tT += tB;  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The following statement contains a magic number: if (input.Type == SkillshotType.SkillshotLine || input.Type == SkillshotType.SkillshotCone) {  	if (input.From.Distance (input.Unit.ServerPosition' true) < 200 * 200) {  		d = input.Delay * speed;  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The following statement contains a magic number: if (input.Type == SkillshotType.SkillshotLine || input.Type == SkillshotType.SkillshotCone) {  	if (input.From.Distance (input.Unit.ServerPosition' true) < 200 * 200) {  		d = input.Delay * speed;  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The following statement contains a magic number: if (input.From.Distance (input.Unit.ServerPosition' true) < 200 * 200) {  	d = input.Delay * speed;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The following statement contains a magic number: if (input.From.Distance (input.Unit.ServerPosition' true) < 200 * 200) {  	d = input.Delay * speed;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The following statement contains a magic number: for (var i = 0; i < path.Count - 1; i++) {  	var a = path [i];  	var b = path [i + 1];  	var tB = a.Distance (b) / speed;  	var direction = (b - a).Normalized ();  	a = a - speed * tT * direction;  	var sol = Geometry.VectorMovementCollision (a' b' speed' input.From.To2D ()' input.Speed' tT);  	var t = (float)sol [0];  	var pos = (Vector2)sol [1];  	if (pos.IsValid () && t >= tT && t <= tT + tB) {  		if (pos.Distance (b' true) < 20)  			break;  		var p = pos + input.RealRadius * direction;  		if (input.Type == SkillshotType.SkillshotLine && false) {  			var alpha = (input.From.To2D () - p).AngleBetween (a - b);  			if (alpha > 30 && alpha < 180 - 30) {  				var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  				var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  				var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  				pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  			}  		}  		return new PredictionOutput {  			Input = input'  			CastPosition = pos.To3D ()'  			UnitPosition = p.To3D ()'  			Hitchance = HitChance.High  		};  	}  	tT += tB;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The following statement contains a magic number: for (var i = 0; i < path.Count - 1; i++) {  	var a = path [i];  	var b = path [i + 1];  	var tB = a.Distance (b) / speed;  	var direction = (b - a).Normalized ();  	a = a - speed * tT * direction;  	var sol = Geometry.VectorMovementCollision (a' b' speed' input.From.To2D ()' input.Speed' tT);  	var t = (float)sol [0];  	var pos = (Vector2)sol [1];  	if (pos.IsValid () && t >= tT && t <= tT + tB) {  		if (pos.Distance (b' true) < 20)  			break;  		var p = pos + input.RealRadius * direction;  		if (input.Type == SkillshotType.SkillshotLine && false) {  			var alpha = (input.From.To2D () - p).AngleBetween (a - b);  			if (alpha > 30 && alpha < 180 - 30) {  				var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  				var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  				var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  				pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  			}  		}  		return new PredictionOutput {  			Input = input'  			CastPosition = pos.To3D ()'  			UnitPosition = p.To3D ()'  			Hitchance = HitChance.High  		};  	}  	tT += tB;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The following statement contains a magic number: for (var i = 0; i < path.Count - 1; i++) {  	var a = path [i];  	var b = path [i + 1];  	var tB = a.Distance (b) / speed;  	var direction = (b - a).Normalized ();  	a = a - speed * tT * direction;  	var sol = Geometry.VectorMovementCollision (a' b' speed' input.From.To2D ()' input.Speed' tT);  	var t = (float)sol [0];  	var pos = (Vector2)sol [1];  	if (pos.IsValid () && t >= tT && t <= tT + tB) {  		if (pos.Distance (b' true) < 20)  			break;  		var p = pos + input.RealRadius * direction;  		if (input.Type == SkillshotType.SkillshotLine && false) {  			var alpha = (input.From.To2D () - p).AngleBetween (a - b);  			if (alpha > 30 && alpha < 180 - 30) {  				var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  				var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  				var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  				pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  			}  		}  		return new PredictionOutput {  			Input = input'  			CastPosition = pos.To3D ()'  			UnitPosition = p.To3D ()'  			Hitchance = HitChance.High  		};  	}  	tT += tB;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The following statement contains a magic number: for (var i = 0; i < path.Count - 1; i++) {  	var a = path [i];  	var b = path [i + 1];  	var tB = a.Distance (b) / speed;  	var direction = (b - a).Normalized ();  	a = a - speed * tT * direction;  	var sol = Geometry.VectorMovementCollision (a' b' speed' input.From.To2D ()' input.Speed' tT);  	var t = (float)sol [0];  	var pos = (Vector2)sol [1];  	if (pos.IsValid () && t >= tT && t <= tT + tB) {  		if (pos.Distance (b' true) < 20)  			break;  		var p = pos + input.RealRadius * direction;  		if (input.Type == SkillshotType.SkillshotLine && false) {  			var alpha = (input.From.To2D () - p).AngleBetween (a - b);  			if (alpha > 30 && alpha < 180 - 30) {  				var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  				var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  				var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  				pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  			}  		}  		return new PredictionOutput {  			Input = input'  			CastPosition = pos.To3D ()'  			UnitPosition = p.To3D ()'  			Hitchance = HitChance.High  		};  	}  	tT += tB;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The following statement contains a magic number: if (pos.IsValid () && t >= tT && t <= tT + tB) {  	if (pos.Distance (b' true) < 20)  		break;  	var p = pos + input.RealRadius * direction;  	if (input.Type == SkillshotType.SkillshotLine && false) {  		var alpha = (input.From.To2D () - p).AngleBetween (a - b);  		if (alpha > 30 && alpha < 180 - 30) {  			var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  			var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  			var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  			pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  		}  	}  	return new PredictionOutput {  		Input = input'  		CastPosition = pos.To3D ()'  		UnitPosition = p.To3D ()'  		Hitchance = HitChance.High  	};  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The following statement contains a magic number: if (pos.IsValid () && t >= tT && t <= tT + tB) {  	if (pos.Distance (b' true) < 20)  		break;  	var p = pos + input.RealRadius * direction;  	if (input.Type == SkillshotType.SkillshotLine && false) {  		var alpha = (input.From.To2D () - p).AngleBetween (a - b);  		if (alpha > 30 && alpha < 180 - 30) {  			var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  			var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  			var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  			pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  		}  	}  	return new PredictionOutput {  		Input = input'  		CastPosition = pos.To3D ()'  		UnitPosition = p.To3D ()'  		Hitchance = HitChance.High  	};  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The following statement contains a magic number: if (pos.IsValid () && t >= tT && t <= tT + tB) {  	if (pos.Distance (b' true) < 20)  		break;  	var p = pos + input.RealRadius * direction;  	if (input.Type == SkillshotType.SkillshotLine && false) {  		var alpha = (input.From.To2D () - p).AngleBetween (a - b);  		if (alpha > 30 && alpha < 180 - 30) {  			var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  			var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  			var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  			pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  		}  	}  	return new PredictionOutput {  		Input = input'  		CastPosition = pos.To3D ()'  		UnitPosition = p.To3D ()'  		Hitchance = HitChance.High  	};  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The following statement contains a magic number: if (pos.IsValid () && t >= tT && t <= tT + tB) {  	if (pos.Distance (b' true) < 20)  		break;  	var p = pos + input.RealRadius * direction;  	if (input.Type == SkillshotType.SkillshotLine && false) {  		var alpha = (input.From.To2D () - p).AngleBetween (a - b);  		if (alpha > 30 && alpha < 180 - 30) {  			var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  			var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  			var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  			pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  		}  	}  	return new PredictionOutput {  		Input = input'  		CastPosition = pos.To3D ()'  		UnitPosition = p.To3D ()'  		Hitchance = HitChance.High  	};  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The following statement contains a magic number: if (pos.Distance (b' true) < 20)  	break;  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The following statement contains a magic number: if (input.Type == SkillshotType.SkillshotLine && false) {  	var alpha = (input.From.To2D () - p).AngleBetween (a - b);  	if (alpha > 30 && alpha < 180 - 30) {  		var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  		var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  		var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  		pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The following statement contains a magic number: if (input.Type == SkillshotType.SkillshotLine && false) {  	var alpha = (input.From.To2D () - p).AngleBetween (a - b);  	if (alpha > 30 && alpha < 180 - 30) {  		var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  		var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  		var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  		pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The following statement contains a magic number: if (input.Type == SkillshotType.SkillshotLine && false) {  	var alpha = (input.From.To2D () - p).AngleBetween (a - b);  	if (alpha > 30 && alpha < 180 - 30) {  		var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  		var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  		var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  		pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  	}  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The following statement contains a magic number: if (alpha > 30 && alpha < 180 - 30) {  	var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  	var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  	var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  	pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The following statement contains a magic number: if (alpha > 30 && alpha < 180 - 30) {  	var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  	var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  	var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  	pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  }  
Magic Number,SebbyLib.Prediction,Prediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPositionOnPath,The following statement contains a magic number: if (alpha > 30 && alpha < 180 - 30) {  	var beta = (float)Math.Asin (input.RealRadius / p.Distance (input.From));  	var cp1 = input.From.To2D () + (p - input.From.To2D ()).Rotated (beta);  	var cp2 = input.From.To2D () + (p - input.From.To2D ()).Rotated (-beta);  	pos = cp1.Distance (pos' true) < cp2.Distance (pos' true) ? cp1 : cp2;  }  
Magic Number,SebbyLib.Prediction,AoePrediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPossibleTargets,The following statement contains a magic number: foreach (var enemy in HeroManager.Enemies.FindAll (h => h.NetworkId != originalUnit.NetworkId && h.IsValidTarget ((input.Range + 200 + input.RealRadius)' true' input.RangeCheckFrom))) {  	input.Unit = enemy;  	var prediction = Prediction.GetPrediction (input' false' false);  	if (prediction.Hitchance >= HitChance.High) {  		result.Add (new PossibleTarget {  			Position = prediction.UnitPosition.To2D ()'  			Unit = enemy  		});  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var position in positions) {  	foreach (var objectType in input.CollisionObjects) {  		switch (objectType) {  		case CollisionableObjects.Minions:  			foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  				var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  				if (distanceFromToUnit < 10 + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else {  					var minionPos = minion.ServerPosition;  					int bonusRadius = 15;  					if (minion.IsMoving) {  						var predInput2 = new PredictionInput {  							Collision = false'  							Speed = input.Speed'  							Delay = input.Delay'  							Range = input.Range'  							From = input.From'  							Radius = input.Radius'  							Unit = minion'  							Type = input.Type  						};  						minionPos = Prediction.GetPrediction (predInput2).CastPosition;  						bonusRadius = 50 + (int)input.Radius;  					}  					if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  						if (MinionIsDead (input' minion' distanceFromToUnit))  							continue;  						else  							return true;  					}  				}  			}  			break;  		case CollisionableObjects.Heroes:  			foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  				input.Unit = hero;  				var prediction = Prediction.GetPrediction (input' false' false);  				if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  					return true;  				}  			}  			break;  		case CollisionableObjects.Walls:  			var step = position.Distance (input.From) / 20;  			for (var i = 0; i < 20; i++) {  				var p = input.From.To2D ().Extend (position.To2D ()' step * i);  				if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  					return true;  				}  			}  			break;  		}  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var position in positions) {  	foreach (var objectType in input.CollisionObjects) {  		switch (objectType) {  		case CollisionableObjects.Minions:  			foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  				var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  				if (distanceFromToUnit < 10 + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else {  					var minionPos = minion.ServerPosition;  					int bonusRadius = 15;  					if (minion.IsMoving) {  						var predInput2 = new PredictionInput {  							Collision = false'  							Speed = input.Speed'  							Delay = input.Delay'  							Range = input.Range'  							From = input.From'  							Radius = input.Radius'  							Unit = minion'  							Type = input.Type  						};  						minionPos = Prediction.GetPrediction (predInput2).CastPosition;  						bonusRadius = 50 + (int)input.Radius;  					}  					if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  						if (MinionIsDead (input' minion' distanceFromToUnit))  							continue;  						else  							return true;  					}  				}  			}  			break;  		case CollisionableObjects.Heroes:  			foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  				input.Unit = hero;  				var prediction = Prediction.GetPrediction (input' false' false);  				if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  					return true;  				}  			}  			break;  		case CollisionableObjects.Walls:  			var step = position.Distance (input.From) / 20;  			for (var i = 0; i < 20; i++) {  				var p = input.From.To2D ().Extend (position.To2D ()' step * i);  				if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  					return true;  				}  			}  			break;  		}  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var position in positions) {  	foreach (var objectType in input.CollisionObjects) {  		switch (objectType) {  		case CollisionableObjects.Minions:  			foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  				var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  				if (distanceFromToUnit < 10 + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else {  					var minionPos = minion.ServerPosition;  					int bonusRadius = 15;  					if (minion.IsMoving) {  						var predInput2 = new PredictionInput {  							Collision = false'  							Speed = input.Speed'  							Delay = input.Delay'  							Range = input.Range'  							From = input.From'  							Radius = input.Radius'  							Unit = minion'  							Type = input.Type  						};  						minionPos = Prediction.GetPrediction (predInput2).CastPosition;  						bonusRadius = 50 + (int)input.Radius;  					}  					if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  						if (MinionIsDead (input' minion' distanceFromToUnit))  							continue;  						else  							return true;  					}  				}  			}  			break;  		case CollisionableObjects.Heroes:  			foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  				input.Unit = hero;  				var prediction = Prediction.GetPrediction (input' false' false);  				if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  					return true;  				}  			}  			break;  		case CollisionableObjects.Walls:  			var step = position.Distance (input.From) / 20;  			for (var i = 0; i < 20; i++) {  				var p = input.From.To2D ().Extend (position.To2D ()' step * i);  				if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  					return true;  				}  			}  			break;  		}  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var position in positions) {  	foreach (var objectType in input.CollisionObjects) {  		switch (objectType) {  		case CollisionableObjects.Minions:  			foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  				var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  				if (distanceFromToUnit < 10 + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else {  					var minionPos = minion.ServerPosition;  					int bonusRadius = 15;  					if (minion.IsMoving) {  						var predInput2 = new PredictionInput {  							Collision = false'  							Speed = input.Speed'  							Delay = input.Delay'  							Range = input.Range'  							From = input.From'  							Radius = input.Radius'  							Unit = minion'  							Type = input.Type  						};  						minionPos = Prediction.GetPrediction (predInput2).CastPosition;  						bonusRadius = 50 + (int)input.Radius;  					}  					if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  						if (MinionIsDead (input' minion' distanceFromToUnit))  							continue;  						else  							return true;  					}  				}  			}  			break;  		case CollisionableObjects.Heroes:  			foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  				input.Unit = hero;  				var prediction = Prediction.GetPrediction (input' false' false);  				if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  					return true;  				}  			}  			break;  		case CollisionableObjects.Walls:  			var step = position.Distance (input.From) / 20;  			for (var i = 0; i < 20; i++) {  				var p = input.From.To2D ().Extend (position.To2D ()' step * i);  				if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  					return true;  				}  			}  			break;  		}  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var position in positions) {  	foreach (var objectType in input.CollisionObjects) {  		switch (objectType) {  		case CollisionableObjects.Minions:  			foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  				var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  				if (distanceFromToUnit < 10 + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else {  					var minionPos = minion.ServerPosition;  					int bonusRadius = 15;  					if (minion.IsMoving) {  						var predInput2 = new PredictionInput {  							Collision = false'  							Speed = input.Speed'  							Delay = input.Delay'  							Range = input.Range'  							From = input.From'  							Radius = input.Radius'  							Unit = minion'  							Type = input.Type  						};  						minionPos = Prediction.GetPrediction (predInput2).CastPosition;  						bonusRadius = 50 + (int)input.Radius;  					}  					if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  						if (MinionIsDead (input' minion' distanceFromToUnit))  							continue;  						else  							return true;  					}  				}  			}  			break;  		case CollisionableObjects.Heroes:  			foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  				input.Unit = hero;  				var prediction = Prediction.GetPrediction (input' false' false);  				if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  					return true;  				}  			}  			break;  		case CollisionableObjects.Walls:  			var step = position.Distance (input.From) / 20;  			for (var i = 0; i < 20; i++) {  				var p = input.From.To2D ().Extend (position.To2D ()' step * i);  				if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  					return true;  				}  			}  			break;  		}  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var position in positions) {  	foreach (var objectType in input.CollisionObjects) {  		switch (objectType) {  		case CollisionableObjects.Minions:  			foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  				var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  				if (distanceFromToUnit < 10 + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else {  					var minionPos = minion.ServerPosition;  					int bonusRadius = 15;  					if (minion.IsMoving) {  						var predInput2 = new PredictionInput {  							Collision = false'  							Speed = input.Speed'  							Delay = input.Delay'  							Range = input.Range'  							From = input.From'  							Radius = input.Radius'  							Unit = minion'  							Type = input.Type  						};  						minionPos = Prediction.GetPrediction (predInput2).CastPosition;  						bonusRadius = 50 + (int)input.Radius;  					}  					if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  						if (MinionIsDead (input' minion' distanceFromToUnit))  							continue;  						else  							return true;  					}  				}  			}  			break;  		case CollisionableObjects.Heroes:  			foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  				input.Unit = hero;  				var prediction = Prediction.GetPrediction (input' false' false);  				if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  					return true;  				}  			}  			break;  		case CollisionableObjects.Walls:  			var step = position.Distance (input.From) / 20;  			for (var i = 0; i < 20; i++) {  				var p = input.From.To2D ().Extend (position.To2D ()' step * i);  				if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  					return true;  				}  			}  			break;  		}  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var position in positions) {  	foreach (var objectType in input.CollisionObjects) {  		switch (objectType) {  		case CollisionableObjects.Minions:  			foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  				var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  				if (distanceFromToUnit < 10 + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else {  					var minionPos = minion.ServerPosition;  					int bonusRadius = 15;  					if (minion.IsMoving) {  						var predInput2 = new PredictionInput {  							Collision = false'  							Speed = input.Speed'  							Delay = input.Delay'  							Range = input.Range'  							From = input.From'  							Radius = input.Radius'  							Unit = minion'  							Type = input.Type  						};  						minionPos = Prediction.GetPrediction (predInput2).CastPosition;  						bonusRadius = 50 + (int)input.Radius;  					}  					if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  						if (MinionIsDead (input' minion' distanceFromToUnit))  							continue;  						else  							return true;  					}  				}  			}  			break;  		case CollisionableObjects.Heroes:  			foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  				input.Unit = hero;  				var prediction = Prediction.GetPrediction (input' false' false);  				if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  					return true;  				}  			}  			break;  		case CollisionableObjects.Walls:  			var step = position.Distance (input.From) / 20;  			for (var i = 0; i < 20; i++) {  				var p = input.From.To2D ().Extend (position.To2D ()' step * i);  				if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  					return true;  				}  			}  			break;  		}  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var position in positions) {  	foreach (var objectType in input.CollisionObjects) {  		switch (objectType) {  		case CollisionableObjects.Minions:  			foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  				var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  				if (distanceFromToUnit < 10 + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else {  					var minionPos = minion.ServerPosition;  					int bonusRadius = 15;  					if (minion.IsMoving) {  						var predInput2 = new PredictionInput {  							Collision = false'  							Speed = input.Speed'  							Delay = input.Delay'  							Range = input.Range'  							From = input.From'  							Radius = input.Radius'  							Unit = minion'  							Type = input.Type  						};  						minionPos = Prediction.GetPrediction (predInput2).CastPosition;  						bonusRadius = 50 + (int)input.Radius;  					}  					if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  						if (MinionIsDead (input' minion' distanceFromToUnit))  							continue;  						else  							return true;  					}  				}  			}  			break;  		case CollisionableObjects.Heroes:  			foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  				input.Unit = hero;  				var prediction = Prediction.GetPrediction (input' false' false);  				if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  					return true;  				}  			}  			break;  		case CollisionableObjects.Walls:  			var step = position.Distance (input.From) / 20;  			for (var i = 0; i < 20; i++) {  				var p = input.From.To2D ().Extend (position.To2D ()' step * i);  				if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  					return true;  				}  			}  			break;  		}  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var position in positions) {  	foreach (var objectType in input.CollisionObjects) {  		switch (objectType) {  		case CollisionableObjects.Minions:  			foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  				var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  				if (distanceFromToUnit < 10 + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else {  					var minionPos = minion.ServerPosition;  					int bonusRadius = 15;  					if (minion.IsMoving) {  						var predInput2 = new PredictionInput {  							Collision = false'  							Speed = input.Speed'  							Delay = input.Delay'  							Range = input.Range'  							From = input.From'  							Radius = input.Radius'  							Unit = minion'  							Type = input.Type  						};  						minionPos = Prediction.GetPrediction (predInput2).CastPosition;  						bonusRadius = 50 + (int)input.Radius;  					}  					if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  						if (MinionIsDead (input' minion' distanceFromToUnit))  							continue;  						else  							return true;  					}  				}  			}  			break;  		case CollisionableObjects.Heroes:  			foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  				input.Unit = hero;  				var prediction = Prediction.GetPrediction (input' false' false);  				if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  					return true;  				}  			}  			break;  		case CollisionableObjects.Walls:  			var step = position.Distance (input.From) / 20;  			for (var i = 0; i < 20; i++) {  				var p = input.From.To2D ().Extend (position.To2D ()' step * i);  				if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  					return true;  				}  			}  			break;  		}  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var position in positions) {  	foreach (var objectType in input.CollisionObjects) {  		switch (objectType) {  		case CollisionableObjects.Minions:  			foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  				var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  				if (distanceFromToUnit < 10 + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else {  					var minionPos = minion.ServerPosition;  					int bonusRadius = 15;  					if (minion.IsMoving) {  						var predInput2 = new PredictionInput {  							Collision = false'  							Speed = input.Speed'  							Delay = input.Delay'  							Range = input.Range'  							From = input.From'  							Radius = input.Radius'  							Unit = minion'  							Type = input.Type  						};  						minionPos = Prediction.GetPrediction (predInput2).CastPosition;  						bonusRadius = 50 + (int)input.Radius;  					}  					if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  						if (MinionIsDead (input' minion' distanceFromToUnit))  							continue;  						else  							return true;  					}  				}  			}  			break;  		case CollisionableObjects.Heroes:  			foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  				input.Unit = hero;  				var prediction = Prediction.GetPrediction (input' false' false);  				if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  					return true;  				}  			}  			break;  		case CollisionableObjects.Walls:  			var step = position.Distance (input.From) / 20;  			for (var i = 0; i < 20; i++) {  				var p = input.From.To2D ().Extend (position.To2D ()' step * i);  				if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  					return true;  				}  			}  			break;  		}  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var position in positions) {  	foreach (var objectType in input.CollisionObjects) {  		switch (objectType) {  		case CollisionableObjects.Minions:  			foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  				var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  				if (distanceFromToUnit < 10 + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else {  					var minionPos = minion.ServerPosition;  					int bonusRadius = 15;  					if (minion.IsMoving) {  						var predInput2 = new PredictionInput {  							Collision = false'  							Speed = input.Speed'  							Delay = input.Delay'  							Range = input.Range'  							From = input.From'  							Radius = input.Radius'  							Unit = minion'  							Type = input.Type  						};  						minionPos = Prediction.GetPrediction (predInput2).CastPosition;  						bonusRadius = 50 + (int)input.Radius;  					}  					if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  						if (MinionIsDead (input' minion' distanceFromToUnit))  							continue;  						else  							return true;  					}  				}  			}  			break;  		case CollisionableObjects.Heroes:  			foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  				input.Unit = hero;  				var prediction = Prediction.GetPrediction (input' false' false);  				if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  					return true;  				}  			}  			break;  		case CollisionableObjects.Walls:  			var step = position.Distance (input.From) / 20;  			for (var i = 0; i < 20; i++) {  				var p = input.From.To2D ().Extend (position.To2D ()' step * i);  				if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  					return true;  				}  			}  			break;  		}  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var position in positions) {  	foreach (var objectType in input.CollisionObjects) {  		switch (objectType) {  		case CollisionableObjects.Minions:  			foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  				var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  				if (distanceFromToUnit < 10 + minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				} else {  					var minionPos = minion.ServerPosition;  					int bonusRadius = 15;  					if (minion.IsMoving) {  						var predInput2 = new PredictionInput {  							Collision = false'  							Speed = input.Speed'  							Delay = input.Delay'  							Range = input.Range'  							From = input.From'  							Radius = input.Radius'  							Unit = minion'  							Type = input.Type  						};  						minionPos = Prediction.GetPrediction (predInput2).CastPosition;  						bonusRadius = 50 + (int)input.Radius;  					}  					if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  						if (MinionIsDead (input' minion' distanceFromToUnit))  							continue;  						else  							return true;  					}  				}  			}  			break;  		case CollisionableObjects.Heroes:  			foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  				input.Unit = hero;  				var prediction = Prediction.GetPrediction (input' false' false);  				if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  					return true;  				}  			}  			break;  		case CollisionableObjects.Walls:  			var step = position.Distance (input.From) / 20;  			for (var i = 0; i < 20; i++) {  				var p = input.From.To2D ().Extend (position.To2D ()' step * i);  				if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  					return true;  				}  			}  			break;  		}  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var objectType in input.CollisionObjects) {  	switch (objectType) {  	case CollisionableObjects.Minions:  		foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  			var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  			if (distanceFromToUnit < 10 + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else {  				var minionPos = minion.ServerPosition;  				int bonusRadius = 15;  				if (minion.IsMoving) {  					var predInput2 = new PredictionInput {  						Collision = false'  						Speed = input.Speed'  						Delay = input.Delay'  						Range = input.Range'  						From = input.From'  						Radius = input.Radius'  						Unit = minion'  						Type = input.Type  					};  					minionPos = Prediction.GetPrediction (predInput2).CastPosition;  					bonusRadius = 50 + (int)input.Radius;  				}  				if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				}  			}  		}  		break;  	case CollisionableObjects.Heroes:  		foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  			input.Unit = hero;  			var prediction = Prediction.GetPrediction (input' false' false);  			if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  				return true;  			}  		}  		break;  	case CollisionableObjects.Walls:  		var step = position.Distance (input.From) / 20;  		for (var i = 0; i < 20; i++) {  			var p = input.From.To2D ().Extend (position.To2D ()' step * i);  			if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  				return true;  			}  		}  		break;  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var objectType in input.CollisionObjects) {  	switch (objectType) {  	case CollisionableObjects.Minions:  		foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  			var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  			if (distanceFromToUnit < 10 + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else {  				var minionPos = minion.ServerPosition;  				int bonusRadius = 15;  				if (minion.IsMoving) {  					var predInput2 = new PredictionInput {  						Collision = false'  						Speed = input.Speed'  						Delay = input.Delay'  						Range = input.Range'  						From = input.From'  						Radius = input.Radius'  						Unit = minion'  						Type = input.Type  					};  					minionPos = Prediction.GetPrediction (predInput2).CastPosition;  					bonusRadius = 50 + (int)input.Radius;  				}  				if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				}  			}  		}  		break;  	case CollisionableObjects.Heroes:  		foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  			input.Unit = hero;  			var prediction = Prediction.GetPrediction (input' false' false);  			if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  				return true;  			}  		}  		break;  	case CollisionableObjects.Walls:  		var step = position.Distance (input.From) / 20;  		for (var i = 0; i < 20; i++) {  			var p = input.From.To2D ().Extend (position.To2D ()' step * i);  			if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  				return true;  			}  		}  		break;  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var objectType in input.CollisionObjects) {  	switch (objectType) {  	case CollisionableObjects.Minions:  		foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  			var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  			if (distanceFromToUnit < 10 + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else {  				var minionPos = minion.ServerPosition;  				int bonusRadius = 15;  				if (minion.IsMoving) {  					var predInput2 = new PredictionInput {  						Collision = false'  						Speed = input.Speed'  						Delay = input.Delay'  						Range = input.Range'  						From = input.From'  						Radius = input.Radius'  						Unit = minion'  						Type = input.Type  					};  					minionPos = Prediction.GetPrediction (predInput2).CastPosition;  					bonusRadius = 50 + (int)input.Radius;  				}  				if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				}  			}  		}  		break;  	case CollisionableObjects.Heroes:  		foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  			input.Unit = hero;  			var prediction = Prediction.GetPrediction (input' false' false);  			if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  				return true;  			}  		}  		break;  	case CollisionableObjects.Walls:  		var step = position.Distance (input.From) / 20;  		for (var i = 0; i < 20; i++) {  			var p = input.From.To2D ().Extend (position.To2D ()' step * i);  			if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  				return true;  			}  		}  		break;  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var objectType in input.CollisionObjects) {  	switch (objectType) {  	case CollisionableObjects.Minions:  		foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  			var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  			if (distanceFromToUnit < 10 + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else {  				var minionPos = minion.ServerPosition;  				int bonusRadius = 15;  				if (minion.IsMoving) {  					var predInput2 = new PredictionInput {  						Collision = false'  						Speed = input.Speed'  						Delay = input.Delay'  						Range = input.Range'  						From = input.From'  						Radius = input.Radius'  						Unit = minion'  						Type = input.Type  					};  					minionPos = Prediction.GetPrediction (predInput2).CastPosition;  					bonusRadius = 50 + (int)input.Radius;  				}  				if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				}  			}  		}  		break;  	case CollisionableObjects.Heroes:  		foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  			input.Unit = hero;  			var prediction = Prediction.GetPrediction (input' false' false);  			if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  				return true;  			}  		}  		break;  	case CollisionableObjects.Walls:  		var step = position.Distance (input.From) / 20;  		for (var i = 0; i < 20; i++) {  			var p = input.From.To2D ().Extend (position.To2D ()' step * i);  			if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  				return true;  			}  		}  		break;  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var objectType in input.CollisionObjects) {  	switch (objectType) {  	case CollisionableObjects.Minions:  		foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  			var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  			if (distanceFromToUnit < 10 + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else {  				var minionPos = minion.ServerPosition;  				int bonusRadius = 15;  				if (minion.IsMoving) {  					var predInput2 = new PredictionInput {  						Collision = false'  						Speed = input.Speed'  						Delay = input.Delay'  						Range = input.Range'  						From = input.From'  						Radius = input.Radius'  						Unit = minion'  						Type = input.Type  					};  					minionPos = Prediction.GetPrediction (predInput2).CastPosition;  					bonusRadius = 50 + (int)input.Radius;  				}  				if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				}  			}  		}  		break;  	case CollisionableObjects.Heroes:  		foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  			input.Unit = hero;  			var prediction = Prediction.GetPrediction (input' false' false);  			if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  				return true;  			}  		}  		break;  	case CollisionableObjects.Walls:  		var step = position.Distance (input.From) / 20;  		for (var i = 0; i < 20; i++) {  			var p = input.From.To2D ().Extend (position.To2D ()' step * i);  			if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  				return true;  			}  		}  		break;  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var objectType in input.CollisionObjects) {  	switch (objectType) {  	case CollisionableObjects.Minions:  		foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  			var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  			if (distanceFromToUnit < 10 + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else {  				var minionPos = minion.ServerPosition;  				int bonusRadius = 15;  				if (minion.IsMoving) {  					var predInput2 = new PredictionInput {  						Collision = false'  						Speed = input.Speed'  						Delay = input.Delay'  						Range = input.Range'  						From = input.From'  						Radius = input.Radius'  						Unit = minion'  						Type = input.Type  					};  					minionPos = Prediction.GetPrediction (predInput2).CastPosition;  					bonusRadius = 50 + (int)input.Radius;  				}  				if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				}  			}  		}  		break;  	case CollisionableObjects.Heroes:  		foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  			input.Unit = hero;  			var prediction = Prediction.GetPrediction (input' false' false);  			if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  				return true;  			}  		}  		break;  	case CollisionableObjects.Walls:  		var step = position.Distance (input.From) / 20;  		for (var i = 0; i < 20; i++) {  			var p = input.From.To2D ().Extend (position.To2D ()' step * i);  			if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  				return true;  			}  		}  		break;  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var objectType in input.CollisionObjects) {  	switch (objectType) {  	case CollisionableObjects.Minions:  		foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  			var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  			if (distanceFromToUnit < 10 + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else {  				var minionPos = minion.ServerPosition;  				int bonusRadius = 15;  				if (minion.IsMoving) {  					var predInput2 = new PredictionInput {  						Collision = false'  						Speed = input.Speed'  						Delay = input.Delay'  						Range = input.Range'  						From = input.From'  						Radius = input.Radius'  						Unit = minion'  						Type = input.Type  					};  					minionPos = Prediction.GetPrediction (predInput2).CastPosition;  					bonusRadius = 50 + (int)input.Radius;  				}  				if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				}  			}  		}  		break;  	case CollisionableObjects.Heroes:  		foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  			input.Unit = hero;  			var prediction = Prediction.GetPrediction (input' false' false);  			if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  				return true;  			}  		}  		break;  	case CollisionableObjects.Walls:  		var step = position.Distance (input.From) / 20;  		for (var i = 0; i < 20; i++) {  			var p = input.From.To2D ().Extend (position.To2D ()' step * i);  			if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  				return true;  			}  		}  		break;  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var objectType in input.CollisionObjects) {  	switch (objectType) {  	case CollisionableObjects.Minions:  		foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  			var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  			if (distanceFromToUnit < 10 + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else {  				var minionPos = minion.ServerPosition;  				int bonusRadius = 15;  				if (minion.IsMoving) {  					var predInput2 = new PredictionInput {  						Collision = false'  						Speed = input.Speed'  						Delay = input.Delay'  						Range = input.Range'  						From = input.From'  						Radius = input.Radius'  						Unit = minion'  						Type = input.Type  					};  					minionPos = Prediction.GetPrediction (predInput2).CastPosition;  					bonusRadius = 50 + (int)input.Radius;  				}  				if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				}  			}  		}  		break;  	case CollisionableObjects.Heroes:  		foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  			input.Unit = hero;  			var prediction = Prediction.GetPrediction (input' false' false);  			if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  				return true;  			}  		}  		break;  	case CollisionableObjects.Walls:  		var step = position.Distance (input.From) / 20;  		for (var i = 0; i < 20; i++) {  			var p = input.From.To2D ().Extend (position.To2D ()' step * i);  			if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  				return true;  			}  		}  		break;  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var objectType in input.CollisionObjects) {  	switch (objectType) {  	case CollisionableObjects.Minions:  		foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  			var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  			if (distanceFromToUnit < 10 + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else {  				var minionPos = minion.ServerPosition;  				int bonusRadius = 15;  				if (minion.IsMoving) {  					var predInput2 = new PredictionInput {  						Collision = false'  						Speed = input.Speed'  						Delay = input.Delay'  						Range = input.Range'  						From = input.From'  						Radius = input.Radius'  						Unit = minion'  						Type = input.Type  					};  					minionPos = Prediction.GetPrediction (predInput2).CastPosition;  					bonusRadius = 50 + (int)input.Radius;  				}  				if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				}  			}  		}  		break;  	case CollisionableObjects.Heroes:  		foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  			input.Unit = hero;  			var prediction = Prediction.GetPrediction (input' false' false);  			if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  				return true;  			}  		}  		break;  	case CollisionableObjects.Walls:  		var step = position.Distance (input.From) / 20;  		for (var i = 0; i < 20; i++) {  			var p = input.From.To2D ().Extend (position.To2D ()' step * i);  			if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  				return true;  			}  		}  		break;  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var objectType in input.CollisionObjects) {  	switch (objectType) {  	case CollisionableObjects.Minions:  		foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  			var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  			if (distanceFromToUnit < 10 + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else {  				var minionPos = minion.ServerPosition;  				int bonusRadius = 15;  				if (minion.IsMoving) {  					var predInput2 = new PredictionInput {  						Collision = false'  						Speed = input.Speed'  						Delay = input.Delay'  						Range = input.Range'  						From = input.From'  						Radius = input.Radius'  						Unit = minion'  						Type = input.Type  					};  					minionPos = Prediction.GetPrediction (predInput2).CastPosition;  					bonusRadius = 50 + (int)input.Radius;  				}  				if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				}  			}  		}  		break;  	case CollisionableObjects.Heroes:  		foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  			input.Unit = hero;  			var prediction = Prediction.GetPrediction (input' false' false);  			if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  				return true;  			}  		}  		break;  	case CollisionableObjects.Walls:  		var step = position.Distance (input.From) / 20;  		for (var i = 0; i < 20; i++) {  			var p = input.From.To2D ().Extend (position.To2D ()' step * i);  			if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  				return true;  			}  		}  		break;  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var objectType in input.CollisionObjects) {  	switch (objectType) {  	case CollisionableObjects.Minions:  		foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  			var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  			if (distanceFromToUnit < 10 + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else {  				var minionPos = minion.ServerPosition;  				int bonusRadius = 15;  				if (minion.IsMoving) {  					var predInput2 = new PredictionInput {  						Collision = false'  						Speed = input.Speed'  						Delay = input.Delay'  						Range = input.Range'  						From = input.From'  						Radius = input.Radius'  						Unit = minion'  						Type = input.Type  					};  					minionPos = Prediction.GetPrediction (predInput2).CastPosition;  					bonusRadius = 50 + (int)input.Radius;  				}  				if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				}  			}  		}  		break;  	case CollisionableObjects.Heroes:  		foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  			input.Unit = hero;  			var prediction = Prediction.GetPrediction (input' false' false);  			if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  				return true;  			}  		}  		break;  	case CollisionableObjects.Walls:  		var step = position.Distance (input.From) / 20;  		for (var i = 0; i < 20; i++) {  			var p = input.From.To2D ().Extend (position.To2D ()' step * i);  			if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  				return true;  			}  		}  		break;  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var objectType in input.CollisionObjects) {  	switch (objectType) {  	case CollisionableObjects.Minions:  		foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  			var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  			if (distanceFromToUnit < 10 + minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			} else {  				var minionPos = minion.ServerPosition;  				int bonusRadius = 15;  				if (minion.IsMoving) {  					var predInput2 = new PredictionInput {  						Collision = false'  						Speed = input.Speed'  						Delay = input.Delay'  						Range = input.Range'  						From = input.From'  						Radius = input.Radius'  						Unit = minion'  						Type = input.Type  					};  					minionPos = Prediction.GetPrediction (predInput2).CastPosition;  					bonusRadius = 50 + (int)input.Radius;  				}  				if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  					if (MinionIsDead (input' minion' distanceFromToUnit))  						continue;  					else  						return true;  				}  			}  		}  		break;  	case CollisionableObjects.Heroes:  		foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  			input.Unit = hero;  			var prediction = Prediction.GetPrediction (input' false' false);  			if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  				return true;  			}  		}  		break;  	case CollisionableObjects.Walls:  		var step = position.Distance (input.From) / 20;  		for (var i = 0; i < 20; i++) {  			var p = input.From.To2D ().Extend (position.To2D ()' step * i);  			if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  				return true;  			}  		}  		break;  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: switch (objectType) {  case CollisionableObjects.Minions:  	foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  		var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  		if (distanceFromToUnit < 10 + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else {  			var minionPos = minion.ServerPosition;  			int bonusRadius = 15;  			if (minion.IsMoving) {  				var predInput2 = new PredictionInput {  					Collision = false'  					Speed = input.Speed'  					Delay = input.Delay'  					Range = input.Range'  					From = input.From'  					Radius = input.Radius'  					Unit = minion'  					Type = input.Type  				};  				minionPos = Prediction.GetPrediction (predInput2).CastPosition;  				bonusRadius = 50 + (int)input.Radius;  			}  			if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			}  		}  	}  	break;  case CollisionableObjects.Heroes:  	foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  		input.Unit = hero;  		var prediction = Prediction.GetPrediction (input' false' false);  		if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  			return true;  		}  	}  	break;  case CollisionableObjects.Walls:  	var step = position.Distance (input.From) / 20;  	for (var i = 0; i < 20; i++) {  		var p = input.From.To2D ().Extend (position.To2D ()' step * i);  		if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  			return true;  		}  	}  	break;  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: switch (objectType) {  case CollisionableObjects.Minions:  	foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  		var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  		if (distanceFromToUnit < 10 + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else {  			var minionPos = minion.ServerPosition;  			int bonusRadius = 15;  			if (minion.IsMoving) {  				var predInput2 = new PredictionInput {  					Collision = false'  					Speed = input.Speed'  					Delay = input.Delay'  					Range = input.Range'  					From = input.From'  					Radius = input.Radius'  					Unit = minion'  					Type = input.Type  				};  				minionPos = Prediction.GetPrediction (predInput2).CastPosition;  				bonusRadius = 50 + (int)input.Radius;  			}  			if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			}  		}  	}  	break;  case CollisionableObjects.Heroes:  	foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  		input.Unit = hero;  		var prediction = Prediction.GetPrediction (input' false' false);  		if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  			return true;  		}  	}  	break;  case CollisionableObjects.Walls:  	var step = position.Distance (input.From) / 20;  	for (var i = 0; i < 20; i++) {  		var p = input.From.To2D ().Extend (position.To2D ()' step * i);  		if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  			return true;  		}  	}  	break;  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: switch (objectType) {  case CollisionableObjects.Minions:  	foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  		var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  		if (distanceFromToUnit < 10 + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else {  			var minionPos = minion.ServerPosition;  			int bonusRadius = 15;  			if (minion.IsMoving) {  				var predInput2 = new PredictionInput {  					Collision = false'  					Speed = input.Speed'  					Delay = input.Delay'  					Range = input.Range'  					From = input.From'  					Radius = input.Radius'  					Unit = minion'  					Type = input.Type  				};  				minionPos = Prediction.GetPrediction (predInput2).CastPosition;  				bonusRadius = 50 + (int)input.Radius;  			}  			if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			}  		}  	}  	break;  case CollisionableObjects.Heroes:  	foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  		input.Unit = hero;  		var prediction = Prediction.GetPrediction (input' false' false);  		if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  			return true;  		}  	}  	break;  case CollisionableObjects.Walls:  	var step = position.Distance (input.From) / 20;  	for (var i = 0; i < 20; i++) {  		var p = input.From.To2D ().Extend (position.To2D ()' step * i);  		if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  			return true;  		}  	}  	break;  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: switch (objectType) {  case CollisionableObjects.Minions:  	foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  		var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  		if (distanceFromToUnit < 10 + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else {  			var minionPos = minion.ServerPosition;  			int bonusRadius = 15;  			if (minion.IsMoving) {  				var predInput2 = new PredictionInput {  					Collision = false'  					Speed = input.Speed'  					Delay = input.Delay'  					Range = input.Range'  					From = input.From'  					Radius = input.Radius'  					Unit = minion'  					Type = input.Type  				};  				minionPos = Prediction.GetPrediction (predInput2).CastPosition;  				bonusRadius = 50 + (int)input.Radius;  			}  			if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			}  		}  	}  	break;  case CollisionableObjects.Heroes:  	foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  		input.Unit = hero;  		var prediction = Prediction.GetPrediction (input' false' false);  		if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  			return true;  		}  	}  	break;  case CollisionableObjects.Walls:  	var step = position.Distance (input.From) / 20;  	for (var i = 0; i < 20; i++) {  		var p = input.From.To2D ().Extend (position.To2D ()' step * i);  		if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  			return true;  		}  	}  	break;  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: switch (objectType) {  case CollisionableObjects.Minions:  	foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  		var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  		if (distanceFromToUnit < 10 + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else {  			var minionPos = minion.ServerPosition;  			int bonusRadius = 15;  			if (minion.IsMoving) {  				var predInput2 = new PredictionInput {  					Collision = false'  					Speed = input.Speed'  					Delay = input.Delay'  					Range = input.Range'  					From = input.From'  					Radius = input.Radius'  					Unit = minion'  					Type = input.Type  				};  				minionPos = Prediction.GetPrediction (predInput2).CastPosition;  				bonusRadius = 50 + (int)input.Radius;  			}  			if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			}  		}  	}  	break;  case CollisionableObjects.Heroes:  	foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  		input.Unit = hero;  		var prediction = Prediction.GetPrediction (input' false' false);  		if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  			return true;  		}  	}  	break;  case CollisionableObjects.Walls:  	var step = position.Distance (input.From) / 20;  	for (var i = 0; i < 20; i++) {  		var p = input.From.To2D ().Extend (position.To2D ()' step * i);  		if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  			return true;  		}  	}  	break;  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: switch (objectType) {  case CollisionableObjects.Minions:  	foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  		var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  		if (distanceFromToUnit < 10 + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else {  			var minionPos = minion.ServerPosition;  			int bonusRadius = 15;  			if (minion.IsMoving) {  				var predInput2 = new PredictionInput {  					Collision = false'  					Speed = input.Speed'  					Delay = input.Delay'  					Range = input.Range'  					From = input.From'  					Radius = input.Radius'  					Unit = minion'  					Type = input.Type  				};  				minionPos = Prediction.GetPrediction (predInput2).CastPosition;  				bonusRadius = 50 + (int)input.Radius;  			}  			if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			}  		}  	}  	break;  case CollisionableObjects.Heroes:  	foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  		input.Unit = hero;  		var prediction = Prediction.GetPrediction (input' false' false);  		if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  			return true;  		}  	}  	break;  case CollisionableObjects.Walls:  	var step = position.Distance (input.From) / 20;  	for (var i = 0; i < 20; i++) {  		var p = input.From.To2D ().Extend (position.To2D ()' step * i);  		if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  			return true;  		}  	}  	break;  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: switch (objectType) {  case CollisionableObjects.Minions:  	foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  		var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  		if (distanceFromToUnit < 10 + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else {  			var minionPos = minion.ServerPosition;  			int bonusRadius = 15;  			if (minion.IsMoving) {  				var predInput2 = new PredictionInput {  					Collision = false'  					Speed = input.Speed'  					Delay = input.Delay'  					Range = input.Range'  					From = input.From'  					Radius = input.Radius'  					Unit = minion'  					Type = input.Type  				};  				minionPos = Prediction.GetPrediction (predInput2).CastPosition;  				bonusRadius = 50 + (int)input.Radius;  			}  			if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			}  		}  	}  	break;  case CollisionableObjects.Heroes:  	foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  		input.Unit = hero;  		var prediction = Prediction.GetPrediction (input' false' false);  		if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  			return true;  		}  	}  	break;  case CollisionableObjects.Walls:  	var step = position.Distance (input.From) / 20;  	for (var i = 0; i < 20; i++) {  		var p = input.From.To2D ().Extend (position.To2D ()' step * i);  		if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  			return true;  		}  	}  	break;  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: switch (objectType) {  case CollisionableObjects.Minions:  	foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  		var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  		if (distanceFromToUnit < 10 + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else {  			var minionPos = minion.ServerPosition;  			int bonusRadius = 15;  			if (minion.IsMoving) {  				var predInput2 = new PredictionInput {  					Collision = false'  					Speed = input.Speed'  					Delay = input.Delay'  					Range = input.Range'  					From = input.From'  					Radius = input.Radius'  					Unit = minion'  					Type = input.Type  				};  				minionPos = Prediction.GetPrediction (predInput2).CastPosition;  				bonusRadius = 50 + (int)input.Radius;  			}  			if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			}  		}  	}  	break;  case CollisionableObjects.Heroes:  	foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  		input.Unit = hero;  		var prediction = Prediction.GetPrediction (input' false' false);  		if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  			return true;  		}  	}  	break;  case CollisionableObjects.Walls:  	var step = position.Distance (input.From) / 20;  	for (var i = 0; i < 20; i++) {  		var p = input.From.To2D ().Extend (position.To2D ()' step * i);  		if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  			return true;  		}  	}  	break;  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: switch (objectType) {  case CollisionableObjects.Minions:  	foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  		var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  		if (distanceFromToUnit < 10 + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else {  			var minionPos = minion.ServerPosition;  			int bonusRadius = 15;  			if (minion.IsMoving) {  				var predInput2 = new PredictionInput {  					Collision = false'  					Speed = input.Speed'  					Delay = input.Delay'  					Range = input.Range'  					From = input.From'  					Radius = input.Radius'  					Unit = minion'  					Type = input.Type  				};  				minionPos = Prediction.GetPrediction (predInput2).CastPosition;  				bonusRadius = 50 + (int)input.Radius;  			}  			if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			}  		}  	}  	break;  case CollisionableObjects.Heroes:  	foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  		input.Unit = hero;  		var prediction = Prediction.GetPrediction (input' false' false);  		if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  			return true;  		}  	}  	break;  case CollisionableObjects.Walls:  	var step = position.Distance (input.From) / 20;  	for (var i = 0; i < 20; i++) {  		var p = input.From.To2D ().Extend (position.To2D ()' step * i);  		if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  			return true;  		}  	}  	break;  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: switch (objectType) {  case CollisionableObjects.Minions:  	foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  		var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  		if (distanceFromToUnit < 10 + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else {  			var minionPos = minion.ServerPosition;  			int bonusRadius = 15;  			if (minion.IsMoving) {  				var predInput2 = new PredictionInput {  					Collision = false'  					Speed = input.Speed'  					Delay = input.Delay'  					Range = input.Range'  					From = input.From'  					Radius = input.Radius'  					Unit = minion'  					Type = input.Type  				};  				minionPos = Prediction.GetPrediction (predInput2).CastPosition;  				bonusRadius = 50 + (int)input.Radius;  			}  			if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			}  		}  	}  	break;  case CollisionableObjects.Heroes:  	foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  		input.Unit = hero;  		var prediction = Prediction.GetPrediction (input' false' false);  		if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  			return true;  		}  	}  	break;  case CollisionableObjects.Walls:  	var step = position.Distance (input.From) / 20;  	for (var i = 0; i < 20; i++) {  		var p = input.From.To2D ().Extend (position.To2D ()' step * i);  		if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  			return true;  		}  	}  	break;  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: switch (objectType) {  case CollisionableObjects.Minions:  	foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  		var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  		if (distanceFromToUnit < 10 + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else {  			var minionPos = minion.ServerPosition;  			int bonusRadius = 15;  			if (minion.IsMoving) {  				var predInput2 = new PredictionInput {  					Collision = false'  					Speed = input.Speed'  					Delay = input.Delay'  					Range = input.Range'  					From = input.From'  					Radius = input.Radius'  					Unit = minion'  					Type = input.Type  				};  				minionPos = Prediction.GetPrediction (predInput2).CastPosition;  				bonusRadius = 50 + (int)input.Radius;  			}  			if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			}  		}  	}  	break;  case CollisionableObjects.Heroes:  	foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  		input.Unit = hero;  		var prediction = Prediction.GetPrediction (input' false' false);  		if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  			return true;  		}  	}  	break;  case CollisionableObjects.Walls:  	var step = position.Distance (input.From) / 20;  	for (var i = 0; i < 20; i++) {  		var p = input.From.To2D ().Extend (position.To2D ()' step * i);  		if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  			return true;  		}  	}  	break;  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: switch (objectType) {  case CollisionableObjects.Minions:  	foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  		var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  		if (distanceFromToUnit < 10 + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else {  			var minionPos = minion.ServerPosition;  			int bonusRadius = 15;  			if (minion.IsMoving) {  				var predInput2 = new PredictionInput {  					Collision = false'  					Speed = input.Speed'  					Delay = input.Delay'  					Range = input.Range'  					From = input.From'  					Radius = input.Radius'  					Unit = minion'  					Type = input.Type  				};  				minionPos = Prediction.GetPrediction (predInput2).CastPosition;  				bonusRadius = 50 + (int)input.Radius;  			}  			if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			}  		}  	}  	break;  case CollisionableObjects.Heroes:  	foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  		input.Unit = hero;  		var prediction = Prediction.GetPrediction (input' false' false);  		if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  			return true;  		}  	}  	break;  case CollisionableObjects.Walls:  	var step = position.Distance (input.From) / 20;  	for (var i = 0; i < 20; i++) {  		var p = input.From.To2D ().Extend (position.To2D ()' step * i);  		if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  			return true;  		}  	}  	break;  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  	var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  	if (distanceFromToUnit < 10 + minion.BoundingRadius) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	} else {  		var minionPos = minion.ServerPosition;  		int bonusRadius = 15;  		if (minion.IsMoving) {  			var predInput2 = new PredictionInput {  				Collision = false'  				Speed = input.Speed'  				Delay = input.Delay'  				Range = input.Range'  				From = input.From'  				Radius = input.Radius'  				Unit = minion'  				Type = input.Type  			};  			minionPos = Prediction.GetPrediction (predInput2).CastPosition;  			bonusRadius = 50 + (int)input.Radius;  		}  		if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		}  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  	var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  	if (distanceFromToUnit < 10 + minion.BoundingRadius) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	} else {  		var minionPos = minion.ServerPosition;  		int bonusRadius = 15;  		if (minion.IsMoving) {  			var predInput2 = new PredictionInput {  				Collision = false'  				Speed = input.Speed'  				Delay = input.Delay'  				Range = input.Range'  				From = input.From'  				Radius = input.Radius'  				Unit = minion'  				Type = input.Type  			};  			minionPos = Prediction.GetPrediction (predInput2).CastPosition;  			bonusRadius = 50 + (int)input.Radius;  		}  		if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		}  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  	var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  	if (distanceFromToUnit < 10 + minion.BoundingRadius) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	} else {  		var minionPos = minion.ServerPosition;  		int bonusRadius = 15;  		if (minion.IsMoving) {  			var predInput2 = new PredictionInput {  				Collision = false'  				Speed = input.Speed'  				Delay = input.Delay'  				Range = input.Range'  				From = input.From'  				Radius = input.Radius'  				Unit = minion'  				Type = input.Type  			};  			minionPos = Prediction.GetPrediction (predInput2).CastPosition;  			bonusRadius = 50 + (int)input.Radius;  		}  		if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		}  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  	var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  	if (distanceFromToUnit < 10 + minion.BoundingRadius) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	} else {  		var minionPos = minion.ServerPosition;  		int bonusRadius = 15;  		if (minion.IsMoving) {  			var predInput2 = new PredictionInput {  				Collision = false'  				Speed = input.Speed'  				Delay = input.Delay'  				Range = input.Range'  				From = input.From'  				Radius = input.Radius'  				Unit = minion'  				Type = input.Type  			};  			minionPos = Prediction.GetPrediction (predInput2).CastPosition;  			bonusRadius = 50 + (int)input.Radius;  		}  		if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		}  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  	var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  	if (distanceFromToUnit < 10 + minion.BoundingRadius) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	} else {  		var minionPos = minion.ServerPosition;  		int bonusRadius = 15;  		if (minion.IsMoving) {  			var predInput2 = new PredictionInput {  				Collision = false'  				Speed = input.Speed'  				Delay = input.Delay'  				Range = input.Range'  				From = input.From'  				Radius = input.Radius'  				Unit = minion'  				Type = input.Type  			};  			minionPos = Prediction.GetPrediction (predInput2).CastPosition;  			bonusRadius = 50 + (int)input.Radius;  		}  		if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		}  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  	var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  	if (distanceFromToUnit < 10 + minion.BoundingRadius) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	} else {  		var minionPos = minion.ServerPosition;  		int bonusRadius = 15;  		if (minion.IsMoving) {  			var predInput2 = new PredictionInput {  				Collision = false'  				Speed = input.Speed'  				Delay = input.Delay'  				Range = input.Range'  				From = input.From'  				Radius = input.Radius'  				Unit = minion'  				Type = input.Type  			};  			minionPos = Prediction.GetPrediction (predInput2).CastPosition;  			bonusRadius = 50 + (int)input.Radius;  		}  		if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		}  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: if (distanceFromToUnit < 10 + minion.BoundingRadius) {  	if (MinionIsDead (input' minion' distanceFromToUnit))  		continue;  	else  		return true;  } else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  	if (MinionIsDead (input' minion' distanceFromToUnit))  		continue;  	else  		return true;  } else {  	var minionPos = minion.ServerPosition;  	int bonusRadius = 15;  	if (minion.IsMoving) {  		var predInput2 = new PredictionInput {  			Collision = false'  			Speed = input.Speed'  			Delay = input.Delay'  			Range = input.Range'  			From = input.From'  			Radius = input.Radius'  			Unit = minion'  			Type = input.Type  		};  		minionPos = Prediction.GetPrediction (predInput2).CastPosition;  		bonusRadius = 50 + (int)input.Radius;  	}  	if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: if (distanceFromToUnit < 10 + minion.BoundingRadius) {  	if (MinionIsDead (input' minion' distanceFromToUnit))  		continue;  	else  		return true;  } else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  	if (MinionIsDead (input' minion' distanceFromToUnit))  		continue;  	else  		return true;  } else {  	var minionPos = minion.ServerPosition;  	int bonusRadius = 15;  	if (minion.IsMoving) {  		var predInput2 = new PredictionInput {  			Collision = false'  			Speed = input.Speed'  			Delay = input.Delay'  			Range = input.Range'  			From = input.From'  			Radius = input.Radius'  			Unit = minion'  			Type = input.Type  		};  		minionPos = Prediction.GetPrediction (predInput2).CastPosition;  		bonusRadius = 50 + (int)input.Radius;  	}  	if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: if (distanceFromToUnit < 10 + minion.BoundingRadius) {  	if (MinionIsDead (input' minion' distanceFromToUnit))  		continue;  	else  		return true;  } else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  	if (MinionIsDead (input' minion' distanceFromToUnit))  		continue;  	else  		return true;  } else {  	var minionPos = minion.ServerPosition;  	int bonusRadius = 15;  	if (minion.IsMoving) {  		var predInput2 = new PredictionInput {  			Collision = false'  			Speed = input.Speed'  			Delay = input.Delay'  			Range = input.Range'  			From = input.From'  			Radius = input.Radius'  			Unit = minion'  			Type = input.Type  		};  		minionPos = Prediction.GetPrediction (predInput2).CastPosition;  		bonusRadius = 50 + (int)input.Radius;  	}  	if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: if (distanceFromToUnit < 10 + minion.BoundingRadius) {  	if (MinionIsDead (input' minion' distanceFromToUnit))  		continue;  	else  		return true;  } else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  	if (MinionIsDead (input' minion' distanceFromToUnit))  		continue;  	else  		return true;  } else {  	var minionPos = minion.ServerPosition;  	int bonusRadius = 15;  	if (minion.IsMoving) {  		var predInput2 = new PredictionInput {  			Collision = false'  			Speed = input.Speed'  			Delay = input.Delay'  			Range = input.Range'  			From = input.From'  			Radius = input.Radius'  			Unit = minion'  			Type = input.Type  		};  		minionPos = Prediction.GetPrediction (predInput2).CastPosition;  		bonusRadius = 50 + (int)input.Radius;  	}  	if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  	if (MinionIsDead (input' minion' distanceFromToUnit))  		continue;  	else  		return true;  } else {  	var minionPos = minion.ServerPosition;  	int bonusRadius = 15;  	if (minion.IsMoving) {  		var predInput2 = new PredictionInput {  			Collision = false'  			Speed = input.Speed'  			Delay = input.Delay'  			Range = input.Range'  			From = input.From'  			Radius = input.Radius'  			Unit = minion'  			Type = input.Type  		};  		minionPos = Prediction.GetPrediction (predInput2).CastPosition;  		bonusRadius = 50 + (int)input.Radius;  	}  	if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  	if (MinionIsDead (input' minion' distanceFromToUnit))  		continue;  	else  		return true;  } else {  	var minionPos = minion.ServerPosition;  	int bonusRadius = 15;  	if (minion.IsMoving) {  		var predInput2 = new PredictionInput {  			Collision = false'  			Speed = input.Speed'  			Delay = input.Delay'  			Range = input.Range'  			From = input.From'  			Radius = input.Radius'  			Unit = minion'  			Type = input.Type  		};  		minionPos = Prediction.GetPrediction (predInput2).CastPosition;  		bonusRadius = 50 + (int)input.Radius;  	}  	if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  	if (MinionIsDead (input' minion' distanceFromToUnit))  		continue;  	else  		return true;  } else {  	var minionPos = minion.ServerPosition;  	int bonusRadius = 15;  	if (minion.IsMoving) {  		var predInput2 = new PredictionInput {  			Collision = false'  			Speed = input.Speed'  			Delay = input.Delay'  			Range = input.Range'  			From = input.From'  			Radius = input.Radius'  			Unit = minion'  			Type = input.Type  		};  		minionPos = Prediction.GetPrediction (predInput2).CastPosition;  		bonusRadius = 50 + (int)input.Radius;  	}  	if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  		if (MinionIsDead (input' minion' distanceFromToUnit))  			continue;  		else  			return true;  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: if (minion.IsMoving) {  	var predInput2 = new PredictionInput {  		Collision = false'  		Speed = input.Speed'  		Delay = input.Delay'  		Range = input.Range'  		From = input.From'  		Radius = input.Radius'  		Unit = minion'  		Type = input.Type  	};  	minionPos = Prediction.GetPrediction (predInput2).CastPosition;  	bonusRadius = 50 + (int)input.Radius;  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: bonusRadius = 50 + (int)input.Radius;  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  	if (MinionIsDead (input' minion' distanceFromToUnit))  		continue;  	else  		return true;  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  	input.Unit = hero;  	var prediction = Prediction.GetPrediction (input' false' false);  	if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  		return true;  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  	input.Unit = hero;  	var prediction = Prediction.GetPrediction (input' false' false);  	if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  		return true;  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  	input.Unit = hero;  	var prediction = Prediction.GetPrediction (input' false' false);  	if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  		return true;  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  	input.Unit = hero;  	var prediction = Prediction.GetPrediction (input' false' false);  	if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  		return true;  	}  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  	return true;  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  	return true;  }  
Magic Number,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following statement contains a magic number: for (var i = 0; i < 20; i++) {  	var p = input.From.To2D ().Extend (position.To2D ()' step * i);  	if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  		return true;  	}  }  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,UnitTracker,The following statement contains a magic number: spells.Add (new Spells () {  	name = "consume"'  	duration = 0.5  });  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,UnitTracker,The following statement contains a magic number: spells.Add (new Spells () {  	name = "staticfield"'  	duration = 0.5  });  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,UnitTracker,The following statement contains a magic number: spells.Add (new Spells () {  	name = "cassiopeiapetrifyinggaze"'  	duration = 0.5  });  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,UnitTracker,The following statement contains a magic number: spells.Add (new Spells () {  	name = "jinxw"'  	duration = 0.6  });  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,UnitTracker,The following statement contains a magic number: spells.Add (new Spells () {  	name = "jinxr"'  	duration = 0.6  });  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,UnitTracker,The following statement contains a magic number: spells.Add (new Spells () {  	name = "threshe"'  	duration = 0.4  });  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,UnitTracker,The following statement contains a magic number: spells.Add (new Spells () {  	name = "threshrpenta"'  	duration = 0.75  });  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,UnitTracker,The following statement contains a magic number: spells.Add (new Spells () {  	name = "threshq"'  	duration = 0.75  });  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,UnitTracker,The following statement contains a magic number: spells.Add (new Spells () {  	name = "lucianq"'  	duration = 0.5  });  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,UnitTracker,The following statement contains a magic number: spells.Add (new Spells () {  	name = "caitlynpiltoverpeacemaker"'  	duration = 0.5  });  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,UnitTracker,The following statement contains a magic number: spells.Add (new Spells () {  	name = "velkozr"'  	duration = 0.5  });  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,UnitTracker,The following statement contains a magic number: spells.Add (new Spells () {  	name = "jhinr"'  	duration = 2  });  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,Obj_AI_Hero_OnNewPath,The following statement contains a magic number: if (sender is Obj_AI_Hero) {  	var item = UnitTrackerInfoList.Find (x => x.NetworkId == sender.NetworkId);  	if (args.Path.Count () == 1)  		// STOP MOVE DETECTION  		item.StopMoveTick = Utils.TickCount;  	item.NewPathTick = Utils.TickCount;  	item.PathBank.Add (new PathInfo () {  		Position = args.Path.Last ().To2D ()'  		Time = Utils.TickCount  	});  	if (item.PathBank.Count > 3)  		item.PathBank.RemoveAt (0);  }  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,Obj_AI_Hero_OnNewPath,The following statement contains a magic number: if (item.PathBank.Count > 3)  	item.PathBank.RemoveAt (0);  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,Obj_AI_Base_OnProcessSpellCast,The following statement contains a magic number: if (sender is Obj_AI_Hero) {  	if (args.SData.IsAutoAttack ())  		UnitTrackerInfoList.Find (x => x.NetworkId == sender.NetworkId).AaTick = Utils.TickCount;  	else {  		var foundSpell = spells.Find (x => args.SData.Name.ToLower () == x.name.ToLower ());  		if (foundSpell != null) {  			UnitTrackerInfoList.Find (x => x.NetworkId == sender.NetworkId).SpecialSpellFinishTick = Utils.TickCount + (int)(foundSpell.duration * 1000);  		} else if (sender.IsWindingUp || sender.IsRooted || !sender.CanMove) {  			UnitTrackerInfoList.Find (x => x.NetworkId == sender.NetworkId).SpecialSpellFinishTick = Utils.TickCount + 100;  		}  	}  }  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,Obj_AI_Base_OnProcessSpellCast,The following statement contains a magic number: if (sender is Obj_AI_Hero) {  	if (args.SData.IsAutoAttack ())  		UnitTrackerInfoList.Find (x => x.NetworkId == sender.NetworkId).AaTick = Utils.TickCount;  	else {  		var foundSpell = spells.Find (x => args.SData.Name.ToLower () == x.name.ToLower ());  		if (foundSpell != null) {  			UnitTrackerInfoList.Find (x => x.NetworkId == sender.NetworkId).SpecialSpellFinishTick = Utils.TickCount + (int)(foundSpell.duration * 1000);  		} else if (sender.IsWindingUp || sender.IsRooted || !sender.CanMove) {  			UnitTrackerInfoList.Find (x => x.NetworkId == sender.NetworkId).SpecialSpellFinishTick = Utils.TickCount + 100;  		}  	}  }  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,Obj_AI_Base_OnProcessSpellCast,The following statement contains a magic number: if (args.SData.IsAutoAttack ())  	UnitTrackerInfoList.Find (x => x.NetworkId == sender.NetworkId).AaTick = Utils.TickCount;  else {  	var foundSpell = spells.Find (x => args.SData.Name.ToLower () == x.name.ToLower ());  	if (foundSpell != null) {  		UnitTrackerInfoList.Find (x => x.NetworkId == sender.NetworkId).SpecialSpellFinishTick = Utils.TickCount + (int)(foundSpell.duration * 1000);  	} else if (sender.IsWindingUp || sender.IsRooted || !sender.CanMove) {  		UnitTrackerInfoList.Find (x => x.NetworkId == sender.NetworkId).SpecialSpellFinishTick = Utils.TickCount + 100;  	}  }  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,Obj_AI_Base_OnProcessSpellCast,The following statement contains a magic number: if (args.SData.IsAutoAttack ())  	UnitTrackerInfoList.Find (x => x.NetworkId == sender.NetworkId).AaTick = Utils.TickCount;  else {  	var foundSpell = spells.Find (x => args.SData.Name.ToLower () == x.name.ToLower ());  	if (foundSpell != null) {  		UnitTrackerInfoList.Find (x => x.NetworkId == sender.NetworkId).SpecialSpellFinishTick = Utils.TickCount + (int)(foundSpell.duration * 1000);  	} else if (sender.IsWindingUp || sender.IsRooted || !sender.CanMove) {  		UnitTrackerInfoList.Find (x => x.NetworkId == sender.NetworkId).SpecialSpellFinishTick = Utils.TickCount + 100;  	}  }  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,Obj_AI_Base_OnProcessSpellCast,The following statement contains a magic number: if (foundSpell != null) {  	UnitTrackerInfoList.Find (x => x.NetworkId == sender.NetworkId).SpecialSpellFinishTick = Utils.TickCount + (int)(foundSpell.duration * 1000);  } else if (sender.IsWindingUp || sender.IsRooted || !sender.CanMove) {  	UnitTrackerInfoList.Find (x => x.NetworkId == sender.NetworkId).SpecialSpellFinishTick = Utils.TickCount + 100;  }  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,Obj_AI_Base_OnProcessSpellCast,The following statement contains a magic number: if (foundSpell != null) {  	UnitTrackerInfoList.Find (x => x.NetworkId == sender.NetworkId).SpecialSpellFinishTick = Utils.TickCount + (int)(foundSpell.duration * 1000);  } else if (sender.IsWindingUp || sender.IsRooted || !sender.CanMove) {  	UnitTrackerInfoList.Find (x => x.NetworkId == sender.NetworkId).SpecialSpellFinishTick = Utils.TickCount + 100;  }  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,Obj_AI_Base_OnProcessSpellCast,The following statement contains a magic number: UnitTrackerInfoList.Find (x => x.NetworkId == sender.NetworkId).SpecialSpellFinishTick = Utils.TickCount + (int)(foundSpell.duration * 1000);  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,Obj_AI_Base_OnProcessSpellCast,The following statement contains a magic number: if (sender.IsWindingUp || sender.IsRooted || !sender.CanMove) {  	UnitTrackerInfoList.Find (x => x.NetworkId == sender.NetworkId).SpecialSpellFinishTick = Utils.TickCount + 100;  }  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,Obj_AI_Base_OnProcessSpellCast,The following statement contains a magic number: UnitTrackerInfoList.Find (x => x.NetworkId == sender.NetworkId).SpecialSpellFinishTick = Utils.TickCount + 100;  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,SpamSamePlace,The following statement contains a magic number: if (TrackerUnit.PathBank.Count < 3)  	return false;  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,SpamSamePlace,The following statement contains a magic number: if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [1].Time < 180 && Utils.TickCount - TrackerUnit.PathBank [2].Time < 90) {  	var C = TrackerUnit.PathBank [1].Position;  	var A = TrackerUnit.PathBank [2].Position;  	var B = unit.Position.To2D ();  	var AB = Math.Pow (A.X - B.X' 2) + Math.Pow (A.Y - B.Y' 2);  	var BC = Math.Pow (B.X - C.X' 2) + Math.Pow (B.Y - C.Y' 2);  	var AC = Math.Pow (A.X - C.X' 2) + Math.Pow (A.Y - C.Y' 2);  	if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) < 50) {  		return true;  	} else if (Math.Cos ((AB + BC - AC) / (2 * Math.Sqrt (AB) * Math.Sqrt (BC))) * 180 / Math.PI < 31) {  		return true;  	} else  		return false;  } else  	return false;  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,SpamSamePlace,The following statement contains a magic number: if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [1].Time < 180 && Utils.TickCount - TrackerUnit.PathBank [2].Time < 90) {  	var C = TrackerUnit.PathBank [1].Position;  	var A = TrackerUnit.PathBank [2].Position;  	var B = unit.Position.To2D ();  	var AB = Math.Pow (A.X - B.X' 2) + Math.Pow (A.Y - B.Y' 2);  	var BC = Math.Pow (B.X - C.X' 2) + Math.Pow (B.Y - C.Y' 2);  	var AC = Math.Pow (A.X - C.X' 2) + Math.Pow (A.Y - C.Y' 2);  	if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) < 50) {  		return true;  	} else if (Math.Cos ((AB + BC - AC) / (2 * Math.Sqrt (AB) * Math.Sqrt (BC))) * 180 / Math.PI < 31) {  		return true;  	} else  		return false;  } else  	return false;  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,SpamSamePlace,The following statement contains a magic number: if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [1].Time < 180 && Utils.TickCount - TrackerUnit.PathBank [2].Time < 90) {  	var C = TrackerUnit.PathBank [1].Position;  	var A = TrackerUnit.PathBank [2].Position;  	var B = unit.Position.To2D ();  	var AB = Math.Pow (A.X - B.X' 2) + Math.Pow (A.Y - B.Y' 2);  	var BC = Math.Pow (B.X - C.X' 2) + Math.Pow (B.Y - C.Y' 2);  	var AC = Math.Pow (A.X - C.X' 2) + Math.Pow (A.Y - C.Y' 2);  	if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) < 50) {  		return true;  	} else if (Math.Cos ((AB + BC - AC) / (2 * Math.Sqrt (AB) * Math.Sqrt (BC))) * 180 / Math.PI < 31) {  		return true;  	} else  		return false;  } else  	return false;  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,SpamSamePlace,The following statement contains a magic number: if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [1].Time < 180 && Utils.TickCount - TrackerUnit.PathBank [2].Time < 90) {  	var C = TrackerUnit.PathBank [1].Position;  	var A = TrackerUnit.PathBank [2].Position;  	var B = unit.Position.To2D ();  	var AB = Math.Pow (A.X - B.X' 2) + Math.Pow (A.Y - B.Y' 2);  	var BC = Math.Pow (B.X - C.X' 2) + Math.Pow (B.Y - C.Y' 2);  	var AC = Math.Pow (A.X - C.X' 2) + Math.Pow (A.Y - C.Y' 2);  	if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) < 50) {  		return true;  	} else if (Math.Cos ((AB + BC - AC) / (2 * Math.Sqrt (AB) * Math.Sqrt (BC))) * 180 / Math.PI < 31) {  		return true;  	} else  		return false;  } else  	return false;  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,SpamSamePlace,The following statement contains a magic number: if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [1].Time < 180 && Utils.TickCount - TrackerUnit.PathBank [2].Time < 90) {  	var C = TrackerUnit.PathBank [1].Position;  	var A = TrackerUnit.PathBank [2].Position;  	var B = unit.Position.To2D ();  	var AB = Math.Pow (A.X - B.X' 2) + Math.Pow (A.Y - B.Y' 2);  	var BC = Math.Pow (B.X - C.X' 2) + Math.Pow (B.Y - C.Y' 2);  	var AC = Math.Pow (A.X - C.X' 2) + Math.Pow (A.Y - C.Y' 2);  	if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) < 50) {  		return true;  	} else if (Math.Cos ((AB + BC - AC) / (2 * Math.Sqrt (AB) * Math.Sqrt (BC))) * 180 / Math.PI < 31) {  		return true;  	} else  		return false;  } else  	return false;  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,SpamSamePlace,The following statement contains a magic number: if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [1].Time < 180 && Utils.TickCount - TrackerUnit.PathBank [2].Time < 90) {  	var C = TrackerUnit.PathBank [1].Position;  	var A = TrackerUnit.PathBank [2].Position;  	var B = unit.Position.To2D ();  	var AB = Math.Pow (A.X - B.X' 2) + Math.Pow (A.Y - B.Y' 2);  	var BC = Math.Pow (B.X - C.X' 2) + Math.Pow (B.Y - C.Y' 2);  	var AC = Math.Pow (A.X - C.X' 2) + Math.Pow (A.Y - C.Y' 2);  	if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) < 50) {  		return true;  	} else if (Math.Cos ((AB + BC - AC) / (2 * Math.Sqrt (AB) * Math.Sqrt (BC))) * 180 / Math.PI < 31) {  		return true;  	} else  		return false;  } else  	return false;  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,SpamSamePlace,The following statement contains a magic number: if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [1].Time < 180 && Utils.TickCount - TrackerUnit.PathBank [2].Time < 90) {  	var C = TrackerUnit.PathBank [1].Position;  	var A = TrackerUnit.PathBank [2].Position;  	var B = unit.Position.To2D ();  	var AB = Math.Pow (A.X - B.X' 2) + Math.Pow (A.Y - B.Y' 2);  	var BC = Math.Pow (B.X - C.X' 2) + Math.Pow (B.Y - C.Y' 2);  	var AC = Math.Pow (A.X - C.X' 2) + Math.Pow (A.Y - C.Y' 2);  	if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) < 50) {  		return true;  	} else if (Math.Cos ((AB + BC - AC) / (2 * Math.Sqrt (AB) * Math.Sqrt (BC))) * 180 / Math.PI < 31) {  		return true;  	} else  		return false;  } else  	return false;  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,SpamSamePlace,The following statement contains a magic number: if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [1].Time < 180 && Utils.TickCount - TrackerUnit.PathBank [2].Time < 90) {  	var C = TrackerUnit.PathBank [1].Position;  	var A = TrackerUnit.PathBank [2].Position;  	var B = unit.Position.To2D ();  	var AB = Math.Pow (A.X - B.X' 2) + Math.Pow (A.Y - B.Y' 2);  	var BC = Math.Pow (B.X - C.X' 2) + Math.Pow (B.Y - C.Y' 2);  	var AC = Math.Pow (A.X - C.X' 2) + Math.Pow (A.Y - C.Y' 2);  	if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) < 50) {  		return true;  	} else if (Math.Cos ((AB + BC - AC) / (2 * Math.Sqrt (AB) * Math.Sqrt (BC))) * 180 / Math.PI < 31) {  		return true;  	} else  		return false;  } else  	return false;  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,SpamSamePlace,The following statement contains a magic number: if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [1].Time < 180 && Utils.TickCount - TrackerUnit.PathBank [2].Time < 90) {  	var C = TrackerUnit.PathBank [1].Position;  	var A = TrackerUnit.PathBank [2].Position;  	var B = unit.Position.To2D ();  	var AB = Math.Pow (A.X - B.X' 2) + Math.Pow (A.Y - B.Y' 2);  	var BC = Math.Pow (B.X - C.X' 2) + Math.Pow (B.Y - C.Y' 2);  	var AC = Math.Pow (A.X - C.X' 2) + Math.Pow (A.Y - C.Y' 2);  	if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) < 50) {  		return true;  	} else if (Math.Cos ((AB + BC - AC) / (2 * Math.Sqrt (AB) * Math.Sqrt (BC))) * 180 / Math.PI < 31) {  		return true;  	} else  		return false;  } else  	return false;  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,SpamSamePlace,The following statement contains a magic number: if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [1].Time < 180 && Utils.TickCount - TrackerUnit.PathBank [2].Time < 90) {  	var C = TrackerUnit.PathBank [1].Position;  	var A = TrackerUnit.PathBank [2].Position;  	var B = unit.Position.To2D ();  	var AB = Math.Pow (A.X - B.X' 2) + Math.Pow (A.Y - B.Y' 2);  	var BC = Math.Pow (B.X - C.X' 2) + Math.Pow (B.Y - C.Y' 2);  	var AC = Math.Pow (A.X - C.X' 2) + Math.Pow (A.Y - C.Y' 2);  	if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) < 50) {  		return true;  	} else if (Math.Cos ((AB + BC - AC) / (2 * Math.Sqrt (AB) * Math.Sqrt (BC))) * 180 / Math.PI < 31) {  		return true;  	} else  		return false;  } else  	return false;  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,SpamSamePlace,The following statement contains a magic number: if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [1].Time < 180 && Utils.TickCount - TrackerUnit.PathBank [2].Time < 90) {  	var C = TrackerUnit.PathBank [1].Position;  	var A = TrackerUnit.PathBank [2].Position;  	var B = unit.Position.To2D ();  	var AB = Math.Pow (A.X - B.X' 2) + Math.Pow (A.Y - B.Y' 2);  	var BC = Math.Pow (B.X - C.X' 2) + Math.Pow (B.Y - C.Y' 2);  	var AC = Math.Pow (A.X - C.X' 2) + Math.Pow (A.Y - C.Y' 2);  	if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) < 50) {  		return true;  	} else if (Math.Cos ((AB + BC - AC) / (2 * Math.Sqrt (AB) * Math.Sqrt (BC))) * 180 / Math.PI < 31) {  		return true;  	} else  		return false;  } else  	return false;  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,SpamSamePlace,The following statement contains a magic number: if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [1].Time < 180 && Utils.TickCount - TrackerUnit.PathBank [2].Time < 90) {  	var C = TrackerUnit.PathBank [1].Position;  	var A = TrackerUnit.PathBank [2].Position;  	var B = unit.Position.To2D ();  	var AB = Math.Pow (A.X - B.X' 2) + Math.Pow (A.Y - B.Y' 2);  	var BC = Math.Pow (B.X - C.X' 2) + Math.Pow (B.Y - C.Y' 2);  	var AC = Math.Pow (A.X - C.X' 2) + Math.Pow (A.Y - C.Y' 2);  	if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) < 50) {  		return true;  	} else if (Math.Cos ((AB + BC - AC) / (2 * Math.Sqrt (AB) * Math.Sqrt (BC))) * 180 / Math.PI < 31) {  		return true;  	} else  		return false;  } else  	return false;  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,SpamSamePlace,The following statement contains a magic number: if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [1].Time < 180 && Utils.TickCount - TrackerUnit.PathBank [2].Time < 90) {  	var C = TrackerUnit.PathBank [1].Position;  	var A = TrackerUnit.PathBank [2].Position;  	var B = unit.Position.To2D ();  	var AB = Math.Pow (A.X - B.X' 2) + Math.Pow (A.Y - B.Y' 2);  	var BC = Math.Pow (B.X - C.X' 2) + Math.Pow (B.Y - C.Y' 2);  	var AC = Math.Pow (A.X - C.X' 2) + Math.Pow (A.Y - C.Y' 2);  	if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) < 50) {  		return true;  	} else if (Math.Cos ((AB + BC - AC) / (2 * Math.Sqrt (AB) * Math.Sqrt (BC))) * 180 / Math.PI < 31) {  		return true;  	} else  		return false;  } else  	return false;  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,SpamSamePlace,The following statement contains a magic number: if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [1].Time < 180 && Utils.TickCount - TrackerUnit.PathBank [2].Time < 90) {  	var C = TrackerUnit.PathBank [1].Position;  	var A = TrackerUnit.PathBank [2].Position;  	var B = unit.Position.To2D ();  	var AB = Math.Pow (A.X - B.X' 2) + Math.Pow (A.Y - B.Y' 2);  	var BC = Math.Pow (B.X - C.X' 2) + Math.Pow (B.Y - C.Y' 2);  	var AC = Math.Pow (A.X - C.X' 2) + Math.Pow (A.Y - C.Y' 2);  	if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) < 50) {  		return true;  	} else if (Math.Cos ((AB + BC - AC) / (2 * Math.Sqrt (AB) * Math.Sqrt (BC))) * 180 / Math.PI < 31) {  		return true;  	} else  		return false;  } else  	return false;  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,SpamSamePlace,The following statement contains a magic number: if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [1].Time < 180 && Utils.TickCount - TrackerUnit.PathBank [2].Time < 90) {  	var C = TrackerUnit.PathBank [1].Position;  	var A = TrackerUnit.PathBank [2].Position;  	var B = unit.Position.To2D ();  	var AB = Math.Pow (A.X - B.X' 2) + Math.Pow (A.Y - B.Y' 2);  	var BC = Math.Pow (B.X - C.X' 2) + Math.Pow (B.Y - C.Y' 2);  	var AC = Math.Pow (A.X - C.X' 2) + Math.Pow (A.Y - C.Y' 2);  	if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) < 50) {  		return true;  	} else if (Math.Cos ((AB + BC - AC) / (2 * Math.Sqrt (AB) * Math.Sqrt (BC))) * 180 / Math.PI < 31) {  		return true;  	} else  		return false;  } else  	return false;  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,SpamSamePlace,The following statement contains a magic number: if (TrackerUnit.PathBank [2].Time - TrackerUnit.PathBank [1].Time < 180 && Utils.TickCount - TrackerUnit.PathBank [2].Time < 90) {  	var C = TrackerUnit.PathBank [1].Position;  	var A = TrackerUnit.PathBank [2].Position;  	var B = unit.Position.To2D ();  	var AB = Math.Pow (A.X - B.X' 2) + Math.Pow (A.Y - B.Y' 2);  	var BC = Math.Pow (B.X - C.X' 2) + Math.Pow (B.Y - C.Y' 2);  	var AC = Math.Pow (A.X - C.X' 2) + Math.Pow (A.Y - C.Y' 2);  	if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) < 50) {  		return true;  	} else if (Math.Cos ((AB + BC - AC) / (2 * Math.Sqrt (AB) * Math.Sqrt (BC))) * 180 / Math.PI < 31) {  		return true;  	} else  		return false;  } else  	return false;  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,SpamSamePlace,The following statement contains a magic number: if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) < 50) {  	return true;  } else if (Math.Cos ((AB + BC - AC) / (2 * Math.Sqrt (AB) * Math.Sqrt (BC))) * 180 / Math.PI < 31) {  	return true;  } else  	return false;  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,SpamSamePlace,The following statement contains a magic number: if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) < 50) {  	return true;  } else if (Math.Cos ((AB + BC - AC) / (2 * Math.Sqrt (AB) * Math.Sqrt (BC))) * 180 / Math.PI < 31) {  	return true;  } else  	return false;  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,SpamSamePlace,The following statement contains a magic number: if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) < 50) {  	return true;  } else if (Math.Cos ((AB + BC - AC) / (2 * Math.Sqrt (AB) * Math.Sqrt (BC))) * 180 / Math.PI < 31) {  	return true;  } else  	return false;  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,SpamSamePlace,The following statement contains a magic number: if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) < 50) {  	return true;  } else if (Math.Cos ((AB + BC - AC) / (2 * Math.Sqrt (AB) * Math.Sqrt (BC))) * 180 / Math.PI < 31) {  	return true;  } else  	return false;  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,SpamSamePlace,The following statement contains a magic number: if (TrackerUnit.PathBank [1].Position.Distance (TrackerUnit.PathBank [2].Position) < 50) {  	return true;  } else if (Math.Cos ((AB + BC - AC) / (2 * Math.Sqrt (AB) * Math.Sqrt (BC))) * 180 / Math.PI < 31) {  	return true;  } else  	return false;  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,SpamSamePlace,The following statement contains a magic number: if (Math.Cos ((AB + BC - AC) / (2 * Math.Sqrt (AB) * Math.Sqrt (BC))) * 180 / Math.PI < 31) {  	return true;  } else  	return false;  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,SpamSamePlace,The following statement contains a magic number: if (Math.Cos ((AB + BC - AC) / (2 * Math.Sqrt (AB) * Math.Sqrt (BC))) * 180 / Math.PI < 31) {  	return true;  } else  	return false;  
Magic Number,SebbyLib.Prediction,UnitTracker,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,SpamSamePlace,The following statement contains a magic number: if (Math.Cos ((AB + BC - AC) / (2 * Math.Sqrt (AB) * Math.Sqrt (BC))) * 180 / Math.PI < 31) {  	return true;  } else  	return false;  
Missing Default,SebbyLib.Movement,AoePrediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetPrediction,The following switch statement is missing a default case: switch (input.Type) {  case SkillshotType.SkillshotCircle:  	return Circle.GetPrediction (input);  case SkillshotType.SkillshotCone:  	return Cone.GetPrediction (input);  case SkillshotType.SkillshotLine:  	return Line.GetPrediction (input);  }  
Missing Default,SebbyLib.Movement,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\Movement.cs,GetCollision,The following switch statement is missing a default case: switch (objectType) {  case CollisionableObjects.Minions:  	foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  		input.Unit = minion;  		var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  		if (distanceFromToUnit < input.Radius + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else if (minion.ServerPosition.Distance (position) < input.Radius + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else {  			var minionPos = minion.ServerPosition;  			int bonusRadius = 20;  			if (minion.IsMoving) {  				minionPos = Prediction.GetPrediction (input' false' false).CastPosition;  				bonusRadius = 60 + (int)input.Radius;  			}  			if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			}  		}  	}  	break;  case CollisionableObjects.Heroes:  	foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  		input.Unit = hero;  		var prediction = Prediction.GetPrediction (input' false' false);  		if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  			return true;  		}  	}  	break;  case CollisionableObjects.Walls:  	var step = position.Distance (input.From) / 20;  	for (var i = 0; i < 20; i++) {  		var p = input.From.To2D ().Extend (position.To2D ()' step * i);  		if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  			return true;  		}  	}  	break;  }  
Missing Default,SebbyLib.Prediction,AoePrediction,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetPrediction,The following switch statement is missing a default case: switch (input.Type) {  case SkillshotType.SkillshotCircle:  	return Circle.GetPrediction (input);  case SkillshotType.SkillshotCone:  	return Cone.GetPrediction (input);  case SkillshotType.SkillshotLine:  	return Line.GetPrediction (input);  }  
Missing Default,SebbyLib.Prediction,Collision,D:\newReposJune17\OneKeyToWin_LeagueRepo\SebbyLib\SebbyLib\PredictionOktw.cs,GetCollision,The following switch statement is missing a default case: switch (objectType) {  case CollisionableObjects.Minions:  	foreach (var minion in Cache.GetMinions (input.From' Math.Min (input.Range + input.Radius + 100' 2000))) {  		var distanceFromToUnit = minion.ServerPosition.Distance (input.From);  		if (distanceFromToUnit < 10 + minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else if (minion.ServerPosition.Distance (position) < minion.BoundingRadius) {  			if (MinionIsDead (input' minion' distanceFromToUnit))  				continue;  			else  				return true;  		} else {  			var minionPos = minion.ServerPosition;  			int bonusRadius = 15;  			if (minion.IsMoving) {  				var predInput2 = new PredictionInput {  					Collision = false'  					Speed = input.Speed'  					Delay = input.Delay'  					Range = input.Range'  					From = input.From'  					Radius = input.Radius'  					Unit = minion'  					Type = input.Type  				};  				minionPos = Prediction.GetPrediction (predInput2).CastPosition;  				bonusRadius = 50 + (int)input.Radius;  			}  			if (minionPos.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + bonusRadius + minion.BoundingRadius)' 2)) {  				if (MinionIsDead (input' minion' distanceFromToUnit))  					continue;  				else  					return true;  			}  		}  	}  	break;  case CollisionableObjects.Heroes:  	foreach (var hero in HeroManager.Enemies.FindAll (hero => hero.IsValidTarget (Math.Min (input.Range + input.Radius + 100' 2000)' true' input.RangeCheckFrom))) {  		input.Unit = hero;  		var prediction = Prediction.GetPrediction (input' false' false);  		if (prediction.UnitPosition.To2D ().Distance (input.From.To2D ()' position.To2D ()' true' true) <= Math.Pow ((input.Radius + 50 + hero.BoundingRadius)' 2)) {  			return true;  		}  	}  	break;  case CollisionableObjects.Walls:  	var step = position.Distance (input.From) / 20;  	for (var i = 0; i < 20; i++) {  		var p = input.From.To2D ().Extend (position.To2D ()' step * i);  		if (NavMesh.GetCollisionFlags (p.X' p.Y).HasFlag (CollisionFlags.Wall)) {  			return true;  		}  	}  	break;  }  
