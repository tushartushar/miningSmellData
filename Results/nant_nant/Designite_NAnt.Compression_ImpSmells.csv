Implementation smell,Namespace,Class,File,Method,Description
Long Method,NAnt.Compression.Tasks,TarTask,C:\repos\nant_nant\src\NAnt.Compression\Tasks\TarTask.cs,ExecuteTask,The method has 160 lines of code.
Long Method,NAnt.Compression.Tasks,ZipTask,C:\repos\nant_nant\src\NAnt.Compression\Tasks\ZipTask.cs,ExecuteTask,The method has 196 lines of code.
Complex Method,NAnt.Compression.Tasks,TarTask,C:\repos\nant_nant\src\NAnt.Compression\Tasks\TarTask.cs,ExecuteTask,Cyclomatic complexity of the method is 19
Complex Method,NAnt.Compression.Tasks,ZipTask,C:\repos\nant_nant\src\NAnt.Compression\Tasks\ZipTask.cs,ExecuteTask,Cyclomatic complexity of the method is 23
Long Parameter List,NAnt.Compression.Tasks,ExpandBaseTask,C:\repos\nant_nant\src\NAnt.Compression\Tasks\ExpandBaseTask.cs,ExtractFile,The method has 5 parameters. Parameters: inputStream' destDirectory' entryName' entryDate' entrySize
Magic Number,NAnt.Compression.Tasks,ExpandBaseTask,C:\repos\nant_nant\src\NAnt.Compression\Tasks\ExpandBaseTask.cs,ExtractFile,The following statement contains a magic number: try {                  // extract the entry                  using (FileStream sw = new FileStream(destFile.FullName' FileMode.Create' FileAccess.Write)) {                      int size = 2048;                      byte[] data = new byte[size];                        while (true) {                          size = inputStream.Read(data' 0' data.Length);                          if (size == 0) {                              break;                          }                          sw.Write(data' 0' size);                      }                        sw.Close();                  }              } catch (Exception ex) {                  throw new BuildException(string.Format(CultureInfo.InvariantCulture'                      "Unable to expand '{0}' to '{1}'."' entryName' destDirectory)'                      Location' ex);              }
Magic Number,NAnt.Compression.Tasks,GUnzip,C:\repos\nant_nant\src\NAnt.Compression\Tasks\GUnzip.cs,ExecuteTask,The following statement contains a magic number: try {                  using (GZipInputStream gzs = new GZipInputStream(SrcFile.OpenRead())) {                      Log(Level.Info' "Expanding '{0}' to '{1}' ({2} bytes)."'                           SrcFile.FullName' DestFile.FullName' gzs.Length);                        // holds data from src file                      byte[] data = new byte[8 * 1024];                        // first read from input to ensure we're dealing with valid                      // src file before we actually create the dest file                      int size = gzs.Read(data' 0' data.Length);                        // write expanded data to dest file                      using (FileStream fs = new FileStream(DestFile.FullName' FileMode.Create' FileAccess.Write' FileShare.None)) {                          while (size > 0) {                              fs.Write(data' 0' size);                              size = gzs.Read(data' 0' data.Length);                          }                          // close output stream                          fs.Close();                      }                      // close input stream                      gzs.Close();                  }              } catch (IOException ex) {                  throw new BuildException(string.Format(CultureInfo.InvariantCulture'                      "Failed to expand '{0}' to '{1}'."' SrcFile.FullName'                       DestFile.FullName)' Location' ex);              } catch (GZipException ex) {                  throw new BuildException(string.Format(CultureInfo.InvariantCulture'                      "Invalid gzip file '{0}'."' SrcFile.FullName)' Location' ex);              }
Magic Number,NAnt.Compression.Tasks,GUnzip,C:\repos\nant_nant\src\NAnt.Compression\Tasks\GUnzip.cs,ExecuteTask,The following statement contains a magic number: try {                  using (GZipInputStream gzs = new GZipInputStream(SrcFile.OpenRead())) {                      Log(Level.Info' "Expanding '{0}' to '{1}' ({2} bytes)."'                           SrcFile.FullName' DestFile.FullName' gzs.Length);                        // holds data from src file                      byte[] data = new byte[8 * 1024];                        // first read from input to ensure we're dealing with valid                      // src file before we actually create the dest file                      int size = gzs.Read(data' 0' data.Length);                        // write expanded data to dest file                      using (FileStream fs = new FileStream(DestFile.FullName' FileMode.Create' FileAccess.Write' FileShare.None)) {                          while (size > 0) {                              fs.Write(data' 0' size);                              size = gzs.Read(data' 0' data.Length);                          }                          // close output stream                          fs.Close();                      }                      // close input stream                      gzs.Close();                  }              } catch (IOException ex) {                  throw new BuildException(string.Format(CultureInfo.InvariantCulture'                      "Failed to expand '{0}' to '{1}'."' SrcFile.FullName'                       DestFile.FullName)' Location' ex);              } catch (GZipException ex) {                  throw new BuildException(string.Format(CultureInfo.InvariantCulture'                      "Invalid gzip file '{0}'."' SrcFile.FullName)' Location' ex);              }
Magic Number,NAnt.Compression.Tasks,ZipTask,C:\repos\nant_nant\src\NAnt.Compression\Tasks\ZipTask.cs,ExecuteTask,The following statement contains a magic number: try {                 if (!Directory.Exists(ZipFile.DirectoryName)) {                     Directory.CreateDirectory(ZipFile.DirectoryName);                 }                              // set encoding to use for filenames and comment                 ZipConstants.DefaultCodePage = Encoding.CodePage;                  zOutstream = new ZipOutputStream(ZipFile.Create());                  // set compression level                 zOutstream.SetLevel(ZipLevel);                    // set password                  if(!String.IsNullOrEmpty(PassWord)) {                      zOutstream.Password = PassWord;                  }                  // set comment                 if (!String.IsNullOrEmpty(Comment)) {                     zOutstream.SetComment(Comment);                 }                  foreach (ZipFileSet fileset in ZipFileSets) {                     string basePath = fileset.BaseDirectory.FullName;                     if (Path.GetPathRoot(basePath) != basePath) {                         basePath = Path.GetDirectoryName(basePath + Path.DirectorySeparatorChar);                     }                      // add files to zip                     foreach (string file in fileset.FileNames) {                         // ensure file exists (in case "asis" was used)                         if (!File.Exists(file)) {                             throw new BuildException(string.Format(CultureInfo.InvariantCulture'                                 "File '{0}' does not exist."' file)' Location);                         }                          // the name of the zip entry                         string entryName;                          // determine name of the zip entry                         if (!Flatten && file.StartsWith(basePath)) {                             entryName = file.Substring(basePath.Length);                             if (entryName.Length > 0 && entryName[0] == Path.DirectorySeparatorChar) {                                 entryName = entryName.Substring(1);                             }                              // remember that directory was added to zip file' so                             // that we won't add it again later                             string dir = Path.GetDirectoryName(file);                             if (_addedDirs[dir] == null) {                                 _addedDirs[dir] = dir;                             }                         } else {                             // flatten directory structure                             entryName = Path.GetFileName(file);                         }                          // add prefix if specified                         if (fileset.Prefix != null) {                             entryName = fileset.Prefix + entryName;                         }                          // ensure directory separators are understood on linux                         if (Path.DirectorySeparatorChar == '\\') {                             entryName = entryName.Replace(@"\"' "/");                         }                          // perform duplicate checking                         if (_fileEntries.ContainsKey(entryName)) {                             switch (DuplicateHandling) {                                 case DuplicateHandling.Add:                                     break;                                 case DuplicateHandling.Fail:                                     throw new BuildException(string.Format(                                         CultureInfo.InvariantCulture'                                          "Duplicate file '{0}' was found."'                                          entryName)' Location.UnknownLocation);                                 case DuplicateHandling.Preserve:                                     // skip current entry                                     continue;                                 default:                                     throw new BuildException(string.Format(                                         CultureInfo.InvariantCulture'                                          "Duplicate value '{0}' is not supported."'                                          DuplicateHandling.ToString())'                                          Location.UnknownLocation);                             }                         }                          // create zip entry                         ZipEntry entry = new ZipEntry(entryName);                          // store entry (to allow for duplicate checking)                         _fileEntries[entryName] = null;                          // set date/time stamp on zip entry                         if (Stamp != DateTime.MinValue) {                             entry.DateTime = Stamp;                         } else {                             entry.DateTime = File.GetLastWriteTime(file);                         }                          // write file content to stream in small chuncks                         using (FileStream fs = File.OpenRead(file)) {                             // set size for backward compatibility with older unzip                             entry.Size = fs.Length;                              Log(Level.Verbose' "Adding {0}."' entryName);                              // write file to zip file                             zOutstream.PutNextEntry(entry);                              byte[] buffer = new byte[50000];                              while (true) {                                 int bytesRead = fs.Read(buffer' 0' buffer.Length);                                 if (bytesRead == 0)                                     break;                                 zOutstream.Write(buffer' 0' bytesRead);                             }                         }                      }                      // add (possibly empty) directories to zip                     if (IncludeEmptyDirs) {                         foreach (string directory in fileset.DirectoryNames) {                             // skip directories that were already added when the                              // files were added                             if (_addedDirs[directory] != null) {                                 continue;                             }                              // skip directories that are not located beneath the base                              // directory                             if (!directory.StartsWith(basePath) || directory.Length <= basePath.Length) {                                 continue;                             }                              // determine zip entry name                             string entryName = directory.Substring(basePath.Length + 1);                              // add prefix if specified                             if (fileset.Prefix != null) {                                 entryName = fileset.Prefix + entryName;                             }                              // ensure directory separators are understood on linux                             if (Path.DirectorySeparatorChar == '\\') {                                 entryName = entryName.Replace(@"\"' "/");                             }                              if (!entryName.EndsWith("/")) {                                 // trailing directory signals to #ziplib that we're                                 // dealing with directory entry                                 entryName += "/";                             }                              // create directory entry                             ZipEntry entry = new ZipEntry(entryName);                              // set size for backward compatibility with older unzip                             entry.Size = 0L;                              // write directory to zip file                             zOutstream.PutNextEntry(entry);                         }                     }                 }                  zOutstream.Close();                 zOutstream.Finish();             } catch (Exception ex) {                 // close the zip output stream                 if (zOutstream != null) {                     zOutstream.Close();                 }                  // delete the (possibly corrupt) zip file                 if (ZipFile.Exists) {                     ZipFile.Delete();                 }                  throw new BuildException(string.Format(CultureInfo.InvariantCulture'                     "Zip file '{0}' could not be created."' ZipFile.FullName)'                      Location' ex);             } finally {                 CleanUp();             }
Missing Default,NAnt.Compression.Tasks,TarTask,C:\repos\nant_nant\src\NAnt.Compression\Tasks\TarTask.cs,ExecuteTask,The following switch statement is missing a default case: switch (CompressionMethod) {                     case TarCompressionMethod.GZip:                         outstream = new GZipOutputStream(outstream);                         break;                     case TarCompressionMethod.BZip2:                         outstream = new BZip2OutputStream(outstream);                         break;                 }
