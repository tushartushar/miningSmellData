Implementation smell,Namespace,Class,File,Method,Description
Long Method,NAnt.Core,ConsoleDriver,C:\repos\nant_nant\src\NAnt.Core\ConsoleDriver.cs,Main,The method has 248 lines of code.
Long Method,NAnt.Core,DirectoryScanner,C:\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,ScanDirectory,The method has 112 lines of code.
Long Method,NAnt.Core,AttributeConfigurator,C:\repos\nant_nant\src\NAnt.Core\Element.cs,InitializeAttribute,The method has 161 lines of code.
Long Method,NAnt.Core,AttributeConfigurator,C:\repos\nant_nant\src\NAnt.Core\Element.cs,InitializeBuildElementCollection,The method has 283 lines of code.
Long Method,NAnt.Core,AttributeConfigurator,C:\repos\nant_nant\src\NAnt.Core\Element.cs,InitializeOrderedChildElements,The method has 112 lines of code.
Long Method,NAnt.Core,ExpressionEvalBase,C:\repos\nant_nant\src\NAnt.Core\ExpressionEvalBase.cs,ParseRelationalExpression,The method has 255 lines of code.
Long Method,NAnt.Core,ExpressionEvalBase,C:\repos\nant_nant\src\NAnt.Core\ExpressionEvalBase.cs,ParseMulDiv,The method has 173 lines of code.
Long Method,NAnt.Core,ExpressionEvalBase,C:\repos\nant_nant\src\NAnt.Core\ExpressionEvalBase.cs,ParseValue,The method has 194 lines of code.
Long Method,NAnt.Core,ExpressionTokenizer,C:\repos\nant_nant\src\NAnt.Core\ExpressionTokenizer.cs,GetNextToken,The method has 120 lines of code.
Long Method,NAnt.Core,LocationMap,C:\repos\nant_nant\src\NAnt.Core\LocationMap.cs,Add,The method has 102 lines of code.
Long Method,NAnt.Core,MailLogger,C:\repos\nant_nant\src\NAnt.Core\Log.cs,BuildFinished,The method has 129 lines of code.
Long Method,NAnt.Core,Project,C:\repos\nant_nant\src\NAnt.Core\Project.cs,CtorHelper,The method has 111 lines of code.
Long Method,NAnt.Core.Tasks,CopyTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\CopyTask.cs,ExecuteTask,The method has 226 lines of code.
Long Method,NAnt.Core.Tasks,GetTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\GetTask.cs,ExecuteTask,The method has 131 lines of code.
Long Method,NAnt.Core.Tasks,IncludeTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\IncludeTask.cs,ExecuteTask,The method has 135 lines of code.
Long Method,NAnt.Core.Tasks,LoopTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\LoopTask.cs,ExecuteTask,The method has 144 lines of code.
Long Method,NAnt.Core.Tasks,MailTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\MailTask.cs,ExecuteTask,The method has 177 lines of code.
Long Method,NAnt.Core.Tasks,NAntSchemaGenerator,C:\repos\nant_nant\src\NAnt.Core\Tasks\NAntSchemaTask.cs,FindOrCreateComplexType,The method has 132 lines of code.
Long Method,NAnt.Core.Tasks,StyleTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\StyleTask.cs,ExecuteTask,The method has 187 lines of code.
Long Method,NAnt.Core.Util,CommandLineArgument,C:\repos\nant_nant\src\NAnt.Core\Util\CommandLineArgument.cs,Finish,The method has 101 lines of code.
Complex Method,NAnt.Core,ConsoleDriver,C:\repos\nant_nant\src\NAnt.Core\ConsoleDriver.cs,Main,Cyclomatic complexity of the method is 13
Complex Method,NAnt.Core,DirectoryScanner,C:\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,Clone,Cyclomatic complexity of the method is 14
Complex Method,NAnt.Core,DirectoryScanner,C:\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,CheckIsEverythingIncluded,Cyclomatic complexity of the method is 12
Complex Method,NAnt.Core,DirectoryScanner,C:\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,ParseSearchDirectoryAndPattern,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core,DirectoryScanner,C:\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,ScanDirectory,Cyclomatic complexity of the method is 15
Complex Method,NAnt.Core,Element,C:\repos\nant_nant\src\NAnt.Core\Element.cs,GetAttributeConfigurationNode,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core,AttributeConfigurator,C:\repos\nant_nant\src\NAnt.Core\Element.cs,AttributeConfigurator,Cyclomatic complexity of the method is 9
Complex Method,NAnt.Core,AttributeConfigurator,C:\repos\nant_nant\src\NAnt.Core\Element.cs,Initialize,Cyclomatic complexity of the method is 12
Complex Method,NAnt.Core,AttributeConfigurator,C:\repos\nant_nant\src\NAnt.Core\Element.cs,InitializeAttribute,Cyclomatic complexity of the method is 15
Complex Method,NAnt.Core,AttributeConfigurator,C:\repos\nant_nant\src\NAnt.Core\Element.cs,InitializeBuildElementCollection,Cyclomatic complexity of the method is 22
Complex Method,NAnt.Core,AttributeConfigurator,C:\repos\nant_nant\src\NAnt.Core\Element.cs,InitializeOrderedChildElements,Cyclomatic complexity of the method is 14
Complex Method,NAnt.Core,AttributeConfigurator,C:\repos\nant_nant\src\NAnt.Core\Element.cs,CreateChildBuildElement,Cyclomatic complexity of the method is 9
Complex Method,NAnt.Core,ExpressionEvalBase,C:\repos\nant_nant\src\NAnt.Core\ExpressionEvalBase.cs,ParseConditional,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core,ExpressionEvalBase,C:\repos\nant_nant\src\NAnt.Core\ExpressionEvalBase.cs,ParseValue,Cyclomatic complexity of the method is 31
Complex Method,NAnt.Core,ExpressionEvalBase,C:\repos\nant_nant\src\NAnt.Core\ExpressionEvalBase.cs,SafeConvert,Cyclomatic complexity of the method is 22
Complex Method,NAnt.Core,ExpressionTokenizer,C:\repos\nant_nant\src\NAnt.Core\ExpressionTokenizer.cs,GetNextToken,Cyclomatic complexity of the method is 25
Complex Method,NAnt.Core,LocationMap,C:\repos\nant_nant\src\NAnt.Core\LocationMap.cs,Add,Cyclomatic complexity of the method is 10
Complex Method,NAnt.Core,MailLogger,C:\repos\nant_nant\src\NAnt.Core\Log.cs,BuildFinished,Cyclomatic complexity of the method is 9
Complex Method,NAnt.Core,PathScanner,C:\repos\nant_nant\src\NAnt.Core\PathScanner.cs,Scan,Cyclomatic complexity of the method is 10
Complex Method,NAnt.Core,Project,C:\repos\nant_nant\src\NAnt.Core\Project.cs,GetFrameworks,Cyclomatic complexity of the method is 9
Complex Method,NAnt.Core,Project,C:\repos\nant_nant\src\NAnt.Core\Project.cs,CtorHelper,Cyclomatic complexity of the method is 12
Complex Method,NAnt.Core,Task,C:\repos\nant_nant\src\NAnt.Core\Task.cs,InitializeTaskConfiguration,Cyclomatic complexity of the method is 10
Complex Method,NAnt.Core,TypeFactory,C:\repos\nant_nant\src\NAnt.Core\TypeFactory.cs,ScanAssembly,Cyclomatic complexity of the method is 13
Complex Method,NAnt.Core.Filters,FilterChainConfigurator,C:\repos\nant_nant\src\NAnt.Core\Filters\Support\FilterChain.cs,InitializeBuildElementCollection,Cyclomatic complexity of the method is 11
Complex Method,NAnt.Core.Tasks,AttribTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\AttribTask.cs,ExecuteTask,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core.Tasks,CopyTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\CopyTask.cs,DoFileOperations,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core.Tasks,ExternalProgramBase,C:\repos\nant_nant\src\NAnt.Core\Tasks\ExternalProgramBase.cs,PrepareProcess,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core.Tasks,MailTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\MailTask.cs,ExecuteTask,Cyclomatic complexity of the method is 13
Complex Method,NAnt.Core.Tasks,MoveTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\MoveTask.cs,DoFileOperations,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core.Tasks,NAntSchemaGenerator,C:\repos\nant_nant\src\NAnt.Core\Tasks\NAntSchemaTask.cs,NAntSchemaGenerator,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core.Tasks,NAntTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\NAntTask.cs,RunBuild,Cyclomatic complexity of the method is 9
Complex Method,NAnt.Core.Tasks,PropertyTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\PropertyTask.cs,ExecuteTask,Cyclomatic complexity of the method is 9
Complex Method,NAnt.Core.Tasks,StyleTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\StyleTask.cs,ExecuteTask,Cyclomatic complexity of the method is 18
Complex Method,NAnt.Core.Tasks,XmlPeekTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\XmlPeekTask.cs,GetNodeContents,Cyclomatic complexity of the method is 9
Complex Method,NAnt.Core.Types,PathSet,C:\repos\nant_nant\src\NAnt.Core\Types\PathSet.cs,TranslatePath,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core.Util,FileUtils,C:\repos\nant_nant\src\NAnt.Core\Util\FileUtils.cs,CombinePaths,Cyclomatic complexity of the method is 14
Long Parameter List,NAnt.Core,DirectoryScanner,C:\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,ParseSearchDirectoryAndPattern,The method has 6 parameters. Parameters: isInclude' originalNAntPattern' searchDirectory' recursive' isRegex' regexPattern
Long Parameter List,NAnt.Core,AttributeConfigurator,C:\repos\nant_nant\src\NAnt.Core\Element.cs,CreateChildBuildElement,The method has 6 parameters. Parameters: propInf' getter' setter' xml' properties' framework
Long Parameter List,NAnt.Core,ExpressionEvalBase,C:\repos\nant_nant\src\NAnt.Core\ExpressionEvalBase.cs,SafeConvert,The method has 5 parameters. Parameters: returnType' source' description' p0' p1
Long Parameter List,NAnt.Core,Project,C:\repos\nant_nant\src\NAnt.Core\Project.cs,TopologicalTargetSort,The method has 5 parameters. Parameters: root' targets' state' visiting' executeTargets
Long Parameter List,NAnt.Core.Extensibility,FunctionArgument,C:\repos\nant_nant\src\NAnt.Core\Extensibility\FunctionArgument.cs,FunctionArgument,The method has 5 parameters. Parameters: name' index' value' beforeArgument' afterArgument
Long Parameter List,NAnt.Core.Util,FileUtils,C:\repos\nant_nant\src\NAnt.Core\Util\FileUtils.cs,CopyFile,The method has 5 parameters. Parameters: sourceFileName' destFileName' filterChain' inputEncoding' outputEncoding
Long Parameter List,NAnt.Core.Util,FileUtils,C:\repos\nant_nant\src\NAnt.Core\Util\FileUtils.cs,MoveFile,The method has 5 parameters. Parameters: sourceFileName' destFileName' filterChain' inputEncoding' outputEncoding
Long Identifier,NAnt.Core,DirectoryScanner,C:\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,ParseSearchDirectoryAndPattern,The length of the parameter indexOfLastOriginalDirectorySeparator is 37.
Long Identifier,NAnt.Core,AttributeConfigurator,C:\repos\nant_nant\src\NAnt.Core\Element.cs,InitializeBuildElementCollection,The length of the parameter buildElementCollectionAttribute is 31.
Long Identifier,NAnt.Core.Filters,ExpandProperties,C:\repos\nant_nant\src\NAnt.Core\Filters\ExpandProperties.cs,,The length of the parameter MAX_RELIABLE_EXPRESSION_LENGTH is 30.
Long Identifier,NAnt.Core.Tasks,NAntSchemaGenerator,C:\repos\nant_nant\src\NAnt.Core\Tasks\NAntSchemaTask.cs,FindOrCreateComplexType,The length of the parameter buildElementCollectionAttribute is 31.
Long Statement,NAnt.Core,ConsoleDriver,C:\repos\nant_nant\src\NAnt.Core\ConsoleDriver.cs,Main,The length of the statement  "                        Console.WriteLine(string.Format(CultureInfo.InvariantCulture' "Buildfile has already been loaded! Using new value '{0}'; discarding old project file '{1}'"' cmdlineOptions.BuildFile' project.BuildFileUri));" is 206.
Long Statement,NAnt.Core,ConsoleDriver,C:\repos\nant_nant\src\NAnt.Core\ConsoleDriver.cs,Main,The length of the statement  "                    project = new Project(GetBuildFileName(Environment.CurrentDirectory' null' cmdlineOptions.FindInParent)' projectThreshold' cmdlineOptions.IndentationLevel);" is 156.
Long Statement,NAnt.Core,ConsoleDriver,C:\repos\nant_nant\src\NAnt.Core\ConsoleDriver.cs,Main,The length of the statement  "                Console.WriteLine("Please send a bug report (including the version of NAnt you're using) to nant-developers@lists.sourceforge.net");" is 132.
Long Statement,NAnt.Core,ConsoleDriver,C:\repos\nant_nant\src\NAnt.Core\ConsoleDriver.cs,AddBuildListeners,The length of the statement  "                    outputWriter = new StreamWriter(new FileStream(cmdlineOptions.LogFile.FullName' FileMode.Create' FileAccess.Write' FileShare.Read));" is 132.
Long Statement,NAnt.Core,DirectoryScanner,C:\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,ConvertPatterns,The length of the statement  "                ParseSearchDirectoryAndPattern(addSearchDirectories' nantPattern' out searchDirectory' out isRecursive' out isRegex' out regexPattern); " is 135.
Long Statement,NAnt.Core,DirectoryScanner,C:\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,ParseSearchDirectoryAndPattern,The length of the statement  "            recursive = (indexOfFirstWildcard != -1 && (indexOfFirstWildcard < indexOfLastOriginalDirectorySeparator )) || indexOfFirstDirectoryWildcard != -1; " is 147.
Long Statement,NAnt.Core,DirectoryScanner,C:\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,ParseSearchDirectoryAndPattern,The length of the statement  "            if (searchDirectory.EndsWith(Path.DirectorySeparatorChar.ToString()) && (searchDirectory.Length != 3 || searchDirectory[1] != Path.VolumeSeparatorChar)) { " is 154.
Long Statement,NAnt.Core,DirectoryScanner,C:\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,TestRegex,The length of the statement  "            Console.WriteLine("{0} ({1}) [basedir={2}]"' entry.Pattern' path.Substring(entry.BaseDirectory.Length + ((endsWithSlash) ? 0 : 1))' entry.BaseDirectory); " is 153.
Long Statement,NAnt.Core,DirectoryScanner,C:\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,ToRegexPattern,The length of the statement  "            pattern = new StringBuilder(Regex.Replace(pattern.ToString()' "(?<=" + seperator + ")\\*(?=($|" + seperator + "))"' "[^" + seperator + "]+")); " is 142.
Long Statement,NAnt.Core,AttributeConfigurator,C:\repos\nant_nant\src\NAnt.Core\Element.cs,InitializeAttribute,The length of the statement  "                        ObsoleteAttribute obsoleteAttribute = (ObsoleteAttribute) Attribute.GetCustomAttribute(propertyInfo' typeof(ObsoleteAttribute));" is 128.
Long Statement,NAnt.Core,AttributeConfigurator,C:\repos\nant_nant\src\NAnt.Core\Element.cs,InitializeBuildElementCollection,The length of the statement  "                        ObsoleteAttribute obsoleteAttribute = (ObsoleteAttribute) Attribute.GetCustomAttribute(propertyInfo' typeof(ObsoleteAttribute));" is 128.
Long Statement,NAnt.Core,AttributeConfigurator,C:\repos\nant_nant\src\NAnt.Core\Element.cs,InitializeBuildElementCollection,The length of the statement  "                        ObsoleteAttribute obsoleteAttribute = (ObsoleteAttribute) Attribute.GetCustomAttribute(propertyInfo' typeof(ObsoleteAttribute));" is 128.
Long Statement,NAnt.Core,AttributeConfigurator,C:\repos\nant_nant\src\NAnt.Core\Element.cs,InitializeBuildElementCollection,The length of the statement  "                    if (!(childNode.NodeType == XmlNodeType.Element) || !childNode.NamespaceURI.Equals(NamespaceManager.LookupNamespace("nant"))) {" is 127.
Long Statement,NAnt.Core,AttributeConfigurator,C:\repos\nant_nant\src\NAnt.Core\Element.cs,CreateChildBuildElement,The length of the statement  "                    childElement = (Element) Activator.CreateInstance(elementType' BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance' null' null ' CultureInfo.InvariantCulture);" is 176.
Long Statement,NAnt.Core,EnumAttributeSetter,C:\repos\nant_nant\src\NAnt.Core\Element.cs,Set,The length of the statement  "                        property.SetValue(parent' propertyValue' BindingFlags.Public | BindingFlags.Instance' null' null' CultureInfo.InvariantCulture);" is 128.
Long Statement,NAnt.Core,FileAttributeSetter,C:\repos\nant_nant\src\NAnt.Core\Element.cs,Set,The length of the statement  "                            property.SetValue(parent' propertyValue' BindingFlags.Public | BindingFlags.Instance' null' null' CultureInfo.InvariantCulture);" is 128.
Long Statement,NAnt.Core,PathSetAttributeSetter,C:\repos\nant_nant\src\NAnt.Core\Element.cs,Set,The length of the statement  "                        property.SetValue(parent' propertyValue' BindingFlags.Public | BindingFlags.Instance' null' null' CultureInfo.InvariantCulture);" is 128.
Long Statement,NAnt.Core,UriAttributeSetter,C:\repos\nant_nant\src\NAnt.Core\Element.cs,Set,The length of the statement  "                            property.SetValue(parent' propertyValue' BindingFlags.Public | BindingFlags.Instance' null' null' CultureInfo.InvariantCulture);" is 128.
Long Statement,NAnt.Core,ConvertableAttributeSetter,C:\repos\nant_nant\src\NAnt.Core\Element.cs,Set,The length of the statement  "                        property.SetValue(parent' propertyValue' BindingFlags.Public | BindingFlags.Instance' null' null' CultureInfo.InvariantCulture);" is 128.
Long Statement,NAnt.Core,ExpressionEvaluator,C:\repos\nant_nant\src\NAnt.Core\ExpressionEvaluator.cs,EvaluateFunction,The length of the statement  "                    ConstructorInfo constructor = methodInfo.DeclaringType.GetConstructor(new Type[] {typeof(Project)' typeof(PropertyDictionary)});" is 128.
Long Statement,NAnt.Core,LocationMap,C:\repos\nant_nant\src\NAnt.Core\LocationMap.cs,Add,The length of the statement  "                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture' "XML document '{0}' has already been mapped."' fileName));" is 130.
Long Statement,NAnt.Core,MailLogger,C:\repos\nant_nant\src\NAnt.Core\Log.cs,GetPropertyValue,The length of the statement  "                throw new ArgumentNullException(string.Format(CultureInfo.InvariantCulture' "Missing required parameter {0}."' propertyName));" is 126.
Long Statement,NAnt.Core,Project,C:\repos\nant_nant\src\NAnt.Core\Project.cs,Execute,The length of the statement  "                System.Collections.Generic.Dictionary<string' Target> targets = new System.Collections.Generic.Dictionary<string' Target>();" is 124.
Long Statement,NAnt.Core,Project,C:\repos\nant_nant\src\NAnt.Core\Project.cs,InitializeProjectDocument,The length of the statement  "                if (!(childNode.NodeType == XmlNodeType.Element) || !childNode.NamespaceURI.Equals(NamespaceManager.LookupNamespace("nant")) || childNode.LocalName.Equals(TargetXml)) {" is 168.
Long Statement,NAnt.Core,Project,C:\repos\nant_nant\src\NAnt.Core\Project.cs,UpdateTargetFrameworkProperties,The length of the statement  "            Properties["nant.settings.currentframework.frameworkassemblydirectory"] = TargetFramework.FrameworkAssemblyDirectory.FullName;" is 126.
Long Statement,NAnt.Core,Target,C:\repos\nant_nant\src\NAnt.Core\Target.cs,Execute,The length of the statement  "                        if (!(childNode.NodeType == XmlNodeType.Element)|| !childNode.NamespaceURI.Equals(NamespaceManager.LookupNamespace("nant"))) {" is 126.
Long Statement,NAnt.Core,Task,C:\repos\nant_nant\src\NAnt.Core\Task.cs,InitializeTaskConfiguration,The length of the statement  "                            propertyInfo.SetValue(this' propertyValue' BindingFlags.Public | BindingFlags.Instance' null' null' CultureInfo.InvariantCulture); " is 130.
Long Statement,NAnt.Core,TaskContainer,C:\repos\nant_nant\src\NAnt.Core\TaskContainer.cs,Initialize,The length of the statement  "                BuildElementAttribute buildElemAttr = (BuildElementAttribute) Attribute.GetCustomAttribute(memInfo' typeof(BuildElementAttribute)' true);" is 137.
Long Statement,NAnt.Core,TaskContainer,C:\repos\nant_nant\src\NAnt.Core\TaskContainer.cs,ExecuteChildTasks,The length of the statement  "                if (!(childNode.NodeType == XmlNodeType.Element) || !childNode.NamespaceURI.Equals(NamespaceManager.LookupNamespace("nant"))) {" is 127.
Long Statement,NAnt.Core,XmlLogger,C:\repos\nant_nant\src\NAnt.Core\XmlLogger.cs,BuildFinished,The length of the statement  "                    using (StreamWriter writer = new StreamWriter(new FileStream(outFileName' FileMode.Create' FileAccess.Write' FileShare.Read)' Encoding.UTF8)) {" is 143.
Long Statement,NAnt.Core,ElementContainer,C:\repos\nant_nant\src\NAnt.Core\ElementContainer.cs,ExecuteChildTasks,The length of the statement  "                if (!(childNode.NodeType == XmlNodeType.Element) || !childNode.NamespaceURI.Equals(NamespaceManager.LookupNamespace("nant"))) { " is 127.
Long Statement,NAnt.Core.Filters,ExpandProperties,C:\repos\nant_nant\src\NAnt.Core\Filters\ExpandProperties.cs,ReplenishBuffer,The length of the statement  "                // There's an unfinished expression - don't attempt to expand it yet. Perhaps it will all fit in the buffer next time around." is 125.
Long Statement,NAnt.Core.Filters,ExpandProperties,C:\repos\nant_nant\src\NAnt.Core\Filters\ExpandProperties.cs,ReplenishBuffer,The length of the statement  "                _buffer = new StringBuilder(bufferAfterExpand' Math.Max(BUFFER_LENGTH' bufferAfterExpand.Length + bufferBeforeExpand.Length));" is 126.
Long Statement,NAnt.Core.Filters,FilterChainConfigurator,C:\repos\nant_nant\src\NAnt.Core\Filters\Support\FilterChain.cs,InitializeBuildElementCollection,The length of the statement  "                    if (!(childNode.NodeType == XmlNodeType.Element) || !childNode.NamespaceURI.Equals(NamespaceManager.LookupNamespace("nant"))) {" is 127.
Long Statement,NAnt.Core.Functions,AssemblyFunctions,C:\repos\nant_nant\src\NAnt.Core\Functions\AssemblyFunctions.cs,GetAttributeProperty,The length of the statement  "            PropertyInfo property = attributeType.GetProperty(propertyName' BindingFlags.GetProperty | BindingFlags.Instance | BindingFlags.Public | BindingFlags.Static); " is 158.
Long Statement,NAnt.Core.Tasks,AvailableTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\AvailableTask.cs,Evaluate,The length of the statement  "                    throw new BuildException(string.Format(CultureInfo.InvariantCulture' "No resource check is implemented for {0}"' Type)); " is 120.
Long Statement,NAnt.Core.Tasks,ExternalProgramBase,C:\repos\nant_nant\src\NAnt.Core\Tasks\ExternalProgramBase.cs,ExecuteTask,The length of the statement  "                    string.Format(CultureInfo.InvariantCulture' "{0}: {1} had errors. Please see log4net log."' GetType().ToString()' ProgramFileName)'  " is 131.
Long Statement,NAnt.Core.Tasks,ExternalProgramBase,C:\repos\nant_nant\src\NAnt.Core\Tasks\ExternalProgramBase.cs,DetermineFilePath,The length of the statement  "            ProgramLocationAttribute programLocationAttribute = (ProgramLocationAttribute) Attribute.GetCustomAttribute(this.GetType()'  " is 123.
Long Statement,NAnt.Core.Tasks,GetTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\GetTask.cs,Initialize,The length of the statement  "            if (DestinationFile.Exists && (FileAttributes.ReadOnly == (File.GetAttributes(DestinationFile.FullName) & FileAttributes.ReadOnly))) { " is 134.
Long Statement,NAnt.Core.Tasks,IfTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\IfTask.cs,Initialize,The length of the statement  "            if ((UpToDateFiles == null || CompareFiles == null) && Test == null && PropertyNameExists == null && PropertyNameTrue == null && TargetNameExists == null) {" is 156.
Long Statement,NAnt.Core.Tasks,NAntSchemaGenerator,C:\repos\nant_nant\src\NAnt.Core\Tasks\NAntSchemaTask.cs,FindOrCreateComplexType,The length of the statement  "                        // We will only process child elements if they are defined for Properties or Fields' this should be enforced by the AttributeUsage on the Attribute class " is 153.
Long Statement,NAnt.Core.Tasks,NAntSchemaGenerator,C:\repos\nant_nant\src\NAnt.Core\Tasks\NAntSchemaTask.cs,FindOrCreateComplexType,The length of the statement  "                        BuildElementCollectionAttribute buildElementCollectionAttribute = (BuildElementCollectionAttribute) Attribute.GetCustomAttribute(memInfo' typeof(BuildElementCollectionAttribute)' false); " is 186.
Long Statement,NAnt.Core.Tasks,SysInfoTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\SysInfo.cs,ExecuteTask,The length of the statement  "            Properties[Prefix + "os.folder.applicationdata"] = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);  " is 120.
Long Statement,NAnt.Core.Tasks,SysInfoTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\SysInfo.cs,ExecuteTask,The length of the statement  "            Properties[Prefix + "os.folder.commonapplicationData"] = Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData);  " is 132.
Long Statement,NAnt.Core.Tasks,SysInfoTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\SysInfo.cs,ExecuteTask,The length of the statement  "            Properties[Prefix + "os.folder.commonprogramFiles"] = Environment.GetFolderPath(Environment.SpecialFolder.CommonProgramFiles);  " is 126.
Long Statement,NAnt.Core.Tasks,SysInfoTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\SysInfo.cs,ExecuteTask,The length of the statement  "            Properties[Prefix + "os.folder.desktopdirectory"] = Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory);                          " is 122.
Long Statement,NAnt.Core.Tasks,SysInfoTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\SysInfo.cs,ExecuteTask,The length of the statement  "                    string safeName = name.EndsWith("(x86)") ? name.Replace("(x86)"' ".x86") : name;    // since on 64bit Windows provide such variable names' let's make them nice" is 159.
Long Statement,NAnt.Core.Util,CommandLineArgument,C:\repos\nant_nant\src\NAnt.Core\Util\CommandLineArgument.cs,Finish,The length of the statement  "                throw new CommandLineArgumentException(string.Format(CultureInfo.InvariantCulture' "Missing required argument '-{0}'."' LongName));" is 131.
Long Statement,NAnt.Core.Util,CommandLineArgument,C:\repos\nant_nant\src\NAnt.Core\Util\CommandLineArgument.cs,Finish,The length of the statement  "                _propertyInfo.SetValue(destination' _collectionValues.ToArray(_elementType)' BindingFlags.Default' null' null' CultureInfo.InvariantCulture);" is 141.
Long Statement,NAnt.Core.Util,CommandLineArgument,C:\repos\nant_nant\src\NAnt.Core\Util\CommandLineArgument.cs,Finish,The length of the statement  "                    object instance = Activator.CreateInstance(_propertyInfo.PropertyType' BindingFlags.Public | BindingFlags.Instance' null' null' CultureInfo.InvariantCulture);" is 158.
Long Statement,NAnt.Core.Util,CommandLineArgument,C:\repos\nant_nant\src\NAnt.Core\Util\CommandLineArgument.cs,Finish,The length of the statement  "                    throw new NotSupportedException(string.Format(CultureInfo.InvariantCulture' ResourceUtils.GetString("NA1169")' LongName));" is 122.
Long Statement,NAnt.Core.Util,CommandLineArgument,C:\repos\nant_nant\src\NAnt.Core\Util\CommandLineArgument.cs,Finish,The length of the statement  "                    object instance = Activator.CreateInstance(_propertyInfo.PropertyType' BindingFlags.Public | BindingFlags.Instance' null' null' CultureInfo.InvariantCulture);" is 158.
Long Statement,NAnt.Core.Util,CommandLineArgument,C:\repos\nant_nant\src\NAnt.Core\Util\CommandLineArgument.cs,GetElementType,The length of the statement  "                    throw new NotSupportedException(string.Format(CultureInfo.InvariantCulture' "Property {0} is not a strong-typed array."' propertyInfo.Name));" is 141.
Long Statement,NAnt.Core.Util,CommandLineArgument,C:\repos\nant_nant\src\NAnt.Core\Util\CommandLineArgument.cs,GetElementType,The length of the statement  "                            throw new NotSupportedException(string.Format(CultureInfo.InvariantCulture' "Property {0} is not a strong-typed collection."' propertyInfo.Name));" is 146.
Long Statement,NAnt.Core.Util,CommandLineArgument,C:\repos\nant_nant\src\NAnt.Core\Util\CommandLineArgument.cs,GetElementType,The length of the statement  "                    throw new NotSupportedException(string.Format(CultureInfo.InvariantCulture' "Invalid commandline argument type for property {0}."' propertyInfo.Name));" is 151.
Complex Conditional,NAnt.Core,ExpressionEvalBase,C:\repos\nant_nant\src\NAnt.Core\ExpressionEvalBase.cs,ParseRelationalExpression,The conditional expression  "_tokenizer.CurrentToken == ExpressionTokenizer.TokenType.EQ                  || _tokenizer.CurrentToken == ExpressionTokenizer.TokenType.NE                  || _tokenizer.CurrentToken == ExpressionTokenizer.TokenType.LT                  || _tokenizer.CurrentToken == ExpressionTokenizer.TokenType.GT                  || _tokenizer.CurrentToken == ExpressionTokenizer.TokenType.LE                  || _tokenizer.CurrentToken == ExpressionTokenizer.TokenType.GE"  is complex.
Complex Conditional,NAnt.Core,ExpressionEvalBase,C:\repos\nant_nant\src\NAnt.Core\ExpressionEvalBase.cs,ParseValue,The conditional expression  "_tokenizer.CurrentToken == ExpressionTokenizer.TokenType.Dot                          || _tokenizer.CurrentToken == ExpressionTokenizer.TokenType.Minus                          || _tokenizer.CurrentToken == ExpressionTokenizer.TokenType.Keyword                          || _tokenizer.CurrentToken == ExpressionTokenizer.TokenType.Number"  is complex.
Complex Conditional,NAnt.Core,ExpressionTokenizer,C:\repos\nant_nant\src\NAnt.Core\ExpressionTokenizer.cs,GetNextToken,The conditional expression  "c == '_' || c == '-' || c == '.' || c == '\\' || Char.IsLetterOrDigit(c)"  is complex.
Complex Conditional,NAnt.Core,LocationMap,C:\repos\nant_nant\src\NAnt.Core\LocationMap.cs,Add,The conditional expression  "(reader.NodeType != XmlNodeType.Whitespace) &&                         (reader.NodeType != XmlNodeType.EndElement) &&                         (reader.NodeType != XmlNodeType.ProcessingInstruction) &&                         (reader.NodeType != XmlNodeType.XmlDeclaration) &&                         (reader.NodeType != XmlNodeType.DocumentType)"  is complex.
Complex Conditional,NAnt.Core.Tasks,IfTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\IfTask.cs,Initialize,The conditional expression  "(UpToDateFiles == null || CompareFiles == null) && Test == null && PropertyNameExists == null && PropertyNameTrue == null && TargetNameExists == null"  is complex.
Complex Conditional,NAnt.Core.Types,PathSet,C:\repos\nant_nant\src\NAnt.Core\Types\PathSet.cs,TranslatePath,The conditional expression  "part.Length == 1 && Char.IsLetter(part[0]) && _dosBasedFileSystem && (parts.Length > i + 1)"  is complex.
Complex Conditional,NAnt.Core.Util,CommandLineArgument,C:\repos\nant_nant\src\NAnt.Core\Util\CommandLineArgument.cs,ParseValue,The conditional expression  "(stringData != null || type == typeof(bool)) && (stringData == null || stringData.Length > 0)"  is complex.
Complex Conditional,NAnt.Core.Util,FileUtils,C:\repos\nant_nant\src\NAnt.Core\Util\FileUtils.cs,MoveFile,The conditional expression  "(filterChain == null || filterChain.Filters.Count == 0) && inputEncoding == null && outputEncoding == null"  is complex.
Virtual Method Call from Constructor,NAnt.Core.Filters,PhysicalTextReader,C:\repos\nant_nant\src\NAnt.Core\Filters\Support\PhysicalTextReader.cs,PhysicalTextReader,The constructor "PhysicalTextReader" calls a virtual method "Chain".
Empty Catch Block,NAnt.Core,FrameworkInfo,C:\repos\nant_nant\src\NAnt.Core\FrameworkInfo.cs,PerformInit,The method has an empty catch block.
Empty Catch Block,NAnt.Core,Location,C:\repos\nant_nant\src\NAnt.Core\Location.cs,Init,The method has an empty catch block.
Empty Catch Block,NAnt.Core,MailLogger,C:\repos\nant_nant\src\NAnt.Core\Log.cs,BuildFinished,The method has an empty catch block.
Empty Catch Block,NAnt.Core,Project,C:\repos\nant_nant\src\NAnt.Core\Project.cs,GetFullPath,The method has an empty catch block.
Empty Catch Block,NAnt.Core.Tasks,ExternalProgramBase,C:\repos\nant_nant\src\NAnt.Core\Tasks\ExternalProgramBase.cs,ExecuteTask,The method has an empty catch block.
Magic Number,NAnt.Core,ConsoleDriver,C:\repos\nant_nant\src\NAnt.Core\ConsoleDriver.cs,Main,The following statement contains a magic number: try {                                 commandLineParser = new CommandLineParser(typeof(CommandLineOptions)' true);                 commandLineParser.Parse(args' cmdlineOptions);                  if (!cmdlineOptions.NoLogo) {                     Console.WriteLine(commandLineParser.LogoBanner);                     // insert empty line                     Console.WriteLine();                 }                  if (cmdlineOptions.ShowHelp) {                     ConsoleDriver.ShowHelp(commandLineParser);                     return 0;                 }                  // determine the project message threshold                 if (cmdlineOptions.Debug) {                     projectThreshold = Level.Debug;                 } else if (cmdlineOptions.Verbose) {                     projectThreshold = Level.Verbose;                 } else if (cmdlineOptions.Quiet) {                     projectThreshold = Level.Warning;                 }                  if (cmdlineOptions.BuildFile != null) {                     if (project != null) {                         Console.WriteLine(string.Format(CultureInfo.InvariantCulture' "Buildfile has already been loaded! Using new value '{0}'; discarding old project file '{1}'"' cmdlineOptions.BuildFile' project.BuildFileUri));                         // insert empty line                         Console.WriteLine();                     }                      project = new Project(cmdlineOptions.BuildFile' projectThreshold' cmdlineOptions.IndentationLevel);                 }                  // get build file name if the project has not been created.                 // If a build file was not specified on the command line.                 if (project == null) {                     project = new Project(GetBuildFileName(Environment.CurrentDirectory' null' cmdlineOptions.FindInParent)' projectThreshold' cmdlineOptions.IndentationLevel);                 }                  // load extension asseemblies                 LoadExtensionAssemblies(cmdlineOptions.ExtensionAssemblies' project);                  PropertyDictionary buildOptionProps = new PropertyDictionary(project);                  // add build logger and build listeners to project                 ConsoleDriver.AddBuildListeners(cmdlineOptions' project);                      // copy cmd line targets                 foreach (string target in cmdlineOptions.Targets) {                     project.BuildTargets.Add(target);                 }                  // build collection of valid properties that were specified on                  // the command line.                 foreach (string key in cmdlineOptions.Properties) {                     buildOptionProps.AddReadOnly(key'                          cmdlineOptions.Properties.Get(key));                 }                  // add valid properties to the project.                 foreach (System.Collections.DictionaryEntry de in buildOptionProps) {                     project.Properties.AddReadOnly((string) de.Key' (string) de.Value);                 }                  //add these here and in the project .ctor                 Assembly ass = Assembly.GetExecutingAssembly();                  project.Properties.AddReadOnly(Project.NAntPropertyFileName' ass.Location);                 project.Properties.AddReadOnly(Project.NAntPropertyVersion'  ass.GetName().Version.ToString());                 project.Properties.AddReadOnly(Project.NAntPropertyLocation' Path.GetDirectoryName(ass.Location));                  if (cmdlineOptions.TargetFramework != null) {                     FrameworkInfo framework = project.Frameworks[cmdlineOptions.TargetFramework];                      if (framework != null) {                         try {                             framework.Validate();                             project.TargetFramework = framework;                         } catch (Exception ex) {                             // write message of exception to console                             WriteException(ex);                             // output full stacktrace when NAnt is started in debug mode                             if (Level.Debug >= projectThreshold) {                                 // insert empty line                                 Console.Error.WriteLine();                                 // output header                                 Console.Error.WriteLine("Stacktrace:");                                 // insert empty line                                 Console.Error.WriteLine();                                 // output full stacktrace                                 Console.Error.WriteLine(ex.ToString());                             }                             // signal error                             return 1;                         }                     } else {                         Console.Error.WriteLine("Invalid framework '{0}' specified."'                              cmdlineOptions.TargetFramework);                          // insert empty line                         Console.Error.WriteLine();                          FrameworkInfo[] installedFrameworks = project.GetFrameworks(                             FrameworkTypes.Installed);                          if (installedFrameworks.Length == 0) {                             Console.Error.WriteLine("There are no supported frameworks available on your system.");                         } else {                             Console.Error.WriteLine("Possible values include:");                             // insert empty line                             Console.Error.WriteLine();                              foreach (FrameworkInfo fi in installedFrameworks) {                                 Console.Error.WriteLine("{0} ({1})"'                                     fi.Name' fi.Description);                             }                         }                         // signal error                         return 1;                     }                 }                  // Enable parallel execution of targets                 project.RunTargetsInParallel = cmdlineOptions.UseJobs;                  if (cmdlineOptions.ShowProjectHelp) {                     Console.WriteLine();                     ConsoleDriver.ShowProjectHelp(project.Document);                 } else {                     if (!project.Run()) {                         return 1;                     }                 }                 // signal success                 return 0;             } catch (CommandLineArgumentException ex) {                 // Write logo banner to console if parser was created successfully                 if (commandLineParser != null) {                     Console.WriteLine(commandLineParser.LogoBanner);                     // insert empty line                     Console.Error.WriteLine();                 }                 // write message of exception to console                 WriteException(ex);                 // output full stacktrace when NAnt is started in debug mode                 if (Level.Debug >= projectThreshold) {                     // insert empty line                     Console.Error.WriteLine();                     // output header                     Console.Error.WriteLine("Stacktrace:");                     // insert empty line                     Console.Error.WriteLine();                     // output full stacktrace                     Console.Error.WriteLine(ex.ToString());                 }                 // insert empty line                 Console.WriteLine();                 // instruct users to check the usage instructions                 Console.WriteLine("Try 'nant -help' for more information");                 // signal error                 return 1;             } catch (ApplicationException ex) {                 // insert empty line                 Console.Error.WriteLine();                 // output build result                 Console.Error.WriteLine("BUILD FAILED");                 // insert empty line                 Console.Error.WriteLine();                 // write message of exception to console                 WriteException(ex);                 // output full stacktrace when NAnt is started in debug mode                 if (Level.Debug >= projectThreshold) {                     // insert empty line                     Console.Error.WriteLine();                     // output header                     Console.Error.WriteLine("Stacktrace:");                     // insert empty line                     Console.Error.WriteLine();                     // output full stacktrace                     Console.Error.WriteLine(ex.ToString());                 } else {                     // insert empty line                     Console.WriteLine(string.Empty);                     // output help text                     Console.WriteLine("For more information regarding the cause of the " +                         "build failure' run the build again in debug mode.");                 }                 // insert empty line                 Console.WriteLine();                 // instruct users to check the usage instructions                 Console.WriteLine("Try 'nant -help' for more information");                 // signal error                 return 1;             } catch (Exception ex) {                 // insert empty line                 Console.Error.WriteLine();                 // all other exceptions should have been caught                 Console.Error.WriteLine("INTERNAL ERROR");                 // insert empty line                 Console.Error.WriteLine();                 // write message of exception to console                 WriteException(ex);                 // output full stacktrace when NAnt is started in verbose mode                 if (Level.Verbose >= projectThreshold) {                     // insert empty line                     Console.Error.WriteLine();                     // output header                     Console.Error.WriteLine("Stacktrace:");                     // insert empty line                     Console.Error.WriteLine();                     // output full stacktrace                     Console.Error.WriteLine(ex.ToString());                 } else {                     // insert xempty line                     Console.WriteLine();                     // output help text                     Console.WriteLine("For more information regarding the cause of the " +                         "build failure' run the build again in verbose mode.");                 }                 // insert empty line                 Console.WriteLine();                 // instruct users to report this problem                 Console.WriteLine("Please send a bug report (including the version of NAnt you're using) to nant-developers@lists.sourceforge.net");                 // signal fatal error                 return 2;             } finally {                 if (project != null) {                     project.DetachBuildListeners();                 }                 // detach assembly resolver from the current domain                 assemblyResolver.Detach();                 if (cmdlineOptions.Pause)                     Console.ReadKey();             }
Magic Number,NAnt.Core,DirectoryScanner,C:\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,Scan,The following statement contains a magic number: Thread[] lastTasks = new Thread[2];
Magic Number,NAnt.Core,DirectoryScanner,C:\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,ParseSearchDirectoryAndPattern,The following statement contains a magic number: if (indexOfLastDirectorySeparator != -1) {                  s = originalNAntPattern.Substring(0' indexOfLastDirectorySeparator);                  if (s.Length == 2 && s[1] == Path.VolumeSeparatorChar) {                      s += Path.DirectorySeparatorChar;                  }              } else {                  s = string.Empty;              }
Magic Number,NAnt.Core,DirectoryScanner,C:\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,ParseSearchDirectoryAndPattern,The following statement contains a magic number: if (searchDirectory.EndsWith(Path.DirectorySeparatorChar.ToString()) && (searchDirectory.Length != 3 || searchDirectory[1] != Path.VolumeSeparatorChar)) {                  searchDirectory = searchDirectory.Substring(0' searchDirectory.Length - 1);              }
Magic Number,NAnt.Core,DirectoryScanner,C:\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,ToRegexPattern,The following statement contains a magic number: if (patternText.StartsWith("^.*"))                  patternText = patternText.Substring(3);
Magic Number,NAnt.Core,DirectoryScanner,C:\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,ToRegexPattern,The following statement contains a magic number: if (patternText.EndsWith(".*$"))                  patternText = patternText.Substring(0' pattern.Length - 3);
Magic Number,NAnt.Core,ExpressionTokenizer,C:\repos\nant_nant\src\NAnt.Core\ExpressionTokenizer.cs,ExpressionTokenizer,The following statement contains a magic number: for (int i = 0; i < 128; ++i)                  charIndexToTokenType[i] = TokenType.Punctuation;
Magic Number,NAnt.Core,ExpressionTokenizer,C:\repos\nant_nant\src\NAnt.Core\ExpressionTokenizer.cs,GetNextToken,The following statement contains a magic number: if (ch >= 32 && ch < 128) {                  _tokenType = charIndexToTokenType[ch];              } else {                  _tokenType = TokenType.Punctuation;              }
Magic Number,NAnt.Core,ExpressionTokenizer,C:\repos\nant_nant\src\NAnt.Core\ExpressionTokenizer.cs,GetNextToken,The following statement contains a magic number: if (ch >= 32 && ch < 128) {                  _tokenType = charIndexToTokenType[ch];              } else {                  _tokenType = TokenType.Punctuation;              }
Magic Number,NAnt.Core,DefaultLogger,C:\repos\nant_nant\src\NAnt.Core\Log.cs,BuildFinished,The following statement contains a magic number: if (error == null) {                 OutputMessage(Level.Info' string.Empty' indentationLevel);                 if (report.Errors == 0 && report.Warnings == 0) {                     OutputMessage(Level.Info' "BUILD SUCCEEDED"' indentationLevel);                 } else {                     OutputMessage(Level.Info' string.Format(CultureInfo.InvariantCulture'                         ResourceUtils.GetString("String_BuildSucceeded")'                          report.Errors' report.Warnings)' indentationLevel);                 }                 OutputMessage(Level.Info' string.Empty' indentationLevel);             } else {                 OutputMessage(Level.Error' string.Empty' indentationLevel);                 if (report.Errors == 0 && report.Warnings == 0) {                     OutputMessage(Level.Error' "BUILD FAILED"' indentationLevel);                 } else {                     OutputMessage(Level.Info' string.Format(CultureInfo.InvariantCulture'                         ResourceUtils.GetString("String_BuildFailed")'                          report.Errors' report.Warnings)' indentationLevel);                 }                 OutputMessage(Level.Error' string.Empty' indentationLevel);                  if (error is BuildException) {                     if (Threshold <= Level.Verbose) {                         OutputMessage(Level.Error' error.ToString()' indentationLevel);                     } else {                         if (error.Message != null) {                             OutputMessage(Level.Error' error.Message' indentationLevel);                         }                          // output nested exceptions                         Exception nestedException = error.InnerException;                         int exceptionIndentationLevel = indentationLevel;                         int indentShift = 4; //e.Project.IndentationSize;                         while (nestedException != null && !String.IsNullOrEmpty(nestedException.Message)) {                             exceptionIndentationLevel += indentShift;                             OutputMessage(Level.Error' nestedException.Message' exceptionIndentationLevel);                             nestedException = nestedException.InnerException;                         }                     }                 } else {                     OutputMessage(Level.Error' "INTERNAL ERROR"' indentationLevel);                     OutputMessage(Level.Error' string.Empty' indentationLevel);                     OutputMessage(Level.Error' error.ToString()' indentationLevel);                     OutputMessage(Level.Error' string.Empty' indentationLevel);                     OutputMessage(Level.Error' "Please send bug report to nant-developers@lists.sourceforge.net."' indentationLevel);                 }                  OutputMessage(Level.Error' string.Empty' indentationLevel);             }
Magic Number,NAnt.Core,PlatformHelper,C:\repos\nant_nant\src\NAnt.Core\PlatformHelper.cs,PlatformHelper,The following statement contains a magic number: if ((p == 4) || (p == 6) || (p == 128))                  IsUnix = true;
Magic Number,NAnt.Core,PlatformHelper,C:\repos\nant_nant\src\NAnt.Core\PlatformHelper.cs,PlatformHelper,The following statement contains a magic number: if ((p == 4) || (p == 6) || (p == 128))                  IsUnix = true;
Magic Number,NAnt.Core,PlatformHelper,C:\repos\nant_nant\src\NAnt.Core\PlatformHelper.cs,PlatformHelper,The following statement contains a magic number: if ((p == 4) || (p == 6) || (p == 128))                  IsUnix = true;
Magic Number,NAnt.Core,Project,C:\repos\nant_nant\src\NAnt.Core\Project.cs,CtorHelper,The following statement contains a magic number: _indentationSize = 12;
Magic Number,NAnt.Core,ProjectSettingsLoader,C:\repos\nant_nant\src\NAnt.Core\ProjectSettingsLoader.cs,ConfigureRuntimeFramework,The following statement contains a magic number: Version frameworkClrVersion = new Version(Environment.Version.ToString(3));
Magic Number,NAnt.Core,Task,C:\repos\nant_nant\src\NAnt.Core\Task.cs,Execute,The following statement contains a magic number: if (IfDefined && !UnlessDefined) {                  try {                      Project.OnTaskStarted(this' new BuildEventArgs(this));                      ExecuteTask();                  } catch (Exception ex) {                      logger.ErrorFormat(                          CultureInfo.InvariantCulture'                          ResourceUtils.GetString("NA1077")'                           Name' ex);                        if (FailOnError) {                          throw;                      } else {                          if (this.Verbose) {                              // output exception (with stacktrace) to build log                              Log(Level.Error' ex.ToString());                          } else {                              string msg = ex.Message;                              // get first nested exception                              Exception nestedException = ex.InnerException;                              // set initial indentation level for the nested exceptions                              int exceptionIndentationLevel = 0;                              // output message of nested exceptions                              while (nestedException != null && !String.IsNullOrEmpty(nestedException.Message)) {                                  // indent exception message with 4 extra spaces                                   // (for each nesting level)                                  exceptionIndentationLevel += 4;                                  // start new line for each exception level                                  msg = (msg != null) ? msg + Environment.NewLine : string.Empty;                                  // output exception message                                  msg += new string(' '' exceptionIndentationLevel)                                       + nestedException.Message;                                  // move on to next inner exception                                  nestedException = nestedException.InnerException;                              }                                // output message of exception(s) to build log                              Log(Level.Error' msg);                          }                      }                  } finally {                      Project.OnTaskFinished(this' new BuildEventArgs(this));                  }              }
Magic Number,NAnt.Core,Task,C:\repos\nant_nant\src\NAnt.Core\Task.cs,InitializeTaskConfiguration,The following statement contains a magic number: foreach (PropertyInfo propertyInfo in properties) {                  XmlNode attributeNode = null;                  string attributeValue = null;                    FrameworkConfigurableAttribute frameworkAttribute = (FrameworkConfigurableAttribute)                       Attribute.GetCustomAttribute(propertyInfo' typeof(FrameworkConfigurableAttribute));                    if (frameworkAttribute != null) {                      // locate XML configuration node for current attribute                      attributeNode = GetAttributeConfigurationNode(                          Project.TargetFramework' frameworkAttribute.Name);                        if (attributeNode != null) {                          // get the configured value                          attributeValue = attributeNode.InnerText;                            if (frameworkAttribute.ExpandProperties && Project.TargetFramework != null) {                              try {                                  // expand attribute properites                                  attributeValue = Project.TargetFramework.Project.Properties.ExpandProperties(                                      attributeValue' Location);                              } catch (Exception ex) {                                  // throw BuildException if required                                  if (frameworkAttribute.Required) {                                      throw new BuildException(string.Format(CultureInfo.InvariantCulture'                                           ResourceUtils.GetString("NA1075")' frameworkAttribute.Name' Name)' Location' ex);                                  }                                    // set value to null                                  attributeValue = null;                              }                          }                      } else {                          // check if its required                          if (frameworkAttribute.Required) {                              throw new BuildException(string.Format(CultureInfo.InvariantCulture'                                   "'{0}' is a required framework configuration setting for the '{1}'"                                   + " build element that should be set in the NAnt configuration file."'                                   frameworkAttribute.Name' Name)' Location);                          }                      }                        if (attributeValue != null) {                          if (propertyInfo.CanWrite) {                              Type propertyType = propertyInfo.PropertyType;                                //validate attribute value with custom ValidatorAttribute(ors)                              object[] validateAttributes = (ValidatorAttribute[])                                   Attribute.GetCustomAttributes(propertyInfo' typeof(ValidatorAttribute));                              try {                                  foreach (ValidatorAttribute validator in validateAttributes) {                                      logger.InfoFormat(CultureInfo.InvariantCulture'                                          ResourceUtils.GetString("NA1074")'                                           attributeValue' Name' validator.GetType().Name);                                        validator.Validate(attributeValue);                                  }                              } catch (ValidationException ve) {                                  logger.Error("Validation Exception"' ve);                                  throw new ValidationException("Validation failed on" + propertyInfo.DeclaringType.FullName' Location' ve);                              }                                // holds the attribute value converted to the property type                              object propertyValue = null;                                // If the object is an enum                              if (propertyType.IsEnum) {                                  try {                                      TypeConverter tc = TypeDescriptor.GetConverter(propertyType);                                      if (!(tc.GetType() == typeof(EnumConverter))) {                                          propertyValue = tc.ConvertFrom(attributeValue);                                      } else {                                          propertyValue = Enum.Parse(propertyType' attributeValue);                                      }                                  } catch (Exception) {                                      // catch type conversion exceptions here                                      string message = "Invalid configuration value \"" + attributeValue + "\". Valid values for this attribute are: ";                                      foreach (object value in Enum.GetValues(propertyType)) {                                          message += value.ToString() + "' ";                                      }                                      // strip last '                                      message = message.Substring(0' message.Length - 2);                                      throw new BuildException(message' Location);                                  }                              } else {                                  propertyValue = Convert.ChangeType(attributeValue' propertyInfo.PropertyType' CultureInfo.InvariantCulture);                              }                                //set property value                              propertyInfo.SetValue(this' propertyValue' BindingFlags.Public | BindingFlags.Instance' null' null' CultureInfo.InvariantCulture);                          }                      }                  }              }
Magic Number,NAnt.Core,TypeFactory,C:\repos\nant_nant\src\NAnt.Core\TypeFactory.cs,AddProject,The following statement contains a magic number: ScanDir(Path.Combine(commonTasksDir' project.RuntimeFramework.                 ClrVersion.ToString (2))' loadTasks' false);
Magic Number,NAnt.Core,TypeFactory,C:\repos\nant_nant\src\NAnt.Core\TypeFactory.cs,RegisterFunction,The following statement contains a magic number: if (functions == null) {                 _methodInfoCollection.Add(key' info);             } else {                 MethodInfo mi = functions as MethodInfo;                 if (mi == null) {                     ArrayList overloads = (ArrayList) functions;                     overloads.Add (info);                 } else {                     ArrayList overloads = new ArrayList (3);                     overloads.Add (mi);                     overloads.Add (info);                     _methodInfoCollection [key] = overloads;                 }             }
Magic Number,NAnt.Core.Tasks,CopyTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\CopyTask.cs,ExecuteTask,The following statement contains a magic number: if (SourceFile != null)             {                 // copy a single file.                 if (SourceFile.Exists)                 {                     FileInfo dstInfo = null;                     if (ToFile != null)                      {                         dstInfo = ToFile;                     }                      else                      {                         string dstFilePath = Path.Combine(ToDirectory.FullName'                              SourceFile.Name);                         dstInfo = new FileInfo(dstFilePath);                     }                      // do the outdated check                     bool outdated = (!dstInfo.Exists) || (SourceFile.LastWriteTime > dstInfo.LastWriteTime);                      if (Overwrite || outdated)                      {                         // add to a copy map of absolute verified paths                         FileCopyMap.Add(dstInfo.FullName' new FileDateInfo(SourceFile.FullName' SourceFile.LastWriteTime));                         _fileCount++;                          if (dstInfo.Exists && dstInfo.Attributes != FileAttributes.Normal)                         {                             File.SetAttributes(dstInfo.FullName' FileAttributes.Normal);                         }                     }                 }                 // If SourceFile exists as a directory' proceed with moving the specified directory                 else if (!SourceFile.Exists && Directory.Exists(SourceFile.FullName))                 {                     // Stage the directory names                     string sourceDirName = SourceFile.FullName;                     string destDirName;                                          // If ToFile was specified' make sure the specified filename does not exist                     // as a file or a directory.                     if (ToFile != null)                     {                         if (ToFile.Exists)                         {                             throw new BuildException(String.Format(CultureInfo.InvariantCulture'                                 "Cannot move directory '{0}' to an existing file '{1}'"'                                  SourceFile.FullName' ToFile.FullName)' Location);                         }                         if (Directory.Exists(ToFile.FullName))                         {                             throw new BuildException(String.Format(CultureInfo.InvariantCulture'                                 "Cannot move directory '{0}' to an existing directory '{1}'"'                                 SourceFile.FullName' ToFile.FullName)' Location);                         }                         destDirName = ToFile.FullName;                     }                     // If ToDirectory was specified' make sure the specified directory does not                     // exist.                     else if (ToDirectory != null)                     {                         if (ToDirectory.Exists)                         {                             throw new BuildException(String.Format(CultureInfo.InvariantCulture'                                 "Cannot move directory '{0}' to an existing directory '{1}'"'                                 SourceFile.FullName' ToDirectory.FullName)' Location);                         }                         destDirName = ToDirectory.FullName;                     }                     // Else' throw an exception                     else                     {                         throw new BuildException("Target directory name not specified"'                             Location);                     }                     FileCopyMap.Add(destDirName' new FileDateInfo(sourceDirName' SourceFile.LastWriteTime' true));                     _dirCount++;                 }                 else                  {                     throw CreateSourceFileNotFoundException (SourceFile.FullName);                 }             }              // copy file set contents.             else             {                 // get the complete path of the base directory of the fileset' ie' c:\work\nant\src                 DirectoryInfo srcBaseInfo = CopyFileSet.BaseDirectory;                  // Check to see if the file operation is a straight pass through (ie: no file or                 // directory modifications) before proceeding.                 bool completeDir = true;                  // completeDir criteria                 bool[] dirCheck = new bool[8];                 dirCheck[0] = CopyFileSet.IsEverythingIncluded;                 dirCheck[1] = !Flatten;                 dirCheck[2] = IncludeEmptyDirs || !CopyFileSet.HasEmptyDirectories;                 dirCheck[3] = FilterChain.IsNullOrEmpty(Filters);                 dirCheck[4] = _inputEncoding == null;                 dirCheck[5] = _outputEncoding == null;                 dirCheck[6] = srcBaseInfo != null && srcBaseInfo.Exists;                 dirCheck[7] = !ToDirectory.Exists ||                     srcBaseInfo.FullName.Equals(ToDirectory.FullName'                         StringComparison.InvariantCultureIgnoreCase);                  for (int b = 0; b < dirCheck.Length; b++) completeDir &= dirCheck[b];                                      if (completeDir)                 {                     FileCopyMap.Add(ToDirectory.FullName'                          new FileDateInfo(srcBaseInfo.FullName' srcBaseInfo.LastWriteTime' true));                     _dirCount++;                 }                 else                 {                     // if source file not specified use fileset                     foreach (string pathname in CopyFileSet.FileNames)                      {                         FileInfo srcInfo = new FileInfo(pathname);                         if (srcInfo.Exists) {                             // will holds the full path to the destination file                             string dstFilePath;                              if (Flatten) {                                 dstFilePath = Path.Combine(ToDirectory.FullName'                                      srcInfo.Name);                             } else {                                 // Gets the relative path and file info from the full                                  // source filepath                                 // pathname = C:\f2\f3\file1' srcBaseInfo=C:\f2' then                                  // dstRelFilePath=f3\file1                                 string dstRelFilePath = "";                                 if (srcInfo.FullName.IndexOf(srcBaseInfo.FullName' 0) != -1) {                                     dstRelFilePath = srcInfo.FullName.Substring(                                         srcBaseInfo.FullName.Length);                                 } else {                                     dstRelFilePath = srcInfo.Name;                                 }                                                              if (dstRelFilePath[0] == Path.DirectorySeparatorChar) {                                     dstRelFilePath = dstRelFilePath.Substring(1);                                 }                                                              // The full filepath to copy to.                                 dstFilePath = Path.Combine(ToDirectory.FullName'                                      dstRelFilePath);                             }                                                          // do the outdated check                             FileInfo dstInfo = new FileInfo(dstFilePath);                             bool outdated = (!dstInfo.Exists) || (srcInfo.LastWriteTime > dstInfo.LastWriteTime);                              if (Overwrite || outdated) {                                 // construct FileDateInfo for current file                                 FileDateInfo newFile = new FileDateInfo(srcInfo.FullName'                                      srcInfo.LastWriteTime);                                 // if multiple source files are selected to be copied                                  // to the same destination file' then only the last                                 // updated source should actually be copied                                 FileDateInfo oldFile = (FileDateInfo) FileCopyMap[dstInfo.FullName];                                 if (oldFile != null) {                                     // if current file was updated after scheduled file'                                     // then replace it                                     if (newFile.LastWriteTime > oldFile.LastWriteTime) {                                         FileCopyMap[dstInfo.FullName] = newFile;                                     }                                 } else {                                     FileCopyMap.Add(dstInfo.FullName' newFile);                                     _fileCount++;                                      if (dstInfo.Exists && dstInfo.Attributes != FileAttributes.Normal) {                                         File.SetAttributes(dstInfo.FullName' FileAttributes.Normal);                                     }                                 }                             }                         } else {                             throw CreateSourceFileNotFoundException (srcInfo.FullName);                         }                     }                                          if (IncludeEmptyDirs && !Flatten) {                         // create any specified directories that weren't created during the copy (ie: empty directories)                         foreach (string pathname in CopyFileSet.DirectoryNames) {                             DirectoryInfo srcInfo = new DirectoryInfo(pathname);                             // skip directory if not relative to base dir of fileset                             if (srcInfo.FullName.IndexOf(srcBaseInfo.FullName) == -1) {                                 continue;                             }                             string dstRelPath = srcInfo.FullName.Substring(srcBaseInfo.FullName.Length);                             if (dstRelPath.Length > 0 && dstRelPath[0] == Path.DirectorySeparatorChar) {                                 dstRelPath = dstRelPath.Substring(1);                             }                              // The full filepath to copy to.                             string destinationDirectory = Path.Combine(ToDirectory.FullName' dstRelPath);                             if (!Directory.Exists(destinationDirectory)) {                                 try {                                     Directory.CreateDirectory(destinationDirectory);                                 } catch (Exception ex) {                                     throw new BuildException(string.Format(CultureInfo.InvariantCulture'                                     "Failed to create directory '{0}'."' destinationDirectory )'                                       Location' ex);                                 }                                 Log(Level.Verbose' "Created directory '{0}'."' destinationDirectory);                             }                         }                     }                 }             }
Magic Number,NAnt.Core.Tasks,CopyTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\CopyTask.cs,ExecuteTask,The following statement contains a magic number: if (SourceFile != null)             {                 // copy a single file.                 if (SourceFile.Exists)                 {                     FileInfo dstInfo = null;                     if (ToFile != null)                      {                         dstInfo = ToFile;                     }                      else                      {                         string dstFilePath = Path.Combine(ToDirectory.FullName'                              SourceFile.Name);                         dstInfo = new FileInfo(dstFilePath);                     }                      // do the outdated check                     bool outdated = (!dstInfo.Exists) || (SourceFile.LastWriteTime > dstInfo.LastWriteTime);                      if (Overwrite || outdated)                      {                         // add to a copy map of absolute verified paths                         FileCopyMap.Add(dstInfo.FullName' new FileDateInfo(SourceFile.FullName' SourceFile.LastWriteTime));                         _fileCount++;                          if (dstInfo.Exists && dstInfo.Attributes != FileAttributes.Normal)                         {                             File.SetAttributes(dstInfo.FullName' FileAttributes.Normal);                         }                     }                 }                 // If SourceFile exists as a directory' proceed with moving the specified directory                 else if (!SourceFile.Exists && Directory.Exists(SourceFile.FullName))                 {                     // Stage the directory names                     string sourceDirName = SourceFile.FullName;                     string destDirName;                                          // If ToFile was specified' make sure the specified filename does not exist                     // as a file or a directory.                     if (ToFile != null)                     {                         if (ToFile.Exists)                         {                             throw new BuildException(String.Format(CultureInfo.InvariantCulture'                                 "Cannot move directory '{0}' to an existing file '{1}'"'                                  SourceFile.FullName' ToFile.FullName)' Location);                         }                         if (Directory.Exists(ToFile.FullName))                         {                             throw new BuildException(String.Format(CultureInfo.InvariantCulture'                                 "Cannot move directory '{0}' to an existing directory '{1}'"'                                 SourceFile.FullName' ToFile.FullName)' Location);                         }                         destDirName = ToFile.FullName;                     }                     // If ToDirectory was specified' make sure the specified directory does not                     // exist.                     else if (ToDirectory != null)                     {                         if (ToDirectory.Exists)                         {                             throw new BuildException(String.Format(CultureInfo.InvariantCulture'                                 "Cannot move directory '{0}' to an existing directory '{1}'"'                                 SourceFile.FullName' ToDirectory.FullName)' Location);                         }                         destDirName = ToDirectory.FullName;                     }                     // Else' throw an exception                     else                     {                         throw new BuildException("Target directory name not specified"'                             Location);                     }                     FileCopyMap.Add(destDirName' new FileDateInfo(sourceDirName' SourceFile.LastWriteTime' true));                     _dirCount++;                 }                 else                  {                     throw CreateSourceFileNotFoundException (SourceFile.FullName);                 }             }              // copy file set contents.             else             {                 // get the complete path of the base directory of the fileset' ie' c:\work\nant\src                 DirectoryInfo srcBaseInfo = CopyFileSet.BaseDirectory;                  // Check to see if the file operation is a straight pass through (ie: no file or                 // directory modifications) before proceeding.                 bool completeDir = true;                  // completeDir criteria                 bool[] dirCheck = new bool[8];                 dirCheck[0] = CopyFileSet.IsEverythingIncluded;                 dirCheck[1] = !Flatten;                 dirCheck[2] = IncludeEmptyDirs || !CopyFileSet.HasEmptyDirectories;                 dirCheck[3] = FilterChain.IsNullOrEmpty(Filters);                 dirCheck[4] = _inputEncoding == null;                 dirCheck[5] = _outputEncoding == null;                 dirCheck[6] = srcBaseInfo != null && srcBaseInfo.Exists;                 dirCheck[7] = !ToDirectory.Exists ||                     srcBaseInfo.FullName.Equals(ToDirectory.FullName'                         StringComparison.InvariantCultureIgnoreCase);                  for (int b = 0; b < dirCheck.Length; b++) completeDir &= dirCheck[b];                                      if (completeDir)                 {                     FileCopyMap.Add(ToDirectory.FullName'                          new FileDateInfo(srcBaseInfo.FullName' srcBaseInfo.LastWriteTime' true));                     _dirCount++;                 }                 else                 {                     // if source file not specified use fileset                     foreach (string pathname in CopyFileSet.FileNames)                      {                         FileInfo srcInfo = new FileInfo(pathname);                         if (srcInfo.Exists) {                             // will holds the full path to the destination file                             string dstFilePath;                              if (Flatten) {                                 dstFilePath = Path.Combine(ToDirectory.FullName'                                      srcInfo.Name);                             } else {                                 // Gets the relative path and file info from the full                                  // source filepath                                 // pathname = C:\f2\f3\file1' srcBaseInfo=C:\f2' then                                  // dstRelFilePath=f3\file1                                 string dstRelFilePath = "";                                 if (srcInfo.FullName.IndexOf(srcBaseInfo.FullName' 0) != -1) {                                     dstRelFilePath = srcInfo.FullName.Substring(                                         srcBaseInfo.FullName.Length);                                 } else {                                     dstRelFilePath = srcInfo.Name;                                 }                                                              if (dstRelFilePath[0] == Path.DirectorySeparatorChar) {                                     dstRelFilePath = dstRelFilePath.Substring(1);                                 }                                                              // The full filepath to copy to.                                 dstFilePath = Path.Combine(ToDirectory.FullName'                                      dstRelFilePath);                             }                                                          // do the outdated check                             FileInfo dstInfo = new FileInfo(dstFilePath);                             bool outdated = (!dstInfo.Exists) || (srcInfo.LastWriteTime > dstInfo.LastWriteTime);                              if (Overwrite || outdated) {                                 // construct FileDateInfo for current file                                 FileDateInfo newFile = new FileDateInfo(srcInfo.FullName'                                      srcInfo.LastWriteTime);                                 // if multiple source files are selected to be copied                                  // to the same destination file' then only the last                                 // updated source should actually be copied                                 FileDateInfo oldFile = (FileDateInfo) FileCopyMap[dstInfo.FullName];                                 if (oldFile != null) {                                     // if current file was updated after scheduled file'                                     // then replace it                                     if (newFile.LastWriteTime > oldFile.LastWriteTime) {                                         FileCopyMap[dstInfo.FullName] = newFile;                                     }                                 } else {                                     FileCopyMap.Add(dstInfo.FullName' newFile);                                     _fileCount++;                                      if (dstInfo.Exists && dstInfo.Attributes != FileAttributes.Normal) {                                         File.SetAttributes(dstInfo.FullName' FileAttributes.Normal);                                     }                                 }                             }                         } else {                             throw CreateSourceFileNotFoundException (srcInfo.FullName);                         }                     }                                          if (IncludeEmptyDirs && !Flatten) {                         // create any specified directories that weren't created during the copy (ie: empty directories)                         foreach (string pathname in CopyFileSet.DirectoryNames) {                             DirectoryInfo srcInfo = new DirectoryInfo(pathname);                             // skip directory if not relative to base dir of fileset                             if (srcInfo.FullName.IndexOf(srcBaseInfo.FullName) == -1) {                                 continue;                             }                             string dstRelPath = srcInfo.FullName.Substring(srcBaseInfo.FullName.Length);                             if (dstRelPath.Length > 0 && dstRelPath[0] == Path.DirectorySeparatorChar) {                                 dstRelPath = dstRelPath.Substring(1);                             }                              // The full filepath to copy to.                             string destinationDirectory = Path.Combine(ToDirectory.FullName' dstRelPath);                             if (!Directory.Exists(destinationDirectory)) {                                 try {                                     Directory.CreateDirectory(destinationDirectory);                                 } catch (Exception ex) {                                     throw new BuildException(string.Format(CultureInfo.InvariantCulture'                                     "Failed to create directory '{0}'."' destinationDirectory )'                                       Location' ex);                                 }                                 Log(Level.Verbose' "Created directory '{0}'."' destinationDirectory);                             }                         }                     }                 }             }
Magic Number,NAnt.Core.Tasks,CopyTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\CopyTask.cs,ExecuteTask,The following statement contains a magic number: if (SourceFile != null)             {                 // copy a single file.                 if (SourceFile.Exists)                 {                     FileInfo dstInfo = null;                     if (ToFile != null)                      {                         dstInfo = ToFile;                     }                      else                      {                         string dstFilePath = Path.Combine(ToDirectory.FullName'                              SourceFile.Name);                         dstInfo = new FileInfo(dstFilePath);                     }                      // do the outdated check                     bool outdated = (!dstInfo.Exists) || (SourceFile.LastWriteTime > dstInfo.LastWriteTime);                      if (Overwrite || outdated)                      {                         // add to a copy map of absolute verified paths                         FileCopyMap.Add(dstInfo.FullName' new FileDateInfo(SourceFile.FullName' SourceFile.LastWriteTime));                         _fileCount++;                          if (dstInfo.Exists && dstInfo.Attributes != FileAttributes.Normal)                         {                             File.SetAttributes(dstInfo.FullName' FileAttributes.Normal);                         }                     }                 }                 // If SourceFile exists as a directory' proceed with moving the specified directory                 else if (!SourceFile.Exists && Directory.Exists(SourceFile.FullName))                 {                     // Stage the directory names                     string sourceDirName = SourceFile.FullName;                     string destDirName;                                          // If ToFile was specified' make sure the specified filename does not exist                     // as a file or a directory.                     if (ToFile != null)                     {                         if (ToFile.Exists)                         {                             throw new BuildException(String.Format(CultureInfo.InvariantCulture'                                 "Cannot move directory '{0}' to an existing file '{1}'"'                                  SourceFile.FullName' ToFile.FullName)' Location);                         }                         if (Directory.Exists(ToFile.FullName))                         {                             throw new BuildException(String.Format(CultureInfo.InvariantCulture'                                 "Cannot move directory '{0}' to an existing directory '{1}'"'                                 SourceFile.FullName' ToFile.FullName)' Location);                         }                         destDirName = ToFile.FullName;                     }                     // If ToDirectory was specified' make sure the specified directory does not                     // exist.                     else if (ToDirectory != null)                     {                         if (ToDirectory.Exists)                         {                             throw new BuildException(String.Format(CultureInfo.InvariantCulture'                                 "Cannot move directory '{0}' to an existing directory '{1}'"'                                 SourceFile.FullName' ToDirectory.FullName)' Location);                         }                         destDirName = ToDirectory.FullName;                     }                     // Else' throw an exception                     else                     {                         throw new BuildException("Target directory name not specified"'                             Location);                     }                     FileCopyMap.Add(destDirName' new FileDateInfo(sourceDirName' SourceFile.LastWriteTime' true));                     _dirCount++;                 }                 else                  {                     throw CreateSourceFileNotFoundException (SourceFile.FullName);                 }             }              // copy file set contents.             else             {                 // get the complete path of the base directory of the fileset' ie' c:\work\nant\src                 DirectoryInfo srcBaseInfo = CopyFileSet.BaseDirectory;                  // Check to see if the file operation is a straight pass through (ie: no file or                 // directory modifications) before proceeding.                 bool completeDir = true;                  // completeDir criteria                 bool[] dirCheck = new bool[8];                 dirCheck[0] = CopyFileSet.IsEverythingIncluded;                 dirCheck[1] = !Flatten;                 dirCheck[2] = IncludeEmptyDirs || !CopyFileSet.HasEmptyDirectories;                 dirCheck[3] = FilterChain.IsNullOrEmpty(Filters);                 dirCheck[4] = _inputEncoding == null;                 dirCheck[5] = _outputEncoding == null;                 dirCheck[6] = srcBaseInfo != null && srcBaseInfo.Exists;                 dirCheck[7] = !ToDirectory.Exists ||                     srcBaseInfo.FullName.Equals(ToDirectory.FullName'                         StringComparison.InvariantCultureIgnoreCase);                  for (int b = 0; b < dirCheck.Length; b++) completeDir &= dirCheck[b];                                      if (completeDir)                 {                     FileCopyMap.Add(ToDirectory.FullName'                          new FileDateInfo(srcBaseInfo.FullName' srcBaseInfo.LastWriteTime' true));                     _dirCount++;                 }                 else                 {                     // if source file not specified use fileset                     foreach (string pathname in CopyFileSet.FileNames)                      {                         FileInfo srcInfo = new FileInfo(pathname);                         if (srcInfo.Exists) {                             // will holds the full path to the destination file                             string dstFilePath;                              if (Flatten) {                                 dstFilePath = Path.Combine(ToDirectory.FullName'                                      srcInfo.Name);                             } else {                                 // Gets the relative path and file info from the full                                  // source filepath                                 // pathname = C:\f2\f3\file1' srcBaseInfo=C:\f2' then                                  // dstRelFilePath=f3\file1                                 string dstRelFilePath = "";                                 if (srcInfo.FullName.IndexOf(srcBaseInfo.FullName' 0) != -1) {                                     dstRelFilePath = srcInfo.FullName.Substring(                                         srcBaseInfo.FullName.Length);                                 } else {                                     dstRelFilePath = srcInfo.Name;                                 }                                                              if (dstRelFilePath[0] == Path.DirectorySeparatorChar) {                                     dstRelFilePath = dstRelFilePath.Substring(1);                                 }                                                              // The full filepath to copy to.                                 dstFilePath = Path.Combine(ToDirectory.FullName'                                      dstRelFilePath);                             }                                                          // do the outdated check                             FileInfo dstInfo = new FileInfo(dstFilePath);                             bool outdated = (!dstInfo.Exists) || (srcInfo.LastWriteTime > dstInfo.LastWriteTime);                              if (Overwrite || outdated) {                                 // construct FileDateInfo for current file                                 FileDateInfo newFile = new FileDateInfo(srcInfo.FullName'                                      srcInfo.LastWriteTime);                                 // if multiple source files are selected to be copied                                  // to the same destination file' then only the last                                 // updated source should actually be copied                                 FileDateInfo oldFile = (FileDateInfo) FileCopyMap[dstInfo.FullName];                                 if (oldFile != null) {                                     // if current file was updated after scheduled file'                                     // then replace it                                     if (newFile.LastWriteTime > oldFile.LastWriteTime) {                                         FileCopyMap[dstInfo.FullName] = newFile;                                     }                                 } else {                                     FileCopyMap.Add(dstInfo.FullName' newFile);                                     _fileCount++;                                      if (dstInfo.Exists && dstInfo.Attributes != FileAttributes.Normal) {                                         File.SetAttributes(dstInfo.FullName' FileAttributes.Normal);                                     }                                 }                             }                         } else {                             throw CreateSourceFileNotFoundException (srcInfo.FullName);                         }                     }                                          if (IncludeEmptyDirs && !Flatten) {                         // create any specified directories that weren't created during the copy (ie: empty directories)                         foreach (string pathname in CopyFileSet.DirectoryNames) {                             DirectoryInfo srcInfo = new DirectoryInfo(pathname);                             // skip directory if not relative to base dir of fileset                             if (srcInfo.FullName.IndexOf(srcBaseInfo.FullName) == -1) {                                 continue;                             }                             string dstRelPath = srcInfo.FullName.Substring(srcBaseInfo.FullName.Length);                             if (dstRelPath.Length > 0 && dstRelPath[0] == Path.DirectorySeparatorChar) {                                 dstRelPath = dstRelPath.Substring(1);                             }                              // The full filepath to copy to.                             string destinationDirectory = Path.Combine(ToDirectory.FullName' dstRelPath);                             if (!Directory.Exists(destinationDirectory)) {                                 try {                                     Directory.CreateDirectory(destinationDirectory);                                 } catch (Exception ex) {                                     throw new BuildException(string.Format(CultureInfo.InvariantCulture'                                     "Failed to create directory '{0}'."' destinationDirectory )'                                       Location' ex);                                 }                                 Log(Level.Verbose' "Created directory '{0}'."' destinationDirectory);                             }                         }                     }                 }             }
Magic Number,NAnt.Core.Tasks,CopyTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\CopyTask.cs,ExecuteTask,The following statement contains a magic number: if (SourceFile != null)             {                 // copy a single file.                 if (SourceFile.Exists)                 {                     FileInfo dstInfo = null;                     if (ToFile != null)                      {                         dstInfo = ToFile;                     }                      else                      {                         string dstFilePath = Path.Combine(ToDirectory.FullName'                              SourceFile.Name);                         dstInfo = new FileInfo(dstFilePath);                     }                      // do the outdated check                     bool outdated = (!dstInfo.Exists) || (SourceFile.LastWriteTime > dstInfo.LastWriteTime);                      if (Overwrite || outdated)                      {                         // add to a copy map of absolute verified paths                         FileCopyMap.Add(dstInfo.FullName' new FileDateInfo(SourceFile.FullName' SourceFile.LastWriteTime));                         _fileCount++;                          if (dstInfo.Exists && dstInfo.Attributes != FileAttributes.Normal)                         {                             File.SetAttributes(dstInfo.FullName' FileAttributes.Normal);                         }                     }                 }                 // If SourceFile exists as a directory' proceed with moving the specified directory                 else if (!SourceFile.Exists && Directory.Exists(SourceFile.FullName))                 {                     // Stage the directory names                     string sourceDirName = SourceFile.FullName;                     string destDirName;                                          // If ToFile was specified' make sure the specified filename does not exist                     // as a file or a directory.                     if (ToFile != null)                     {                         if (ToFile.Exists)                         {                             throw new BuildException(String.Format(CultureInfo.InvariantCulture'                                 "Cannot move directory '{0}' to an existing file '{1}'"'                                  SourceFile.FullName' ToFile.FullName)' Location);                         }                         if (Directory.Exists(ToFile.FullName))                         {                             throw new BuildException(String.Format(CultureInfo.InvariantCulture'                                 "Cannot move directory '{0}' to an existing directory '{1}'"'                                 SourceFile.FullName' ToFile.FullName)' Location);                         }                         destDirName = ToFile.FullName;                     }                     // If ToDirectory was specified' make sure the specified directory does not                     // exist.                     else if (ToDirectory != null)                     {                         if (ToDirectory.Exists)                         {                             throw new BuildException(String.Format(CultureInfo.InvariantCulture'                                 "Cannot move directory '{0}' to an existing directory '{1}'"'                                 SourceFile.FullName' ToDirectory.FullName)' Location);                         }                         destDirName = ToDirectory.FullName;                     }                     // Else' throw an exception                     else                     {                         throw new BuildException("Target directory name not specified"'                             Location);                     }                     FileCopyMap.Add(destDirName' new FileDateInfo(sourceDirName' SourceFile.LastWriteTime' true));                     _dirCount++;                 }                 else                  {                     throw CreateSourceFileNotFoundException (SourceFile.FullName);                 }             }              // copy file set contents.             else             {                 // get the complete path of the base directory of the fileset' ie' c:\work\nant\src                 DirectoryInfo srcBaseInfo = CopyFileSet.BaseDirectory;                  // Check to see if the file operation is a straight pass through (ie: no file or                 // directory modifications) before proceeding.                 bool completeDir = true;                  // completeDir criteria                 bool[] dirCheck = new bool[8];                 dirCheck[0] = CopyFileSet.IsEverythingIncluded;                 dirCheck[1] = !Flatten;                 dirCheck[2] = IncludeEmptyDirs || !CopyFileSet.HasEmptyDirectories;                 dirCheck[3] = FilterChain.IsNullOrEmpty(Filters);                 dirCheck[4] = _inputEncoding == null;                 dirCheck[5] = _outputEncoding == null;                 dirCheck[6] = srcBaseInfo != null && srcBaseInfo.Exists;                 dirCheck[7] = !ToDirectory.Exists ||                     srcBaseInfo.FullName.Equals(ToDirectory.FullName'                         StringComparison.InvariantCultureIgnoreCase);                  for (int b = 0; b < dirCheck.Length; b++) completeDir &= dirCheck[b];                                      if (completeDir)                 {                     FileCopyMap.Add(ToDirectory.FullName'                          new FileDateInfo(srcBaseInfo.FullName' srcBaseInfo.LastWriteTime' true));                     _dirCount++;                 }                 else                 {                     // if source file not specified use fileset                     foreach (string pathname in CopyFileSet.FileNames)                      {                         FileInfo srcInfo = new FileInfo(pathname);                         if (srcInfo.Exists) {                             // will holds the full path to the destination file                             string dstFilePath;                              if (Flatten) {                                 dstFilePath = Path.Combine(ToDirectory.FullName'                                      srcInfo.Name);                             } else {                                 // Gets the relative path and file info from the full                                  // source filepath                                 // pathname = C:\f2\f3\file1' srcBaseInfo=C:\f2' then                                  // dstRelFilePath=f3\file1                                 string dstRelFilePath = "";                                 if (srcInfo.FullName.IndexOf(srcBaseInfo.FullName' 0) != -1) {                                     dstRelFilePath = srcInfo.FullName.Substring(                                         srcBaseInfo.FullName.Length);                                 } else {                                     dstRelFilePath = srcInfo.Name;                                 }                                                              if (dstRelFilePath[0] == Path.DirectorySeparatorChar) {                                     dstRelFilePath = dstRelFilePath.Substring(1);                                 }                                                              // The full filepath to copy to.                                 dstFilePath = Path.Combine(ToDirectory.FullName'                                      dstRelFilePath);                             }                                                          // do the outdated check                             FileInfo dstInfo = new FileInfo(dstFilePath);                             bool outdated = (!dstInfo.Exists) || (srcInfo.LastWriteTime > dstInfo.LastWriteTime);                              if (Overwrite || outdated) {                                 // construct FileDateInfo for current file                                 FileDateInfo newFile = new FileDateInfo(srcInfo.FullName'                                      srcInfo.LastWriteTime);                                 // if multiple source files are selected to be copied                                  // to the same destination file' then only the last                                 // updated source should actually be copied                                 FileDateInfo oldFile = (FileDateInfo) FileCopyMap[dstInfo.FullName];                                 if (oldFile != null) {                                     // if current file was updated after scheduled file'                                     // then replace it                                     if (newFile.LastWriteTime > oldFile.LastWriteTime) {                                         FileCopyMap[dstInfo.FullName] = newFile;                                     }                                 } else {                                     FileCopyMap.Add(dstInfo.FullName' newFile);                                     _fileCount++;                                      if (dstInfo.Exists && dstInfo.Attributes != FileAttributes.Normal) {                                         File.SetAttributes(dstInfo.FullName' FileAttributes.Normal);                                     }                                 }                             }                         } else {                             throw CreateSourceFileNotFoundException (srcInfo.FullName);                         }                     }                                          if (IncludeEmptyDirs && !Flatten) {                         // create any specified directories that weren't created during the copy (ie: empty directories)                         foreach (string pathname in CopyFileSet.DirectoryNames) {                             DirectoryInfo srcInfo = new DirectoryInfo(pathname);                             // skip directory if not relative to base dir of fileset                             if (srcInfo.FullName.IndexOf(srcBaseInfo.FullName) == -1) {                                 continue;                             }                             string dstRelPath = srcInfo.FullName.Substring(srcBaseInfo.FullName.Length);                             if (dstRelPath.Length > 0 && dstRelPath[0] == Path.DirectorySeparatorChar) {                                 dstRelPath = dstRelPath.Substring(1);                             }                              // The full filepath to copy to.                             string destinationDirectory = Path.Combine(ToDirectory.FullName' dstRelPath);                             if (!Directory.Exists(destinationDirectory)) {                                 try {                                     Directory.CreateDirectory(destinationDirectory);                                 } catch (Exception ex) {                                     throw new BuildException(string.Format(CultureInfo.InvariantCulture'                                     "Failed to create directory '{0}'."' destinationDirectory )'                                       Location' ex);                                 }                                 Log(Level.Verbose' "Created directory '{0}'."' destinationDirectory);                             }                         }                     }                 }             }
Magic Number,NAnt.Core.Tasks,CopyTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\CopyTask.cs,ExecuteTask,The following statement contains a magic number: if (SourceFile != null)             {                 // copy a single file.                 if (SourceFile.Exists)                 {                     FileInfo dstInfo = null;                     if (ToFile != null)                      {                         dstInfo = ToFile;                     }                      else                      {                         string dstFilePath = Path.Combine(ToDirectory.FullName'                              SourceFile.Name);                         dstInfo = new FileInfo(dstFilePath);                     }                      // do the outdated check                     bool outdated = (!dstInfo.Exists) || (SourceFile.LastWriteTime > dstInfo.LastWriteTime);                      if (Overwrite || outdated)                      {                         // add to a copy map of absolute verified paths                         FileCopyMap.Add(dstInfo.FullName' new FileDateInfo(SourceFile.FullName' SourceFile.LastWriteTime));                         _fileCount++;                          if (dstInfo.Exists && dstInfo.Attributes != FileAttributes.Normal)                         {                             File.SetAttributes(dstInfo.FullName' FileAttributes.Normal);                         }                     }                 }                 // If SourceFile exists as a directory' proceed with moving the specified directory                 else if (!SourceFile.Exists && Directory.Exists(SourceFile.FullName))                 {                     // Stage the directory names                     string sourceDirName = SourceFile.FullName;                     string destDirName;                                          // If ToFile was specified' make sure the specified filename does not exist                     // as a file or a directory.                     if (ToFile != null)                     {                         if (ToFile.Exists)                         {                             throw new BuildException(String.Format(CultureInfo.InvariantCulture'                                 "Cannot move directory '{0}' to an existing file '{1}'"'                                  SourceFile.FullName' ToFile.FullName)' Location);                         }                         if (Directory.Exists(ToFile.FullName))                         {                             throw new BuildException(String.Format(CultureInfo.InvariantCulture'                                 "Cannot move directory '{0}' to an existing directory '{1}'"'                                 SourceFile.FullName' ToFile.FullName)' Location);                         }                         destDirName = ToFile.FullName;                     }                     // If ToDirectory was specified' make sure the specified directory does not                     // exist.                     else if (ToDirectory != null)                     {                         if (ToDirectory.Exists)                         {                             throw new BuildException(String.Format(CultureInfo.InvariantCulture'                                 "Cannot move directory '{0}' to an existing directory '{1}'"'                                 SourceFile.FullName' ToDirectory.FullName)' Location);                         }                         destDirName = ToDirectory.FullName;                     }                     // Else' throw an exception                     else                     {                         throw new BuildException("Target directory name not specified"'                             Location);                     }                     FileCopyMap.Add(destDirName' new FileDateInfo(sourceDirName' SourceFile.LastWriteTime' true));                     _dirCount++;                 }                 else                  {                     throw CreateSourceFileNotFoundException (SourceFile.FullName);                 }             }              // copy file set contents.             else             {                 // get the complete path of the base directory of the fileset' ie' c:\work\nant\src                 DirectoryInfo srcBaseInfo = CopyFileSet.BaseDirectory;                  // Check to see if the file operation is a straight pass through (ie: no file or                 // directory modifications) before proceeding.                 bool completeDir = true;                  // completeDir criteria                 bool[] dirCheck = new bool[8];                 dirCheck[0] = CopyFileSet.IsEverythingIncluded;                 dirCheck[1] = !Flatten;                 dirCheck[2] = IncludeEmptyDirs || !CopyFileSet.HasEmptyDirectories;                 dirCheck[3] = FilterChain.IsNullOrEmpty(Filters);                 dirCheck[4] = _inputEncoding == null;                 dirCheck[5] = _outputEncoding == null;                 dirCheck[6] = srcBaseInfo != null && srcBaseInfo.Exists;                 dirCheck[7] = !ToDirectory.Exists ||                     srcBaseInfo.FullName.Equals(ToDirectory.FullName'                         StringComparison.InvariantCultureIgnoreCase);                  for (int b = 0; b < dirCheck.Length; b++) completeDir &= dirCheck[b];                                      if (completeDir)                 {                     FileCopyMap.Add(ToDirectory.FullName'                          new FileDateInfo(srcBaseInfo.FullName' srcBaseInfo.LastWriteTime' true));                     _dirCount++;                 }                 else                 {                     // if source file not specified use fileset                     foreach (string pathname in CopyFileSet.FileNames)                      {                         FileInfo srcInfo = new FileInfo(pathname);                         if (srcInfo.Exists) {                             // will holds the full path to the destination file                             string dstFilePath;                              if (Flatten) {                                 dstFilePath = Path.Combine(ToDirectory.FullName'                                      srcInfo.Name);                             } else {                                 // Gets the relative path and file info from the full                                  // source filepath                                 // pathname = C:\f2\f3\file1' srcBaseInfo=C:\f2' then                                  // dstRelFilePath=f3\file1                                 string dstRelFilePath = "";                                 if (srcInfo.FullName.IndexOf(srcBaseInfo.FullName' 0) != -1) {                                     dstRelFilePath = srcInfo.FullName.Substring(                                         srcBaseInfo.FullName.Length);                                 } else {                                     dstRelFilePath = srcInfo.Name;                                 }                                                              if (dstRelFilePath[0] == Path.DirectorySeparatorChar) {                                     dstRelFilePath = dstRelFilePath.Substring(1);                                 }                                                              // The full filepath to copy to.                                 dstFilePath = Path.Combine(ToDirectory.FullName'                                      dstRelFilePath);                             }                                                          // do the outdated check                             FileInfo dstInfo = new FileInfo(dstFilePath);                             bool outdated = (!dstInfo.Exists) || (srcInfo.LastWriteTime > dstInfo.LastWriteTime);                              if (Overwrite || outdated) {                                 // construct FileDateInfo for current file                                 FileDateInfo newFile = new FileDateInfo(srcInfo.FullName'                                      srcInfo.LastWriteTime);                                 // if multiple source files are selected to be copied                                  // to the same destination file' then only the last                                 // updated source should actually be copied                                 FileDateInfo oldFile = (FileDateInfo) FileCopyMap[dstInfo.FullName];                                 if (oldFile != null) {                                     // if current file was updated after scheduled file'                                     // then replace it                                     if (newFile.LastWriteTime > oldFile.LastWriteTime) {                                         FileCopyMap[dstInfo.FullName] = newFile;                                     }                                 } else {                                     FileCopyMap.Add(dstInfo.FullName' newFile);                                     _fileCount++;                                      if (dstInfo.Exists && dstInfo.Attributes != FileAttributes.Normal) {                                         File.SetAttributes(dstInfo.FullName' FileAttributes.Normal);                                     }                                 }                             }                         } else {                             throw CreateSourceFileNotFoundException (srcInfo.FullName);                         }                     }                                          if (IncludeEmptyDirs && !Flatten) {                         // create any specified directories that weren't created during the copy (ie: empty directories)                         foreach (string pathname in CopyFileSet.DirectoryNames) {                             DirectoryInfo srcInfo = new DirectoryInfo(pathname);                             // skip directory if not relative to base dir of fileset                             if (srcInfo.FullName.IndexOf(srcBaseInfo.FullName) == -1) {                                 continue;                             }                             string dstRelPath = srcInfo.FullName.Substring(srcBaseInfo.FullName.Length);                             if (dstRelPath.Length > 0 && dstRelPath[0] == Path.DirectorySeparatorChar) {                                 dstRelPath = dstRelPath.Substring(1);                             }                              // The full filepath to copy to.                             string destinationDirectory = Path.Combine(ToDirectory.FullName' dstRelPath);                             if (!Directory.Exists(destinationDirectory)) {                                 try {                                     Directory.CreateDirectory(destinationDirectory);                                 } catch (Exception ex) {                                     throw new BuildException(string.Format(CultureInfo.InvariantCulture'                                     "Failed to create directory '{0}'."' destinationDirectory )'                                       Location' ex);                                 }                                 Log(Level.Verbose' "Created directory '{0}'."' destinationDirectory);                             }                         }                     }                 }             }
Magic Number,NAnt.Core.Tasks,CopyTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\CopyTask.cs,ExecuteTask,The following statement contains a magic number: if (SourceFile != null)             {                 // copy a single file.                 if (SourceFile.Exists)                 {                     FileInfo dstInfo = null;                     if (ToFile != null)                      {                         dstInfo = ToFile;                     }                      else                      {                         string dstFilePath = Path.Combine(ToDirectory.FullName'                              SourceFile.Name);                         dstInfo = new FileInfo(dstFilePath);                     }                      // do the outdated check                     bool outdated = (!dstInfo.Exists) || (SourceFile.LastWriteTime > dstInfo.LastWriteTime);                      if (Overwrite || outdated)                      {                         // add to a copy map of absolute verified paths                         FileCopyMap.Add(dstInfo.FullName' new FileDateInfo(SourceFile.FullName' SourceFile.LastWriteTime));                         _fileCount++;                          if (dstInfo.Exists && dstInfo.Attributes != FileAttributes.Normal)                         {                             File.SetAttributes(dstInfo.FullName' FileAttributes.Normal);                         }                     }                 }                 // If SourceFile exists as a directory' proceed with moving the specified directory                 else if (!SourceFile.Exists && Directory.Exists(SourceFile.FullName))                 {                     // Stage the directory names                     string sourceDirName = SourceFile.FullName;                     string destDirName;                                          // If ToFile was specified' make sure the specified filename does not exist                     // as a file or a directory.                     if (ToFile != null)                     {                         if (ToFile.Exists)                         {                             throw new BuildException(String.Format(CultureInfo.InvariantCulture'                                 "Cannot move directory '{0}' to an existing file '{1}'"'                                  SourceFile.FullName' ToFile.FullName)' Location);                         }                         if (Directory.Exists(ToFile.FullName))                         {                             throw new BuildException(String.Format(CultureInfo.InvariantCulture'                                 "Cannot move directory '{0}' to an existing directory '{1}'"'                                 SourceFile.FullName' ToFile.FullName)' Location);                         }                         destDirName = ToFile.FullName;                     }                     // If ToDirectory was specified' make sure the specified directory does not                     // exist.                     else if (ToDirectory != null)                     {                         if (ToDirectory.Exists)                         {                             throw new BuildException(String.Format(CultureInfo.InvariantCulture'                                 "Cannot move directory '{0}' to an existing directory '{1}'"'                                 SourceFile.FullName' ToDirectory.FullName)' Location);                         }                         destDirName = ToDirectory.FullName;                     }                     // Else' throw an exception                     else                     {                         throw new BuildException("Target directory name not specified"'                             Location);                     }                     FileCopyMap.Add(destDirName' new FileDateInfo(sourceDirName' SourceFile.LastWriteTime' true));                     _dirCount++;                 }                 else                  {                     throw CreateSourceFileNotFoundException (SourceFile.FullName);                 }             }              // copy file set contents.             else             {                 // get the complete path of the base directory of the fileset' ie' c:\work\nant\src                 DirectoryInfo srcBaseInfo = CopyFileSet.BaseDirectory;                  // Check to see if the file operation is a straight pass through (ie: no file or                 // directory modifications) before proceeding.                 bool completeDir = true;                  // completeDir criteria                 bool[] dirCheck = new bool[8];                 dirCheck[0] = CopyFileSet.IsEverythingIncluded;                 dirCheck[1] = !Flatten;                 dirCheck[2] = IncludeEmptyDirs || !CopyFileSet.HasEmptyDirectories;                 dirCheck[3] = FilterChain.IsNullOrEmpty(Filters);                 dirCheck[4] = _inputEncoding == null;                 dirCheck[5] = _outputEncoding == null;                 dirCheck[6] = srcBaseInfo != null && srcBaseInfo.Exists;                 dirCheck[7] = !ToDirectory.Exists ||                     srcBaseInfo.FullName.Equals(ToDirectory.FullName'                         StringComparison.InvariantCultureIgnoreCase);                  for (int b = 0; b < dirCheck.Length; b++) completeDir &= dirCheck[b];                                      if (completeDir)                 {                     FileCopyMap.Add(ToDirectory.FullName'                          new FileDateInfo(srcBaseInfo.FullName' srcBaseInfo.LastWriteTime' true));                     _dirCount++;                 }                 else                 {                     // if source file not specified use fileset                     foreach (string pathname in CopyFileSet.FileNames)                      {                         FileInfo srcInfo = new FileInfo(pathname);                         if (srcInfo.Exists) {                             // will holds the full path to the destination file                             string dstFilePath;                              if (Flatten) {                                 dstFilePath = Path.Combine(ToDirectory.FullName'                                      srcInfo.Name);                             } else {                                 // Gets the relative path and file info from the full                                  // source filepath                                 // pathname = C:\f2\f3\file1' srcBaseInfo=C:\f2' then                                  // dstRelFilePath=f3\file1                                 string dstRelFilePath = "";                                 if (srcInfo.FullName.IndexOf(srcBaseInfo.FullName' 0) != -1) {                                     dstRelFilePath = srcInfo.FullName.Substring(                                         srcBaseInfo.FullName.Length);                                 } else {                                     dstRelFilePath = srcInfo.Name;                                 }                                                              if (dstRelFilePath[0] == Path.DirectorySeparatorChar) {                                     dstRelFilePath = dstRelFilePath.Substring(1);                                 }                                                              // The full filepath to copy to.                                 dstFilePath = Path.Combine(ToDirectory.FullName'                                      dstRelFilePath);                             }                                                          // do the outdated check                             FileInfo dstInfo = new FileInfo(dstFilePath);                             bool outdated = (!dstInfo.Exists) || (srcInfo.LastWriteTime > dstInfo.LastWriteTime);                              if (Overwrite || outdated) {                                 // construct FileDateInfo for current file                                 FileDateInfo newFile = new FileDateInfo(srcInfo.FullName'                                      srcInfo.LastWriteTime);                                 // if multiple source files are selected to be copied                                  // to the same destination file' then only the last                                 // updated source should actually be copied                                 FileDateInfo oldFile = (FileDateInfo) FileCopyMap[dstInfo.FullName];                                 if (oldFile != null) {                                     // if current file was updated after scheduled file'                                     // then replace it                                     if (newFile.LastWriteTime > oldFile.LastWriteTime) {                                         FileCopyMap[dstInfo.FullName] = newFile;                                     }                                 } else {                                     FileCopyMap.Add(dstInfo.FullName' newFile);                                     _fileCount++;                                      if (dstInfo.Exists && dstInfo.Attributes != FileAttributes.Normal) {                                         File.SetAttributes(dstInfo.FullName' FileAttributes.Normal);                                     }                                 }                             }                         } else {                             throw CreateSourceFileNotFoundException (srcInfo.FullName);                         }                     }                                          if (IncludeEmptyDirs && !Flatten) {                         // create any specified directories that weren't created during the copy (ie: empty directories)                         foreach (string pathname in CopyFileSet.DirectoryNames) {                             DirectoryInfo srcInfo = new DirectoryInfo(pathname);                             // skip directory if not relative to base dir of fileset                             if (srcInfo.FullName.IndexOf(srcBaseInfo.FullName) == -1) {                                 continue;                             }                             string dstRelPath = srcInfo.FullName.Substring(srcBaseInfo.FullName.Length);                             if (dstRelPath.Length > 0 && dstRelPath[0] == Path.DirectorySeparatorChar) {                                 dstRelPath = dstRelPath.Substring(1);                             }                              // The full filepath to copy to.                             string destinationDirectory = Path.Combine(ToDirectory.FullName' dstRelPath);                             if (!Directory.Exists(destinationDirectory)) {                                 try {                                     Directory.CreateDirectory(destinationDirectory);                                 } catch (Exception ex) {                                     throw new BuildException(string.Format(CultureInfo.InvariantCulture'                                     "Failed to create directory '{0}'."' destinationDirectory )'                                       Location' ex);                                 }                                 Log(Level.Verbose' "Created directory '{0}'."' destinationDirectory);                             }                         }                     }                 }             }
Magic Number,NAnt.Core.Tasks,CopyTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\CopyTask.cs,ExecuteTask,The following statement contains a magic number: if (SourceFile != null)             {                 // copy a single file.                 if (SourceFile.Exists)                 {                     FileInfo dstInfo = null;                     if (ToFile != null)                      {                         dstInfo = ToFile;                     }                      else                      {                         string dstFilePath = Path.Combine(ToDirectory.FullName'                              SourceFile.Name);                         dstInfo = new FileInfo(dstFilePath);                     }                      // do the outdated check                     bool outdated = (!dstInfo.Exists) || (SourceFile.LastWriteTime > dstInfo.LastWriteTime);                      if (Overwrite || outdated)                      {                         // add to a copy map of absolute verified paths                         FileCopyMap.Add(dstInfo.FullName' new FileDateInfo(SourceFile.FullName' SourceFile.LastWriteTime));                         _fileCount++;                          if (dstInfo.Exists && dstInfo.Attributes != FileAttributes.Normal)                         {                             File.SetAttributes(dstInfo.FullName' FileAttributes.Normal);                         }                     }                 }                 // If SourceFile exists as a directory' proceed with moving the specified directory                 else if (!SourceFile.Exists && Directory.Exists(SourceFile.FullName))                 {                     // Stage the directory names                     string sourceDirName = SourceFile.FullName;                     string destDirName;                                          // If ToFile was specified' make sure the specified filename does not exist                     // as a file or a directory.                     if (ToFile != null)                     {                         if (ToFile.Exists)                         {                             throw new BuildException(String.Format(CultureInfo.InvariantCulture'                                 "Cannot move directory '{0}' to an existing file '{1}'"'                                  SourceFile.FullName' ToFile.FullName)' Location);                         }                         if (Directory.Exists(ToFile.FullName))                         {                             throw new BuildException(String.Format(CultureInfo.InvariantCulture'                                 "Cannot move directory '{0}' to an existing directory '{1}'"'                                 SourceFile.FullName' ToFile.FullName)' Location);                         }                         destDirName = ToFile.FullName;                     }                     // If ToDirectory was specified' make sure the specified directory does not                     // exist.                     else if (ToDirectory != null)                     {                         if (ToDirectory.Exists)                         {                             throw new BuildException(String.Format(CultureInfo.InvariantCulture'                                 "Cannot move directory '{0}' to an existing directory '{1}'"'                                 SourceFile.FullName' ToDirectory.FullName)' Location);                         }                         destDirName = ToDirectory.FullName;                     }                     // Else' throw an exception                     else                     {                         throw new BuildException("Target directory name not specified"'                             Location);                     }                     FileCopyMap.Add(destDirName' new FileDateInfo(sourceDirName' SourceFile.LastWriteTime' true));                     _dirCount++;                 }                 else                  {                     throw CreateSourceFileNotFoundException (SourceFile.FullName);                 }             }              // copy file set contents.             else             {                 // get the complete path of the base directory of the fileset' ie' c:\work\nant\src                 DirectoryInfo srcBaseInfo = CopyFileSet.BaseDirectory;                  // Check to see if the file operation is a straight pass through (ie: no file or                 // directory modifications) before proceeding.                 bool completeDir = true;                  // completeDir criteria                 bool[] dirCheck = new bool[8];                 dirCheck[0] = CopyFileSet.IsEverythingIncluded;                 dirCheck[1] = !Flatten;                 dirCheck[2] = IncludeEmptyDirs || !CopyFileSet.HasEmptyDirectories;                 dirCheck[3] = FilterChain.IsNullOrEmpty(Filters);                 dirCheck[4] = _inputEncoding == null;                 dirCheck[5] = _outputEncoding == null;                 dirCheck[6] = srcBaseInfo != null && srcBaseInfo.Exists;                 dirCheck[7] = !ToDirectory.Exists ||                     srcBaseInfo.FullName.Equals(ToDirectory.FullName'                         StringComparison.InvariantCultureIgnoreCase);                  for (int b = 0; b < dirCheck.Length; b++) completeDir &= dirCheck[b];                                      if (completeDir)                 {                     FileCopyMap.Add(ToDirectory.FullName'                          new FileDateInfo(srcBaseInfo.FullName' srcBaseInfo.LastWriteTime' true));                     _dirCount++;                 }                 else                 {                     // if source file not specified use fileset                     foreach (string pathname in CopyFileSet.FileNames)                      {                         FileInfo srcInfo = new FileInfo(pathname);                         if (srcInfo.Exists) {                             // will holds the full path to the destination file                             string dstFilePath;                              if (Flatten) {                                 dstFilePath = Path.Combine(ToDirectory.FullName'                                      srcInfo.Name);                             } else {                                 // Gets the relative path and file info from the full                                  // source filepath                                 // pathname = C:\f2\f3\file1' srcBaseInfo=C:\f2' then                                  // dstRelFilePath=f3\file1                                 string dstRelFilePath = "";                                 if (srcInfo.FullName.IndexOf(srcBaseInfo.FullName' 0) != -1) {                                     dstRelFilePath = srcInfo.FullName.Substring(                                         srcBaseInfo.FullName.Length);                                 } else {                                     dstRelFilePath = srcInfo.Name;                                 }                                                              if (dstRelFilePath[0] == Path.DirectorySeparatorChar) {                                     dstRelFilePath = dstRelFilePath.Substring(1);                                 }                                                              // The full filepath to copy to.                                 dstFilePath = Path.Combine(ToDirectory.FullName'                                      dstRelFilePath);                             }                                                          // do the outdated check                             FileInfo dstInfo = new FileInfo(dstFilePath);                             bool outdated = (!dstInfo.Exists) || (srcInfo.LastWriteTime > dstInfo.LastWriteTime);                              if (Overwrite || outdated) {                                 // construct FileDateInfo for current file                                 FileDateInfo newFile = new FileDateInfo(srcInfo.FullName'                                      srcInfo.LastWriteTime);                                 // if multiple source files are selected to be copied                                  // to the same destination file' then only the last                                 // updated source should actually be copied                                 FileDateInfo oldFile = (FileDateInfo) FileCopyMap[dstInfo.FullName];                                 if (oldFile != null) {                                     // if current file was updated after scheduled file'                                     // then replace it                                     if (newFile.LastWriteTime > oldFile.LastWriteTime) {                                         FileCopyMap[dstInfo.FullName] = newFile;                                     }                                 } else {                                     FileCopyMap.Add(dstInfo.FullName' newFile);                                     _fileCount++;                                      if (dstInfo.Exists && dstInfo.Attributes != FileAttributes.Normal) {                                         File.SetAttributes(dstInfo.FullName' FileAttributes.Normal);                                     }                                 }                             }                         } else {                             throw CreateSourceFileNotFoundException (srcInfo.FullName);                         }                     }                                          if (IncludeEmptyDirs && !Flatten) {                         // create any specified directories that weren't created during the copy (ie: empty directories)                         foreach (string pathname in CopyFileSet.DirectoryNames) {                             DirectoryInfo srcInfo = new DirectoryInfo(pathname);                             // skip directory if not relative to base dir of fileset                             if (srcInfo.FullName.IndexOf(srcBaseInfo.FullName) == -1) {                                 continue;                             }                             string dstRelPath = srcInfo.FullName.Substring(srcBaseInfo.FullName.Length);                             if (dstRelPath.Length > 0 && dstRelPath[0] == Path.DirectorySeparatorChar) {                                 dstRelPath = dstRelPath.Substring(1);                             }                              // The full filepath to copy to.                             string destinationDirectory = Path.Combine(ToDirectory.FullName' dstRelPath);                             if (!Directory.Exists(destinationDirectory)) {                                 try {                                     Directory.CreateDirectory(destinationDirectory);                                 } catch (Exception ex) {                                     throw new BuildException(string.Format(CultureInfo.InvariantCulture'                                     "Failed to create directory '{0}'."' destinationDirectory )'                                       Location' ex);                                 }                                 Log(Level.Verbose' "Created directory '{0}'."' destinationDirectory);                             }                         }                     }                 }             }
Magic Number,NAnt.Core.Tasks,ExternalProgramBase,C:\repos\nant_nant\src\NAnt.Core\Tasks\ExternalProgramBase.cs,ExternalProgramBase,The following statement contains a magic number: const int defaultTimeout = 2000;
Magic Number,NAnt.Core.Tasks,GetTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\GetTask.cs,ExecuteTask,The following statement contains a magic number: try {                  //set the timestamp to the file date.                  DateTime fileTimeStamp = new DateTime();                    if (UseTimeStamp && DestinationFile.Exists) {                      fileTimeStamp = DestinationFile.LastWriteTime;                      Log(Level.Verbose' "Local file time stamp is {0}."'                           fileTimeStamp.ToString(CultureInfo.InvariantCulture));                  }                    //set up the URL connection                  WebRequest webRequest = GetWebRequest(Source' fileTimeStamp);                  WebResponse webResponse = webRequest.GetResponse();                    Stream responseStream = null;                    // Get stream                  // try three times' then error out                  int tryCount = 1;                    while (true) {                      try {                          responseStream = webResponse.GetResponseStream();                          break;                      } catch (IOException ex) {                          if (tryCount > 3) {                              throw new BuildException(string.Format(CultureInfo.InvariantCulture'                                   ResourceUtils.GetString("NA1125")' Source'                                   DestinationFile.FullName)' Location);                          } else {                              Log(Level.Warning' "Unable to open connection to '{0}' (try {1} of 3): " + ex.Message' Source' tryCount);                          }                      }                                        // increment try count                      tryCount++;                  }                    // open file for writing                  BinaryWriter destWriter = new BinaryWriter(new FileStream(                      DestinationFile.FullName' FileMode.Create));                                    Log(Level.Info' "Retrieving '{0}' to '{1}'."'                       Source' DestinationFile.FullName);                    // Read in stream from URL and write data in chunks                  // to the dest file.                  int bufferSize = 100 * 1024;                  byte[] buffer = new byte[bufferSize];                  int totalReadCount = 0;                  int totalBytesReadFromStream = 0;                  int totalBytesReadSinceLastDot = 0;                    do {                      totalReadCount = responseStream.Read(buffer' 0' bufferSize);                      if (totalReadCount != 0) { // zero means EOF                          // write buffer into file                          destWriter.Write(buffer' 0' totalReadCount);                          // increment byte counters                          totalBytesReadFromStream += totalReadCount;                          totalBytesReadSinceLastDot += totalReadCount;                          // display progress                          if (Verbose && totalBytesReadSinceLastDot > bufferSize) {                              if (totalBytesReadSinceLastDot == totalBytesReadFromStream) {                                  // TO-DO !!!!                                  //Log.Write(LogPrefix);                              }                              // TO-DO !!!                              //Log.Write(".");                              totalBytesReadSinceLastDot = 0;                          }                      }                  } while (totalReadCount != 0);                    if (totalBytesReadFromStream > bufferSize) {                      Log(Level.Verbose' "");                  }                  Log(Level.Verbose' "Number of bytes read: {0}."'                       totalBytesReadFromStream.ToString(CultureInfo.InvariantCulture));                    // clean up response streams                  destWriter.Close();                  responseStream.Close();                    // refresh file info                  DestinationFile.Refresh();                    // check to see if we actually have a file...                  if(!DestinationFile.Exists) {                      throw new BuildException(string.Format(CultureInfo.InvariantCulture'                           ResourceUtils.GetString("NA1125")' Source'                           DestinationFile.FullName)' Location);                  }                    // if (and only if) the use file time option is set' then the                  // saved file now has its timestamp set to that of the downloaded file                  if (UseTimeStamp)  {                      // HTTP only                      if (webRequest is HttpWebRequest) {                          HttpWebResponse httpResponse = (HttpWebResponse) webResponse;                            // get timestamp of remote file                          DateTime remoteTimestamp = httpResponse.LastModified;                            Log(Level.Verbose' "'{0}' last modified on {1}."'                               Source' remoteTimestamp.ToString(CultureInfo.InvariantCulture));                            // update timestamp of local file to match that of the                           // remote file                          TouchFile(DestinationFile' remoteTimestamp);                      }                  }              } catch (BuildException) {                  // re-throw the exception                  throw;              } catch (WebException ex) {                  // If status is WebExceptionStatus.ProtocolError'                  //   there has been a protocol error and a WebResponse                  //   should exist. Display the protocol error.                  if (ex.Status == WebExceptionStatus.ProtocolError) {                      // test for a 304 result (HTTP only)                      // Get HttpWebResponse so we can check the HTTP status code                      HttpWebResponse httpResponse = (HttpWebResponse) ex.Response;                      if (httpResponse.StatusCode == HttpStatusCode.NotModified) {                          //not modified so no file download. just return instead                          //and trace out something so the user doesn't think that the                          //download happened when it didn't                            Log(Level.Verbose' "'{0}' not downloaded.  Not modified since {1}."'                               Source' DestinationFile.LastWriteTime.ToString(CultureInfo.InvariantCulture));                          return;                      } else {                          throw new BuildException(string.Format(CultureInfo.InvariantCulture'                               ResourceUtils.GetString("NA1125")' Source'                               DestinationFile.FullName)' Location' ex);                      }                  } else {                      throw new BuildException(string.Format(CultureInfo.InvariantCulture'                           ResourceUtils.GetString("NA1125")' Source' DestinationFile.FullName)'                           Location' ex);                  }              } catch (Exception ex) {                  throw new BuildException(string.Format(CultureInfo.InvariantCulture'                       ResourceUtils.GetString("NA1125")' Source' DestinationFile.FullName)'                       Location' ex);              }
Magic Number,NAnt.Core.Tasks,GetTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\GetTask.cs,ExecuteTask,The following statement contains a magic number: try {                  //set the timestamp to the file date.                  DateTime fileTimeStamp = new DateTime();                    if (UseTimeStamp && DestinationFile.Exists) {                      fileTimeStamp = DestinationFile.LastWriteTime;                      Log(Level.Verbose' "Local file time stamp is {0}."'                           fileTimeStamp.ToString(CultureInfo.InvariantCulture));                  }                    //set up the URL connection                  WebRequest webRequest = GetWebRequest(Source' fileTimeStamp);                  WebResponse webResponse = webRequest.GetResponse();                    Stream responseStream = null;                    // Get stream                  // try three times' then error out                  int tryCount = 1;                    while (true) {                      try {                          responseStream = webResponse.GetResponseStream();                          break;                      } catch (IOException ex) {                          if (tryCount > 3) {                              throw new BuildException(string.Format(CultureInfo.InvariantCulture'                                   ResourceUtils.GetString("NA1125")' Source'                                   DestinationFile.FullName)' Location);                          } else {                              Log(Level.Warning' "Unable to open connection to '{0}' (try {1} of 3): " + ex.Message' Source' tryCount);                          }                      }                                        // increment try count                      tryCount++;                  }                    // open file for writing                  BinaryWriter destWriter = new BinaryWriter(new FileStream(                      DestinationFile.FullName' FileMode.Create));                                    Log(Level.Info' "Retrieving '{0}' to '{1}'."'                       Source' DestinationFile.FullName);                    // Read in stream from URL and write data in chunks                  // to the dest file.                  int bufferSize = 100 * 1024;                  byte[] buffer = new byte[bufferSize];                  int totalReadCount = 0;                  int totalBytesReadFromStream = 0;                  int totalBytesReadSinceLastDot = 0;                    do {                      totalReadCount = responseStream.Read(buffer' 0' bufferSize);                      if (totalReadCount != 0) { // zero means EOF                          // write buffer into file                          destWriter.Write(buffer' 0' totalReadCount);                          // increment byte counters                          totalBytesReadFromStream += totalReadCount;                          totalBytesReadSinceLastDot += totalReadCount;                          // display progress                          if (Verbose && totalBytesReadSinceLastDot > bufferSize) {                              if (totalBytesReadSinceLastDot == totalBytesReadFromStream) {                                  // TO-DO !!!!                                  //Log.Write(LogPrefix);                              }                              // TO-DO !!!                              //Log.Write(".");                              totalBytesReadSinceLastDot = 0;                          }                      }                  } while (totalReadCount != 0);                    if (totalBytesReadFromStream > bufferSize) {                      Log(Level.Verbose' "");                  }                  Log(Level.Verbose' "Number of bytes read: {0}."'                       totalBytesReadFromStream.ToString(CultureInfo.InvariantCulture));                    // clean up response streams                  destWriter.Close();                  responseStream.Close();                    // refresh file info                  DestinationFile.Refresh();                    // check to see if we actually have a file...                  if(!DestinationFile.Exists) {                      throw new BuildException(string.Format(CultureInfo.InvariantCulture'                           ResourceUtils.GetString("NA1125")' Source'                           DestinationFile.FullName)' Location);                  }                    // if (and only if) the use file time option is set' then the                  // saved file now has its timestamp set to that of the downloaded file                  if (UseTimeStamp)  {                      // HTTP only                      if (webRequest is HttpWebRequest) {                          HttpWebResponse httpResponse = (HttpWebResponse) webResponse;                            // get timestamp of remote file                          DateTime remoteTimestamp = httpResponse.LastModified;                            Log(Level.Verbose' "'{0}' last modified on {1}."'                               Source' remoteTimestamp.ToString(CultureInfo.InvariantCulture));                            // update timestamp of local file to match that of the                           // remote file                          TouchFile(DestinationFile' remoteTimestamp);                      }                  }              } catch (BuildException) {                  // re-throw the exception                  throw;              } catch (WebException ex) {                  // If status is WebExceptionStatus.ProtocolError'                  //   there has been a protocol error and a WebResponse                  //   should exist. Display the protocol error.                  if (ex.Status == WebExceptionStatus.ProtocolError) {                      // test for a 304 result (HTTP only)                      // Get HttpWebResponse so we can check the HTTP status code                      HttpWebResponse httpResponse = (HttpWebResponse) ex.Response;                      if (httpResponse.StatusCode == HttpStatusCode.NotModified) {                          //not modified so no file download. just return instead                          //and trace out something so the user doesn't think that the                          //download happened when it didn't                            Log(Level.Verbose' "'{0}' not downloaded.  Not modified since {1}."'                               Source' DestinationFile.LastWriteTime.ToString(CultureInfo.InvariantCulture));                          return;                      } else {                          throw new BuildException(string.Format(CultureInfo.InvariantCulture'                               ResourceUtils.GetString("NA1125")' Source'                               DestinationFile.FullName)' Location' ex);                      }                  } else {                      throw new BuildException(string.Format(CultureInfo.InvariantCulture'                           ResourceUtils.GetString("NA1125")' Source' DestinationFile.FullName)'                           Location' ex);                  }              } catch (Exception ex) {                  throw new BuildException(string.Format(CultureInfo.InvariantCulture'                       ResourceUtils.GetString("NA1125")' Source' DestinationFile.FullName)'                       Location' ex);              }
Magic Number,NAnt.Core.Tasks,GetTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\GetTask.cs,ExecuteTask,The following statement contains a magic number: try {                  //set the timestamp to the file date.                  DateTime fileTimeStamp = new DateTime();                    if (UseTimeStamp && DestinationFile.Exists) {                      fileTimeStamp = DestinationFile.LastWriteTime;                      Log(Level.Verbose' "Local file time stamp is {0}."'                           fileTimeStamp.ToString(CultureInfo.InvariantCulture));                  }                    //set up the URL connection                  WebRequest webRequest = GetWebRequest(Source' fileTimeStamp);                  WebResponse webResponse = webRequest.GetResponse();                    Stream responseStream = null;                    // Get stream                  // try three times' then error out                  int tryCount = 1;                    while (true) {                      try {                          responseStream = webResponse.GetResponseStream();                          break;                      } catch (IOException ex) {                          if (tryCount > 3) {                              throw new BuildException(string.Format(CultureInfo.InvariantCulture'                                   ResourceUtils.GetString("NA1125")' Source'                                   DestinationFile.FullName)' Location);                          } else {                              Log(Level.Warning' "Unable to open connection to '{0}' (try {1} of 3): " + ex.Message' Source' tryCount);                          }                      }                                        // increment try count                      tryCount++;                  }                    // open file for writing                  BinaryWriter destWriter = new BinaryWriter(new FileStream(                      DestinationFile.FullName' FileMode.Create));                                    Log(Level.Info' "Retrieving '{0}' to '{1}'."'                       Source' DestinationFile.FullName);                    // Read in stream from URL and write data in chunks                  // to the dest file.                  int bufferSize = 100 * 1024;                  byte[] buffer = new byte[bufferSize];                  int totalReadCount = 0;                  int totalBytesReadFromStream = 0;                  int totalBytesReadSinceLastDot = 0;                    do {                      totalReadCount = responseStream.Read(buffer' 0' bufferSize);                      if (totalReadCount != 0) { // zero means EOF                          // write buffer into file                          destWriter.Write(buffer' 0' totalReadCount);                          // increment byte counters                          totalBytesReadFromStream += totalReadCount;                          totalBytesReadSinceLastDot += totalReadCount;                          // display progress                          if (Verbose && totalBytesReadSinceLastDot > bufferSize) {                              if (totalBytesReadSinceLastDot == totalBytesReadFromStream) {                                  // TO-DO !!!!                                  //Log.Write(LogPrefix);                              }                              // TO-DO !!!                              //Log.Write(".");                              totalBytesReadSinceLastDot = 0;                          }                      }                  } while (totalReadCount != 0);                    if (totalBytesReadFromStream > bufferSize) {                      Log(Level.Verbose' "");                  }                  Log(Level.Verbose' "Number of bytes read: {0}."'                       totalBytesReadFromStream.ToString(CultureInfo.InvariantCulture));                    // clean up response streams                  destWriter.Close();                  responseStream.Close();                    // refresh file info                  DestinationFile.Refresh();                    // check to see if we actually have a file...                  if(!DestinationFile.Exists) {                      throw new BuildException(string.Format(CultureInfo.InvariantCulture'                           ResourceUtils.GetString("NA1125")' Source'                           DestinationFile.FullName)' Location);                  }                    // if (and only if) the use file time option is set' then the                  // saved file now has its timestamp set to that of the downloaded file                  if (UseTimeStamp)  {                      // HTTP only                      if (webRequest is HttpWebRequest) {                          HttpWebResponse httpResponse = (HttpWebResponse) webResponse;                            // get timestamp of remote file                          DateTime remoteTimestamp = httpResponse.LastModified;                            Log(Level.Verbose' "'{0}' last modified on {1}."'                               Source' remoteTimestamp.ToString(CultureInfo.InvariantCulture));                            // update timestamp of local file to match that of the                           // remote file                          TouchFile(DestinationFile' remoteTimestamp);                      }                  }              } catch (BuildException) {                  // re-throw the exception                  throw;              } catch (WebException ex) {                  // If status is WebExceptionStatus.ProtocolError'                  //   there has been a protocol error and a WebResponse                  //   should exist. Display the protocol error.                  if (ex.Status == WebExceptionStatus.ProtocolError) {                      // test for a 304 result (HTTP only)                      // Get HttpWebResponse so we can check the HTTP status code                      HttpWebResponse httpResponse = (HttpWebResponse) ex.Response;                      if (httpResponse.StatusCode == HttpStatusCode.NotModified) {                          //not modified so no file download. just return instead                          //and trace out something so the user doesn't think that the                          //download happened when it didn't                            Log(Level.Verbose' "'{0}' not downloaded.  Not modified since {1}."'                               Source' DestinationFile.LastWriteTime.ToString(CultureInfo.InvariantCulture));                          return;                      } else {                          throw new BuildException(string.Format(CultureInfo.InvariantCulture'                               ResourceUtils.GetString("NA1125")' Source'                               DestinationFile.FullName)' Location' ex);                      }                  } else {                      throw new BuildException(string.Format(CultureInfo.InvariantCulture'                           ResourceUtils.GetString("NA1125")' Source' DestinationFile.FullName)'                           Location' ex);                  }              } catch (Exception ex) {                  throw new BuildException(string.Format(CultureInfo.InvariantCulture'                       ResourceUtils.GetString("NA1125")' Source' DestinationFile.FullName)'                       Location' ex);              }
Magic Number,NAnt.Core.Tasks,NAntSchemaTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\NAntSchemaTask.cs,ExecuteTask,The following statement contains a magic number: using (FileStream file = File.Open(OutputFile.FullName' FileMode.Create' FileAccess.Write' FileShare.Read)) {                  byte[] buffer = new byte[4096];                  int bytesRead = ms.Read(buffer' 0' buffer.Length);                  while (bytesRead != 0) {                      file.Write(buffer' 0' bytesRead);                      bytesRead = ms.Read(buffer' 0' buffer.Length);                  }                  file.Flush();                  file.Close();              }
Magic Number,NAnt.Core.Tasks,NAntSchemaGenerator,C:\repos\nant_nant\src\NAnt.Core\Tasks\NAntSchemaTask.cs,NAntSchemaGenerator,The following statement contains a magic number: ArrayList taskContainerComplexTypes = new ArrayList(4);
Magic Number,NAnt.Core.Tasks,SleepTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\SleepTask.cs,GetSleepTime,The following statement contains a magic number: return ((((int) Hours * 60) + Minutes) * 60 + Seconds) * 1000 + Milliseconds;
Magic Number,NAnt.Core.Tasks,SleepTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\SleepTask.cs,GetSleepTime,The following statement contains a magic number: return ((((int) Hours * 60) + Minutes) * 60 + Seconds) * 1000 + Milliseconds;
Magic Number,NAnt.Core.Tasks,SleepTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\SleepTask.cs,GetSleepTime,The following statement contains a magic number: return ((((int) Hours * 60) + Minutes) * 60 + Seconds) * 1000 + Milliseconds;
Magic Number,NAnt.Core.Util,CommandLineArgument,C:\repos\nant_nant\src\NAnt.Core\Util\CommandLineArgument.cs,Finish,The following statement contains a magic number: if (IsArray) {                 _propertyInfo.SetValue(destination' _collectionValues.ToArray(_elementType)' BindingFlags.Default' null' null' CultureInfo.InvariantCulture);             } else if (IsCollection) {                 // If value of property is null' create new instance of collection                  if (_propertyInfo.GetValue(destination' BindingFlags.Default' null' null' CultureInfo.InvariantCulture) == null) {                     if (!_propertyInfo.CanWrite) {                         throw new NotSupportedException(string.Format(CultureInfo.InvariantCulture'                              ResourceUtils.GetString("NA1171")                              + " but is not initialized and does not allow the"                             + "collection to be initialized."' LongName));                     }                     object instance = Activator.CreateInstance(_propertyInfo.PropertyType' BindingFlags.Public | BindingFlags.Instance' null' null' CultureInfo.InvariantCulture);                     _propertyInfo.SetValue(destination' instance' BindingFlags.Default' null' null' CultureInfo.InvariantCulture);                 }                                  object value = _propertyInfo.GetValue(destination'                      BindingFlags.Default' null' null' CultureInfo.InvariantCulture);                                   MethodInfo addMethod = null;                  // Locate Add method with 1 parameter                 foreach (MethodInfo method in value.GetType().GetMethods(BindingFlags.Public | BindingFlags.Instance)) {                     if (method.Name == "Add" && method.GetParameters().Length == 1) {                         ParameterInfo parameter = method.GetParameters()[0];                         if (parameter.ParameterType != typeof(object)) {                             addMethod = method;                             break;                         }                     }                 }                  if (addMethod == null) {                     throw new NotSupportedException(string.Format(CultureInfo.InvariantCulture' ResourceUtils.GetString("NA1169")' LongName));                 } else {                     try {                         foreach (object item in _collectionValues) {                             addMethod.Invoke(value' BindingFlags.Default' null' new object[] {item}' CultureInfo.InvariantCulture);                         }                     } catch (Exception ex) {                         throw new NotSupportedException(string.Format(CultureInfo.InvariantCulture'                              ResourceUtils.GetString("NA1173")'                             LongName)' ex);                     }                 }             } else if (IsNameValueCollection) {                 // If value of property is null' create new instance of collection                  if (_propertyInfo.GetValue(destination' BindingFlags.Default' null' null' CultureInfo.InvariantCulture) == null) {                     if (!_propertyInfo.CanWrite) {                         throw new NotSupportedException(string.Format(CultureInfo.InvariantCulture'                              ResourceUtils.GetString("NA1171")                              + " but is not initialized and does not allow the"                             + "collection to be initialized."' LongName));                     }                     object instance = Activator.CreateInstance(_propertyInfo.PropertyType' BindingFlags.Public | BindingFlags.Instance' null' null' CultureInfo.InvariantCulture);                     _propertyInfo.SetValue(destination' instance' BindingFlags.Default' null' null' CultureInfo.InvariantCulture);                 }                                  object value = _propertyInfo.GetValue(destination'                      BindingFlags.Default' null' null' CultureInfo.InvariantCulture);                                   MethodInfo addMethod = null;                  // Locate Add method with 2 string parameters                 foreach (MethodInfo method in value.GetType().GetMethods(BindingFlags.Public | BindingFlags.Instance)) {                     if (method.Name == "Add" && method.GetParameters().Length == 2) {                         if (method.GetParameters()[0].ParameterType == typeof(string) &&                             method.GetParameters()[1].ParameterType == typeof(string)) {                             addMethod = method;                             break;                         }                     }                 }                  if (addMethod == null) {                     throw new NotSupportedException(string.Format(CultureInfo.InvariantCulture'                          ResourceUtils.GetString("NA1169")' LongName));                 } else {                     try {                         foreach (string key in _valuePairs) {                             addMethod.Invoke(value' BindingFlags.Default' null'                                 new object[] {key' _valuePairs.Get(key)}'                                  CultureInfo.InvariantCulture);                         }                     } catch (Exception ex) {                         throw new NotSupportedException(string.Format(CultureInfo.InvariantCulture'                              ResourceUtils.GetString("NA1173")'                             LongName)' ex);                     }                 }             } else {                 // this fails on mono if the _argumentValue is null                 if (_argumentValue != null) {                     _propertyInfo.SetValue(destination' _argumentValue' BindingFlags.Default' null' null' CultureInfo.InvariantCulture);                 }             }
Magic Number,NAnt.Core.Util,CommandLineArgument,C:\repos\nant_nant\src\NAnt.Core\Util\CommandLineArgument.cs,ParseValue,The following statement contains a magic number: if ((stringData != null || type == typeof(bool)) && (stringData == null || stringData.Length > 0)) {                 try {                     if (type == typeof(string)) {                         return stringData;                     } else if (type == typeof(bool)) {                         if (stringData == null || stringData == "+") {                             return true;                         } else if (stringData == "-") {                             return false;                         }                     } else if (IsNameValueCollectionType(type)) {                         Match match = Regex.Match(stringData' @"(\w+[^=]*)=(\w*.*)");                         if (match.Success) {                             string name = match.Groups[1].Value;                             string value = match.Groups[2].Value;                              if (Unique && _valuePairs.Get(name) != null) {                                 // we always assume we're dealing with properties                                 // here to make the message more clear                                 throw new CommandLineArgumentException(string.Format(CultureInfo.InvariantCulture'                                      ResourceUtils.GetString("NA1174")'                                      name' LongName));                             }                             _valuePairs.Add(name' value);                             return _valuePairs;                         } else {                             throw new CommandLineArgumentException(string.Format(CultureInfo.InvariantCulture'                                  ResourceUtils.GetString("NA1170")'                                  stringData' LongName)' new ArgumentException(                                 "Expected name/value pair (<name>=<value>)."));                         }                     } else {                         if (type.IsEnum) {                             try {                                 return Enum.Parse(type' stringData' true);                             } catch(ArgumentException ex) {                                 string message = "Invalid value {0} for command-line argument '-{1}'. Valid values are: ";                                 foreach (object value in Enum.GetValues(type)) {                                     message += value.ToString() + "' ";                                 }                                 // strip last '                                 message = message.Substring(0' message.Length - 2) + ".";                                 throw new CommandLineArgumentException(string.Format(CultureInfo.InvariantCulture'                                      message' stringData' LongName)' ex);                             }                         } else {                             // Make a guess that the there's a public static Parse method on the type of the property                             // that will take an argument of type string to convert the string to the type                              // required by the property.                             System.Reflection.MethodInfo parseMethod = type.GetMethod(                                 "Parse"' BindingFlags.Public | BindingFlags.Static'                                  null' CallingConventions.Standard' new Type[] {typeof(string)}'                                  null);                              if (parseMethod != null) {                                 // Call the Parse method                                 return parseMethod.Invoke(null' BindingFlags.Default'                                      null' new object[] {stringData}' CultureInfo.InvariantCulture);                             } else if (type.IsClass) {                                 // Search for a constructor that takes a string argument                                 ConstructorInfo stringArgumentConstructor =                                      type.GetConstructor(new Type[] {typeof(string)});                                  if (stringArgumentConstructor != null) {                                     return stringArgumentConstructor.Invoke(                                         BindingFlags.Default' null' new object[] {stringData}'                                          CultureInfo.InvariantCulture);                                 }                             }                         }                     }                 } catch (CommandLineArgumentException) {                     throw;                 } catch (Exception ex) {                     throw new CommandLineArgumentException(string.Format(CultureInfo.InvariantCulture'                          ResourceUtils.GetString("NA1170")'                          stringData' LongName)' ex);                 }             }
Magic Number,NAnt.Core.Util,CommandLineArgument,C:\repos\nant_nant\src\NAnt.Core\Util\CommandLineArgument.cs,ParseValue,The following statement contains a magic number: if ((stringData != null || type == typeof(bool)) && (stringData == null || stringData.Length > 0)) {                 try {                     if (type == typeof(string)) {                         return stringData;                     } else if (type == typeof(bool)) {                         if (stringData == null || stringData == "+") {                             return true;                         } else if (stringData == "-") {                             return false;                         }                     } else if (IsNameValueCollectionType(type)) {                         Match match = Regex.Match(stringData' @"(\w+[^=]*)=(\w*.*)");                         if (match.Success) {                             string name = match.Groups[1].Value;                             string value = match.Groups[2].Value;                              if (Unique && _valuePairs.Get(name) != null) {                                 // we always assume we're dealing with properties                                 // here to make the message more clear                                 throw new CommandLineArgumentException(string.Format(CultureInfo.InvariantCulture'                                      ResourceUtils.GetString("NA1174")'                                      name' LongName));                             }                             _valuePairs.Add(name' value);                             return _valuePairs;                         } else {                             throw new CommandLineArgumentException(string.Format(CultureInfo.InvariantCulture'                                  ResourceUtils.GetString("NA1170")'                                  stringData' LongName)' new ArgumentException(                                 "Expected name/value pair (<name>=<value>)."));                         }                     } else {                         if (type.IsEnum) {                             try {                                 return Enum.Parse(type' stringData' true);                             } catch(ArgumentException ex) {                                 string message = "Invalid value {0} for command-line argument '-{1}'. Valid values are: ";                                 foreach (object value in Enum.GetValues(type)) {                                     message += value.ToString() + "' ";                                 }                                 // strip last '                                 message = message.Substring(0' message.Length - 2) + ".";                                 throw new CommandLineArgumentException(string.Format(CultureInfo.InvariantCulture'                                      message' stringData' LongName)' ex);                             }                         } else {                             // Make a guess that the there's a public static Parse method on the type of the property                             // that will take an argument of type string to convert the string to the type                              // required by the property.                             System.Reflection.MethodInfo parseMethod = type.GetMethod(                                 "Parse"' BindingFlags.Public | BindingFlags.Static'                                  null' CallingConventions.Standard' new Type[] {typeof(string)}'                                  null);                              if (parseMethod != null) {                                 // Call the Parse method                                 return parseMethod.Invoke(null' BindingFlags.Default'                                      null' new object[] {stringData}' CultureInfo.InvariantCulture);                             } else if (type.IsClass) {                                 // Search for a constructor that takes a string argument                                 ConstructorInfo stringArgumentConstructor =                                      type.GetConstructor(new Type[] {typeof(string)});                                  if (stringArgumentConstructor != null) {                                     return stringArgumentConstructor.Invoke(                                         BindingFlags.Default' null' new object[] {stringData}'                                          CultureInfo.InvariantCulture);                                 }                             }                         }                     }                 } catch (CommandLineArgumentException) {                     throw;                 } catch (Exception ex) {                     throw new CommandLineArgumentException(string.Format(CultureInfo.InvariantCulture'                          ResourceUtils.GetString("NA1170")'                          stringData' LongName)' ex);                 }             }
Magic Number,NAnt.Core.Util,CommandLineParser,C:\repos\nant_nant\src\NAnt.Core\Util\CommandLineParser.cs,ParseArgumentList,The following statement contains a magic number: foreach (string argument in args) {                  if (argument.Length == 0) {                      continue;                  }                  switch (argument[0]) {                      case '-':                      case '/':                          int endIndex = argument.IndexOfAny(new char[] {':'' '+'' '-'}' 1);                          string option = argument.Substring(1' endIndex == -1 ? argument.Length - 1 : endIndex - 1);                          string optionArgument;                            if (option.Length + 1 == argument.Length) {                              optionArgument = null;                          } else if (argument.Length > 1 + option.Length && argument[1 + option.Length] == ':') {                              optionArgument = argument.Substring(option.Length + 2);                          } else {                              optionArgument = argument.Substring(option.Length + 1);                          }                                                    CommandLineArgument arg = _argumentCollection[option];                          if (arg == null) {                              throw new CommandLineArgumentException(string.Format(CultureInfo.InvariantCulture'                                  "Unknown argument '{0}'"' argument));                          } else {                              // check if argument is obsolete                              Attribute[] attribs = (Attribute[]) arg.Property.GetCustomAttributes(                                  typeof(ObsoleteAttribute)' false);                              if (attribs.Length > 0) {                                  ObsoleteAttribute obsoleteAttrib = (ObsoleteAttribute) attribs[0];                                  string message = string.Format(CultureInfo.InvariantCulture'                                       ResourceUtils.GetString("NA1177")' option'                                       obsoleteAttrib.Message);                                  if (obsoleteAttrib.IsError) {                                      throw new CommandLineArgumentException(message);                                  } else {                                      Console.WriteLine(string.Empty);                                      Console.WriteLine("Warning: " + message);                                      Console.WriteLine(string.Empty);                                  }                              }                                if (arg.IsExclusive && args.Length > 1) {                                  throw new CommandLineArgumentException(string.Format(CultureInfo.InvariantCulture'                                      "Commandline argument '-{0}' cannot be combined with other arguments."'                                      arg.LongName));                              } else {                                  arg.SetValue(optionArgument);                              }                          }                          break;                      case '@':                          if (_supportsResponseFile) {                              string responseFile = argument.Substring(1' argument.Length - 1);                              if (!File.Exists(responseFile)) {                                  throw new CommandLineArgumentException(string.Format(CultureInfo.InvariantCulture'                                       "Unable to open response file '{0}'."' responseFile));                                  }                              // load file and parse it.                              ProcessResponseFile(responseFile);                              break;                          }                          continue;                                                default:                          if (_defaultArgument != null) {                              _defaultArgument.SetValue(argument);                          } else {                              throw new CommandLineArgumentException(string.Format(CultureInfo.InvariantCulture'                                  "Unknown argument '{0}'"' argument));                          }                          break;                  }              }
Magic Number,NAnt.Core.Util,FileUtils,C:\repos\nant_nant\src\NAnt.Core\Util\FileUtils.cs,CopyFile,The following statement contains a magic number: if (!filtersAvailable && inputEncoding == null && outputEncoding == null) {                  File.Copy(sourceFileName' destFileName' true);              } else {                  // determine actual input encoding to use. if no explicit input                  // encoding is specified' we'll use the system's current ANSI                  // code page                  Encoding actualInputEncoding = (inputEncoding != null) ?                      inputEncoding : Encoding.Default;                    // get base filter built on the file's reader. Use a 8k buffer.                  using (StreamReader sourceFileReader = new StreamReader(sourceFileName' actualInputEncoding' true' 8192)) {                      Encoding actualOutputEncoding = outputEncoding;                      if (actualOutputEncoding == null) {                          // if no explicit output encoding is specified' we'll                          // just use the encoding of the input file as determined                          // by the runtime                          //                           // Note : the input encoding as specified on the filterchain                          // might not match the current encoding of the streamreader                          //                          // eg. when specifing an ANSI encoding' the runtime might                          // still detect the file is using UTF-8 encoding' because                           // we use BOM detection                          actualOutputEncoding = sourceFileReader.CurrentEncoding;                      }                        // writer for destination file                      using (StreamWriter destFileWriter = new StreamWriter(destFileName' false' actualOutputEncoding' 8192)) {                          if (filtersAvailable) {                              Filter baseFilter = filterChain.GetBaseFilter(new PhysicalTextReader(sourceFileReader));                                bool atEnd = false;                              int character;                              while (!atEnd) {                                  character = baseFilter.Read();                                  if (character > -1) {                                      destFileWriter.Write((char)character);                                  } else {                                      atEnd = true;                                  }                              }                          } else {                              char[] buffer = new char[8192];                                while (true) {                                  int charsRead = sourceFileReader.Read(buffer' 0' buffer.Length);                                  if (charsRead == 0) {                                      break;                                  }                                  destFileWriter.Write(buffer' 0' charsRead);                              }                          }                      }                  }              }
Magic Number,NAnt.Core.Util,FileUtils,C:\repos\nant_nant\src\NAnt.Core\Util\FileUtils.cs,CopyFile,The following statement contains a magic number: if (!filtersAvailable && inputEncoding == null && outputEncoding == null) {                  File.Copy(sourceFileName' destFileName' true);              } else {                  // determine actual input encoding to use. if no explicit input                  // encoding is specified' we'll use the system's current ANSI                  // code page                  Encoding actualInputEncoding = (inputEncoding != null) ?                      inputEncoding : Encoding.Default;                    // get base filter built on the file's reader. Use a 8k buffer.                  using (StreamReader sourceFileReader = new StreamReader(sourceFileName' actualInputEncoding' true' 8192)) {                      Encoding actualOutputEncoding = outputEncoding;                      if (actualOutputEncoding == null) {                          // if no explicit output encoding is specified' we'll                          // just use the encoding of the input file as determined                          // by the runtime                          //                           // Note : the input encoding as specified on the filterchain                          // might not match the current encoding of the streamreader                          //                          // eg. when specifing an ANSI encoding' the runtime might                          // still detect the file is using UTF-8 encoding' because                           // we use BOM detection                          actualOutputEncoding = sourceFileReader.CurrentEncoding;                      }                        // writer for destination file                      using (StreamWriter destFileWriter = new StreamWriter(destFileName' false' actualOutputEncoding' 8192)) {                          if (filtersAvailable) {                              Filter baseFilter = filterChain.GetBaseFilter(new PhysicalTextReader(sourceFileReader));                                bool atEnd = false;                              int character;                              while (!atEnd) {                                  character = baseFilter.Read();                                  if (character > -1) {                                      destFileWriter.Write((char)character);                                  } else {                                      atEnd = true;                                  }                              }                          } else {                              char[] buffer = new char[8192];                                while (true) {                                  int charsRead = sourceFileReader.Read(buffer' 0' buffer.Length);                                  if (charsRead == 0) {                                      break;                                  }                                  destFileWriter.Write(buffer' 0' charsRead);                              }                          }                      }                  }              }
Magic Number,NAnt.Core.Util,FileUtils,C:\repos\nant_nant\src\NAnt.Core\Util\FileUtils.cs,CopyFile,The following statement contains a magic number: if (!filtersAvailable && inputEncoding == null && outputEncoding == null) {                  File.Copy(sourceFileName' destFileName' true);              } else {                  // determine actual input encoding to use. if no explicit input                  // encoding is specified' we'll use the system's current ANSI                  // code page                  Encoding actualInputEncoding = (inputEncoding != null) ?                      inputEncoding : Encoding.Default;                    // get base filter built on the file's reader. Use a 8k buffer.                  using (StreamReader sourceFileReader = new StreamReader(sourceFileName' actualInputEncoding' true' 8192)) {                      Encoding actualOutputEncoding = outputEncoding;                      if (actualOutputEncoding == null) {                          // if no explicit output encoding is specified' we'll                          // just use the encoding of the input file as determined                          // by the runtime                          //                           // Note : the input encoding as specified on the filterchain                          // might not match the current encoding of the streamreader                          //                          // eg. when specifing an ANSI encoding' the runtime might                          // still detect the file is using UTF-8 encoding' because                           // we use BOM detection                          actualOutputEncoding = sourceFileReader.CurrentEncoding;                      }                        // writer for destination file                      using (StreamWriter destFileWriter = new StreamWriter(destFileName' false' actualOutputEncoding' 8192)) {                          if (filtersAvailable) {                              Filter baseFilter = filterChain.GetBaseFilter(new PhysicalTextReader(sourceFileReader));                                bool atEnd = false;                              int character;                              while (!atEnd) {                                  character = baseFilter.Read();                                  if (character > -1) {                                      destFileWriter.Write((char)character);                                  } else {                                      atEnd = true;                                  }                              }                          } else {                              char[] buffer = new char[8192];                                while (true) {                                  int charsRead = sourceFileReader.Read(buffer' 0' buffer.Length);                                  if (charsRead == 0) {                                      break;                                  }                                  destFileWriter.Write(buffer' 0' charsRead);                              }                          }                      }                  }              }
Magic Number,NAnt.Core.Util,FileUtils,C:\repos\nant_nant\src\NAnt.Core\Util\FileUtils.cs,CombinePaths,The following statement contains a magic number: for (int i = 0; i < arList2.Count; i++) {                  // never discard first part of path1                  if ((string) arList2[i] != ".." || counter < 2) {                      break;                  }                    // skip part of current directory                  counter--;                    arList.RemoveAt(0);              }
Magic Number,NAnt.Core.Util,ResourceUtils,C:\repos\nant_nant\src\NAnt.Core\Util\ResourceUtils.cs,GetResourceName,The following statement contains a magic number: if (assemblyName.EndsWith("Tasks")) {                  // hack to determine the manifest resource name as our                  // assembly names have a Tasks suffix' while our                  // root namespace in VS.NET does not                  resourceName = assemblyName.Substring(0' assemblyName.Length - 5);              } else {                  resourceName = assemblyName;              }
Missing Default,NAnt.Core,ExpressionEvalBase,C:\repos\nant_nant\src\NAnt.Core\ExpressionEvalBase.cs,ParseRelationalExpression,The following switch statement is missing a default case: switch (op) {                      case ExpressionTokenizer.TokenType.EQ:                          if (o is string && o2 is string) {                              return o.Equals(o2);                          } else if (o is bool && o2 is bool) {                              return o.Equals(o2);                          } else if (o is int && o2 is int) {                              return o.Equals(o2);                          } else if (o is int && o2 is long) {                              return (Convert.ToInt64(o)).Equals(o2);                          } else if (o is int && o2 is double) {                              return (Convert.ToDouble(o)).Equals(o2);                          } else if (o is long && o2 is long) {                              return o.Equals(o2);                          } else if (o is long && o2 is int) {                              return (o.Equals(Convert.ToInt64(o2)));                          } else if (o is long && o2 is double) {                              return (Convert.ToDouble(o)).Equals(o2);                          } else if (o is double && o2 is double) {                              return o.Equals(o2);                          } else if (o is double && o2 is int) {                              return o.Equals(Convert.ToDouble(o2));                          } else if (o is double && o2 is long) {                              return o.Equals(Convert.ToDouble(o2));                          } else if (o is DateTime && o2 is DateTime) {                              return o.Equals(o2);                          } else if (o is TimeSpan && o2 is TimeSpan) {                              return o.Equals(o2);                          } else if (o is Version && o2 is Version) {                              return o.Equals(o2);                          } else if (o.GetType().IsEnum) {                              if (o2 is string) {                                  return o.Equals(Enum.Parse(o.GetType()' (string) o2' false));                              } else {                                  return o.Equals(Enum.ToObject(o.GetType()' o2));                              }                          } else if (o2.GetType().IsEnum) {                              if (o is string) {                                  return o2.Equals(Enum.Parse(o2.GetType()' (string) o' false));                              } else {                                  return o2.Equals(Enum.ToObject(o2.GetType()' o));                              }                          }                            throw BuildParseError(string.Format(CultureInfo.InvariantCulture'                               ResourceUtils.GetString("NA1038")'                               GetSimpleTypeName(o.GetType())' GetSimpleTypeName(o2.GetType()))'                               p0' p2);                      case ExpressionTokenizer.TokenType.NE:                          if (o is string && o2 is string) {                              return !o.Equals(o2);                          } else if (o is bool && o2 is bool) {                              return !o.Equals(o2);                          } else if (o is int && o2 is int) {                              return !o.Equals(o2);                          } else if (o is int && o2 is long) {                              return !(Convert.ToInt64(o)).Equals(o2);                          } else if (o is int && o2 is double) {                              return !(Convert.ToDouble(o)).Equals(o2);                          } else if (o is long && o2 is long) {                              return !o.Equals(o2);                          } else if (o is long && o2 is int) {                              return !(o.Equals(Convert.ToInt64(o2)));                          } else if (o is long && o2 is double) {                              return !(Convert.ToDouble(o)).Equals(o2);                          } else if (o is double && o2 is double) {                              return !o.Equals(o2);                          } else if (o is double && o2 is int) {                              return !o.Equals(Convert.ToDouble(o2));                          } else if (o is double && o2 is long) {                              return !o.Equals(Convert.ToDouble(o2));                          } else if (o is DateTime && o2 is DateTime) {                              return !o.Equals(o2);                          } else if (o is TimeSpan && o2 is TimeSpan) {                              return !o.Equals(o2);                          } else if (o is Version && o2 is Version) {                              return !o.Equals(o2);                          } else if (o.GetType().IsEnum) {                              if (o2 is string) {                                  return !o.Equals(Enum.Parse(o.GetType()' (string) o2' false));                              } else {                                  return !o.Equals(Enum.ToObject(o.GetType()' o2));                              }                          } else if (o2.GetType().IsEnum) {                              if (o is string) {                                  return !o2.Equals(Enum.Parse(o2.GetType()' (string) o' false));                              } else {                                  return !o2.Equals(Enum.ToObject(o2.GetType()' o));                              }                          }                            throw BuildParseError(string.Format(CultureInfo.InvariantCulture'                               ResourceUtils.GetString("NA1042")'                               GetSimpleTypeName(o.GetType())' GetSimpleTypeName(o2.GetType()))'                               p0' p2);                      case ExpressionTokenizer.TokenType.LT:                          if (o is string && o2 is string) {                              return string.Compare((string) o' (string) o2' false'                                   CultureInfo.InvariantCulture) < 0;                          } else if (o is bool && o2 is bool) {                              return ((IComparable) o).CompareTo(o2) < 0;                          } else if (o is int && o2 is int) {                              return ((IComparable) o).CompareTo(o2) < 0;                          } else if (o is int && o2 is long) {                              return ((IComparable) Convert.ToInt64(o)).CompareTo(o2) < 0;                          } else if (o is int && o2 is double) {                              return ((IComparable) Convert.ToDouble(o)).CompareTo(o2) < 0;                          } else if (o is long && o2 is long) {                              return ((IComparable) o).CompareTo(o2) < 0;                          } else if (o is long && o2 is int) {                              return ((IComparable) o).CompareTo(Convert.ToInt64(o2)) < 0;                          } else if (o is long && o2 is double) {                              return ((IComparable) Convert.ToDouble(o)).CompareTo(o2) < 0;                          } else if (o is double && o2 is double) {                              return ((IComparable) o).CompareTo(o2) < 0;                          } else if (o is double && o2 is int) {                              return ((IComparable) o).CompareTo(Convert.ToDouble(o2)) < 0;                          } else if (o is double && o2 is long) {                              return ((IComparable) o).CompareTo(Convert.ToDouble(o2)) < 0;                          } else if (o is DateTime && o2 is DateTime) {                              return ((IComparable) o).CompareTo(o2) < 0;                          } else if (o is TimeSpan && o2 is TimeSpan) {                              return ((IComparable) o).CompareTo(o2) < 0;                          } else if (o is Version && o2 is Version) {                              return ((IComparable) o).CompareTo(o2) < 0;                          }                            throw BuildParseError(string.Format(CultureInfo.InvariantCulture'                               ResourceUtils.GetString("NA1051")'                               GetSimpleTypeName(o.GetType())' GetSimpleTypeName(o2.GetType()))'                               p0' p2);                      case ExpressionTokenizer.TokenType.GT:                          if (o is string && o2 is string) {                              return string.Compare((string) o' (string) o2' false'                                   CultureInfo.InvariantCulture) > 0;                          } else if (o is bool && o2 is bool) {                              return ((IComparable) o).CompareTo(o2) > 0;                          } else if (o is int && o2 is int) {                              return ((IComparable) o).CompareTo(o2) > 0;                          } else if (o is int && o2 is long) {                              return ((IComparable) Convert.ToInt64(o)).CompareTo(o2) > 0;                          } else if (o is int && o2 is double) {                              return ((IComparable) Convert.ToDouble(o)).CompareTo(o2) > 0;                          } else if (o is long && o2 is long) {                              return ((IComparable) o).CompareTo(o2) > 0;                          } else if (o is long && o2 is int) {                              return ((IComparable) o).CompareTo(Convert.ToInt64(o2)) > 0;                          } else if (o is long && o2 is double) {                              return ((IComparable) Convert.ToDouble(o)).CompareTo(o2) > 0;                          } else if (o is double && o2 is double) {                              return ((IComparable) o).CompareTo(o2) > 0;                          } else if (o is double && o2 is int) {                              return ((IComparable) o).CompareTo(Convert.ToDouble(o2)) > 0;                          } else if (o is double && o2 is long) {                              return ((IComparable) o).CompareTo(Convert.ToDouble(o2)) > 0;                          } else if (o is DateTime && o2 is DateTime) {                              return ((IComparable) o).CompareTo(o2) > 0;                          } else if (o is TimeSpan && o2 is TimeSpan) {                              return ((IComparable) o).CompareTo(o2) > 0;                          } else if (o is Version && o2 is Version) {                              return ((IComparable) o).CompareTo(o2) > 0;                          }                            throw BuildParseError(string.Format(CultureInfo.InvariantCulture'                               ResourceUtils.GetString("NA1037")'                               GetSimpleTypeName(o.GetType())' GetSimpleTypeName(o2.GetType()))'                               p0' p2);                      case ExpressionTokenizer.TokenType.LE:                          if (o is string && o2 is string) {                              return string.Compare((string) o' (string) o2' false'                                   CultureInfo.InvariantCulture) <= 0;                          } else if (o is bool && o2 is bool) {                              return ((IComparable) o).CompareTo(o2) <= 0;                          } else if (o is int && o2 is int) {                              return ((IComparable) o).CompareTo(o2) <= 0;                          } else if (o is int && o2 is long) {                              return ((IComparable) Convert.ToInt64(o)).CompareTo(o2) <= 0;                          } else if (o is int && o2 is double) {                              return ((IComparable) Convert.ToDouble(o)).CompareTo(o2) <= 0;                          } else if (o is long && o2 is long) {                              return ((IComparable) o).CompareTo(o2) <= 0;                          } else if (o is long && o2 is int) {                              return ((IComparable) o).CompareTo(Convert.ToInt64(o2)) <= 0;                          } else if (o is long && o2 is double) {                              return ((IComparable) Convert.ToDouble(o)).CompareTo(o2) <= 0;                          } else if (o is double && o2 is double) {                              return ((IComparable) o).CompareTo(o2) <= 0;                          } else if (o is double && o2 is int) {                              return ((IComparable) o).CompareTo(Convert.ToDouble(o2)) <= 0;                          } else if (o is double && o2 is long) {                              return ((IComparable) o).CompareTo(Convert.ToDouble(o2)) <= 0;                          } else if (o is DateTime && o2 is DateTime) {                              return ((IComparable) o).CompareTo(o2) <= 0;                          } else if (o is TimeSpan && o2 is TimeSpan) {                              return ((IComparable) o).CompareTo(o2) <= 0;                          } else if (o is Version && o2 is Version) {                              return ((IComparable) o).CompareTo(o2) <= 0;                          }                            throw BuildParseError(string.Format(CultureInfo.InvariantCulture'                               ResourceUtils.GetString("NA1049")'                               GetSimpleTypeName(o.GetType())' GetSimpleTypeName(o2.GetType()))'                               p0' p2);                      case ExpressionTokenizer.TokenType.GE:                          if (o is string && o2 is string) {                              return string.Compare((string) o' (string) o2' false'                                   CultureInfo.InvariantCulture) >= 0;                          } else if (o is bool && o2 is bool) {                              return ((IComparable) o).CompareTo(o2) >= 0;                          } else if (o is int && o2 is int) {                              return ((IComparable) o).CompareTo(o2) >= 0;                          } else if (o is int && o2 is long) {                              return ((IComparable) Convert.ToInt64(o)).CompareTo(o2) >= 0;                          } else if (o is int && o2 is double) {                              return ((IComparable) Convert.ToDouble(o)).CompareTo(o2) >= 0;                          } else if (o is long && o2 is long) {                              return ((IComparable) o).CompareTo(o2) >= 0;                          } else if (o is long && o2 is int) {                              return ((IComparable) o).CompareTo(Convert.ToInt64(o2)) >= 0;                          } else if (o is long && o2 is double) {                              return ((IComparable) Convert.ToDouble(o)).CompareTo(o2) >= 0;                          } else if (o is double && o2 is double) {                              return ((IComparable) o).CompareTo(o2) >= 0;                          } else if (o is double && o2 is int) {                              return ((IComparable) o).CompareTo(Convert.ToDouble(o2)) >= 0;                          } else if (o is double && o2 is long) {                              return ((IComparable) o).CompareTo(Convert.ToDouble(o2)) >= 0;                          } else if (o is DateTime && o2 is DateTime) {                              return ((IComparable) o).CompareTo(o2) >= 0;                          } else if (o is TimeSpan && o2 is TimeSpan) {                              return ((IComparable) o).CompareTo(o2) >= 0;                          } else if (o is Version && o2 is Version) {                              return ((IComparable) o).CompareTo(o2) >= 0;                          }                            throw BuildParseError(string.Format(CultureInfo.InvariantCulture'                               ResourceUtils.GetString("NA1050")'                               GetSimpleTypeName(o.GetType())' GetSimpleTypeName(o2.GetType()))'                               p0' p2);                  }
Missing Default,NAnt.Core,Project,C:\repos\nant_nant\src\NAnt.Core\Project.cs,GetFrameworks,The following switch statement is missing a default case: switch (framework.Vendor) {                         case VendorType.Mono:                             if ((types & FrameworkTypes.Mono) == 0)                                 continue;                             break;                         case VendorType.Microsoft:                             if ((types & FrameworkTypes.MS) == 0)                                 continue;                             break;                     }
Missing Default,NAnt.Core.Tasks,ExternalProgramBase,C:\repos\nant_nant\src\NAnt.Core\Tasks\ExternalProgramBase.cs,DetermineFilePath,The following switch statement is missing a default case: switch (programLocationAttribute.LocationType) {                      case LocationType.FrameworkDir:                          if (Project.TargetFramework.FrameworkDirectory != null) {                              string frameworkDir = Project.TargetFramework.FrameworkDirectory.FullName;                              fullPath = Path.Combine(frameworkDir' ExeName + ".exe");                          } else {                              throw new BuildException(                                  string.Format(CultureInfo.InvariantCulture'                                   ResourceUtils.GetString("NA1124")'                                   Project.TargetFramework.Name));                          }                          break;                      case LocationType.FrameworkSdkDir:                          if (Project.TargetFramework.SdkDirectory != null) {                              string sdkDirectory = Project.TargetFramework.SdkDirectory.FullName;                              fullPath = Path.Combine(sdkDirectory' ExeName + ".exe");                          } else {                              throw new BuildException(                                  string.Format(CultureInfo.InvariantCulture'                                   ResourceUtils.GetString("NA1122")'                                   Project.TargetFramework.Name));                          }                          break;                  }
Missing Default,NAnt.Core.Tasks,LoopTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\LoopTask.cs,ExecuteTask,The following switch statement is missing a default case: switch (ItemType) {                     case LoopItem.File:                         if (String.IsNullOrEmpty(Source) && InElement == null) {                             throw new BuildException("Invalid foreach"' Location' new ArgumentException("Nothing to work with...!"' "in"));                         }                          if (!String.IsNullOrEmpty(Source)) {                             // resolve to full path                             Source = Project.GetFullPath(Source);                             // ensure directory exists                             if (!Directory.Exists(Source)) {                                 throw new BuildException(string.Format(                                     CultureInfo.InvariantCulture'                                     ResourceUtils.GetString("NA1134")'                                      Source)' Location);                             }                                                      if (_props.Length != 1) {                                 throw new BuildException(@"Only one property is valid for item=""File"""' Location);                             }                                                      DirectoryInfo dirInfo = new DirectoryInfo(Source);                             FileInfo[] files = dirInfo.GetFiles();                                                      foreach (FileInfo file in files) {                                 DoWork(file.FullName);                             }                         } else {                             if (StuffToDo == null) {                                 throw new BuildException("Must use <do> with <in>."' Location);                             }                              foreach (string file in InElement.Items.FileNames) {                                 DoWork(file);                             }                         }                         break;                     case LoopItem.Folder:                         if (String.IsNullOrEmpty(Source) && InElement == null) {                             throw new BuildException("Invalid foreach"' Location' new ArgumentException("Nothing to work with...!"' "in"));                         }                          if (_props.Length != 1) {                             throw new BuildException(@"Only one property is valid for item=""Folder"""' Location);                         }                          if (!String.IsNullOrEmpty(Source)) {                             // resolve to full path                             Source = Project.GetFullPath(Source);                             // ensure directory exists                             if (!Directory.Exists(Source)) {                                 throw new BuildException(string.Format(                                     CultureInfo.InvariantCulture'                                     ResourceUtils.GetString("NA1134")'                                      Source)' Location);                             }                              DirectoryInfo dirInfo = new DirectoryInfo(Source);                             DirectoryInfo[] dirs = dirInfo.GetDirectories();                             foreach (DirectoryInfo dir in dirs) {                                 DoWork(dir.FullName);                             }                          } else {                             if (StuffToDo == null) {                                 throw new BuildException("Must use <do> with <in>."' Location);                             }                              foreach (string dir in InElement.Items.DirectoryNames) {                                 DoWork(dir);                             }                         }                         break;                     case LoopItem.Line:                         if (String.IsNullOrEmpty(Source) && InElement == null) {                             throw new BuildException("Invalid foreach"' Location' new ArgumentException("Nothing to work with...!"' "in"));                         }                          if (_props.Length > 1 && Delimiter == null) {                             throw new BuildException("Delimiter(s) must be specified if multiple properties are specified"' Location);                         }                          if (!String.IsNullOrEmpty(Source)) {                             // resolve to full path                             Source = Project.GetFullPath(Source);                             // ensure file exists                             if (!File.Exists(Source)) {                                 throw new BuildException(string.Format(                                     CultureInfo.InvariantCulture'                                     ResourceUtils.GetString("NA1133")'                                      Source)' Location);                             }                              DoWorkOnFileLines(Source);                         } else {                             if (StuffToDo == null) {                                 throw new BuildException("Must use <do> with <in>."' Location);                             }                              foreach (string file in InElement.Items.FileNames) {                                 DoWorkOnFileLines(file);                             }                         }                         break;                     case LoopItem.String:                         if (String.IsNullOrEmpty(Source)) {                             return;                         }                          if (_props.Length > 1) {                             throw new BuildException(@"Only one property may be specified for item=""String"""' Location);                         }                          if (Delimiter == null) {                             throw new BuildException(@"Delimiter must be specified for item=""String"""' Location);                         }                          string[] items = Source.Split(Delimiter.ToCharArray());                         foreach (string s in items) {                             DoWork(s);                         }                         break;                 }
Missing Default,NAnt.Core.Tasks,LoopTask,C:\repos\nant_nant\src\NAnt.Core\Tasks\LoopTask.cs,DoWork,The following switch statement is missing a default case: switch (TrimType) {                     case LoopTrim.Both:                         propValue = propValue.Trim();                         break;                     case LoopTrim.Start:                         propValue = propValue.TrimStart();                         break;                     case LoopTrim.End:                         propValue = propValue.TrimEnd();                         break;                 }
