Implementation smell,Namespace,Class,File,Method,Description
Long Method,NAnt.Core,ConsoleDriver,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ConsoleDriver.cs,Main,The method has 248 lines of code.
Long Method,NAnt.Core,DirectoryScanner,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,ScanDirectory,The method has 130 lines of code.
Long Method,NAnt.Core,AttributeConfigurator,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Element.cs,InitializeAttribute,The method has 161 lines of code.
Long Method,NAnt.Core,AttributeConfigurator,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Element.cs,InitializeBuildElementCollection,The method has 283 lines of code.
Long Method,NAnt.Core,AttributeConfigurator,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Element.cs,InitializeOrderedChildElements,The method has 112 lines of code.
Long Method,NAnt.Core,ExpressionEvalBase,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ExpressionEvalBase.cs,ParseRelationalExpression,The method has 264 lines of code.
Long Method,NAnt.Core,ExpressionEvalBase,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ExpressionEvalBase.cs,ParseMulDiv,The method has 196 lines of code.
Long Method,NAnt.Core,ExpressionEvalBase,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ExpressionEvalBase.cs,ParseValue,The method has 229 lines of code.
Long Method,NAnt.Core,ExpressionEvalBase,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ExpressionEvalBase.cs,SafeConvert,The method has 105 lines of code.
Long Method,NAnt.Core,ExpressionTokenizer,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ExpressionTokenizer.cs,GetNextToken,The method has 120 lines of code.
Long Method,NAnt.Core,LocationMap,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\LocationMap.cs,Add,The method has 102 lines of code.
Long Method,NAnt.Core,MailLogger,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Log.cs,BuildFinished,The method has 129 lines of code.
Long Method,NAnt.Core,Project,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Project.cs,CtorHelper,The method has 111 lines of code.
Long Method,NAnt.Core.Tasks,CopyTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\CopyTask.cs,ExecuteTask,The method has 226 lines of code.
Long Method,NAnt.Core.Tasks,GetTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\GetTask.cs,ExecuteTask,The method has 148 lines of code.
Long Method,NAnt.Core.Tasks,IncludeTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\IncludeTask.cs,ExecuteTask,The method has 135 lines of code.
Long Method,NAnt.Core.Tasks,LoopTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\LoopTask.cs,ExecuteTask,The method has 144 lines of code.
Long Method,NAnt.Core.Tasks,MailTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\MailTask.cs,ExecuteTask,The method has 177 lines of code.
Long Method,NAnt.Core.Tasks,NAntSchemaGenerator,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\NAntSchemaTask.cs,FindOrCreateComplexType,The method has 132 lines of code.
Long Method,NAnt.Core.Tasks,StyleTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\StyleTask.cs,ExecuteTask,The method has 187 lines of code.
Long Method,NAnt.Core.Util,CommandLineArgument,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Util\CommandLineArgument.cs,Finish,The method has 101 lines of code.
Long Method,NAnt.Core.Util,FileUtils,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Util\FileUtils.cs,CombinePaths,The method has 104 lines of code.
Complex Method,NAnt.Core,ConsoleDriver,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ConsoleDriver.cs,Main,Cyclomatic complexity of the method is 18
Complex Method,NAnt.Core,ConsoleDriver,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ConsoleDriver.cs,GetBuildFileName,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core,DirectoryScanner,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,Clone,Cyclomatic complexity of the method is 14
Complex Method,NAnt.Core,DirectoryScanner,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,CheckIsEverythingIncluded,Cyclomatic complexity of the method is 21
Complex Method,NAnt.Core,DirectoryScanner,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,ConvertPatterns,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core,DirectoryScanner,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,ParseSearchDirectoryAndPattern,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core,DirectoryScanner,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,ScanDirectory,Cyclomatic complexity of the method is 25
Complex Method,NAnt.Core,Element,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Element.cs,GetAttributeConfigurationNode,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core,AttributeConfigurator,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Element.cs,AttributeConfigurator,Cyclomatic complexity of the method is 9
Complex Method,NAnt.Core,AttributeConfigurator,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Element.cs,Initialize,Cyclomatic complexity of the method is 12
Complex Method,NAnt.Core,AttributeConfigurator,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Element.cs,InitializeAttribute,Cyclomatic complexity of the method is 17
Complex Method,NAnt.Core,AttributeConfigurator,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Element.cs,InitializeBuildElementCollection,Cyclomatic complexity of the method is 40
Complex Method,NAnt.Core,AttributeConfigurator,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Element.cs,InitializeOrderedChildElements,Cyclomatic complexity of the method is 14
Complex Method,NAnt.Core,AttributeConfigurator,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Element.cs,CreateChildBuildElement,Cyclomatic complexity of the method is 9
Complex Method,NAnt.Core,AttributeConfigurator,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Element.cs,CreateAttributeSetter,Cyclomatic complexity of the method is 9
Complex Method,NAnt.Core,ExpressionEvalBase,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ExpressionEvalBase.cs,ParseRelationalExpression,Cyclomatic complexity of the method is 100
Complex Method,NAnt.Core,ExpressionEvalBase,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ExpressionEvalBase.cs,ParseAddSubtract,Cyclomatic complexity of the method is 30
Complex Method,NAnt.Core,ExpressionEvalBase,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ExpressionEvalBase.cs,ParseMulDiv,Cyclomatic complexity of the method is 53
Complex Method,NAnt.Core,ExpressionEvalBase,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ExpressionEvalBase.cs,ParseConditional,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core,ExpressionEvalBase,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ExpressionEvalBase.cs,ParseValue,Cyclomatic complexity of the method is 32
Complex Method,NAnt.Core,ExpressionEvalBase,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ExpressionEvalBase.cs,SafeConvert,Cyclomatic complexity of the method is 23
Complex Method,NAnt.Core,ExpressionEvalBase,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ExpressionEvalBase.cs,GetSimpleTypeName,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core,ExpressionTokenizer,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ExpressionTokenizer.cs,GetNextToken,Cyclomatic complexity of the method is 25
Complex Method,NAnt.Core,LocationMap,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\LocationMap.cs,Add,Cyclomatic complexity of the method is 11
Complex Method,NAnt.Core,DefaultLogger,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Log.cs,BuildFinished,Cyclomatic complexity of the method is 9
Complex Method,NAnt.Core,MailLogger,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Log.cs,BuildFinished,Cyclomatic complexity of the method is 9
Complex Method,NAnt.Core,PathScanner,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\PathScanner.cs,Scan,Cyclomatic complexity of the method is 10
Complex Method,NAnt.Core,Project,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Project.cs,GetFrameworks,Cyclomatic complexity of the method is 16
Complex Method,NAnt.Core,Project,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Project.cs,CtorHelper,Cyclomatic complexity of the method is 13
Complex Method,NAnt.Core,Project,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Project.cs,InitializeProjectDocument,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core,Project,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Project.cs,TopologicalTargetSort,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core,PropertyDictionary,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\PropertyDictionary.cs,EvaluateEmbeddedExpressions,Cyclomatic complexity of the method is 9
Complex Method,NAnt.Core,PropertyDictionary,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\PropertyDictionary.cs,CheckDeprecation,Cyclomatic complexity of the method is 16
Complex Method,NAnt.Core,Target,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Target.cs,Execute,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core,Task,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Task.cs,InitializeTaskConfiguration,Cyclomatic complexity of the method is 11
Complex Method,NAnt.Core,TaskContainer,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\TaskContainer.cs,ExecuteChildTasks,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core,TypeFactory,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\TypeFactory.cs,ScanAssembly,Cyclomatic complexity of the method is 13
Complex Method,NAnt.Core,XmlLogger,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\XmlLogger.cs,WriteErrorNode,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core,ElementContainer,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ElementContainer.cs,ExecuteChildTasks,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core.Filters,ReplaceString,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Filters\ReplaceString.cs,GetNextCharacter,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core.Filters,ReplaceTokens,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Filters\ReplaceTokens.cs,FindTokenContents,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core.Filters,ReplaceTokens,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Filters\ReplaceTokens.cs,GetNextCharacter,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core.Filters,FilterChainConfigurator,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Filters\Support\FilterChain.cs,InitializeBuildElementCollection,Cyclomatic complexity of the method is 11
Complex Method,NAnt.Core.Tasks,AttribTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\AttribTask.cs,ExecuteTask,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core.Tasks,CopyTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\CopyTask.cs,ExecuteTask,Cyclomatic complexity of the method is 29
Complex Method,NAnt.Core.Tasks,CopyTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\CopyTask.cs,DoFileOperations,Cyclomatic complexity of the method is 9
Complex Method,NAnt.Core.Tasks,DeleteTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\DeleteTask.cs,ExecuteTask,Cyclomatic complexity of the method is 12
Complex Method,NAnt.Core.Tasks,ExternalProgramBase,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\ExternalProgramBase.cs,PrepareProcess,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core.Tasks,ExternalProgramBase,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\ExternalProgramBase.cs,DetermineFilePath,Cyclomatic complexity of the method is 9
Complex Method,NAnt.Core.Tasks,LoadTasksTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\LoadTasks.cs,ExecuteTask,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core.Tasks,LoopTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\LoopTask.cs,ExecuteTask,Cyclomatic complexity of the method is 29
Complex Method,NAnt.Core.Tasks,MailTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\MailTask.cs,ExecuteTask,Cyclomatic complexity of the method is 14
Complex Method,NAnt.Core.Tasks,MoveTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\MoveTask.cs,DoFileOperations,Cyclomatic complexity of the method is 10
Complex Method,NAnt.Core.Tasks,NAntSchemaGenerator,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\NAntSchemaTask.cs,NAntSchemaGenerator,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core.Tasks,NAntSchemaGenerator,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\NAntSchemaTask.cs,FindOrCreateComplexType,Cyclomatic complexity of the method is 20
Complex Method,NAnt.Core.Tasks,NAntTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\NAntTask.cs,RunBuild,Cyclomatic complexity of the method is 9
Complex Method,NAnt.Core.Tasks,PropertyTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\PropertyTask.cs,ExecuteTask,Cyclomatic complexity of the method is 14
Complex Method,NAnt.Core.Tasks,StyleTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\StyleTask.cs,ExecuteTask,Cyclomatic complexity of the method is 22
Complex Method,NAnt.Core.Tasks,XmlPeekTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\XmlPeekTask.cs,GetNodeContents,Cyclomatic complexity of the method is 10
Complex Method,NAnt.Core.Types,PathSet,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Types\PathSet.cs,GetElements,Cyclomatic complexity of the method is 9
Complex Method,NAnt.Core.Types,PathSet,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Types\PathSet.cs,TranslatePath,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core.Util,AssemblyResolver,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Util\AssemblyResolver.cs,AssemblyResolve,Cyclomatic complexity of the method is 9
Complex Method,NAnt.Core.Util,CommandLineArgument,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Util\CommandLineArgument.cs,Finish,Cyclomatic complexity of the method is 20
Complex Method,NAnt.Core.Util,CommandLineArgument,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Util\CommandLineArgument.cs,ParseValue,Cyclomatic complexity of the method is 13
Complex Method,NAnt.Core.Util,CommandLineArgument,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Util\CommandLineArgument.cs,GetElementType,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core.Util,CommandLineParser,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Util\CommandLineParser.cs,ParseArgumentList,Cyclomatic complexity of the method is 15
Complex Method,NAnt.Core.Util,FileUtils,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Util\FileUtils.cs,CopyFile,Cyclomatic complexity of the method is 8
Complex Method,NAnt.Core.Util,FileUtils,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Util\FileUtils.cs,CombinePaths,Cyclomatic complexity of the method is 14
Long Parameter List,NAnt.Core,DirectoryScanner,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,ParseSearchDirectoryAndPattern,The method has 6 parameters. Parameters: isInclude' originalNAntPattern' searchDirectory' recursive' isRegex' regexPattern
Long Parameter List,NAnt.Core,AttributeConfigurator,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Element.cs,CreateChildBuildElement,The method has 6 parameters. Parameters: propInf' getter' setter' xml' properties' framework
Long Parameter List,NAnt.Core,ExpressionEvalBase,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ExpressionEvalBase.cs,SafeConvert,The method has 5 parameters. Parameters: returnType' source' description' p0' p1
Long Parameter List,NAnt.Core,Project,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Project.cs,TopologicalTargetSort,The method has 5 parameters. Parameters: root' targets' state' visiting' executeTargets
Long Parameter List,NAnt.Core.Extensibility,FunctionArgument,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Extensibility\FunctionArgument.cs,FunctionArgument,The method has 5 parameters. Parameters: name' index' value' beforeArgument' afterArgument
Long Parameter List,NAnt.Core.Util,FileUtils,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Util\FileUtils.cs,CopyFile,The method has 5 parameters. Parameters: sourceFileName' destFileName' filterChain' inputEncoding' outputEncoding
Long Parameter List,NAnt.Core.Util,FileUtils,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Util\FileUtils.cs,MoveFile,The method has 5 parameters. Parameters: sourceFileName' destFileName' filterChain' inputEncoding' outputEncoding
Long Identifier,NAnt.Core,DirectoryScanner,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,ParseSearchDirectoryAndPattern,The length of the parameter indexOfLastOriginalDirectorySeparator is 37.
Long Identifier,NAnt.Core,AttributeConfigurator,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Element.cs,InitializeBuildElementCollection,The length of the parameter buildElementCollectionAttribute is 31.
Long Identifier,NAnt.Core.Filters,ExpandProperties,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Filters\ExpandProperties.cs,,The length of the parameter MAX_RELIABLE_EXPRESSION_LENGTH is 30.
Long Identifier,NAnt.Core.Tasks,NAntSchemaGenerator,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\NAntSchemaTask.cs,FindOrCreateComplexType,The length of the parameter buildElementCollectionAttribute is 31.
Long Statement,NAnt.Core,ConsoleDriver,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ConsoleDriver.cs,Main,The length of the statement  "                        Console.WriteLine(string.Format(CultureInfo.InvariantCulture' "Buildfile has already been loaded! Using new value '{0}'; discarding old project file '{1}'"' cmdlineOptions.BuildFile' project.BuildFileUri));" is 206.
Long Statement,NAnt.Core,ConsoleDriver,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ConsoleDriver.cs,Main,The length of the statement  "                    project = new Project(GetBuildFileName(Environment.CurrentDirectory' null' cmdlineOptions.FindInParent)' projectThreshold' cmdlineOptions.IndentationLevel);" is 156.
Long Statement,NAnt.Core,ConsoleDriver,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ConsoleDriver.cs,Main,The length of the statement  "                Console.WriteLine("Please send a bug report (including the version of NAnt you're using) to nant-developers@lists.sourceforge.net");" is 132.
Long Statement,NAnt.Core,ConsoleDriver,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ConsoleDriver.cs,AddBuildListeners,The length of the statement  "                    outputWriter = new StreamWriter(new FileStream(cmdlineOptions.LogFile.FullName' FileMode.Create' FileAccess.Write' FileShare.Read));" is 132.
Long Statement,NAnt.Core,DirectoryScanner,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,ConvertPatterns,The length of the statement  "                ParseSearchDirectoryAndPattern(addSearchDirectories' nantPattern' out searchDirectory' out isRecursive' out isRegex' out regexPattern);" is 135.
Long Statement,NAnt.Core,DirectoryScanner,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,ParseSearchDirectoryAndPattern,The length of the statement  "            recursive = (indexOfFirstWildcard != -1 && (indexOfFirstWildcard < indexOfLastOriginalDirectorySeparator )) || indexOfFirstDirectoryWildcard != -1;" is 147.
Long Statement,NAnt.Core,DirectoryScanner,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,ParseSearchDirectoryAndPattern,The length of the statement  "            if (searchDirectory.EndsWith(Path.DirectorySeparatorChar.ToString()) && (searchDirectory.Length != 3 || searchDirectory[1] != Path.VolumeSeparatorChar)) {" is 154.
Long Statement,NAnt.Core,DirectoryScanner,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,TestRegex,The length of the statement  "            Console.WriteLine("{0} ({1}) [basedir={2}]"' entry.Pattern' path.Substring(entry.BaseDirectory.Length + ((endsWithSlash) ? 0 : 1))' entry.BaseDirectory);" is 153.
Long Statement,NAnt.Core,DirectoryScanner,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,ToRegexPattern,The length of the statement  "            pattern = new StringBuilder(Regex.Replace(pattern.ToString()' "(?<=" + seperator + ")\\*(?=($|" + seperator + "))"' "[^" + seperator + "]+"));" is 142.
Long Statement,NAnt.Core,AttributeConfigurator,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Element.cs,InitializeAttribute,The length of the statement  "                        ObsoleteAttribute obsoleteAttribute = (ObsoleteAttribute) Attribute.GetCustomAttribute(propertyInfo' typeof(ObsoleteAttribute));" is 128.
Long Statement,NAnt.Core,AttributeConfigurator,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Element.cs,InitializeBuildElementCollection,The length of the statement  "                        ObsoleteAttribute obsoleteAttribute = (ObsoleteAttribute) Attribute.GetCustomAttribute(propertyInfo' typeof(ObsoleteAttribute));" is 128.
Long Statement,NAnt.Core,AttributeConfigurator,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Element.cs,InitializeBuildElementCollection,The length of the statement  "                        ObsoleteAttribute obsoleteAttribute = (ObsoleteAttribute) Attribute.GetCustomAttribute(propertyInfo' typeof(ObsoleteAttribute));" is 128.
Long Statement,NAnt.Core,AttributeConfigurator,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Element.cs,InitializeBuildElementCollection,The length of the statement  "                    if (!(childNode.NodeType == XmlNodeType.Element) || !childNode.NamespaceURI.Equals(NamespaceManager.LookupNamespace("nant"))) {" is 127.
Long Statement,NAnt.Core,AttributeConfigurator,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Element.cs,CreateChildBuildElement,The length of the statement  "                    childElement = (Element) Activator.CreateInstance(elementType' BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance' null' null ' CultureInfo.InvariantCulture);" is 176.
Long Statement,NAnt.Core,EnumAttributeSetter,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Element.cs,Set,The length of the statement  "                        property.SetValue(parent' propertyValue' BindingFlags.Public | BindingFlags.Instance' null' null' CultureInfo.InvariantCulture);" is 128.
Long Statement,NAnt.Core,FileAttributeSetter,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Element.cs,Set,The length of the statement  "                            property.SetValue(parent' propertyValue' BindingFlags.Public | BindingFlags.Instance' null' null' CultureInfo.InvariantCulture);" is 128.
Long Statement,NAnt.Core,PathSetAttributeSetter,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Element.cs,Set,The length of the statement  "                        property.SetValue(parent' propertyValue' BindingFlags.Public | BindingFlags.Instance' null' null' CultureInfo.InvariantCulture);" is 128.
Long Statement,NAnt.Core,UriAttributeSetter,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Element.cs,Set,The length of the statement  "                            property.SetValue(parent' propertyValue' BindingFlags.Public | BindingFlags.Instance' null' null' CultureInfo.InvariantCulture);" is 128.
Long Statement,NAnt.Core,ConvertableAttributeSetter,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Element.cs,Set,The length of the statement  "                        property.SetValue(parent' propertyValue' BindingFlags.Public | BindingFlags.Instance' null' null' CultureInfo.InvariantCulture);" is 128.
Long Statement,NAnt.Core,ExpressionEvaluator,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ExpressionEvaluator.cs,EvaluateFunction,The length of the statement  "                    ConstructorInfo constructor = methodInfo.DeclaringType.GetConstructor(new Type[] {typeof(Project)' typeof(PropertyDictionary)});" is 128.
Long Statement,NAnt.Core,LocationMap,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\LocationMap.cs,Add,The length of the statement  "                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture' "XML document '{0}' has already been mapped."' fileName));" is 130.
Long Statement,NAnt.Core,MailLogger,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Log.cs,GetPropertyValue,The length of the statement  "                throw new ArgumentNullException(string.Format(CultureInfo.InvariantCulture' "Missing required parameter {0}."' propertyName));" is 126.
Long Statement,NAnt.Core,Project,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Project.cs,Execute,The length of the statement  "                System.Collections.Generic.Dictionary<string' Target> targets = new System.Collections.Generic.Dictionary<string' Target>();" is 124.
Long Statement,NAnt.Core,Project,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Project.cs,InitializeProjectDocument,The length of the statement  "                if (!(childNode.NodeType == XmlNodeType.Element) || !childNode.NamespaceURI.Equals(NamespaceManager.LookupNamespace("nant")) || childNode.LocalName.Equals(TargetXml)) {" is 168.
Long Statement,NAnt.Core,Project,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Project.cs,UpdateTargetFrameworkProperties,The length of the statement  "            Properties["nant.settings.currentframework.frameworkassemblydirectory"] = TargetFramework.FrameworkAssemblyDirectory.FullName;" is 126.
Long Statement,NAnt.Core,Target,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Target.cs,Execute,The length of the statement  "                        if (!(childNode.NodeType == XmlNodeType.Element)|| !childNode.NamespaceURI.Equals(NamespaceManager.LookupNamespace("nant"))) {" is 126.
Long Statement,NAnt.Core,Task,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Task.cs,InitializeTaskConfiguration,The length of the statement  "                            propertyInfo.SetValue(this' propertyValue' BindingFlags.Public | BindingFlags.Instance' null' null' CultureInfo.InvariantCulture);" is 130.
Long Statement,NAnt.Core,TaskContainer,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\TaskContainer.cs,Initialize,The length of the statement  "                BuildElementAttribute buildElemAttr = (BuildElementAttribute) Attribute.GetCustomAttribute(memInfo' typeof(BuildElementAttribute)' true);" is 137.
Long Statement,NAnt.Core,TaskContainer,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\TaskContainer.cs,ExecuteChildTasks,The length of the statement  "                if (!(childNode.NodeType == XmlNodeType.Element) || !childNode.NamespaceURI.Equals(NamespaceManager.LookupNamespace("nant"))) {" is 127.
Long Statement,NAnt.Core,XmlLogger,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\XmlLogger.cs,BuildFinished,The length of the statement  "                    using (StreamWriter writer = new StreamWriter(new FileStream(outFileName' FileMode.Create' FileAccess.Write' FileShare.Read)' Encoding.UTF8)) {" is 143.
Long Statement,NAnt.Core,ElementContainer,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ElementContainer.cs,ExecuteChildTasks,The length of the statement  "                if (!(childNode.NodeType == XmlNodeType.Element) || !childNode.NamespaceURI.Equals(NamespaceManager.LookupNamespace("nant"))) { " is 127.
Long Statement,NAnt.Core.Filters,ExpandProperties,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Filters\ExpandProperties.cs,ReplenishBuffer,The length of the statement  "                // There's an unfinished expression - don't attempt to expand it yet. Perhaps it will all fit in the buffer next time around." is 125.
Long Statement,NAnt.Core.Filters,ExpandProperties,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Filters\ExpandProperties.cs,ReplenishBuffer,The length of the statement  "                _buffer = new StringBuilder(bufferAfterExpand' Math.Max(BUFFER_LENGTH' bufferAfterExpand.Length + bufferBeforeExpand.Length));" is 126.
Long Statement,NAnt.Core.Filters,FilterChainConfigurator,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Filters\Support\FilterChain.cs,InitializeBuildElementCollection,The length of the statement  "                    if (!(childNode.NodeType == XmlNodeType.Element) || !childNode.NamespaceURI.Equals(NamespaceManager.LookupNamespace("nant"))) {" is 127.
Long Statement,NAnt.Core.Functions,AssemblyFunctions,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Functions\AssemblyFunctions.cs,GetAttributeProperty,The length of the statement  "            PropertyInfo property = attributeType.GetProperty(propertyName' BindingFlags.GetProperty | BindingFlags.Instance | BindingFlags.Public | BindingFlags.Static); " is 158.
Long Statement,NAnt.Core.Tasks,AvailableTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\AvailableTask.cs,Evaluate,The length of the statement  "                    throw new BuildException(string.Format(CultureInfo.InvariantCulture' "No resource check is implemented for {0}"' Type));" is 120.
Long Statement,NAnt.Core.Tasks,ExternalProgramBase,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\ExternalProgramBase.cs,ExecuteTask,The length of the statement  "                    string.Format(CultureInfo.InvariantCulture' "{0}: {1} had errors. Please see log4net log."' GetType().ToString()' ProgramFileName)' " is 131.
Long Statement,NAnt.Core.Tasks,ExternalProgramBase,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\ExternalProgramBase.cs,DetermineFilePath,The length of the statement  "            ProgramLocationAttribute programLocationAttribute = (ProgramLocationAttribute) Attribute.GetCustomAttribute(this.GetType()' " is 123.
Long Statement,NAnt.Core.Tasks,GetTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\GetTask.cs,Initialize,The length of the statement  "            if (DestinationFile.Exists && (FileAttributes.ReadOnly == (File.GetAttributes(DestinationFile.FullName) & FileAttributes.ReadOnly))) {" is 134.
Long Statement,NAnt.Core.Tasks,IfTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\IfTask.cs,Initialize,The length of the statement  "            if ((UpToDateFiles == null || CompareFiles == null) && Test == null && PropertyNameExists == null && PropertyNameTrue == null && TargetNameExists == null) {" is 156.
Long Statement,NAnt.Core.Tasks,NAntSchemaGenerator,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\NAntSchemaTask.cs,FindOrCreateComplexType,The length of the statement  "                        // We will only process child elements if they are defined for Properties or Fields' this should be enforced by the AttributeUsage on the Attribute class " is 153.
Long Statement,NAnt.Core.Tasks,NAntSchemaGenerator,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\NAntSchemaTask.cs,FindOrCreateComplexType,The length of the statement  "                        BuildElementCollectionAttribute buildElementCollectionAttribute = (BuildElementCollectionAttribute) Attribute.GetCustomAttribute(memInfo' typeof(BuildElementCollectionAttribute)' false); " is 186.
Long Statement,NAnt.Core.Tasks,SysInfoTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\SysInfo.cs,ExecuteTask,The length of the statement  "            Properties[Prefix + "os.folder.applicationdata"] = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);  " is 120.
Long Statement,NAnt.Core.Tasks,SysInfoTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\SysInfo.cs,ExecuteTask,The length of the statement  "            Properties[Prefix + "os.folder.commonapplicationData"] = Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData);  " is 132.
Long Statement,NAnt.Core.Tasks,SysInfoTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\SysInfo.cs,ExecuteTask,The length of the statement  "            Properties[Prefix + "os.folder.commonprogramFiles"] = Environment.GetFolderPath(Environment.SpecialFolder.CommonProgramFiles);  " is 126.
Long Statement,NAnt.Core.Tasks,SysInfoTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\SysInfo.cs,ExecuteTask,The length of the statement  "            Properties[Prefix + "os.folder.desktopdirectory"] = Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory);                          " is 122.
Long Statement,NAnt.Core.Tasks,SysInfoTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\SysInfo.cs,ExecuteTask,The length of the statement  "                    string safeName = name.EndsWith("(x86)") ? name.Replace("(x86)"' ".x86") : name;    // since on 64bit Windows provide such variable names' let's make them nice" is 159.
Long Statement,NAnt.Core.Util,CommandLineArgument,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Util\CommandLineArgument.cs,Finish,The length of the statement  "                throw new CommandLineArgumentException(string.Format(CultureInfo.InvariantCulture' "Missing required argument '-{0}'."' LongName));" is 131.
Long Statement,NAnt.Core.Util,CommandLineArgument,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Util\CommandLineArgument.cs,Finish,The length of the statement  "                _propertyInfo.SetValue(destination' _collectionValues.ToArray(_elementType)' BindingFlags.Default' null' null' CultureInfo.InvariantCulture);" is 141.
Long Statement,NAnt.Core.Util,CommandLineArgument,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Util\CommandLineArgument.cs,Finish,The length of the statement  "                    object instance = Activator.CreateInstance(_propertyInfo.PropertyType' BindingFlags.Public | BindingFlags.Instance' null' null' CultureInfo.InvariantCulture);" is 158.
Long Statement,NAnt.Core.Util,CommandLineArgument,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Util\CommandLineArgument.cs,Finish,The length of the statement  "                    throw new NotSupportedException(string.Format(CultureInfo.InvariantCulture' ResourceUtils.GetString("NA1169")' LongName));" is 122.
Long Statement,NAnt.Core.Util,CommandLineArgument,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Util\CommandLineArgument.cs,Finish,The length of the statement  "                    object instance = Activator.CreateInstance(_propertyInfo.PropertyType' BindingFlags.Public | BindingFlags.Instance' null' null' CultureInfo.InvariantCulture);" is 158.
Long Statement,NAnt.Core.Util,CommandLineArgument,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Util\CommandLineArgument.cs,GetElementType,The length of the statement  "                    throw new NotSupportedException(string.Format(CultureInfo.InvariantCulture' "Property {0} is not a strong-typed array."' propertyInfo.Name));" is 141.
Long Statement,NAnt.Core.Util,CommandLineArgument,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Util\CommandLineArgument.cs,GetElementType,The length of the statement  "                            throw new NotSupportedException(string.Format(CultureInfo.InvariantCulture' "Property {0} is not a strong-typed collection."' propertyInfo.Name));" is 146.
Long Statement,NAnt.Core.Util,CommandLineArgument,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Util\CommandLineArgument.cs,GetElementType,The length of the statement  "                    throw new NotSupportedException(string.Format(CultureInfo.InvariantCulture' "Invalid commandline argument type for property {0}."' propertyInfo.Name));" is 151.
Complex Conditional,NAnt.Core,ExpressionEvalBase,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ExpressionEvalBase.cs,ParseRelationalExpression,The conditional expression  "_tokenizer.CurrentToken == ExpressionTokenizer.TokenType.EQ                 || _tokenizer.CurrentToken == ExpressionTokenizer.TokenType.NE                 || _tokenizer.CurrentToken == ExpressionTokenizer.TokenType.LT                 || _tokenizer.CurrentToken == ExpressionTokenizer.TokenType.GT                 || _tokenizer.CurrentToken == ExpressionTokenizer.TokenType.LE                 || _tokenizer.CurrentToken == ExpressionTokenizer.TokenType.GE"  is complex.
Complex Conditional,NAnt.Core,ExpressionEvalBase,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ExpressionEvalBase.cs,ParseValue,The conditional expression  "_tokenizer.CurrentToken == ExpressionTokenizer.TokenType.Dot                         || _tokenizer.CurrentToken == ExpressionTokenizer.TokenType.Minus                         || _tokenizer.CurrentToken == ExpressionTokenizer.TokenType.Keyword                         || _tokenizer.CurrentToken == ExpressionTokenizer.TokenType.Number"  is complex.
Complex Conditional,NAnt.Core,ExpressionTokenizer,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ExpressionTokenizer.cs,GetNextToken,The conditional expression  "c == '_' || c == '-' || c == '.' || c == '\\' || Char.IsLetterOrDigit(c)"  is complex.
Complex Conditional,NAnt.Core,LocationMap,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\LocationMap.cs,Add,The conditional expression  "(reader.NodeType != XmlNodeType.Whitespace) &&                         (reader.NodeType != XmlNodeType.EndElement) &&                         (reader.NodeType != XmlNodeType.ProcessingInstruction) &&                         (reader.NodeType != XmlNodeType.XmlDeclaration) &&                         (reader.NodeType != XmlNodeType.DocumentType)"  is complex.
Complex Conditional,NAnt.Core.Tasks,IfTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\IfTask.cs,Initialize,The conditional expression  "(UpToDateFiles == null || CompareFiles == null) && Test == null && PropertyNameExists == null && PropertyNameTrue == null && TargetNameExists == null"  is complex.
Complex Conditional,NAnt.Core.Types,PathSet,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Types\PathSet.cs,TranslatePath,The conditional expression  "part.Length == 1 && Char.IsLetter(part[0]) && _dosBasedFileSystem && (parts.Length > i + 1)"  is complex.
Complex Conditional,NAnt.Core.Util,CommandLineArgument,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Util\CommandLineArgument.cs,ParseValue,The conditional expression  "(stringData != null || type == typeof(bool)) && (stringData == null || stringData.Length > 0)"  is complex.
Complex Conditional,NAnt.Core.Util,FileUtils,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Util\FileUtils.cs,MoveFile,The conditional expression  "(filterChain == null || filterChain.Filters.Count == 0) && inputEncoding == null && outputEncoding == null"  is complex.
Virtual Method Call from Constructor,NAnt.Core.Filters,PhysicalTextReader,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Filters\Support\PhysicalTextReader.cs,PhysicalTextReader,The constructor "PhysicalTextReader" calls a virtual method "Chain".
Empty Catch Block,NAnt.Core,FrameworkInfo,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\FrameworkInfo.cs,PerformInit,The method has an empty catch block.
Empty Catch Block,NAnt.Core,Location,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Location.cs,Init,The method has an empty catch block.
Empty Catch Block,NAnt.Core,MailLogger,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Log.cs,BuildFinished,The method has an empty catch block.
Empty Catch Block,NAnt.Core,Project,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Project.cs,GetFullPath,The method has an empty catch block.
Empty Catch Block,NAnt.Core.Tasks,ExternalProgramBase,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\ExternalProgramBase.cs,ExecuteTask,The method has an empty catch block.
Magic Number,NAnt.Core,DirectoryScanner,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,Scan,The following statement contains a magic number: Thread[] lastTasks = new Thread[2];
Magic Number,NAnt.Core,DirectoryScanner,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,ParseSearchDirectoryAndPattern,The following statement contains a magic number: s.Length == 2 && s[1] == Path.VolumeSeparatorChar
Magic Number,NAnt.Core,DirectoryScanner,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,ParseSearchDirectoryAndPattern,The following statement contains a magic number: searchDirectory.EndsWith(Path.DirectorySeparatorChar.ToString()) && (searchDirectory.Length != 3 || searchDirectory[1] != Path.VolumeSeparatorChar)
Magic Number,NAnt.Core,DirectoryScanner,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,ToRegexPattern,The following statement contains a magic number: patternText = patternText.Substring(3);
Magic Number,NAnt.Core,DirectoryScanner,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\DirectoryScanner.cs,ToRegexPattern,The following statement contains a magic number: patternText = patternText.Substring(0' pattern.Length - 3);
Magic Number,NAnt.Core,ExpressionTokenizer,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ExpressionTokenizer.cs,ExpressionTokenizer,The following statement contains a magic number: i < 128
Magic Number,NAnt.Core,ExpressionTokenizer,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ExpressionTokenizer.cs,GetNextToken,The following statement contains a magic number: ch >= 32 && ch < 128
Magic Number,NAnt.Core,ExpressionTokenizer,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ExpressionTokenizer.cs,GetNextToken,The following statement contains a magic number: ch >= 32 && ch < 128
Magic Number,NAnt.Core,PlatformHelper,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\PlatformHelper.cs,PlatformHelper,The following statement contains a magic number: (p == 4) || (p == 6) || (p == 128)
Magic Number,NAnt.Core,PlatformHelper,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\PlatformHelper.cs,PlatformHelper,The following statement contains a magic number: (p == 4) || (p == 6) || (p == 128)
Magic Number,NAnt.Core,PlatformHelper,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\PlatformHelper.cs,PlatformHelper,The following statement contains a magic number: (p == 4) || (p == 6) || (p == 128)
Magic Number,NAnt.Core,Project,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Project.cs,CtorHelper,The following statement contains a magic number: _indentationSize = 12;
Magic Number,NAnt.Core,ProjectSettingsLoader,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ProjectSettingsLoader.cs,ConfigureRuntimeFramework,The following statement contains a magic number: Version frameworkClrVersion = new Version(Environment.Version.ToString(3));
Magic Number,NAnt.Core,TypeFactory,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\TypeFactory.cs,AddProject,The following statement contains a magic number: ScanDir(Path.Combine(commonTasksDir' project.RuntimeFramework.                 ClrVersion.ToString (2))' loadTasks' false);
Magic Number,NAnt.Core.Tasks,ExternalProgramBase,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\ExternalProgramBase.cs,ExternalProgramBase,The following statement contains a magic number: const int defaultTimeout = 2000;
Magic Number,NAnt.Core.Tasks,GetTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\GetTask.cs,ExecuteTask,The following statement contains a magic number: int bufferSize = 100 * 1024;
Magic Number,NAnt.Core.Tasks,GetTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\GetTask.cs,ExecuteTask,The following statement contains a magic number: int bufferSize = 100 * 1024;
Magic Number,NAnt.Core.Tasks,NAntSchemaTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\NAntSchemaTask.cs,ExecuteTask,The following statement contains a magic number: byte[] buffer = new byte[4096];
Magic Number,NAnt.Core.Tasks,NAntSchemaGenerator,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\NAntSchemaTask.cs,NAntSchemaGenerator,The following statement contains a magic number: ArrayList taskContainerComplexTypes = new ArrayList(4);
Magic Number,NAnt.Core.Tasks,SleepTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\SleepTask.cs,GetSleepTime,The following statement contains a magic number: return ((((int) Hours * 60) + Minutes) * 60 + Seconds) * 1000 + Milliseconds;
Magic Number,NAnt.Core.Tasks,SleepTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\SleepTask.cs,GetSleepTime,The following statement contains a magic number: return ((((int) Hours * 60) + Minutes) * 60 + Seconds) * 1000 + Milliseconds;
Magic Number,NAnt.Core.Tasks,SleepTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\SleepTask.cs,GetSleepTime,The following statement contains a magic number: return ((((int) Hours * 60) + Minutes) * 60 + Seconds) * 1000 + Milliseconds;
Magic Number,NAnt.Core.Util,CommandLineParser,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Util\CommandLineParser.cs,ParseArgumentList,The following statement contains a magic number: switch (argument[0]) {                     case '-':                     case '/':                         int endIndex = argument.IndexOfAny(new char[] {':'' '+'' '-'}' 1);                         string option = argument.Substring(1' endIndex == -1 ? argument.Length - 1 : endIndex - 1);                         string optionArgument;                          if (option.Length + 1 == argument.Length) {                             optionArgument = null;                         } else if (argument.Length > 1 + option.Length && argument[1 + option.Length] == ':') {                             optionArgument = argument.Substring(option.Length + 2);                         } else {                             optionArgument = argument.Substring(option.Length + 1);                         }                                                  CommandLineArgument arg = _argumentCollection[option];                         if (arg == null) {                             throw new CommandLineArgumentException(string.Format(CultureInfo.InvariantCulture'                                 "Unknown argument '{0}'"' argument));                         } else {                             // check if argument is obsolete                             Attribute[] attribs = (Attribute[]) arg.Property.GetCustomAttributes(                                 typeof(ObsoleteAttribute)' false);                             if (attribs.Length > 0) {                                 ObsoleteAttribute obsoleteAttrib = (ObsoleteAttribute) attribs[0];                                 string message = string.Format(CultureInfo.InvariantCulture'                                      ResourceUtils.GetString("NA1177")' option'                                      obsoleteAttrib.Message);                                 if (obsoleteAttrib.IsError) {                                     throw new CommandLineArgumentException(message);                                 } else {                                     Console.WriteLine(string.Empty);                                     Console.WriteLine("Warning: " + message);                                     Console.WriteLine(string.Empty);                                 }                             }                              if (arg.IsExclusive && args.Length > 1) {                                 throw new CommandLineArgumentException(string.Format(CultureInfo.InvariantCulture'                                     "Commandline argument '-{0}' cannot be combined with other arguments."'                                     arg.LongName));                             } else {                                 arg.SetValue(optionArgument);                             }                         }                         break;                     case '@':                         if (_supportsResponseFile) {                             string responseFile = argument.Substring(1' argument.Length - 1);                             if (!File.Exists(responseFile)) {                                 throw new CommandLineArgumentException(string.Format(CultureInfo.InvariantCulture'                                      "Unable to open response file '{0}'."' responseFile));                                 }                             // load file and parse it.                             ProcessResponseFile(responseFile);                             break;                         }                         continue;                                              default:                         if (_defaultArgument != null) {                             _defaultArgument.SetValue(argument);                         } else {                             throw new CommandLineArgumentException(string.Format(CultureInfo.InvariantCulture'                                 "Unknown argument '{0}'"' argument));                         }                         break;                 }
Magic Number,NAnt.Core.Util,FileUtils,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Util\FileUtils.cs,CombinePaths,The following statement contains a magic number: (string) arList2[i] != ".." || counter < 2
Magic Number,NAnt.Core.Util,ResourceUtils,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Util\ResourceUtils.cs,GetResourceName,The following statement contains a magic number: resourceName = assemblyName.Substring(0' assemblyName.Length - 5);
Missing Default,NAnt.Core,ExpressionEvalBase,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\ExpressionEvalBase.cs,ParseRelationalExpression,The following switch statement is missing a default case: switch (op) {                     case ExpressionTokenizer.TokenType.EQ:                         if (o is string && o2 is string) {                             return o.Equals(o2);                         } else if (o is bool && o2 is bool) {                             return o.Equals(o2);                         } else if (o is int && o2 is int) {                             return o.Equals(o2);                         } else if (o is int && o2 is long) {                             return (Convert.ToInt64(o)).Equals(o2);                         } else if (o is int && o2 is double) {                             return (Convert.ToDouble(o)).Equals(o2);                         } else if (o is long && o2 is long) {                             return o.Equals(o2);                         } else if (o is long && o2 is int) {                             return (o.Equals(Convert.ToInt64(o2)));                         } else if (o is long && o2 is double) {                             return (Convert.ToDouble(o)).Equals(o2);                         } else if (o is double && o2 is double) {                             return o.Equals(o2);                         } else if (o is double && o2 is int) {                             return o.Equals(Convert.ToDouble(o2));                         } else if (o is double && o2 is long) {                             return o.Equals(Convert.ToDouble(o2));                         } else if (o is DateTime && o2 is DateTime) {                             return o.Equals(o2);                         } else if (o is TimeSpan && o2 is TimeSpan) {                             return o.Equals(o2);                         } else if (o is Version && o2 is Version) {                             return o.Equals(o2);                         } else if (o.GetType().IsEnum) {                             if (o2 is string) {                                 return o.Equals(Enum.Parse(o.GetType()' (string) o2' false));                             } else {                                 return o.Equals(Enum.ToObject(o.GetType()' o2));                             }                         } else if (o2.GetType().IsEnum) {                             if (o is string) {                                 return o2.Equals(Enum.Parse(o2.GetType()' (string) o' false));                             } else {                                 return o2.Equals(Enum.ToObject(o2.GetType()' o));                             }                         }                          throw BuildParseError(string.Format(CultureInfo.InvariantCulture'                              ResourceUtils.GetString("NA1038")'                              GetSimpleTypeName(o.GetType())' GetSimpleTypeName(o2.GetType()))'                              p0' p2);                     case ExpressionTokenizer.TokenType.NE:                         if (o is string && o2 is string) {                             return !o.Equals(o2);                         } else if (o is bool && o2 is bool) {                             return !o.Equals(o2);                         } else if (o is int && o2 is int) {                             return !o.Equals(o2);                         } else if (o is int && o2 is long) {                             return !(Convert.ToInt64(o)).Equals(o2);                         } else if (o is int && o2 is double) {                             return !(Convert.ToDouble(o)).Equals(o2);                         } else if (o is long && o2 is long) {                             return !o.Equals(o2);                         } else if (o is long && o2 is int) {                             return !(o.Equals(Convert.ToInt64(o2)));                         } else if (o is long && o2 is double) {                             return !(Convert.ToDouble(o)).Equals(o2);                         } else if (o is double && o2 is double) {                             return !o.Equals(o2);                         } else if (o is double && o2 is int) {                             return !o.Equals(Convert.ToDouble(o2));                         } else if (o is double && o2 is long) {                             return !o.Equals(Convert.ToDouble(o2));                         } else if (o is DateTime && o2 is DateTime) {                             return !o.Equals(o2);                         } else if (o is TimeSpan && o2 is TimeSpan) {                             return !o.Equals(o2);                         } else if (o is Version && o2 is Version) {                             return !o.Equals(o2);                         } else if (o.GetType().IsEnum) {                             if (o2 is string) {                                 return !o.Equals(Enum.Parse(o.GetType()' (string) o2' false));                             } else {                                 return !o.Equals(Enum.ToObject(o.GetType()' o2));                             }                         } else if (o2.GetType().IsEnum) {                             if (o is string) {                                 return !o2.Equals(Enum.Parse(o2.GetType()' (string) o' false));                             } else {                                 return !o2.Equals(Enum.ToObject(o2.GetType()' o));                             }                         }                          throw BuildParseError(string.Format(CultureInfo.InvariantCulture'                              ResourceUtils.GetString("NA1042")'                              GetSimpleTypeName(o.GetType())' GetSimpleTypeName(o2.GetType()))'                              p0' p2);                     case ExpressionTokenizer.TokenType.LT:                         if (o is string && o2 is string) {                             return string.Compare((string) o' (string) o2' false'                                  CultureInfo.InvariantCulture) < 0;                         } else if (o is bool && o2 is bool) {                             return ((IComparable) o).CompareTo(o2) < 0;                         } else if (o is int && o2 is int) {                             return ((IComparable) o).CompareTo(o2) < 0;                         } else if (o is int && o2 is long) {                             return ((IComparable) Convert.ToInt64(o)).CompareTo(o2) < 0;                         } else if (o is int && o2 is double) {                             return ((IComparable) Convert.ToDouble(o)).CompareTo(o2) < 0;                         } else if (o is long && o2 is long) {                             return ((IComparable) o).CompareTo(o2) < 0;                         } else if (o is long && o2 is int) {                             return ((IComparable) o).CompareTo(Convert.ToInt64(o2)) < 0;                         } else if (o is long && o2 is double) {                             return ((IComparable) Convert.ToDouble(o)).CompareTo(o2) < 0;                         } else if (o is double && o2 is double) {                             return ((IComparable) o).CompareTo(o2) < 0;                         } else if (o is double && o2 is int) {                             return ((IComparable) o).CompareTo(Convert.ToDouble(o2)) < 0;                         } else if (o is double && o2 is long) {                             return ((IComparable) o).CompareTo(Convert.ToDouble(o2)) < 0;                         } else if (o is DateTime && o2 is DateTime) {                             return ((IComparable) o).CompareTo(o2) < 0;                         } else if (o is TimeSpan && o2 is TimeSpan) {                             return ((IComparable) o).CompareTo(o2) < 0;                         } else if (o is Version && o2 is Version) {                             return ((IComparable) o).CompareTo(o2) < 0;                         }                          throw BuildParseError(string.Format(CultureInfo.InvariantCulture'                              ResourceUtils.GetString("NA1051")'                              GetSimpleTypeName(o.GetType())' GetSimpleTypeName(o2.GetType()))'                              p0' p2);                     case ExpressionTokenizer.TokenType.GT:                         if (o is string && o2 is string) {                             return string.Compare((string) o' (string) o2' false'                                  CultureInfo.InvariantCulture) > 0;                         } else if (o is bool && o2 is bool) {                             return ((IComparable) o).CompareTo(o2) > 0;                         } else if (o is int && o2 is int) {                             return ((IComparable) o).CompareTo(o2) > 0;                         } else if (o is int && o2 is long) {                             return ((IComparable) Convert.ToInt64(o)).CompareTo(o2) > 0;                         } else if (o is int && o2 is double) {                             return ((IComparable) Convert.ToDouble(o)).CompareTo(o2) > 0;                         } else if (o is long && o2 is long) {                             return ((IComparable) o).CompareTo(o2) > 0;                         } else if (o is long && o2 is int) {                             return ((IComparable) o).CompareTo(Convert.ToInt64(o2)) > 0;                         } else if (o is long && o2 is double) {                             return ((IComparable) Convert.ToDouble(o)).CompareTo(o2) > 0;                         } else if (o is double && o2 is double) {                             return ((IComparable) o).CompareTo(o2) > 0;                         } else if (o is double && o2 is int) {                             return ((IComparable) o).CompareTo(Convert.ToDouble(o2)) > 0;                         } else if (o is double && o2 is long) {                             return ((IComparable) o).CompareTo(Convert.ToDouble(o2)) > 0;                         } else if (o is DateTime && o2 is DateTime) {                             return ((IComparable) o).CompareTo(o2) > 0;                         } else if (o is TimeSpan && o2 is TimeSpan) {                             return ((IComparable) o).CompareTo(o2) > 0;                         } else if (o is Version && o2 is Version) {                             return ((IComparable) o).CompareTo(o2) > 0;                         }                          throw BuildParseError(string.Format(CultureInfo.InvariantCulture'                              ResourceUtils.GetString("NA1037")'                              GetSimpleTypeName(o.GetType())' GetSimpleTypeName(o2.GetType()))'                              p0' p2);                     case ExpressionTokenizer.TokenType.LE:                         if (o is string && o2 is string) {                             return string.Compare((string) o' (string) o2' false'                                  CultureInfo.InvariantCulture) <= 0;                         } else if (o is bool && o2 is bool) {                             return ((IComparable) o).CompareTo(o2) <= 0;                         } else if (o is int && o2 is int) {                             return ((IComparable) o).CompareTo(o2) <= 0;                         } else if (o is int && o2 is long) {                             return ((IComparable) Convert.ToInt64(o)).CompareTo(o2) <= 0;                         } else if (o is int && o2 is double) {                             return ((IComparable) Convert.ToDouble(o)).CompareTo(o2) <= 0;                         } else if (o is long && o2 is long) {                             return ((IComparable) o).CompareTo(o2) <= 0;                         } else if (o is long && o2 is int) {                             return ((IComparable) o).CompareTo(Convert.ToInt64(o2)) <= 0;                         } else if (o is long && o2 is double) {                             return ((IComparable) Convert.ToDouble(o)).CompareTo(o2) <= 0;                         } else if (o is double && o2 is double) {                             return ((IComparable) o).CompareTo(o2) <= 0;                         } else if (o is double && o2 is int) {                             return ((IComparable) o).CompareTo(Convert.ToDouble(o2)) <= 0;                         } else if (o is double && o2 is long) {                             return ((IComparable) o).CompareTo(Convert.ToDouble(o2)) <= 0;                         } else if (o is DateTime && o2 is DateTime) {                             return ((IComparable) o).CompareTo(o2) <= 0;                         } else if (o is TimeSpan && o2 is TimeSpan) {                             return ((IComparable) o).CompareTo(o2) <= 0;                         } else if (o is Version && o2 is Version) {                             return ((IComparable) o).CompareTo(o2) <= 0;                         }                          throw BuildParseError(string.Format(CultureInfo.InvariantCulture'                              ResourceUtils.GetString("NA1049")'                              GetSimpleTypeName(o.GetType())' GetSimpleTypeName(o2.GetType()))'                              p0' p2);                     case ExpressionTokenizer.TokenType.GE:                         if (o is string && o2 is string) {                             return string.Compare((string) o' (string) o2' false'                                  CultureInfo.InvariantCulture) >= 0;                         } else if (o is bool && o2 is bool) {                             return ((IComparable) o).CompareTo(o2) >= 0;                         } else if (o is int && o2 is int) {                             return ((IComparable) o).CompareTo(o2) >= 0;                         } else if (o is int && o2 is long) {                             return ((IComparable) Convert.ToInt64(o)).CompareTo(o2) >= 0;                         } else if (o is int && o2 is double) {                             return ((IComparable) Convert.ToDouble(o)).CompareTo(o2) >= 0;                         } else if (o is long && o2 is long) {                             return ((IComparable) o).CompareTo(o2) >= 0;                         } else if (o is long && o2 is int) {                             return ((IComparable) o).CompareTo(Convert.ToInt64(o2)) >= 0;                         } else if (o is long && o2 is double) {                             return ((IComparable) Convert.ToDouble(o)).CompareTo(o2) >= 0;                         } else if (o is double && o2 is double) {                             return ((IComparable) o).CompareTo(o2) >= 0;                         } else if (o is double && o2 is int) {                             return ((IComparable) o).CompareTo(Convert.ToDouble(o2)) >= 0;                         } else if (o is double && o2 is long) {                             return ((IComparable) o).CompareTo(Convert.ToDouble(o2)) >= 0;                         } else if (o is DateTime && o2 is DateTime) {                             return ((IComparable) o).CompareTo(o2) >= 0;                         } else if (o is TimeSpan && o2 is TimeSpan) {                             return ((IComparable) o).CompareTo(o2) >= 0;                         } else if (o is Version && o2 is Version) {                             return ((IComparable) o).CompareTo(o2) >= 0;                         }                          throw BuildParseError(string.Format(CultureInfo.InvariantCulture'                              ResourceUtils.GetString("NA1050")'                              GetSimpleTypeName(o.GetType())' GetSimpleTypeName(o2.GetType()))'                              p0' p2);                 }
Missing Default,NAnt.Core,Project,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Project.cs,GetFrameworks,The following switch statement is missing a default case: switch (framework.Vendor) {                         case VendorType.Mono:                             if ((types & FrameworkTypes.Mono) == 0)                                 continue;                             break;                         case VendorType.Microsoft:                             if ((types & FrameworkTypes.MS) == 0)                                 continue;                             break;                     }
Missing Default,NAnt.Core.Tasks,ExternalProgramBase,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\ExternalProgramBase.cs,DetermineFilePath,The following switch statement is missing a default case: switch (programLocationAttribute.LocationType) {                     case LocationType.FrameworkDir:                         if (Project.TargetFramework.FrameworkDirectory != null) {                             string frameworkDir = Project.TargetFramework.FrameworkDirectory.FullName;                             fullPath = Path.Combine(frameworkDir' ExeName + ".exe");                         } else {                             throw new BuildException(                                 string.Format(CultureInfo.InvariantCulture'                                  ResourceUtils.GetString("NA1124")'                                  Project.TargetFramework.Name));                         }                         break;                     case LocationType.FrameworkSdkDir:                         if (Project.TargetFramework.SdkDirectory != null) {                             string sdkDirectory = Project.TargetFramework.SdkDirectory.FullName;                             fullPath = Path.Combine(sdkDirectory' ExeName + ".exe");                         } else {                             throw new BuildException(                                 string.Format(CultureInfo.InvariantCulture'                                  ResourceUtils.GetString("NA1122")'                                  Project.TargetFramework.Name));                         }                         break;                 }
Missing Default,NAnt.Core.Tasks,LoopTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\LoopTask.cs,ExecuteTask,The following switch statement is missing a default case: switch (ItemType) {                     case LoopItem.File:                         if (String.IsNullOrEmpty(Source) && InElement == null) {                             throw new BuildException("Invalid foreach"' Location' new ArgumentException("Nothing to work with...!"' "in"));                         }                          if (!String.IsNullOrEmpty(Source)) {                             // resolve to full path                             Source = Project.GetFullPath(Source);                             // ensure directory exists                             if (!Directory.Exists(Source)) {                                 throw new BuildException(string.Format(                                     CultureInfo.InvariantCulture'                                     ResourceUtils.GetString("NA1134")'                                      Source)' Location);                             }                                                      if (_props.Length != 1) {                                 throw new BuildException(@"Only one property is valid for item=""File"""' Location);                             }                                                      DirectoryInfo dirInfo = new DirectoryInfo(Source);                             FileInfo[] files = dirInfo.GetFiles();                                                      foreach (FileInfo file in files) {                                 DoWork(file.FullName);                             }                         } else {                             if (StuffToDo == null) {                                 throw new BuildException("Must use <do> with <in>."' Location);                             }                              foreach (string file in InElement.Items.FileNames) {                                 DoWork(file);                             }                         }                         break;                     case LoopItem.Folder:                         if (String.IsNullOrEmpty(Source) && InElement == null) {                             throw new BuildException("Invalid foreach"' Location' new ArgumentException("Nothing to work with...!"' "in"));                         }                          if (_props.Length != 1) {                             throw new BuildException(@"Only one property is valid for item=""Folder"""' Location);                         }                          if (!String.IsNullOrEmpty(Source)) {                             // resolve to full path                             Source = Project.GetFullPath(Source);                             // ensure directory exists                             if (!Directory.Exists(Source)) {                                 throw new BuildException(string.Format(                                     CultureInfo.InvariantCulture'                                     ResourceUtils.GetString("NA1134")'                                      Source)' Location);                             }                              DirectoryInfo dirInfo = new DirectoryInfo(Source);                             DirectoryInfo[] dirs = dirInfo.GetDirectories();                             foreach (DirectoryInfo dir in dirs) {                                 DoWork(dir.FullName);                             }                          } else {                             if (StuffToDo == null) {                                 throw new BuildException("Must use <do> with <in>."' Location);                             }                              foreach (string dir in InElement.Items.DirectoryNames) {                                 DoWork(dir);                             }                         }                         break;                     case LoopItem.Line:                         if (String.IsNullOrEmpty(Source) && InElement == null) {                             throw new BuildException("Invalid foreach"' Location' new ArgumentException("Nothing to work with...!"' "in"));                         }                          if (_props.Length > 1 && Delimiter == null) {                             throw new BuildException("Delimiter(s) must be specified if multiple properties are specified"' Location);                         }                          if (!String.IsNullOrEmpty(Source)) {                             // resolve to full path                             Source = Project.GetFullPath(Source);                             // ensure file exists                             if (!File.Exists(Source)) {                                 throw new BuildException(string.Format(                                     CultureInfo.InvariantCulture'                                     ResourceUtils.GetString("NA1133")'                                      Source)' Location);                             }                              DoWorkOnFileLines(Source);                         } else {                             if (StuffToDo == null) {                                 throw new BuildException("Must use <do> with <in>."' Location);                             }                              foreach (string file in InElement.Items.FileNames) {                                 DoWorkOnFileLines(file);                             }                         }                         break;                     case LoopItem.String:                         if (String.IsNullOrEmpty(Source)) {                             return;                         }                          if (_props.Length > 1) {                             throw new BuildException(@"Only one property may be specified for item=""String"""' Location);                         }                          if (Delimiter == null) {                             throw new BuildException(@"Delimiter must be specified for item=""String"""' Location);                         }                          string[] items = Source.Split(Delimiter.ToCharArray());                         foreach (string s in items) {                             DoWork(s);                         }                         break;                 }
Missing Default,NAnt.Core.Tasks,LoopTask,C:\research\architectureSmells\repos\nant_nant\src\NAnt.Core\Tasks\LoopTask.cs,DoWork,The following switch statement is missing a default case: switch (TrimType) {                     case LoopTrim.Both:                         propValue = propValue.Trim();                         break;                     case LoopTrim.Start:                         propValue = propValue.TrimStart();                         break;                     case LoopTrim.End:                         propValue = propValue.TrimEnd();                         break;                 }
