Implementation smell,Namespace,Class,File,Method,Description
Long Method,HebMorph,Tokenizer,C:\repos\synhershko_HebMorph\dotNet\HebMorph\Tokenizer.cs,NextToken,The method has 135 lines of code.
Long Method,HebMorph.DataStructures,DictRadix<T>,C:\repos\synhershko_HebMorph\dotNet\HebMorph\DataStructures\DictRadix.cs,AddNode,The method has 138 lines of code.
Complex Method,HebMorph,LookupTolerators,C:\repos\synhershko_HebMorph\dotNet\HebMorph\LookupTolerators.cs,TolerateEmKryiaYud,Cyclomatic complexity of the method is 9
Complex Method,HebMorph,Lemmatizer,C:\repos\synhershko_HebMorph\dotNet\HebMorph\Lemmatizer.cs,Lemmatize,Cyclomatic complexity of the method is 9
Complex Method,HebMorph,Lemmatizer,C:\repos\synhershko_HebMorph\dotNet\HebMorph\Lemmatizer.cs,LemmatizeTolerant,Cyclomatic complexity of the method is 12
Complex Method,HebMorph,Lemmatizer,C:\repos\synhershko_HebMorph\dotNet\HebMorph\Lemmatizer.cs,Lemmatize,Cyclomatic complexity of the method is 9
Complex Method,HebMorph,StreamLemmatizer,C:\repos\synhershko_HebMorph\dotNet\HebMorph\StreamLemmatizer.cs,LemmatizeNextToken,Cyclomatic complexity of the method is 13
Complex Method,HebMorph,Tokenizer,C:\repos\synhershko_HebMorph\dotNet\HebMorph\Tokenizer.cs,NextToken,Cyclomatic complexity of the method is 15
Complex Method,HebMorph.HSpell,LingInfo,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2HebrewString,Cyclomatic complexity of the method is 13
Complex Method,HebMorph.HSpell,LingInfo,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2EnglishString,Cyclomatic complexity of the method is 13
Complex Method,HebMorph.DataStructures,DictRadix<T>,C:\repos\synhershko_HebMorph\dotNet\HebMorph\DataStructures\DictRadix.cs,AddNode,Cyclomatic complexity of the method is 11
Complex Method,HebMorph.DataStructures,TolerantLookupCrawler,C:\repos\synhershko_HebMorph\dotNet\HebMorph\DataStructures\DictRadix.cs,DoKeyMatching,Cyclomatic complexity of the method is 10
Long Parameter List,HebMorph,HebrewToken,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HebrewToken.cs,HebrewToken,The method has 5 parameters. Parameters: _word' _prefixLength' _mask' _lemma' _score
Long Parameter List,HebMorph,LookupTolerators,C:\repos\synhershko_HebMorph\dotNet\HebMorph\LookupTolerators.cs,TolerateEmKryiaYud,The method has 5 parameters. Parameters: key' keyPos' word' score' curChar
Long Parameter List,HebMorph,LookupTolerators,C:\repos\synhershko_HebMorph\dotNet\HebMorph\LookupTolerators.cs,TolerateEmKryiaVav,The method has 5 parameters. Parameters: key' keyPos' word' score' curChar
Long Parameter List,HebMorph,LookupTolerators,C:\repos\synhershko_HebMorph\dotNet\HebMorph\LookupTolerators.cs,TolerateNonDoubledConsonantVav,The method has 5 parameters. Parameters: key' keyPos' word' score' curChar
Long Statement,HebMorph,LookupTolerators,C:\repos\synhershko_HebMorph\dotNet\HebMorph\LookupTolerators.cs,TolerateEmKryiaVav,The length of the statement  "                keyPos == 0 || keyPos + 1 == key.Length || // check this isn't the end or the beginning of a word (no one misses Vav there) " is 123.
Long Statement,HebMorph,Lemmatizer,C:\repos\synhershko_HebMorph\dotNet\HebMorph\Lemmatizer.cs,Lemmatize,The length of the statement  "                            yield return new HebrewToken(word' prefLen' (DMask)(byte)result.DescFlag' result.Lemma' 0.9f) {Type = WordType.HEBREW_WITH_PREFIX}; " is 131.
Long Statement,HebMorph,Lemmatizer,C:\repos\synhershko_HebMorph\dotNet\HebMorph\Lemmatizer.cs,LemmatizeTolerant,The length of the statement  "                        yield return new HebrewToken(lr.Word' 0' (DMask)(byte)result.DescFlag' result.Lemma' lr.Score) {Type = WordType.HEBREW_TOLERATED}; " is 130.
Long Statement,HebMorph,Lemmatizer,C:\repos\synhershko_HebMorph\dotNet\HebMorph\Lemmatizer.cs,LemmatizeTolerant,The length of the statement  "                                yield return new HebrewToken(word.Substring(0' prefLen) + lr.Word' prefLen' (DMask)(byte)result.DescFlag' result.Lemma' lr.Score*0.9f) " is 134.
Long Statement,HebMorph.HSpell,Loader,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,LoadDictionaryFromHSpellFolder,The length of the statement  "                using (var dataLoader = new MorphDataLoader(path + HSpell.Constants.DescFile' path + Constants.StemsFile' path + HSpell.Constants.DmasksFile)) " is 142.
Long Statement,HebMorph.HSpell,Loader,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,LoadDictionaryFromHSpellFolder,The length of the statement  "                            data.Lemmas[stemPosition] = new MorphData.Entry(lemma' (MorphData.DescFlag)((byte)DescFlags[stemPosition] & 3)' dmaskToPrefix((byte)DescFlags[stemPosition])); " is 158.
Long Statement,HebMorph.HSpell,Loader,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,dmaskToPrefix,The length of the statement  "            else if (((dmask & (int)DMask.D_TYPEMASK) == (int)DMask.D_NOUN) || ((dmask & (int)DMask.D_TYPEMASK) == (int)DMask.D_ADJ)) " is 121.
Long Statement,HebMorph.HSpell,Loader,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,dmaskToPrefix,The length of the statement  "                if (((dmask & (int)DMask.D_OSMICHUT) > 0) || ((dmask & (int)DMask.D_OMASK) > 0) || ((dmask & (int)DMask.D_SPECNOUN) > 0)) " is 121.
Long Statement,HebMorph.DataStructures,TolerantLookupCrawler,C:\repos\synhershko_HebMorph\dotNet\HebMorph\DataStructures\DictRadix.cs,DoKeyMatching,The length of the statement  "                            //System.Diagnostics.Trace.WriteLine(string.Format("{0} tolerated a char' attempting word {1}"' tf.Method.Name' mc.Word + node._Key[nodeKeyPos])); " is 146.
Complex Conditional,HebMorph,LookupTolerators,C:\repos\synhershko_HebMorph\dotNet\HebMorph\LookupTolerators.cs,TolerateEmKryiaVav,The conditional expression  "curChar != 'ו' || // check current trie position                  keyPos == 0 || keyPos + 1 == key.Length || // check this isn't the end or the beginning of a word (no one misses Vav there)                  key[keyPos] == 'י' || key[keyPos] == 'ה' || // Vav shouldn't be tolerated before a Yud or a Heh                  key[keyPos] == 'ו'"  is complex.
Complex Conditional,HebMorph,Tokenizer,C:\repos\synhershko_HebMorph\dotNet\HebMorph\Tokenizer.cs,NextToken,The conditional expression  "(c >= 1488 && c <= 1514) || (c >= 1455 && c <= 1476)"  is complex.
Complex Conditional,HebMorph.DataStructures,DictRadix<T>,C:\repos\synhershko_HebMorph\dotNet\HebMorph\DataStructures\DictRadix.cs,AddNode,The conditional expression  "n < child.Key.Length && keyPos < keyLength && child.Key[n] == key[keyPos] && key[keyPos] != '\0'"  is complex.
Complex Conditional,HebMorph.DataStructures,RealSortedList<T>,C:\repos\synhershko_HebMorph\dotNet\HebMorph\DataStructures\RealSortedList.cs,Add,The conditional expression  "(sortOrder == SortOrder.Desc && cmp < 0) || (sortOrder == SortOrder.Asc && cmp > 0)"  is complex.
Magic Number,HebMorph,LookupTolerators,C:\repos\synhershko_HebMorph\dotNet\HebMorph\LookupTolerators.cs,TolerateEmKryiaYud,The following statement contains a magic number: if (word[word.Length - 1] == 'י')              {                  // We allow adding another Yud only if there was one in the key originally' and the key is longer                  // than 3 letters (otherwise חיה becomes חייה' and בית becomes ביית).                  if (key[keyPos - 1] != 'י' || (keyPos + 1 == key.Length && key.Length <= 3))                      return null;                    score *= 0.8f;                  return 1;              }              // No Yud existed before in the key' so we tolerate normally unless we consumed a Vav recently              else if (word[word.Length - 1] != 'ו')              {                  score *= 0.8f;                  return 1;              }
Magic Number,HebMorph,Lemmatizer,C:\repos\synhershko_HebMorph\dotNet\HebMorph\Lemmatizer.cs,RemoveNiqqud,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  if (word[i] < 1455 || word[i] > 1476) // current position is not a Niqqud character                      sb.Append(word[i]);              }
Magic Number,HebMorph,Lemmatizer,C:\repos\synhershko_HebMorph\dotNet\HebMorph\Lemmatizer.cs,RemoveNiqqud,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  if (word[i] < 1455 || word[i] > 1476) // current position is not a Niqqud character                      sb.Append(word[i]);              }
Magic Number,HebMorph,Lemmatizer,C:\repos\synhershko_HebMorph\dotNet\HebMorph\Lemmatizer.cs,Lemmatize,The following statement contains a magic number: while (true)              {                  // Make sure there are at least 2 letters left after the prefix (the words של' שלא for example)                  if (word.Length - prefLen < 2)                      break;                    int prefixMask = m_prefixes.Lookup(word.Substring(0' ++prefLen));                  if (prefixMask == 0) // no such prefix                      break;                    md = m_dict.Lookup(word.Substring(prefLen));                  if (md != null && (md.Prefixes & prefixMask) > 0)                  {                      foreach (var result in md.Lemmas)                      {                          if (((int) HSpell.LingInfo.dmask2ps((DMask)(byte)result.DescFlag) & prefixMask) > 0)                              yield return new HebrewToken(word' prefLen' (DMask)(byte)result.DescFlag' result.Lemma' 0.9f) {Type = WordType.HEBREW_WITH_PREFIX};                      }                  }              }
Magic Number,HebMorph,Lemmatizer,C:\repos\synhershko_HebMorph\dotNet\HebMorph\Lemmatizer.cs,LemmatizeTolerant,The following statement contains a magic number: if (word.Length > 19)              {                  yield break;              }
Magic Number,HebMorph,Lemmatizer,C:\repos\synhershko_HebMorph\dotNet\HebMorph\Lemmatizer.cs,LemmatizeTolerant,The following statement contains a magic number: while (true)              {                  // Make sure there are at least 2 letters left after the prefix (the words של' שלא for example)                  if (word.Length - prefLen < 2)                      break;                    int prefixMask = m_prefixes.Lookup(word.Substring(0' ++prefLen));                  if (prefixMask == 0) // no such prefix                      break;                    tolerated = m_dict.LookupTolerant(word.Substring(prefLen)' LookupTolerators.TolerateEmKryiaAll);                  if (tolerated != null)                  {                      foreach (DictRadix<MorphData>.LookupResult lr in tolerated)                      {                          foreach (var result in lr.Data.Lemmas)                          {                              if (((int) HSpell.LingInfo.dmask2ps((DMask)(byte)result.DescFlag) & prefixMask) > 0)                                  yield return new HebrewToken(word.Substring(0' prefLen) + lr.Word' prefLen' (DMask)(byte)result.DescFlag' result.Lemma' lr.Score*0.9f)                                  { Type = WordType.HEBREW_TOLERATED_WITH_PREFIX };                          }                      }                  }              }
Magic Number,HebMorph,Tokenizer,C:\repos\synhershko_HebMorph\dotNet\HebMorph\Tokenizer.cs,IsHebrewLetter,The following statement contains a magic number: return (c >= 1488 && c <= 1514);
Magic Number,HebMorph,Tokenizer,C:\repos\synhershko_HebMorph\dotNet\HebMorph\Tokenizer.cs,IsHebrewLetter,The following statement contains a magic number: return (c >= 1488 && c <= 1514);
Magic Number,HebMorph,Tokenizer,C:\repos\synhershko_HebMorph\dotNet\HebMorph\Tokenizer.cs,IsNiqqudChar,The following statement contains a magic number: return (c >= 1455 && c <= 1476);
Magic Number,HebMorph,Tokenizer,C:\repos\synhershko_HebMorph\dotNet\HebMorph\Tokenizer.cs,IsNiqqudChar,The following statement contains a magic number: return (c >= 1455 && c <= 1476);
Magic Number,HebMorph,Tokenizer,C:\repos\synhershko_HebMorph\dotNet\HebMorph\Tokenizer.cs,NextToken,The following statement contains a magic number: while (true)              {  				if (ioBufferIndex >= dataLen)  				{  					inputOffset += dataLen;  					dataLen = input.Read(ioBuffer' 0' ioBuffer.Length);  					if (dataLen <= 0)  					{  						dataLen = 0; // so next offset += dataLen won't decrement offset  						if (length > 0)  							break;    						tokenString = string.Empty;  						tokenLengthInSource = 0;  						return 0;  					}  					ioBufferIndex = 0;  				}                	char c = ioBuffer[ioBufferIndex++];                  bool appendCurrentChar = false;                    // In case we already consumed at least one char' and started a non-Hebrew token.                  // Since tokenizing non-Hebrew characters correctly is out of scope for this implementation'                  // we will consume all non-spaces and non-panctuation and return them as-is.                  if (length > 0 && (tokenType & TokenType.NonHebrew) > 0)                  {                      // No such thing as mixed words; return the current word and go back                      if ((c >= 1488 && c <= 1514) || (c >= 1455 && c <= 1476)) // HEBREW || NIQQUD                      {                          --ioBufferIndex;                          break;                      }                      else if (Char.IsLetterOrDigit(c))// TODO: break to prevent mixing of non-Hebrew and digits as well?                      {                          appendCurrentChar = true;                      }                      else                          break; // Tokenize on everything else                  }                  else if (IsHebrewLetter(c) || (length > 0 && IsNiqqudChar(c))) // HEBREW || (NIQQUD if not first char)                  {                      tokenType |= TokenType.Hebrew;                      appendCurrentChar = true;                  }                  else if (Char.IsLetterOrDigit(c))                  {                      // If met while consuming a Hebrew word' we return the current word (no such thing as mixed words)                      if (length > 0 && (tokenType & TokenType.Hebrew) > 0)                      {                          --ioBufferIndex;                          break;                      }                        tokenType |= TokenType.NonHebrew;                      if (Char.IsDigit(c)) // TODO: break to prevent mixing of non-Hebrew and digits as well?                          tokenType |= TokenType.Numeric;                        appendCurrentChar = true;                  }                  else if (IsOfChars(c' Gershayim) && length > 0)                  {                      // Tokenize if previous char wasn't part of a word                      if (!IsHebrewLetter(wordBuffer[length - 1]) && !IsNiqqudChar(wordBuffer[length - 1]))                          break;                        // TODO: Is it possible to support cases like שה"שםעצם in the tokenizer?                      tokenType |= TokenType.Acronym;                      appendCurrentChar = true;                  }                  else if (IsOfChars(c' Geresh) && length > 0)                  {                      // Tokenize if previous char wasn't part of a word or another Geresh (which we handle below)                      if (!IsHebrewLetter(wordBuffer[length - 1]) && !IsNiqqudChar(wordBuffer[length - 1])                          && !IsOfChars(wordBuffer[length - 1]' Geresh))                          break;                        // TODO: Is it possible to handle cases which are similar to Merchaot - ה'חלל הפנוי' here?                      tokenType |= TokenType.Acronym;                      appendCurrentChar = true;                  }                  else if (length > 0)                  {                      // Flag makaf connected words as constructs                      if (IsOfChars(c' Makaf)) // TODO: Normalize or support other types of dashes too                          tokenType |= TokenType.Construct;                      // TODO: Detect words where Makaf is used for shortening a word (א-ל' י-ם and similar)' instead of tokenizing on it                        // at non-Letter w/ chars                      break; // return 'em                  }                    if (appendCurrentChar)                  {                      // Consume normally                      if (length == 0) // mark the start of a new token                          tokenOffset = inputOffset + ioBufferIndex - 1;                      else if (length == wordBuffer.Length)                          // buffer overflow!                          break;                        // Fix a common replacement of double-Geresh with Gershayim; call it Gershayim normalization if you wish                      if (IsOfChars(c' Geresh))                      {                          if (wordBuffer[length - 1] == c)                              wordBuffer[length - 1] = '"';                          /*else if (IsOfChars(wordBuffer[length - 1]' LettersAcceptingGeresh))                              wordBuffer[length++] = c;                           */                          else                              wordBuffer[length++] = c;                      }                      else                          wordBuffer[length++] = c; // TODO: Normalize c                  }              }
Magic Number,HebMorph,Tokenizer,C:\repos\synhershko_HebMorph\dotNet\HebMorph\Tokenizer.cs,NextToken,The following statement contains a magic number: while (true)              {  				if (ioBufferIndex >= dataLen)  				{  					inputOffset += dataLen;  					dataLen = input.Read(ioBuffer' 0' ioBuffer.Length);  					if (dataLen <= 0)  					{  						dataLen = 0; // so next offset += dataLen won't decrement offset  						if (length > 0)  							break;    						tokenString = string.Empty;  						tokenLengthInSource = 0;  						return 0;  					}  					ioBufferIndex = 0;  				}                	char c = ioBuffer[ioBufferIndex++];                  bool appendCurrentChar = false;                    // In case we already consumed at least one char' and started a non-Hebrew token.                  // Since tokenizing non-Hebrew characters correctly is out of scope for this implementation'                  // we will consume all non-spaces and non-panctuation and return them as-is.                  if (length > 0 && (tokenType & TokenType.NonHebrew) > 0)                  {                      // No such thing as mixed words; return the current word and go back                      if ((c >= 1488 && c <= 1514) || (c >= 1455 && c <= 1476)) // HEBREW || NIQQUD                      {                          --ioBufferIndex;                          break;                      }                      else if (Char.IsLetterOrDigit(c))// TODO: break to prevent mixing of non-Hebrew and digits as well?                      {                          appendCurrentChar = true;                      }                      else                          break; // Tokenize on everything else                  }                  else if (IsHebrewLetter(c) || (length > 0 && IsNiqqudChar(c))) // HEBREW || (NIQQUD if not first char)                  {                      tokenType |= TokenType.Hebrew;                      appendCurrentChar = true;                  }                  else if (Char.IsLetterOrDigit(c))                  {                      // If met while consuming a Hebrew word' we return the current word (no such thing as mixed words)                      if (length > 0 && (tokenType & TokenType.Hebrew) > 0)                      {                          --ioBufferIndex;                          break;                      }                        tokenType |= TokenType.NonHebrew;                      if (Char.IsDigit(c)) // TODO: break to prevent mixing of non-Hebrew and digits as well?                          tokenType |= TokenType.Numeric;                        appendCurrentChar = true;                  }                  else if (IsOfChars(c' Gershayim) && length > 0)                  {                      // Tokenize if previous char wasn't part of a word                      if (!IsHebrewLetter(wordBuffer[length - 1]) && !IsNiqqudChar(wordBuffer[length - 1]))                          break;                        // TODO: Is it possible to support cases like שה"שםעצם in the tokenizer?                      tokenType |= TokenType.Acronym;                      appendCurrentChar = true;                  }                  else if (IsOfChars(c' Geresh) && length > 0)                  {                      // Tokenize if previous char wasn't part of a word or another Geresh (which we handle below)                      if (!IsHebrewLetter(wordBuffer[length - 1]) && !IsNiqqudChar(wordBuffer[length - 1])                          && !IsOfChars(wordBuffer[length - 1]' Geresh))                          break;                        // TODO: Is it possible to handle cases which are similar to Merchaot - ה'חלל הפנוי' here?                      tokenType |= TokenType.Acronym;                      appendCurrentChar = true;                  }                  else if (length > 0)                  {                      // Flag makaf connected words as constructs                      if (IsOfChars(c' Makaf)) // TODO: Normalize or support other types of dashes too                          tokenType |= TokenType.Construct;                      // TODO: Detect words where Makaf is used for shortening a word (א-ל' י-ם and similar)' instead of tokenizing on it                        // at non-Letter w/ chars                      break; // return 'em                  }                    if (appendCurrentChar)                  {                      // Consume normally                      if (length == 0) // mark the start of a new token                          tokenOffset = inputOffset + ioBufferIndex - 1;                      else if (length == wordBuffer.Length)                          // buffer overflow!                          break;                        // Fix a common replacement of double-Geresh with Gershayim; call it Gershayim normalization if you wish                      if (IsOfChars(c' Geresh))                      {                          if (wordBuffer[length - 1] == c)                              wordBuffer[length - 1] = '"';                          /*else if (IsOfChars(wordBuffer[length - 1]' LettersAcceptingGeresh))                              wordBuffer[length++] = c;                           */                          else                              wordBuffer[length++] = c;                      }                      else                          wordBuffer[length++] = c; // TODO: Normalize c                  }              }
Magic Number,HebMorph,Tokenizer,C:\repos\synhershko_HebMorph\dotNet\HebMorph\Tokenizer.cs,NextToken,The following statement contains a magic number: while (true)              {  				if (ioBufferIndex >= dataLen)  				{  					inputOffset += dataLen;  					dataLen = input.Read(ioBuffer' 0' ioBuffer.Length);  					if (dataLen <= 0)  					{  						dataLen = 0; // so next offset += dataLen won't decrement offset  						if (length > 0)  							break;    						tokenString = string.Empty;  						tokenLengthInSource = 0;  						return 0;  					}  					ioBufferIndex = 0;  				}                	char c = ioBuffer[ioBufferIndex++];                  bool appendCurrentChar = false;                    // In case we already consumed at least one char' and started a non-Hebrew token.                  // Since tokenizing non-Hebrew characters correctly is out of scope for this implementation'                  // we will consume all non-spaces and non-panctuation and return them as-is.                  if (length > 0 && (tokenType & TokenType.NonHebrew) > 0)                  {                      // No such thing as mixed words; return the current word and go back                      if ((c >= 1488 && c <= 1514) || (c >= 1455 && c <= 1476)) // HEBREW || NIQQUD                      {                          --ioBufferIndex;                          break;                      }                      else if (Char.IsLetterOrDigit(c))// TODO: break to prevent mixing of non-Hebrew and digits as well?                      {                          appendCurrentChar = true;                      }                      else                          break; // Tokenize on everything else                  }                  else if (IsHebrewLetter(c) || (length > 0 && IsNiqqudChar(c))) // HEBREW || (NIQQUD if not first char)                  {                      tokenType |= TokenType.Hebrew;                      appendCurrentChar = true;                  }                  else if (Char.IsLetterOrDigit(c))                  {                      // If met while consuming a Hebrew word' we return the current word (no such thing as mixed words)                      if (length > 0 && (tokenType & TokenType.Hebrew) > 0)                      {                          --ioBufferIndex;                          break;                      }                        tokenType |= TokenType.NonHebrew;                      if (Char.IsDigit(c)) // TODO: break to prevent mixing of non-Hebrew and digits as well?                          tokenType |= TokenType.Numeric;                        appendCurrentChar = true;                  }                  else if (IsOfChars(c' Gershayim) && length > 0)                  {                      // Tokenize if previous char wasn't part of a word                      if (!IsHebrewLetter(wordBuffer[length - 1]) && !IsNiqqudChar(wordBuffer[length - 1]))                          break;                        // TODO: Is it possible to support cases like שה"שםעצם in the tokenizer?                      tokenType |= TokenType.Acronym;                      appendCurrentChar = true;                  }                  else if (IsOfChars(c' Geresh) && length > 0)                  {                      // Tokenize if previous char wasn't part of a word or another Geresh (which we handle below)                      if (!IsHebrewLetter(wordBuffer[length - 1]) && !IsNiqqudChar(wordBuffer[length - 1])                          && !IsOfChars(wordBuffer[length - 1]' Geresh))                          break;                        // TODO: Is it possible to handle cases which are similar to Merchaot - ה'חלל הפנוי' here?                      tokenType |= TokenType.Acronym;                      appendCurrentChar = true;                  }                  else if (length > 0)                  {                      // Flag makaf connected words as constructs                      if (IsOfChars(c' Makaf)) // TODO: Normalize or support other types of dashes too                          tokenType |= TokenType.Construct;                      // TODO: Detect words where Makaf is used for shortening a word (א-ל' י-ם and similar)' instead of tokenizing on it                        // at non-Letter w/ chars                      break; // return 'em                  }                    if (appendCurrentChar)                  {                      // Consume normally                      if (length == 0) // mark the start of a new token                          tokenOffset = inputOffset + ioBufferIndex - 1;                      else if (length == wordBuffer.Length)                          // buffer overflow!                          break;                        // Fix a common replacement of double-Geresh with Gershayim; call it Gershayim normalization if you wish                      if (IsOfChars(c' Geresh))                      {                          if (wordBuffer[length - 1] == c)                              wordBuffer[length - 1] = '"';                          /*else if (IsOfChars(wordBuffer[length - 1]' LettersAcceptingGeresh))                              wordBuffer[length++] = c;                           */                          else                              wordBuffer[length++] = c;                      }                      else                          wordBuffer[length++] = c; // TODO: Normalize c                  }              }
Magic Number,HebMorph,Tokenizer,C:\repos\synhershko_HebMorph\dotNet\HebMorph\Tokenizer.cs,NextToken,The following statement contains a magic number: while (true)              {  				if (ioBufferIndex >= dataLen)  				{  					inputOffset += dataLen;  					dataLen = input.Read(ioBuffer' 0' ioBuffer.Length);  					if (dataLen <= 0)  					{  						dataLen = 0; // so next offset += dataLen won't decrement offset  						if (length > 0)  							break;    						tokenString = string.Empty;  						tokenLengthInSource = 0;  						return 0;  					}  					ioBufferIndex = 0;  				}                	char c = ioBuffer[ioBufferIndex++];                  bool appendCurrentChar = false;                    // In case we already consumed at least one char' and started a non-Hebrew token.                  // Since tokenizing non-Hebrew characters correctly is out of scope for this implementation'                  // we will consume all non-spaces and non-panctuation and return them as-is.                  if (length > 0 && (tokenType & TokenType.NonHebrew) > 0)                  {                      // No such thing as mixed words; return the current word and go back                      if ((c >= 1488 && c <= 1514) || (c >= 1455 && c <= 1476)) // HEBREW || NIQQUD                      {                          --ioBufferIndex;                          break;                      }                      else if (Char.IsLetterOrDigit(c))// TODO: break to prevent mixing of non-Hebrew and digits as well?                      {                          appendCurrentChar = true;                      }                      else                          break; // Tokenize on everything else                  }                  else if (IsHebrewLetter(c) || (length > 0 && IsNiqqudChar(c))) // HEBREW || (NIQQUD if not first char)                  {                      tokenType |= TokenType.Hebrew;                      appendCurrentChar = true;                  }                  else if (Char.IsLetterOrDigit(c))                  {                      // If met while consuming a Hebrew word' we return the current word (no such thing as mixed words)                      if (length > 0 && (tokenType & TokenType.Hebrew) > 0)                      {                          --ioBufferIndex;                          break;                      }                        tokenType |= TokenType.NonHebrew;                      if (Char.IsDigit(c)) // TODO: break to prevent mixing of non-Hebrew and digits as well?                          tokenType |= TokenType.Numeric;                        appendCurrentChar = true;                  }                  else if (IsOfChars(c' Gershayim) && length > 0)                  {                      // Tokenize if previous char wasn't part of a word                      if (!IsHebrewLetter(wordBuffer[length - 1]) && !IsNiqqudChar(wordBuffer[length - 1]))                          break;                        // TODO: Is it possible to support cases like שה"שםעצם in the tokenizer?                      tokenType |= TokenType.Acronym;                      appendCurrentChar = true;                  }                  else if (IsOfChars(c' Geresh) && length > 0)                  {                      // Tokenize if previous char wasn't part of a word or another Geresh (which we handle below)                      if (!IsHebrewLetter(wordBuffer[length - 1]) && !IsNiqqudChar(wordBuffer[length - 1])                          && !IsOfChars(wordBuffer[length - 1]' Geresh))                          break;                        // TODO: Is it possible to handle cases which are similar to Merchaot - ה'חלל הפנוי' here?                      tokenType |= TokenType.Acronym;                      appendCurrentChar = true;                  }                  else if (length > 0)                  {                      // Flag makaf connected words as constructs                      if (IsOfChars(c' Makaf)) // TODO: Normalize or support other types of dashes too                          tokenType |= TokenType.Construct;                      // TODO: Detect words where Makaf is used for shortening a word (א-ל' י-ם and similar)' instead of tokenizing on it                        // at non-Letter w/ chars                      break; // return 'em                  }                    if (appendCurrentChar)                  {                      // Consume normally                      if (length == 0) // mark the start of a new token                          tokenOffset = inputOffset + ioBufferIndex - 1;                      else if (length == wordBuffer.Length)                          // buffer overflow!                          break;                        // Fix a common replacement of double-Geresh with Gershayim; call it Gershayim normalization if you wish                      if (IsOfChars(c' Geresh))                      {                          if (wordBuffer[length - 1] == c)                              wordBuffer[length - 1] = '"';                          /*else if (IsOfChars(wordBuffer[length - 1]' LettersAcceptingGeresh))                              wordBuffer[length++] = c;                           */                          else                              wordBuffer[length++] = c;                      }                      else                          wordBuffer[length++] = c; // TODO: Normalize c                  }              }
Magic Number,HebMorph,Tokenizer,C:\repos\synhershko_HebMorph\dotNet\HebMorph\Tokenizer.cs,NextToken,The following statement contains a magic number: if (length > 2 && IsOfChars(wordBuffer[length - 1]' Geresh))              {                  // All letters which this Geresh may mean something for                  if (!IsOfChars(wordBuffer[length - 2]' LettersAcceptingGeresh))                  {                      wordBuffer[--length] = '\0';                      tokenLengthInSource--; // Don't include this Geresh in the offset calculation                  }                  // TODO: Support marking abbrevations (פרופ') and Hebrew's th (ת')                  // TODO: Handle ה (Hashem)              }
Magic Number,HebMorph,Tokenizer,C:\repos\synhershko_HebMorph\dotNet\HebMorph\Tokenizer.cs,NextToken,The following statement contains a magic number: if (length > 2 && IsOfChars(wordBuffer[length - 1]' Geresh))              {                  // All letters which this Geresh may mean something for                  if (!IsOfChars(wordBuffer[length - 2]' LettersAcceptingGeresh))                  {                      wordBuffer[--length] = '\0';                      tokenLengthInSource--; // Don't include this Geresh in the offset calculation                  }                  // TODO: Support marking abbrevations (פרופ') and Hebrew's th (ת')                  // TODO: Handle ה (Hashem)              }
Magic Number,HebMorph.HSpell,Loader,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,LoadDictionaryFromHSpellFolder,The following statement contains a magic number: if (bLoadMorphData)              {                  // Load the count of morphological data slots required                  int lookupLen = GetWordCountInHSpellFolder(path);                  var lookup = new string[lookupLen + 1];                    using (GZipStream fdict = new GZipStream(File.OpenRead(path + Constants.DictionaryFile)' CompressionMode.Decompress))                  {                      var sbuf = new char[Constants.MaxWordLength];                      int c = 0' n' slen = 0' i = 0;                      while ((c = fdict.ReadByte()) > -1)                      {                          if (c >= '0' && c <= '9') // No conversion required for chars < 0xBE                          {                              /* new word - finalize and save old word */                              lookup[i++] = new string(sbuf' 0' slen);                                /* and read how much to go back */                              n = 0;                              do                              {                                  /* base 10... */                                  n *= 10;                                  n += (c - '0');                              } while ((c = fdict.ReadByte()) > -1 && c >= '0' && c <= '9');                              slen -= n;                          }                          sbuf[slen++] = ISO8859_To_Unicode(c);                      }                  }                    using (var dataLoader = new MorphDataLoader(path + HSpell.Constants.DescFile' path + Constants.StemsFile' path + HSpell.Constants.DmasksFile))                  using (var fprefixes = new GZipStream(File.OpenRead(path + HSpell.Constants.PrefixesFile)' CompressionMode.Decompress))                  {                      DictRadix<MorphData> ret = new DictRadix<MorphData>();                        for (int i = 0; lookup[i] != null; i++)                      {                          MorphData data = new MorphData {Prefixes = Convert.ToByte(fprefixes.ReadByte())};                          // Read prefix hint byte                          var DescFlags = dataLoader.ReadDescFile();                            var stemReferences = dataLoader.ReadStemFile();                          data.Lemmas = new List<MorphData.Entry>(stemReferences.Count);                          int stemPosition = 0;                          foreach (int r in stemReferences)                          {                              // This is a bypass for the psuedo-stem "שונות"' as defined by hspell                              // TODO: Try looking into changing this in hspell itself                              string lemma;                              if (lookup[r].Equals("שונות") && !lookup[r].Equals(lookup[i]))                              {                                  lemma = null;                              }                              else                              {                                  lemma = lookup[r];                              }                              data.Lemmas[stemPosition] = new MorphData.Entry(lemma' (MorphData.DescFlag)((byte)DescFlags[stemPosition] & 3)' dmaskToPrefix((byte)DescFlags[stemPosition]));                              stemPosition++;                          }                          ret.AddNode(lookup[i]' data);                      }                        return ret;                  }              }              else // Use optimized version for loading HSpell's dictionary files              {                  using (var fdict = new GZipStream(File.OpenRead(path + HSpell.Constants.DictionaryFile)' CompressionMode.Decompress))                  using (var fprefixes = new GZipStream(File.OpenRead(path + HSpell.Constants.PrefixesFile)' CompressionMode.Decompress))                  {                      var ret = new DictRadix<MorphData>();                        var sbuf = new char[HSpell.Constants.MaxWordLength];                      int c = 0' n' slen = 0;                      while ((c = fdict.ReadByte()) > -1)                      {                          if (c >= '0' && c <= '9') // No conversion required for chars < 0xBE                          {                              /* new word - finalize old word first (set value) */                              sbuf[slen] = '\0';                                // TODO: Avoid creating new MorphData object' and enhance DictRadix to store                              // the prefixes mask in the node itself                              MorphData data = new MorphData();                              data.Prefixes = Convert.ToByte(fprefixes.ReadByte()); // Read prefix hint byte                              ret.AddNode(sbuf' data);                                /* and read how much to go back */                              n = 0;                              do                              {                                  /* base 10... */                                  n *= 10;                                  n += (c - '0');                              } while ((c = fdict.ReadByte()) > -1 && c >= '0' && c <= '9');                              slen -= n;                          }                          sbuf[slen++] = ISO8859_To_Unicode(c);                      }                        return ret;                  }              }
Magic Number,HebMorph.HSpell,Loader,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,LoadDictionaryFromHSpellFolder,The following statement contains a magic number: if (bLoadMorphData)              {                  // Load the count of morphological data slots required                  int lookupLen = GetWordCountInHSpellFolder(path);                  var lookup = new string[lookupLen + 1];                    using (GZipStream fdict = new GZipStream(File.OpenRead(path + Constants.DictionaryFile)' CompressionMode.Decompress))                  {                      var sbuf = new char[Constants.MaxWordLength];                      int c = 0' n' slen = 0' i = 0;                      while ((c = fdict.ReadByte()) > -1)                      {                          if (c >= '0' && c <= '9') // No conversion required for chars < 0xBE                          {                              /* new word - finalize and save old word */                              lookup[i++] = new string(sbuf' 0' slen);                                /* and read how much to go back */                              n = 0;                              do                              {                                  /* base 10... */                                  n *= 10;                                  n += (c - '0');                              } while ((c = fdict.ReadByte()) > -1 && c >= '0' && c <= '9');                              slen -= n;                          }                          sbuf[slen++] = ISO8859_To_Unicode(c);                      }                  }                    using (var dataLoader = new MorphDataLoader(path + HSpell.Constants.DescFile' path + Constants.StemsFile' path + HSpell.Constants.DmasksFile))                  using (var fprefixes = new GZipStream(File.OpenRead(path + HSpell.Constants.PrefixesFile)' CompressionMode.Decompress))                  {                      DictRadix<MorphData> ret = new DictRadix<MorphData>();                        for (int i = 0; lookup[i] != null; i++)                      {                          MorphData data = new MorphData {Prefixes = Convert.ToByte(fprefixes.ReadByte())};                          // Read prefix hint byte                          var DescFlags = dataLoader.ReadDescFile();                            var stemReferences = dataLoader.ReadStemFile();                          data.Lemmas = new List<MorphData.Entry>(stemReferences.Count);                          int stemPosition = 0;                          foreach (int r in stemReferences)                          {                              // This is a bypass for the psuedo-stem "שונות"' as defined by hspell                              // TODO: Try looking into changing this in hspell itself                              string lemma;                              if (lookup[r].Equals("שונות") && !lookup[r].Equals(lookup[i]))                              {                                  lemma = null;                              }                              else                              {                                  lemma = lookup[r];                              }                              data.Lemmas[stemPosition] = new MorphData.Entry(lemma' (MorphData.DescFlag)((byte)DescFlags[stemPosition] & 3)' dmaskToPrefix((byte)DescFlags[stemPosition]));                              stemPosition++;                          }                          ret.AddNode(lookup[i]' data);                      }                        return ret;                  }              }              else // Use optimized version for loading HSpell's dictionary files              {                  using (var fdict = new GZipStream(File.OpenRead(path + HSpell.Constants.DictionaryFile)' CompressionMode.Decompress))                  using (var fprefixes = new GZipStream(File.OpenRead(path + HSpell.Constants.PrefixesFile)' CompressionMode.Decompress))                  {                      var ret = new DictRadix<MorphData>();                        var sbuf = new char[HSpell.Constants.MaxWordLength];                      int c = 0' n' slen = 0;                      while ((c = fdict.ReadByte()) > -1)                      {                          if (c >= '0' && c <= '9') // No conversion required for chars < 0xBE                          {                              /* new word - finalize old word first (set value) */                              sbuf[slen] = '\0';                                // TODO: Avoid creating new MorphData object' and enhance DictRadix to store                              // the prefixes mask in the node itself                              MorphData data = new MorphData();                              data.Prefixes = Convert.ToByte(fprefixes.ReadByte()); // Read prefix hint byte                              ret.AddNode(sbuf' data);                                /* and read how much to go back */                              n = 0;                              do                              {                                  /* base 10... */                                  n *= 10;                                  n += (c - '0');                              } while ((c = fdict.ReadByte()) > -1 && c >= '0' && c <= '9');                              slen -= n;                          }                          sbuf[slen++] = ISO8859_To_Unicode(c);                      }                        return ret;                  }              }
Magic Number,HebMorph.HSpell,Loader,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,LoadDictionaryFromHSpellFolder,The following statement contains a magic number: if (bLoadMorphData)              {                  // Load the count of morphological data slots required                  int lookupLen = GetWordCountInHSpellFolder(path);                  var lookup = new string[lookupLen + 1];                    using (GZipStream fdict = new GZipStream(File.OpenRead(path + Constants.DictionaryFile)' CompressionMode.Decompress))                  {                      var sbuf = new char[Constants.MaxWordLength];                      int c = 0' n' slen = 0' i = 0;                      while ((c = fdict.ReadByte()) > -1)                      {                          if (c >= '0' && c <= '9') // No conversion required for chars < 0xBE                          {                              /* new word - finalize and save old word */                              lookup[i++] = new string(sbuf' 0' slen);                                /* and read how much to go back */                              n = 0;                              do                              {                                  /* base 10... */                                  n *= 10;                                  n += (c - '0');                              } while ((c = fdict.ReadByte()) > -1 && c >= '0' && c <= '9');                              slen -= n;                          }                          sbuf[slen++] = ISO8859_To_Unicode(c);                      }                  }                    using (var dataLoader = new MorphDataLoader(path + HSpell.Constants.DescFile' path + Constants.StemsFile' path + HSpell.Constants.DmasksFile))                  using (var fprefixes = new GZipStream(File.OpenRead(path + HSpell.Constants.PrefixesFile)' CompressionMode.Decompress))                  {                      DictRadix<MorphData> ret = new DictRadix<MorphData>();                        for (int i = 0; lookup[i] != null; i++)                      {                          MorphData data = new MorphData {Prefixes = Convert.ToByte(fprefixes.ReadByte())};                          // Read prefix hint byte                          var DescFlags = dataLoader.ReadDescFile();                            var stemReferences = dataLoader.ReadStemFile();                          data.Lemmas = new List<MorphData.Entry>(stemReferences.Count);                          int stemPosition = 0;                          foreach (int r in stemReferences)                          {                              // This is a bypass for the psuedo-stem "שונות"' as defined by hspell                              // TODO: Try looking into changing this in hspell itself                              string lemma;                              if (lookup[r].Equals("שונות") && !lookup[r].Equals(lookup[i]))                              {                                  lemma = null;                              }                              else                              {                                  lemma = lookup[r];                              }                              data.Lemmas[stemPosition] = new MorphData.Entry(lemma' (MorphData.DescFlag)((byte)DescFlags[stemPosition] & 3)' dmaskToPrefix((byte)DescFlags[stemPosition]));                              stemPosition++;                          }                          ret.AddNode(lookup[i]' data);                      }                        return ret;                  }              }              else // Use optimized version for loading HSpell's dictionary files              {                  using (var fdict = new GZipStream(File.OpenRead(path + HSpell.Constants.DictionaryFile)' CompressionMode.Decompress))                  using (var fprefixes = new GZipStream(File.OpenRead(path + HSpell.Constants.PrefixesFile)' CompressionMode.Decompress))                  {                      var ret = new DictRadix<MorphData>();                        var sbuf = new char[HSpell.Constants.MaxWordLength];                      int c = 0' n' slen = 0;                      while ((c = fdict.ReadByte()) > -1)                      {                          if (c >= '0' && c <= '9') // No conversion required for chars < 0xBE                          {                              /* new word - finalize old word first (set value) */                              sbuf[slen] = '\0';                                // TODO: Avoid creating new MorphData object' and enhance DictRadix to store                              // the prefixes mask in the node itself                              MorphData data = new MorphData();                              data.Prefixes = Convert.ToByte(fprefixes.ReadByte()); // Read prefix hint byte                              ret.AddNode(sbuf' data);                                /* and read how much to go back */                              n = 0;                              do                              {                                  /* base 10... */                                  n *= 10;                                  n += (c - '0');                              } while ((c = fdict.ReadByte()) > -1 && c >= '0' && c <= '9');                              slen -= n;                          }                          sbuf[slen++] = ISO8859_To_Unicode(c);                      }                        return ret;                  }              }
Magic Number,HebMorph.HSpell,MorphDataLoader,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,ReadDescFile,The following statement contains a magic number: while ((buf[bufPos] = fdesc.ReadByte()) > -1)                  {                      // Break on EOL or EOF                      if (buf[bufPos] == '\n' || buf[bufPos] == 0)                      {                          bufPos = 0;                          DMask[] ret = wordMasks.ToArray();                          wordMasks.Clear();                          return ret;                      }                      bufPos++;                      if (bufPos % 2 == 0)                      {                          int i = buf[0] - 'A' + (buf[1] - 'A') * 26;                          //wordMasks.Add((DMask)Constants.dmasks[i]);                          wordMasks.Add((DMask)dmasks[i]);                          bufPos = 0;                          continue;                      }                  }
Magic Number,HebMorph.HSpell,MorphDataLoader,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,ReadDescFile,The following statement contains a magic number: while ((buf[bufPos] = fdesc.ReadByte()) > -1)                  {                      // Break on EOL or EOF                      if (buf[bufPos] == '\n' || buf[bufPos] == 0)                      {                          bufPos = 0;                          DMask[] ret = wordMasks.ToArray();                          wordMasks.Clear();                          return ret;                      }                      bufPos++;                      if (bufPos % 2 == 0)                      {                          int i = buf[0] - 'A' + (buf[1] - 'A') * 26;                          //wordMasks.Add((DMask)Constants.dmasks[i]);                          wordMasks.Add((DMask)dmasks[i]);                          bufPos = 0;                          continue;                      }                  }
Magic Number,HebMorph.HSpell,MorphDataLoader,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,ReadStemFile,The following statement contains a magic number: while ((buf[bufPos] = fstem.ReadByte()) > -1)                  {                      // Break on EOL or EOF                      if (buf[bufPos] == '\n' || buf[bufPos] == 0)                      {                          bufPos = 0;                          return wordStems;                      }                      bufPos++;                      if (bufPos % 3 == 0)                      {                          wordStems.Add(buf[0] - 33 + (buf[1] - 33) * 94 + (buf[2] - 33) * 94 * 94);                          bufPos = 0;                          continue;                      }                  }
Magic Number,HebMorph.HSpell,MorphDataLoader,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,ReadStemFile,The following statement contains a magic number: while ((buf[bufPos] = fstem.ReadByte()) > -1)                  {                      // Break on EOL or EOF                      if (buf[bufPos] == '\n' || buf[bufPos] == 0)                      {                          bufPos = 0;                          return wordStems;                      }                      bufPos++;                      if (bufPos % 3 == 0)                      {                          wordStems.Add(buf[0] - 33 + (buf[1] - 33) * 94 + (buf[2] - 33) * 94 * 94);                          bufPos = 0;                          continue;                      }                  }
Magic Number,HebMorph.HSpell,MorphDataLoader,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,ReadStemFile,The following statement contains a magic number: while ((buf[bufPos] = fstem.ReadByte()) > -1)                  {                      // Break on EOL or EOF                      if (buf[bufPos] == '\n' || buf[bufPos] == 0)                      {                          bufPos = 0;                          return wordStems;                      }                      bufPos++;                      if (bufPos % 3 == 0)                      {                          wordStems.Add(buf[0] - 33 + (buf[1] - 33) * 94 + (buf[2] - 33) * 94 * 94);                          bufPos = 0;                          continue;                      }                  }
Magic Number,HebMorph.HSpell,MorphDataLoader,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,ReadStemFile,The following statement contains a magic number: while ((buf[bufPos] = fstem.ReadByte()) > -1)                  {                      // Break on EOL or EOF                      if (buf[bufPos] == '\n' || buf[bufPos] == 0)                      {                          bufPos = 0;                          return wordStems;                      }                      bufPos++;                      if (bufPos % 3 == 0)                      {                          wordStems.Add(buf[0] - 33 + (buf[1] - 33) * 94 + (buf[2] - 33) * 94 * 94);                          bufPos = 0;                          continue;                      }                  }
Magic Number,HebMorph.HSpell,MorphDataLoader,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,ReadStemFile,The following statement contains a magic number: while ((buf[bufPos] = fstem.ReadByte()) > -1)                  {                      // Break on EOL or EOF                      if (buf[bufPos] == '\n' || buf[bufPos] == 0)                      {                          bufPos = 0;                          return wordStems;                      }                      bufPos++;                      if (bufPos % 3 == 0)                      {                          wordStems.Add(buf[0] - 33 + (buf[1] - 33) * 94 + (buf[2] - 33) * 94 * 94);                          bufPos = 0;                          continue;                      }                  }
Magic Number,HebMorph.HSpell,MorphDataLoader,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,ReadStemFile,The following statement contains a magic number: while ((buf[bufPos] = fstem.ReadByte()) > -1)                  {                      // Break on EOL or EOF                      if (buf[bufPos] == '\n' || buf[bufPos] == 0)                      {                          bufPos = 0;                          return wordStems;                      }                      bufPos++;                      if (bufPos % 3 == 0)                      {                          wordStems.Add(buf[0] - 33 + (buf[1] - 33) * 94 + (buf[2] - 33) * 94 * 94);                          bufPos = 0;                          continue;                      }                  }
Magic Number,HebMorph.HSpell,MorphDataLoader,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,ReadStemFile,The following statement contains a magic number: while ((buf[bufPos] = fstem.ReadByte()) > -1)                  {                      // Break on EOL or EOF                      if (buf[bufPos] == '\n' || buf[bufPos] == 0)                      {                          bufPos = 0;                          return wordStems;                      }                      bufPos++;                      if (bufPos % 3 == 0)                      {                          wordStems.Add(buf[0] - 33 + (buf[1] - 33) * 94 + (buf[2] - 33) * 94 * 94);                          bufPos = 0;                          continue;                      }                  }
Magic Number,HebMorph.HSpell,MorphDataLoader,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,ReadStemFile,The following statement contains a magic number: while ((buf[bufPos] = fstem.ReadByte()) > -1)                  {                      // Break on EOL or EOF                      if (buf[bufPos] == '\n' || buf[bufPos] == 0)                      {                          bufPos = 0;                          return wordStems;                      }                      bufPos++;                      if (bufPos % 3 == 0)                      {                          wordStems.Add(buf[0] - 33 + (buf[1] - 33) * 94 + (buf[2] - 33) * 94 * 94);                          bufPos = 0;                          continue;                      }                  }
Magic Number,HebMorph.HSpell,MorphDataLoader,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,tryParseInt,The following statement contains a magic number: for (int i = 0; i < length; i++)                  {                      char c = str[i];                      if (c <= '/' || c >= ':')                      {                          return -1;                      }                      int digit = (int)c - (int)'0';                      num *= 10;                      num += digit;                  }
Magic Number,HebMorph.DataStructures,DictRadix<T>,C:\repos\synhershko_HebMorph\dotNet\HebMorph\DataStructures\DictRadix.cs,AddNode,The following statement contains a magic number: while (cur != null)              {                  // No children' but key is definitely a descendant                  if (cur.Children == null)                  {                      // TODO: This assumes cur has a value and therefore is a leaf' hence we branch                      // instead of merging keys. Is this always the case?                        DictNode newChild = new DictNode();                      newChild.Key = new char[keyLength - keyPos];                      Array.Copy(key' keyPos' newChild.Key' 0' newChild.Key.Length);                      newChild.Value = data;                        cur.Children = new DictNode[1];                      cur.Children[0] = newChild;                      m_nCount++;                      return;                  }                    // Iterate through all children of the current node' and either switch node based on the                  // key' find a node to split into 2' or add a new child with the remaining path                  int childPos = 0;                  bool bFoundChild = false;                  for (; childPos < cur.Children.Length; childPos++)                  {                      DictNode child = cur.Children[childPos];                        int n = 0;                        // By definition' there is no such thing as a null _Key                      while (n < child.Key.Length && keyPos < keyLength && child.Key[n] == key[keyPos] && key[keyPos] != '\0')                      {                          keyPos++;                          n++;                      }                        // If it was a match' even partial                      if (n > 0)                      {                          bFoundChild = true;                            // We consumed this child's key' but the key we are looking for isn't over yet                          if (n == child.Key.Length && keyLength > keyPos)                          {                              cur = child;                              break;                          }                          // We consumed none of the keys                          else if (child.Key.Length > n && keyLength > keyPos)                          {                              // split                              DictNode bridgeChild = new DictNode();                              bridgeChild.Key = new char[n];                              Array.Copy(child.Key' 0' bridgeChild.Key' 0' n);                                int childNewKeyLen = child.Key.Length - n;                              char[] childNewKey = new char[childNewKeyLen];                              Array.Copy(child.Key' n' childNewKey' 0' childNewKeyLen);                              child.Key = childNewKey;                                bridgeChild.Children = new DictNode[2];                                DictNode newNode = new DictNode();                              newNode.Key = new char[keyLength - keyPos];                              Array.Copy(key' keyPos' newNode.Key' 0' newNode.Key.Length);                              newNode.Value = data;                                if (child.Key[0].CompareTo(newNode.Key[0]) < 0)                              {                                  bridgeChild.Children[0] = child;                                  bridgeChild.Children[1] = newNode;                              }                              else                              {                                  bridgeChild.Children[0] = newNode;                                  bridgeChild.Children[1] = child;                              }                                cur.Children[childPos] = bridgeChild;                                m_nCount++;                                return;                          }                          // We consumed the requested key' but the there's still more chars in the child's key                          else if (child.Key.Length > n && keyLength == keyPos)                          {                              // split                              DictNode newChild = new DictNode();                              newChild.Key = new char[n];                              Array.Copy(child.Key' 0' newChild.Key' 0' n);                                int childNewKeyLen = child.Key.Length - n;                              char[] childNewKey = new char[childNewKeyLen];                              Array.Copy(child.Key' n' childNewKey' 0' childNewKeyLen);                              child.Key = childNewKey;                                newChild.Children = new DictNode[1];                              newChild.Children[0] = child;                              newChild.Value = data;                                cur.Children[childPos] = newChild;                                                            m_nCount++;                                return;                          }                          // We consumed both the child's key and the requested key                          else if (n == child.Key.Length && keyLength == keyPos)                          {                              if (object.Equals(child.Value' default(T)))                              {                                  child.Value = data;                                  m_nCount++;                              }                              else if (m_bAllowValueOverride)                              {                                  // Only override data if this radix object is configured to do this                                  child.Value = data;                              }                              return;                          }                      }                  }                    if (!bFoundChild)                  {                      // Dead end - add a new child and return                      DictNode newChild = new DictNode();                      newChild.Key = new char[keyLength - keyPos];                      Array.Copy(key' keyPos' newChild.Key' 0' newChild.Key.Length);                      newChild.Value = data;                        DictNode[] newArray = new DictNode[cur.Children.Length + 1];                      int curPos = 0;                      for (; curPos < cur.Children.Length; ++curPos)                      {                          if (newChild.Key[0].CompareTo(cur.Children[curPos].Key[0]) < 0)                              break;                          newArray[curPos] = cur.Children[curPos];                      }                      newArray[curPos] = newChild;                      for (; curPos < cur.Children.Length; ++curPos)                      {                          newArray[curPos + 1] = cur.Children[curPos];                      }                      cur.Children = newArray;                        m_nCount++;                        return;                  }              }
Missing Default,HebMorph.HSpell,LingInfo,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2HebrewString,The following switch statement is missing a default case: switch (dmask & DMask.D_TYPEMASK)              {                  case DMask.D_NOUN: ret = "ע"; break;                  case DMask.D_VERB: ret = "פ"; break;                  case DMask.D_ADJ: ret = "ת"; break;                  case 0: ret = "x"; break;                  //default: ret = "";              }
Missing Default,HebMorph.HSpell,LingInfo,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2HebrewString,The following switch statement is missing a default case: switch (dmask & DMask.D_GUFMASK)              {                  case DMask.D_FIRST: ret += "'1"; break;                  case DMask.D_SECOND: ret += "'2"; break;                  case DMask.D_THIRD: ret += "'3"; break;                  //default: ret += "";              }
Missing Default,HebMorph.HSpell,LingInfo,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2HebrewString,The following switch statement is missing a default case: switch (dmask & DMask.D_NUMMASK)              {                  case DMask.D_SINGULAR: ret += "'יחיד"; break;                  case DMask.D_DOUBLE: ret += "'זוגי"; break;                  case DMask.D_PLURAL: ret += "'רבים"; break;                  //default: ret += "";              }
Missing Default,HebMorph.HSpell,LingInfo,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2HebrewString,The following switch statement is missing a default case: switch (dmask & DMask.D_TENSEMASK)              {                  case DMask.D_PAST: ret += "'עבר"; break;                  case DMask.D_PRESENT: ret += "'הווה"; break;                  case DMask.D_FUTURE: ret += "'עתיד"; break;                  case DMask.D_IMPERATIVE: ret += "'ציווי"; break;                  case DMask.D_INFINITIVE: ret += "'מקור"; break;                  case DMask.D_BINFINITIVE: ret += "'מקור'ב"; break;                  //default: ret += "";              }
Missing Default,HebMorph.HSpell,LingInfo,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2HebrewString,The following switch statement is missing a default case: switch (dmask & DMask.D_OGENDERMASK)                  {                      case DMask.D_OMASCULINE: ret += "ז"; break;                      case DMask.D_OFEMININE: ret += "נ"; break;                      //default: ret += "";                  }
Missing Default,HebMorph.HSpell,LingInfo,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2HebrewString,The following switch statement is missing a default case: switch (dmask & DMask.D_OGUFMASK)                  {                      case DMask.D_OFIRST: ret += "'1"; break;                      case DMask.D_OSECOND: ret += "'2"; break;                      case DMask.D_OTHIRD: ret += "'3"; break;                      //default: ret += "";                  }
Missing Default,HebMorph.HSpell,LingInfo,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2HebrewString,The following switch statement is missing a default case: switch (dmask & DMask.D_ONUMMASK)                  {                      case DMask.D_OSINGULAR: ret += "'יחיד"; break;                      case DMask.D_ODOUBLE: ret += "'זוגי"; break;                      case DMask.D_OPLURAL: ret += "'רבים"; break;                      //default: ret += "";                  }
Missing Default,HebMorph.HSpell,LingInfo,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2EnglishString,The following switch statement is missing a default case: switch (dmask & DMask.D_TYPEMASK)              {                  case DMask.D_NOUN: ret = "Noun"; break;                  case DMask.D_VERB: ret = "Verb"; break;                  case DMask.D_ADJ: ret = "Adj"; break;                  case 0: ret = "x"; break;                  //default: ret = "";              }
Missing Default,HebMorph.HSpell,LingInfo,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2EnglishString,The following switch statement is missing a default case: switch (dmask & DMask.D_GUFMASK)              {                  case DMask.D_FIRST: ret += "'1st"; break;                  case DMask.D_SECOND: ret += "'2nd"; break;                  case DMask.D_THIRD: ret += "'3rd"; break;                  //default: ret += "";              }
Missing Default,HebMorph.HSpell,LingInfo,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2EnglishString,The following switch statement is missing a default case: switch (dmask & DMask.D_NUMMASK)              {                  case DMask.D_SINGULAR: ret += "'Singular"; break;                  case DMask.D_DOUBLE: ret += "'Dual"; break;                  case DMask.D_PLURAL: ret += "'Plural"; break;                  //default: ret += "";              }
Missing Default,HebMorph.HSpell,LingInfo,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2EnglishString,The following switch statement is missing a default case: switch (dmask & DMask.D_TENSEMASK)              {                  case DMask.D_PAST: ret += "'Past"; break;                  case DMask.D_PRESENT: ret += "'Present"; break;                  case DMask.D_FUTURE: ret += "'Future"; break;                  case DMask.D_IMPERATIVE: ret += "'Imperative"; break;                  case DMask.D_INFINITIVE: ret += "'Infinitive"; break;                  case DMask.D_BINFINITIVE: ret += "'B'Infinitive"; break;                  //default: ret += "";              }
Missing Default,HebMorph.HSpell,LingInfo,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2EnglishString,The following switch statement is missing a default case: switch (dmask & DMask.D_OGENDERMASK)                  {                      case DMask.D_OMASCULINE: ret += "Masculine"; break;                      case DMask.D_OFEMININE: ret += "Feminine"; break;                      //default: ret += "";                  }
Missing Default,HebMorph.HSpell,LingInfo,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2EnglishString,The following switch statement is missing a default case: switch (dmask & DMask.D_OGUFMASK)                  {                      case DMask.D_OFIRST: ret += "'1st"; break;                      case DMask.D_OSECOND: ret += "'2nd"; break;                      case DMask.D_OTHIRD: ret += "'3rd"; break;                      //default: ret += "";                  }
Missing Default,HebMorph.HSpell,LingInfo,C:\repos\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2EnglishString,The following switch statement is missing a default case: switch (dmask & DMask.D_ONUMMASK)                  {                      case DMask.D_OSINGULAR: ret += "'Singular"; break;                      case DMask.D_ODOUBLE: ret += "'Dual"; break;                      case DMask.D_OPLURAL: ret += "'Plural"; break;                      //default: ret += "";                  }
