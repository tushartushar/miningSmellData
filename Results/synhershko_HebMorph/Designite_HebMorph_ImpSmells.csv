Implementation smell,Namespace,Class,File,Method,Description
Long Method,HebMorph.DataStructures,DictRadix<T>,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\DataStructures\DictRadix.cs,AddNode,The method has 138 lines of code.
Long Method,HebMorph,Tokenizer,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\Tokenizer.cs,NextToken,The method has 135 lines of code.
Complex Method,HebMorph.DataStructures,DictRadix<T>,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\DataStructures\DictRadix.cs,LookupImpl,Cyclomatic complexity of the method is 8
Complex Method,HebMorph.DataStructures,DictRadix<T>,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\DataStructures\DictRadix.cs,AddNode,Cyclomatic complexity of the method is 17
Complex Method,HebMorph.DataStructures,TolerantLookupCrawler,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\DataStructures\DictRadix.cs,DoKeyMatching,Cyclomatic complexity of the method is 10
Complex Method,HebMorph.DataStructures,RadixEnumerator,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\DataStructures\DictRadix.cs,MoveNext,Cyclomatic complexity of the method is 8
Complex Method,HebMorph,LookupTolerators,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\LookupTolerators.cs,TolerateEmKryiaYud,Cyclomatic complexity of the method is 10
Complex Method,HebMorph,Lemmatizer,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\Lemmatizer.cs,Lemmatize,Cyclomatic complexity of the method is 12
Complex Method,HebMorph,Lemmatizer,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\Lemmatizer.cs,LemmatizeTolerant,Cyclomatic complexity of the method is 12
Complex Method,HebMorph,Lemmatizer,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\Lemmatizer.cs,Lemmatize,Cyclomatic complexity of the method is 9
Complex Method,HebMorph,StreamLemmatizer,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\StreamLemmatizer.cs,LemmatizeNextToken,Cyclomatic complexity of the method is 18
Complex Method,HebMorph,Tokenizer,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\Tokenizer.cs,NextToken,Cyclomatic complexity of the method is 27
Complex Method,HebMorph.HSpell,Loader,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,LoadDictionaryFromHSpellFolder,Cyclomatic complexity of the method is 10
Complex Method,HebMorph.HSpell,Loader,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,dmaskToPrefix,Cyclomatic complexity of the method is 9
Complex Method,HebMorph.HSpell,LingInfo,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,dmask2ps,Cyclomatic complexity of the method is 9
Complex Method,HebMorph.HSpell,LingInfo,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2HebrewString,Cyclomatic complexity of the method is 23
Complex Method,HebMorph.HSpell,LingInfo,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2EnglishString,Cyclomatic complexity of the method is 23
Long Parameter List,HebMorph,HebrewToken,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HebrewToken.cs,HebrewToken,The method has 5 parameters. Parameters: _word' _prefixLength' _mask' _lemma' _score
Long Parameter List,HebMorph,LookupTolerators,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\LookupTolerators.cs,TolerateEmKryiaYud,The method has 5 parameters. Parameters: key' keyPos' word' score' curChar
Long Parameter List,HebMorph,LookupTolerators,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\LookupTolerators.cs,TolerateEmKryiaVav,The method has 5 parameters. Parameters: key' keyPos' word' score' curChar
Long Parameter List,HebMorph,LookupTolerators,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\LookupTolerators.cs,TolerateNonDoubledConsonantVav,The method has 5 parameters. Parameters: key' keyPos' word' score' curChar
Long Statement,HebMorph.DataStructures,TolerantLookupCrawler,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\DataStructures\DictRadix.cs,DoKeyMatching,The length of the statement  "                            //System.Diagnostics.Trace.WriteLine(string.Format("{0} tolerated a char' attempting word {1}"' tf.Method.Name' mc.Word + node._Key[nodeKeyPos])); " is 146.
Long Statement,HebMorph,LookupTolerators,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\LookupTolerators.cs,TolerateEmKryiaVav,The length of the statement  "                keyPos == 0 || keyPos + 1 == key.Length || // check this isn't the end or the beginning of a word (no one misses Vav there) " is 123.
Long Statement,HebMorph,Lemmatizer,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\Lemmatizer.cs,Lemmatize,The length of the statement  "                            yield return new HebrewToken(word' prefLen' (DMask)(byte)result.DescFlag' result.Lemma' 0.9f) {Type = WordType.HEBREW_WITH_PREFIX}; " is 131.
Long Statement,HebMorph,Lemmatizer,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\Lemmatizer.cs,LemmatizeTolerant,The length of the statement  "                        yield return new HebrewToken(lr.Word' 0' (DMask)(byte)result.DescFlag' result.Lemma' lr.Score) {Type = WordType.HEBREW_TOLERATED}; " is 130.
Long Statement,HebMorph,Lemmatizer,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\Lemmatizer.cs,LemmatizeTolerant,The length of the statement  "                                yield return new HebrewToken(word.Substring(0' prefLen) + lr.Word' prefLen' (DMask)(byte)result.DescFlag' result.Lemma' lr.Score*0.9f) " is 134.
Long Statement,HebMorph.HSpell,Loader,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,LoadDictionaryFromHSpellFolder,The length of the statement  "                using (var dataLoader = new MorphDataLoader(path + HSpell.Constants.DescFile' path + Constants.StemsFile' path + HSpell.Constants.DmasksFile)) " is 142.
Long Statement,HebMorph.HSpell,Loader,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,LoadDictionaryFromHSpellFolder,The length of the statement  "                            data.Lemmas[stemPosition] = new MorphData.Entry(lemma' (MorphData.DescFlag)((byte)DescFlags[stemPosition] & 3)' dmaskToPrefix((byte)DescFlags[stemPosition])); " is 158.
Long Statement,HebMorph.HSpell,Loader,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,dmaskToPrefix,The length of the statement  "            else if (((dmask & (int)DMask.D_TYPEMASK) == (int)DMask.D_NOUN) || ((dmask & (int)DMask.D_TYPEMASK) == (int)DMask.D_ADJ)) " is 121.
Long Statement,HebMorph.HSpell,Loader,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,dmaskToPrefix,The length of the statement  "                if (((dmask & (int)DMask.D_OSMICHUT) > 0) || ((dmask & (int)DMask.D_OMASK) > 0) || ((dmask & (int)DMask.D_SPECNOUN) > 0)) " is 121.
Complex Conditional,HebMorph.DataStructures,DictRadix<T>,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\DataStructures\DictRadix.cs,AddNode,The conditional expression  "n < child.Key.Length && keyPos < keyLength && child.Key[n] == key[keyPos] && key[keyPos] != '\0'"  is complex.
Complex Conditional,HebMorph.DataStructures,RealSortedList<T>,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\DataStructures\RealSortedList.cs,Add,The conditional expression  "(sortOrder == SortOrder.Desc && cmp < 0) || (sortOrder == SortOrder.Asc && cmp > 0)"  is complex.
Complex Conditional,HebMorph,LookupTolerators,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\LookupTolerators.cs,TolerateEmKryiaVav,The conditional expression  "curChar != 'ו' || // check current trie position                  keyPos == 0 || keyPos + 1 == key.Length || // check this isn't the end or the beginning of a word (no one misses Vav there)                  key[keyPos] == 'י' || key[keyPos] == 'ה' || // Vav shouldn't be tolerated before a Yud or a Heh                  key[keyPos] == 'ו'"  is complex.
Complex Conditional,HebMorph,Tokenizer,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\Tokenizer.cs,NextToken,The conditional expression  "(c >= 1488 && c <= 1514) || (c >= 1455 && c <= 1476)"  is complex.
Magic Number,HebMorph,LookupTolerators,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\LookupTolerators.cs,TolerateEmKryiaYud,The following statement contains a magic number: score *= 0.9f;
Magic Number,HebMorph,LookupTolerators,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\LookupTolerators.cs,TolerateEmKryiaYud,The following statement contains a magic number: score *= 0.6f;
Magic Number,HebMorph,LookupTolerators,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\LookupTolerators.cs,TolerateEmKryiaYud,The following statement contains a magic number: key[keyPos - 1] != 'י' || (keyPos + 1 == key.Length && key.Length <= 3)
Magic Number,HebMorph,LookupTolerators,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\LookupTolerators.cs,TolerateEmKryiaYud,The following statement contains a magic number: score *= 0.8f;
Magic Number,HebMorph,LookupTolerators,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\LookupTolerators.cs,TolerateEmKryiaVav,The following statement contains a magic number: score *= 0.8f;
Magic Number,HebMorph,LookupTolerators,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\LookupTolerators.cs,TolerateNonDoubledConsonantVav,The following statement contains a magic number: score *= 0.8f;
Magic Number,HebMorph,Lemmatizer,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\Lemmatizer.cs,RemoveNiqqud,The following statement contains a magic number: word[i] < 1455 || word[i] > 1476
Magic Number,HebMorph,Lemmatizer,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\Lemmatizer.cs,RemoveNiqqud,The following statement contains a magic number: word[i] < 1455 || word[i] > 1476
Magic Number,HebMorph,Lemmatizer,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\Lemmatizer.cs,Lemmatize,The following statement contains a magic number: word.Length - prefLen < 2
Magic Number,HebMorph,Lemmatizer,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\Lemmatizer.cs,Lemmatize,The following statement contains a magic number: yield return new HebrewToken(word' prefLen' (DMask)(byte)result.DescFlag' result.Lemma' 0.9f) {Type = WordType.HEBREW_WITH_PREFIX};
Magic Number,HebMorph,Lemmatizer,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\Lemmatizer.cs,LemmatizeTolerant,The following statement contains a magic number: word.Length > 19
Magic Number,HebMorph,Lemmatizer,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\Lemmatizer.cs,LemmatizeTolerant,The following statement contains a magic number: word.Length - prefLen < 2
Magic Number,HebMorph,Lemmatizer,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\Lemmatizer.cs,LemmatizeTolerant,The following statement contains a magic number: yield return new HebrewToken(word.Substring(0' prefLen) + lr.Word' prefLen' (DMask)(byte)result.DescFlag' result.Lemma' lr.Score*0.9f)                                  { Type = WordType.HEBREW_TOLERATED_WITH_PREFIX };
Magic Number,HebMorph,Tokenizer,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\Tokenizer.cs,IsHebrewLetter,The following statement contains a magic number: return (c >= 1488 && c <= 1514);
Magic Number,HebMorph,Tokenizer,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\Tokenizer.cs,IsHebrewLetter,The following statement contains a magic number: return (c >= 1488 && c <= 1514);
Magic Number,HebMorph,Tokenizer,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\Tokenizer.cs,IsNiqqudChar,The following statement contains a magic number: return (c >= 1455 && c <= 1476);
Magic Number,HebMorph,Tokenizer,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\Tokenizer.cs,IsNiqqudChar,The following statement contains a magic number: return (c >= 1455 && c <= 1476);
Magic Number,HebMorph,Tokenizer,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\Tokenizer.cs,NextToken,The following statement contains a magic number: (c >= 1488 && c <= 1514) || (c >= 1455 && c <= 1476)
Magic Number,HebMorph,Tokenizer,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\Tokenizer.cs,NextToken,The following statement contains a magic number: (c >= 1488 && c <= 1514) || (c >= 1455 && c <= 1476)
Magic Number,HebMorph,Tokenizer,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\Tokenizer.cs,NextToken,The following statement contains a magic number: (c >= 1488 && c <= 1514) || (c >= 1455 && c <= 1476)
Magic Number,HebMorph,Tokenizer,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\Tokenizer.cs,NextToken,The following statement contains a magic number: (c >= 1488 && c <= 1514) || (c >= 1455 && c <= 1476)
Magic Number,HebMorph,Tokenizer,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\Tokenizer.cs,NextToken,The following statement contains a magic number: !IsOfChars(wordBuffer[length - 2]' LettersAcceptingGeresh)
Magic Number,HebMorph,Tokenizer,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\Tokenizer.cs,NextToken,The following statement contains a magic number: length > 2 && IsOfChars(wordBuffer[length - 1]' Geresh)
Magic Number,HebMorph.LemmaFilters,BasicLemmaFilter,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\LemmaFilters\BasicLemmaFilter.cs,IsValidToken,The following statement contains a magic number: ht.Score < 0.7f
Magic Number,HebMorph.LemmaFilters,BasicLemmaFilter,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\LemmaFilters\BasicLemmaFilter.cs,IsValidToken,The following statement contains a magic number: (ht.Mask & DMask.D_TYPEMASK) == DMask.D_VERB && ht.Score < 0.85f
Magic Number,HebMorph.HSpell,Loader,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,LoadDictionaryFromHSpellFolder,The following statement contains a magic number: n *= 10;
Magic Number,HebMorph.HSpell,Loader,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,LoadDictionaryFromHSpellFolder,The following statement contains a magic number: data.Lemmas[stemPosition] = new MorphData.Entry(lemma' (MorphData.DescFlag)((byte)DescFlags[stemPosition] & 3)' dmaskToPrefix((byte)DescFlags[stemPosition]));
Magic Number,HebMorph.HSpell,MorphDataLoader,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,ReadDescFile,The following statement contains a magic number: int i = buf[0] - 'A' + (buf[1] - 'A') * 26;
Magic Number,HebMorph.HSpell,MorphDataLoader,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,ReadDescFile,The following statement contains a magic number: bufPos % 2 == 0
Magic Number,HebMorph.HSpell,MorphDataLoader,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,ReadStemFile,The following statement contains a magic number: wordStems.Add(buf[0] - 33 + (buf[1] - 33) * 94 + (buf[2] - 33) * 94 * 94);
Magic Number,HebMorph.HSpell,MorphDataLoader,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,ReadStemFile,The following statement contains a magic number: wordStems.Add(buf[0] - 33 + (buf[1] - 33) * 94 + (buf[2] - 33) * 94 * 94);
Magic Number,HebMorph.HSpell,MorphDataLoader,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,ReadStemFile,The following statement contains a magic number: wordStems.Add(buf[0] - 33 + (buf[1] - 33) * 94 + (buf[2] - 33) * 94 * 94);
Magic Number,HebMorph.HSpell,MorphDataLoader,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,ReadStemFile,The following statement contains a magic number: wordStems.Add(buf[0] - 33 + (buf[1] - 33) * 94 + (buf[2] - 33) * 94 * 94);
Magic Number,HebMorph.HSpell,MorphDataLoader,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,ReadStemFile,The following statement contains a magic number: wordStems.Add(buf[0] - 33 + (buf[1] - 33) * 94 + (buf[2] - 33) * 94 * 94);
Magic Number,HebMorph.HSpell,MorphDataLoader,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,ReadStemFile,The following statement contains a magic number: wordStems.Add(buf[0] - 33 + (buf[1] - 33) * 94 + (buf[2] - 33) * 94 * 94);
Magic Number,HebMorph.HSpell,MorphDataLoader,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,ReadStemFile,The following statement contains a magic number: wordStems.Add(buf[0] - 33 + (buf[1] - 33) * 94 + (buf[2] - 33) * 94 * 94);
Magic Number,HebMorph.HSpell,MorphDataLoader,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,ReadStemFile,The following statement contains a magic number: bufPos % 3 == 0
Magic Number,HebMorph.HSpell,MorphDataLoader,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\Loader.cs,tryParseInt,The following statement contains a magic number: num *= 10;
Missing Default,HebMorph.HSpell,LingInfo,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2HebrewString,The following switch statement is missing a default case: switch (dmask & DMask.D_TYPEMASK)              {                  case DMask.D_NOUN: ret = "ע"; break;                  case DMask.D_VERB: ret = "פ"; break;                  case DMask.D_ADJ: ret = "ת"; break;                  case 0: ret = "x"; break;                  //default: ret = "";              }
Missing Default,HebMorph.HSpell,LingInfo,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2HebrewString,The following switch statement is missing a default case: switch (dmask & DMask.D_GUFMASK)              {                  case DMask.D_FIRST: ret += "'1"; break;                  case DMask.D_SECOND: ret += "'2"; break;                  case DMask.D_THIRD: ret += "'3"; break;                  //default: ret += "";              }
Missing Default,HebMorph.HSpell,LingInfo,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2HebrewString,The following switch statement is missing a default case: switch (dmask & DMask.D_NUMMASK)              {                  case DMask.D_SINGULAR: ret += "'יחיד"; break;                  case DMask.D_DOUBLE: ret += "'זוגי"; break;                  case DMask.D_PLURAL: ret += "'רבים"; break;                  //default: ret += "";              }
Missing Default,HebMorph.HSpell,LingInfo,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2HebrewString,The following switch statement is missing a default case: switch (dmask & DMask.D_TENSEMASK)              {                  case DMask.D_PAST: ret += "'עבר"; break;                  case DMask.D_PRESENT: ret += "'הווה"; break;                  case DMask.D_FUTURE: ret += "'עתיד"; break;                  case DMask.D_IMPERATIVE: ret += "'ציווי"; break;                  case DMask.D_INFINITIVE: ret += "'מקור"; break;                  case DMask.D_BINFINITIVE: ret += "'מקור'ב"; break;                  //default: ret += "";              }
Missing Default,HebMorph.HSpell,LingInfo,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2HebrewString,The following switch statement is missing a default case: switch (dmask & DMask.D_OGENDERMASK)                  {                      case DMask.D_OMASCULINE: ret += "ז"; break;                      case DMask.D_OFEMININE: ret += "נ"; break;                      //default: ret += "";                  }
Missing Default,HebMorph.HSpell,LingInfo,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2HebrewString,The following switch statement is missing a default case: switch (dmask & DMask.D_OGUFMASK)                  {                      case DMask.D_OFIRST: ret += "'1"; break;                      case DMask.D_OSECOND: ret += "'2"; break;                      case DMask.D_OTHIRD: ret += "'3"; break;                      //default: ret += "";                  }
Missing Default,HebMorph.HSpell,LingInfo,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2HebrewString,The following switch statement is missing a default case: switch (dmask & DMask.D_ONUMMASK)                  {                      case DMask.D_OSINGULAR: ret += "'יחיד"; break;                      case DMask.D_ODOUBLE: ret += "'זוגי"; break;                      case DMask.D_OPLURAL: ret += "'רבים"; break;                      //default: ret += "";                  }
Missing Default,HebMorph.HSpell,LingInfo,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2EnglishString,The following switch statement is missing a default case: switch (dmask & DMask.D_TYPEMASK)              {                  case DMask.D_NOUN: ret = "Noun"; break;                  case DMask.D_VERB: ret = "Verb"; break;                  case DMask.D_ADJ: ret = "Adj"; break;                  case 0: ret = "x"; break;                  //default: ret = "";              }
Missing Default,HebMorph.HSpell,LingInfo,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2EnglishString,The following switch statement is missing a default case: switch (dmask & DMask.D_GUFMASK)              {                  case DMask.D_FIRST: ret += "'1st"; break;                  case DMask.D_SECOND: ret += "'2nd"; break;                  case DMask.D_THIRD: ret += "'3rd"; break;                  //default: ret += "";              }
Missing Default,HebMorph.HSpell,LingInfo,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2EnglishString,The following switch statement is missing a default case: switch (dmask & DMask.D_NUMMASK)              {                  case DMask.D_SINGULAR: ret += "'Singular"; break;                  case DMask.D_DOUBLE: ret += "'Dual"; break;                  case DMask.D_PLURAL: ret += "'Plural"; break;                  //default: ret += "";              }
Missing Default,HebMorph.HSpell,LingInfo,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2EnglishString,The following switch statement is missing a default case: switch (dmask & DMask.D_TENSEMASK)              {                  case DMask.D_PAST: ret += "'Past"; break;                  case DMask.D_PRESENT: ret += "'Present"; break;                  case DMask.D_FUTURE: ret += "'Future"; break;                  case DMask.D_IMPERATIVE: ret += "'Imperative"; break;                  case DMask.D_INFINITIVE: ret += "'Infinitive"; break;                  case DMask.D_BINFINITIVE: ret += "'B'Infinitive"; break;                  //default: ret += "";              }
Missing Default,HebMorph.HSpell,LingInfo,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2EnglishString,The following switch statement is missing a default case: switch (dmask & DMask.D_OGENDERMASK)                  {                      case DMask.D_OMASCULINE: ret += "Masculine"; break;                      case DMask.D_OFEMININE: ret += "Feminine"; break;                      //default: ret += "";                  }
Missing Default,HebMorph.HSpell,LingInfo,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2EnglishString,The following switch statement is missing a default case: switch (dmask & DMask.D_OGUFMASK)                  {                      case DMask.D_OFIRST: ret += "'1st"; break;                      case DMask.D_OSECOND: ret += "'2nd"; break;                      case DMask.D_OTHIRD: ret += "'3rd"; break;                      //default: ret += "";                  }
Missing Default,HebMorph.HSpell,LingInfo,D:\research\architectureSmells\repos1\synhershko_HebMorph\dotNet\HebMorph\HSpell\LingInfo.cs,DMask2EnglishString,The following switch statement is missing a default case: switch (dmask & DMask.D_ONUMMASK)                  {                      case DMask.D_OSINGULAR: ret += "'Singular"; break;                      case DMask.D_ODOUBLE: ret += "'Dual"; break;                      case DMask.D_OPLURAL: ret += "'Plural"; break;                      //default: ret += "";                  }
