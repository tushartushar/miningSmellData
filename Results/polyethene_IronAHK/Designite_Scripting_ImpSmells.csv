Implementation smell,Namespace,Class,File,Method,Description
Long Method,IronAHK.Scripting,Emit,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,EmitInvoke,The method has 128 lines of code.
Long Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Set,The method has 110 lines of code.
Long Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorFromString,The method has 218 lines of code.
Long Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitTokens,The method has 245 lines of code.
Long Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The method has 584 lines of code.
Long Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Statements,The method has 185 lines of code.
Long Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,MultilineString,The method has 116 lines of code.
Long Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseDirective,The method has 178 lines of code.
Long Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The method has 771 lines of code.
Long Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseFlow,The method has 284 lines of code.
Long Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseFunction,The method has 122 lines of code.
Long Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseFunctionParameters,The method has 104 lines of code.
Long Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Read,The method has 271 lines of code.
Long Method,IronAHK.Scripting,Script,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Script\Call.cs,ForceString,The method has 116 lines of code.
Long Method,IronAHK.Scripting,Script,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Script\Call.cs,IfLegacy,The method has 164 lines of code.
Long Method,IronAHK.Scripting,MethodWriter,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Emission\MethodWriter.cs,EmitMethodInvoke,The method has 178 lines of code.
Long Method,IronAHK.Scripting,ILMirror,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,CopyOpcode,The method has 184 lines of code.
Long Method,IronAHK.Scripting,ILMirror,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,GrabType,The method has 100 lines of code.
Complex Method,IronAHK.Scripting,Emit,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,ScriptOperator,Cyclomatic complexity of the method is 34
Complex Method,IronAHK.Scripting,Emit,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,EmitConditionStatement,Cyclomatic complexity of the method is 8
Complex Method,IronAHK.Scripting,Emit,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,EmitStatement,Cyclomatic complexity of the method is 10
Complex Method,IronAHK.Scripting,Emit,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,EmitExpression,Cyclomatic complexity of the method is 12
Complex Method,IronAHK.Scripting,Emit,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,EmitInvoke,Cyclomatic complexity of the method is 16
Complex Method,IronAHK.Scripting,Emit,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,EmitPrimitive,Cyclomatic complexity of the method is 8
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,MergeAssignmentAt,Cyclomatic complexity of the method is 10
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseObject,Cyclomatic complexity of the method is 17
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Set,Cyclomatic complexity of the method is 26
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorFromString,Cyclomatic complexity of the method is 54
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorPrecedence,Cyclomatic complexity of the method is 14
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitTokens,Cyclomatic complexity of the method is 35
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,RemoveExcessParentheses,Cyclomatic complexity of the method is 9
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ScanLibrary,Cyclomatic complexity of the method is 9
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,Cyclomatic complexity of the method is 85
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,VarIdExpand,Cyclomatic complexity of the method is 11
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,VarIdOrConstant,Cyclomatic complexity of the method is 11
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,StdLib,Cyclomatic complexity of the method is 10
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsContinuationLine,Cyclomatic complexity of the method is 12
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsPrimativeObject,Cyclomatic complexity of the method is 9
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Statements,Cyclomatic complexity of the method is 27
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseHotkey,Cyclomatic complexity of the method is 9
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,MultilineString,Cyclomatic complexity of the method is 22
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,EscapedString,Cyclomatic complexity of the method is 14
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseAssign,Cyclomatic complexity of the method is 11
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitCommandParameters,Cyclomatic complexity of the method is 17
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseDirective,Cyclomatic complexity of the method is 40
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,Cyclomatic complexity of the method is 121
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseFlow,Cyclomatic complexity of the method is 39
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseFlowParameter,Cyclomatic complexity of the method is 8
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseInequality,Cyclomatic complexity of the method is 10
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseFunction,Cyclomatic complexity of the method is 17
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseFunctionParameters,Cyclomatic complexity of the method is 19
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ValidateParameterLiteral,Cyclomatic complexity of the method is 10
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Read,Cyclomatic complexity of the method is 42
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,GetToken,Cyclomatic complexity of the method is 8
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsCommand,Cyclomatic complexity of the method is 15
Complex Method,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsFunction,Cyclomatic complexity of the method is 15
Complex Method,IronAHK.Scripting,Script,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Script\Call.cs,ForceString,Cyclomatic complexity of the method is 22
Complex Method,IronAHK.Scripting,Script,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Script\Call.cs,Index,Cyclomatic complexity of the method is 9
Complex Method,IronAHK.Scripting,Script,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Script\Call.cs,SetObject,Cyclomatic complexity of the method is 13
Complex Method,IronAHK.Scripting,Script,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Script\Call.cs,Operate,Cyclomatic complexity of the method is 25
Complex Method,IronAHK.Scripting,Script,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Script\Call.cs,IfLegacy,Cyclomatic complexity of the method is 44
Complex Method,IronAHK.Scripting,Generator,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Generator\Generator.cs,Supports,Cyclomatic complexity of the method is 27
Complex Method,IronAHK.Scripting,MethodWriter,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Emission\MethodWriter.cs,EmitStatement,Cyclomatic complexity of the method is 10
Complex Method,IronAHK.Scripting,MethodWriter,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Emission\MethodWriter.cs,EmitLiteral,Cyclomatic complexity of the method is 22
Complex Method,IronAHK.Scripting,MethodWriter,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Emission\MethodWriter.cs,EmitExpression,Cyclomatic complexity of the method is 13
Complex Method,IronAHK.Scripting,MethodWriter,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Emission\MethodWriter.cs,EmitBinaryOperator,Cyclomatic complexity of the method is 17
Complex Method,IronAHK.Scripting,MethodWriter,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Emission\MethodWriter.cs,EmitAssignment,Cyclomatic complexity of the method is 8
Complex Method,IronAHK.Scripting,MethodWriter,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Emission\MethodWriter.cs,ForceTopStack,Cyclomatic complexity of the method is 9
Complex Method,IronAHK.Scripting,MethodWriter,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Emission\MethodWriter.cs,EmitMethodInvoke,Cyclomatic complexity of the method is 28
Complex Method,IronAHK.Scripting,MethodWriter,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Emission\MethodWriter.cs,GetDefaultValueOfType,Cyclomatic complexity of the method is 11
Complex Method,IronAHK.Scripting,MethodWriter,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Emission\MethodWriter.cs,GetMethodInfo,Cyclomatic complexity of the method is 8
Complex Method,IronAHK.Scripting,ILMirror,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,GrabMethod,Cyclomatic complexity of the method is 13
Complex Method,IronAHK.Scripting,ILMirror,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,CopyOpcode,Cyclomatic complexity of the method is 30
Complex Method,IronAHK.Scripting,ILMirror,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,GrabField,Cyclomatic complexity of the method is 9
Complex Method,IronAHK.Scripting,ILMirror,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,GrabProperty,Cyclomatic complexity of the method is 8
Complex Method,IronAHK.Scripting,ILMirror,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,GrabType,Cyclomatic complexity of the method is 24
Complex Method,IronAHK.Scripting,ILMirror,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,CopyTryCatch,Cyclomatic complexity of the method is 8
Complex Method,IronAHK.Scripting,ILMirror,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,MineLabels,Cyclomatic complexity of the method is 8
Long Parameter List,IronAHK.Scripting,CodeBlock,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\CodeDom\CodeBlock.cs,CodeBlock,The method has 5 parameters. Parameters: line' method' statements' kind' parent
Long Parameter List,IronAHK.Scripting,CodeBlock,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\CodeDom\CodeBlock.cs,CodeBlock,The method has 7 parameters. Parameters: line' method' statements' kind' parent' endLabel' exitLabel
Long Parameter List,IronAHK.Scripting,ILMirror,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,CopyOpcode,The method has 6 parameters. Parameters: Bytes' i' Gen' Origin' ExceptionTrinkets' LabelOrigins
Long Statement,IronAHK.Scripting,Compiler,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\CompilerSetup.cs,Setup,The length of the statement  "                    Options.OutputAssembly = Path.Combine(Path.GetTempPath()' Path.GetFileNameWithoutExtension(Path.GetRandomFileName()) + ".exe");" is 127.
Long Statement,IronAHK.Scripting,Emit,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,EmitInvoke,The length of the statement  "                    invoke.Parameters[1] is CodePrimitiveExpression && (((CodePrimitiveExpression)invoke.Parameters[1]).Value as string) == Parser.IsTxt)" is 133.
Long Statement,IronAHK.Scripting,Emit,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,EmitInvoke,The length of the statement  "                    var op = (Script.Operator)Enum.Parse(typeof(Script.Operator)' ((CodeFieldReferenceExpression)invoke.Parameters[0]).FieldName);" is 126.
Long Statement,IronAHK.Scripting,Emit,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,EmitInvoke,The length of the statement  "                !(invoke.Method.TargetObject is CodeTypeReferenceExpression && IsInternalType((CodeTypeReferenceExpression)invoke.Method.TargetObject)))" is 136.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsJsonObject,The length of the statement  "            return item is CodeMethodInvokeExpression && ((CodeMethodInvokeExpression)item).Method.MethodName == InternalMethods.Index.MethodName;" is 134.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsArrayExtension,The length of the statement  "            return item is CodeMethodInvokeExpression && ((CodeMethodInvokeExpression)item).Method.MethodName == InternalMethods.ExtendArray.MethodName;" is 140.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitTokens,The length of the statement  "                else if (IsIdentifier(sym) || sym == Resolve || (sym == Concatenate && i + 1 < code.Length && IsIdentifier(code[i + 1])))" is 121.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitTokens,The length of the statement  "                        if ((sym == 'e' || sym == 'E') && IsPrimativeObject(id.ToString()) && id.ToString().IndexOf("0x") != 0 && i + 1 < code.Length)" is 126.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitTokens,The length of the statement  "                        else if (IsIdentifier(sym) || sym == Resolve || (sym == Concatenate && (i + 1 < code.Length ? code[i + 1] != Equal : true)))" is 124.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsVarAssignment,The length of the statement  "            return expr is CodeBinaryOperatorExpression && ((CodeBinaryOperatorExpression)expr).Operator == CodeBinaryOperatorType.Assign;" is 126.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,VarMixedExpr,The length of the statement  "            return IsVarReference(part) ? VarRefOrPrimitive(part) : IsVarAssignment(part) ? (CodeBinaryOperatorExpression)part : part is CodeExpression ? (CodeExpression)part : new CodePrimitiveExpression(part);" is 199.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,StdLib,The length of the statement  "                search.Append(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments)' Path.Combine("AutoHotkey"' LibDir)));" is 130.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,StdLib,The length of the statement  "                    var obj = new CodeArrayCreateExpression { Size = invoke.Parameters.Count' CreateType = new CodeTypeReference(typeof(object)) };" is 127.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsContinuationLine,The length of the statement  "            if (code.Length >= AndTxt.Length && code.Substring(0' AndTxt.Length).Equals(AndTxt' StringComparison.OrdinalIgnoreCase))" is 120.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsContinuationLine,The length of the statement  "            else if (code.Length >= OrTxt.Length && code.Substring(0' OrTxt.Length).Equals(OrTxt' StringComparison.OrdinalIgnoreCase))" is 122.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Statements,The length of the statement  "                                block = new CodeBlock(lines[i]' Scope' new CodeStatementCollection()' CodeBlock.BlockKind.Dummy' blocks.Count == 0 ? null : blocks.Peek());" is 139.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,MultilineString,The length of the statement  "                            if (option.Length > joinOpt.Length && option.Substring(0' joinOpt.Length).Equals(joinOpt' StringComparison.OrdinalIgnoreCase))" is 126.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitCommandStatement,The length of the statement  "            var parts = new[] { code.Substring(0' i).TrimEnd(Spaces)' n >= code.Length ? string.Empty : code.Substring(n).TrimStart(Spaces) };" is 130.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitCommandParameters,The length of the statement  "                if (sym == Multicast && (i == 0 || code[i - 1] != Escape) && !str && levels[0] == 0 && levels[1] == 0 && levels[2] == 0)" is 120.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The length of the statement  "                        if (call && parts[n] is CodeMethodInvokeExpression && ((CodeMethodInvokeExpression)parts[n]).Parameters[0] is CodeFieldReferenceExpression)" is 139.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The length of the statement  "                                    if ((x > 0 && (parts[x] is CodeBinaryOperatorExpression || parts[x] is CodeMethodInvokeExpression || parts[x] is CodePrimitiveExpression)) ||" is 141.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The length of the statement  "                    (parts[i - 1] is Script.Operator || parts[i - 1] as CodeBinaryOperatorType? == CodeBinaryOperatorType.Assign || IsVarAssignment(parts[i - 1])) &&" is 145.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The length of the statement  "                            while (parts[u] is Script.Operator && ((Script.Operator)parts[u] == Script.Operator.Add || (Script.Operator)parts[u] == Script.Operator.Subtract))" is 146.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The length of the statement  "                        if (i + 3 < parts.Count && IsVarReference(parts[i + 1]) && parts[i + 2] as CodeBinaryOperatorType? == CodeBinaryOperatorType.Assign)" is 132.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The length of the statement  "                                boolean.Operator = op == Script.Operator.BooleanAnd ? CodeBinaryOperatorType.BooleanAnd : CodeBinaryOperatorType.BooleanOr;" is 123.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The length of the statement  "                                if (LaxExpressions && parts[i] is Script.Operator && (Script.Operator)parts[i] == Script.Operator.Concat && parts[x] as CodeBinaryOperatorType? == CodeBinaryOperatorType.Assign)" is 177.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The length of the statement  "                    if (!(typed || parts[i] is CodeMethodInvokeExpression || parts[i] is CodePrimitiveExpression || parts[i] is CodeTernaryOperatorExpression || parts[i] is CodeBinaryOperatorExpression || parts[i] is CodePropertyReferenceExpression))" is 230.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseFlow,The length of the statement  "                        var block = new CodeBlock(line' Scope' ifelse.TrueStatements' CodeBlock.BlockKind.IfElse' blocks.Count == 0 ? null : blocks.Peek());" is 132.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseFlow,The length of the statement  "                        var block = new CodeBlock(lines[index]' Scope' elses.Pop()' CodeBlock.BlockKind.IfElse' blocks.Count == 0 ? null : blocks.Peek()) { Type = type };" is 146.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseFlow,The length of the statement  "                        return new CodeStatement[] { new CodeExpressionStatement(LocalLabelInvoke(parts[1]))' new CodeMethodReturnStatement() };" is 120.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseFlow,The length of the statement  "                        var block = new CodeBlock(line' Scope' loop.Statements' CodeBlock.BlockKind.Loop' blocks.Count == 0 ? null : blocks.Peek()' InternalID' InternalID);" is 148.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseFlow,The length of the statement  "                        CodeExpression condition = parts.Length > 1 ? ParseFlowParameter(parts[1]' true' out blockOpen' true) : new CodePrimitiveExpression(true);" is 138.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseFlow,The length of the statement  "                        var block = new CodeBlock(line' Scope' loop.Statements' CodeBlock.BlockKind.Loop' blocks.Count == 0 ? null : blocks.Peek()' InternalID' InternalID);" is 148.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseFunction,The length of the statement  "            var block = new CodeBlock(line' method.Name' method.Statements' CodeBlock.BlockKind.Function' blocks.Count == 0 ? null : blocks.Peek());" is 136.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseFunctionParameters,The length of the statement  "            List<CodePrimitiveExpression> names = new List<CodePrimitiveExpression>()' defaults = new List<CodePrimitiveExpression>();" is 122.
Long Statement,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,PushLabel,The length of the statement  "            var block = new CodeBlock(line' method.Name' method.Statements' CodeBlock.BlockKind.Label' blocks.Count == 0 ? null : blocks.Peek())" is 132.
Long Statement,IronAHK.Scripting,Script,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Script\Call.cs,IsNumeric,The length of the statement  "            return type == typeof(int) || type == typeof(long) || type == typeof(float) || type == typeof(double) || type == typeof(decimal);" is 129.
Long Statement,IronAHK.Scripting,MethodWriter,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Emission\MethodWriter.cs,EmitBinaryOperator,The length of the statement  "            bool Shortcut = Binary.Operator == CodeBinaryOperatorType.BooleanAnd || Binary.Operator == CodeBinaryOperatorType.BooleanOr;" is 124.
Long Statement,IronAHK.Scripting,ILMirror,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,GrabPInvokeImpl,The length of the statement  "            MethodBuilder PInvoke = On.DefinePInvokeMethod(Original.Name' Attr.Value' Original.Attributes' Original.CallingConvention' " is 122.
Long Statement,IronAHK.Scripting,ILMirror,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,CopyOpcode,The length of the statement  "                    // messy fix to convert short branch targets to normal ones' since there's no easy way to calculate offsets via reflection" is 122.
Complex Conditional,IronAHK.Scripting,Compiler,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\CompilerSetup.cs,MineMethods,The conditional expression  "Method.IsPrivate || Method.IsAbstract || Method.IsConstructor || !Method.IsStatic || Method.IsGenericMethod ||                    Method.Name.StartsWith("get_") || Method.Name.StartsWith("set_")"  is complex.
Complex Conditional,IronAHK.Scripting,Emit,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,EmitInvoke,The conditional expression  "name == Parser.InternalMethods.IfLegacy.MethodName && invoke.Parameters.Count == 3 &&                     invoke.Parameters[1] is CodePrimitiveExpression && (((CodePrimitiveExpression)invoke.Parameters[1]).Value as string) == Parser.IsTxt"  is complex.
Complex Conditional,IronAHK.Scripting,Emit,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,EmitArrayIndexer,The conditional expression  "array.TargetObject is CodePropertyReferenceExpression &&                 ((CodePropertyReferenceExpression)array.TargetObject).PropertyName == Parser.VarProperty &&                 array.Indices.Count == 1 && array.Indices[0] is CodePrimitiveExpression"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Set,The conditional expression  "expect == BlockClose && levels[0] == 0 && levels[1] == 0 && levels[2] == 0"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Set,The conditional expression  "expect == ArrayClose && levels[0] == 0 && levels[1] == 0 && levels[2] == 0"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Set,The conditional expression  "expect == ParenClose && levels[0] == 0 && levels[1] == 0 && levels[2] == 0"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitTokens,The conditional expression  "IsIdentifier(sym) || sym == Resolve || (sym == Concatenate && i + 1 < code.Length && IsIdentifier(code[i + 1]))"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitTokens,The conditional expression  "(sym == 'e' || sym == 'E') && IsPrimativeObject(id.ToString()) && id.ToString().IndexOf("0x") != 0 && i + 1 < code.Length"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitTokens,The conditional expression  "IsIdentifier(sym) || sym == Resolve || (sym == Concatenate && (i + 1 < code.Length ? code[i + 1] != Equal : true))"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitTokens,The conditional expression  "(sym == Less && symNext == Greater) || (sym == TernaryA && symNext == TernaryA)"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,RemoveExcessParentheses,The conditional expression  "!(--last > 1 &&                     parts[0] is string && ((string)parts[0]).Length == 1 && ((string)parts[0])[0] == ParenOpen &&                     parts[last] is string && ((string)parts[last]).Length == 1 && ((string)parts[last])[0] == ParenClose)"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsIdentifier,The conditional expression  "token[0] == TernaryA && (token.Length == 1 || token.Length == 2 && token[1] == TernaryA)"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitCommandParameters,The conditional expression  "sym == Multicast && (i == 0 || code[i - 1] != Escape) && !str && levels[0] == 0 && levels[1] == 0 && levels[2] == 0"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseCommandParameter,The conditional expression  "expr && code.Length > 2 && code[0] == Resolve && code[code.Length - 1] == Resolve"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The conditional expression  "zx[1] < parts.Count &&                                             parts[zx[1]] is string && ((string)parts[zx[1]]).Length == 1 && ((string)parts[zx[1]])[0] == ParenClose &&                                             (parts[zx[0]] is string && IsDynamicReference((string)parts[zx[0]]) || IsVarReference(parts[zx[0]]))"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The conditional expression  "(x > 0 && (parts[x] is CodeBinaryOperatorExpression || parts[x] is CodeMethodInvokeExpression || parts[x] is CodePrimitiveExpression)) ||                                         (y < parts.Count && (parts[y] is string && !IsOperator(parts[y] as string) || parts[y] is Script.Operator))"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The conditional expression  "w < parts.Count && (parts[w] is string && IsAssignOp((string)parts[w]) || IsVarAssignment(parts[w]))"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The conditional expression  "y < parts.Count && (IsVarReference(parts[y]) ||                                         (parts[y] is string && IsIdentifier((string)parts[y]) && !IsKeyword((string)parts[y])))"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The conditional expression  "parts[i] is Script.Operator &&                     (parts[i - 1] is Script.Operator || parts[i - 1] as CodeBinaryOperatorType? == CodeBinaryOperatorType.Assign || IsVarAssignment(parts[i - 1])) &&                     IsUnaryOperator((Script.Operator)parts[i])"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The conditional expression  "LaxExpressions && parts[i] is Script.Operator && (Script.Operator)parts[i] == Script.Operator.Concat && parts[x] as CodeBinaryOperatorType? == CodeBinaryOperatorType.Assign"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The conditional expression  "!(typed || parts[i] is CodeMethodInvokeExpression || parts[i] is CodePrimitiveExpression || parts[i] is CodeTernaryOperatorExpression || parts[i] is CodeBinaryOperatorExpression || parts[i] is CodePropertyReferenceExpression)"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Read,The conditional expression  "line == 1 && code.Length > 2 && code[0] == '#' && code[1] == '!'"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Read,The conditional expression  "parts[1].Length > 3 && parts[1][0] == '*' && (parts[1][1] == 'i' || parts[1][1] == 'I') && IsSpace(parts[1][2])"  is complex.
Complex Conditional,IronAHK.Scripting,Script,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Script\Call.cs,ForceBool,The conditional expression  "input is decimal || input is float || input is double || input is long || input is int"  is complex.
Complex Conditional,IronAHK.Scripting,Script,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Script\Call.cs,IfLegacy,The conditional expression  "var.Length > 3 && var[0] == '0' && (var[1] == 'x' || var[1] == 'X')"  is complex.
Complex Conditional,IronAHK.Scripting,Script,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Script\Call.cs,IfLegacy,The conditional expression  "!(char.IsDigit(sym) || (sym > 'a' - 1 && sym < 'f' + 1) || (sym > 'A' - 1 && sym < 'F' + 1))"  is complex.
Empty Catch Block,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OptimiseExpression,The method has an empty catch block.
Magic Number,IronAHK.Scripting,Emit,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,ScriptOperator,The following statement contains a magic number: switch (op)             {                 case Script.Operator.Add: return Parser.Add.ToString();                 case Script.Operator.Address: return Parser.Address.ToString();                 case Script.Operator.Assign: return new string(new[] { Parser.AssignPre' Parser.Equal });                 case Script.Operator.BitShiftLeft: return new string(Parser.Less' 2);                 case Script.Operator.BitShiftRight: return new string(Parser.Greater' 2);                 case Script.Operator.BitwiseAnd: return Parser.BitAND.ToString();                 case Script.Operator.BitwiseNot: return Parser.BitNOT.ToString();                 case Script.Operator.BitwiseOr: return Parser.BitOR.ToString();                 case Script.Operator.BitwiseXor: return Parser.BitXOR.ToString();                 case Script.Operator.BooleanAnd: return Parser.AndTxt;                 case Script.Operator.BooleanOr: return Parser.OrTxt;                 case Script.Operator.Concat: return Parser.Concatenate.ToString();                 case Script.Operator.Decrement: return new string(Parser.Subtract' 2);;                 case Script.Operator.Dereference: return Parser.Dereference.ToString();                 case Script.Operator.Divide: return Parser.Divide.ToString();                 case Script.Operator.FloorDivide: return new string(Parser.Divide' 2);                 case Script.Operator.GreaterThan: return Parser.Greater.ToString();                 case Script.Operator.GreaterThanOrEqual: return new string(new[] { Parser.Greater' Parser.Equal });                 case Script.Operator.IdentityEquality: return new string(Parser.Equal' 2);                 case Script.Operator.IdentityInequality: return new string(new[] { Parser.Not' Parser.Equal' Parser.Equal });                 case Script.Operator.Increment: return new string(Parser.Add' 2);                 case Script.Operator.LessThan: return Parser.Less.ToString();                 case Script.Operator.LessThanOrEqual: return new string(new[] { Parser.Less' Parser.Equal });                 case Script.Operator.LogicalNot: return Parser.Not.ToString();                 case Script.Operator.LogicalNotEx: return Parser.NotTxt;                 case Script.Operator.Minus: return Parser.Minus.ToString();                 case Script.Operator.Multiply: return Parser.Multiply.ToString();                 case Script.Operator.Power: return new string(Parser.Multiply' 2);                 case Script.Operator.Subtract: return Parser.Subtract.ToString();                 case Script.Operator.TernaryA: return Parser.TernaryA.ToString();                 case Script.Operator.TernaryB: return Parser.TernaryB.ToString(); ;                 case Script.Operator.ValueEquality: return Parser.Equal.ToString();                 case Script.Operator.ValueInequality: return new string(new[] { Parser.Not' Parser.Equal });                  default: throw new ArgumentOutOfRangeException("op");             }
Magic Number,IronAHK.Scripting,Emit,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,ScriptOperator,The following statement contains a magic number: switch (op)             {                 case Script.Operator.Add: return Parser.Add.ToString();                 case Script.Operator.Address: return Parser.Address.ToString();                 case Script.Operator.Assign: return new string(new[] { Parser.AssignPre' Parser.Equal });                 case Script.Operator.BitShiftLeft: return new string(Parser.Less' 2);                 case Script.Operator.BitShiftRight: return new string(Parser.Greater' 2);                 case Script.Operator.BitwiseAnd: return Parser.BitAND.ToString();                 case Script.Operator.BitwiseNot: return Parser.BitNOT.ToString();                 case Script.Operator.BitwiseOr: return Parser.BitOR.ToString();                 case Script.Operator.BitwiseXor: return Parser.BitXOR.ToString();                 case Script.Operator.BooleanAnd: return Parser.AndTxt;                 case Script.Operator.BooleanOr: return Parser.OrTxt;                 case Script.Operator.Concat: return Parser.Concatenate.ToString();                 case Script.Operator.Decrement: return new string(Parser.Subtract' 2);;                 case Script.Operator.Dereference: return Parser.Dereference.ToString();                 case Script.Operator.Divide: return Parser.Divide.ToString();                 case Script.Operator.FloorDivide: return new string(Parser.Divide' 2);                 case Script.Operator.GreaterThan: return Parser.Greater.ToString();                 case Script.Operator.GreaterThanOrEqual: return new string(new[] { Parser.Greater' Parser.Equal });                 case Script.Operator.IdentityEquality: return new string(Parser.Equal' 2);                 case Script.Operator.IdentityInequality: return new string(new[] { Parser.Not' Parser.Equal' Parser.Equal });                 case Script.Operator.Increment: return new string(Parser.Add' 2);                 case Script.Operator.LessThan: return Parser.Less.ToString();                 case Script.Operator.LessThanOrEqual: return new string(new[] { Parser.Less' Parser.Equal });                 case Script.Operator.LogicalNot: return Parser.Not.ToString();                 case Script.Operator.LogicalNotEx: return Parser.NotTxt;                 case Script.Operator.Minus: return Parser.Minus.ToString();                 case Script.Operator.Multiply: return Parser.Multiply.ToString();                 case Script.Operator.Power: return new string(Parser.Multiply' 2);                 case Script.Operator.Subtract: return Parser.Subtract.ToString();                 case Script.Operator.TernaryA: return Parser.TernaryA.ToString();                 case Script.Operator.TernaryB: return Parser.TernaryB.ToString(); ;                 case Script.Operator.ValueEquality: return Parser.Equal.ToString();                 case Script.Operator.ValueInequality: return new string(new[] { Parser.Not' Parser.Equal });                  default: throw new ArgumentOutOfRangeException("op");             }
Magic Number,IronAHK.Scripting,Emit,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,ScriptOperator,The following statement contains a magic number: switch (op)             {                 case Script.Operator.Add: return Parser.Add.ToString();                 case Script.Operator.Address: return Parser.Address.ToString();                 case Script.Operator.Assign: return new string(new[] { Parser.AssignPre' Parser.Equal });                 case Script.Operator.BitShiftLeft: return new string(Parser.Less' 2);                 case Script.Operator.BitShiftRight: return new string(Parser.Greater' 2);                 case Script.Operator.BitwiseAnd: return Parser.BitAND.ToString();                 case Script.Operator.BitwiseNot: return Parser.BitNOT.ToString();                 case Script.Operator.BitwiseOr: return Parser.BitOR.ToString();                 case Script.Operator.BitwiseXor: return Parser.BitXOR.ToString();                 case Script.Operator.BooleanAnd: return Parser.AndTxt;                 case Script.Operator.BooleanOr: return Parser.OrTxt;                 case Script.Operator.Concat: return Parser.Concatenate.ToString();                 case Script.Operator.Decrement: return new string(Parser.Subtract' 2);;                 case Script.Operator.Dereference: return Parser.Dereference.ToString();                 case Script.Operator.Divide: return Parser.Divide.ToString();                 case Script.Operator.FloorDivide: return new string(Parser.Divide' 2);                 case Script.Operator.GreaterThan: return Parser.Greater.ToString();                 case Script.Operator.GreaterThanOrEqual: return new string(new[] { Parser.Greater' Parser.Equal });                 case Script.Operator.IdentityEquality: return new string(Parser.Equal' 2);                 case Script.Operator.IdentityInequality: return new string(new[] { Parser.Not' Parser.Equal' Parser.Equal });                 case Script.Operator.Increment: return new string(Parser.Add' 2);                 case Script.Operator.LessThan: return Parser.Less.ToString();                 case Script.Operator.LessThanOrEqual: return new string(new[] { Parser.Less' Parser.Equal });                 case Script.Operator.LogicalNot: return Parser.Not.ToString();                 case Script.Operator.LogicalNotEx: return Parser.NotTxt;                 case Script.Operator.Minus: return Parser.Minus.ToString();                 case Script.Operator.Multiply: return Parser.Multiply.ToString();                 case Script.Operator.Power: return new string(Parser.Multiply' 2);                 case Script.Operator.Subtract: return Parser.Subtract.ToString();                 case Script.Operator.TernaryA: return Parser.TernaryA.ToString();                 case Script.Operator.TernaryB: return Parser.TernaryB.ToString(); ;                 case Script.Operator.ValueEquality: return Parser.Equal.ToString();                 case Script.Operator.ValueInequality: return new string(new[] { Parser.Not' Parser.Equal });                  default: throw new ArgumentOutOfRangeException("op");             }
Magic Number,IronAHK.Scripting,Emit,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,ScriptOperator,The following statement contains a magic number: switch (op)             {                 case Script.Operator.Add: return Parser.Add.ToString();                 case Script.Operator.Address: return Parser.Address.ToString();                 case Script.Operator.Assign: return new string(new[] { Parser.AssignPre' Parser.Equal });                 case Script.Operator.BitShiftLeft: return new string(Parser.Less' 2);                 case Script.Operator.BitShiftRight: return new string(Parser.Greater' 2);                 case Script.Operator.BitwiseAnd: return Parser.BitAND.ToString();                 case Script.Operator.BitwiseNot: return Parser.BitNOT.ToString();                 case Script.Operator.BitwiseOr: return Parser.BitOR.ToString();                 case Script.Operator.BitwiseXor: return Parser.BitXOR.ToString();                 case Script.Operator.BooleanAnd: return Parser.AndTxt;                 case Script.Operator.BooleanOr: return Parser.OrTxt;                 case Script.Operator.Concat: return Parser.Concatenate.ToString();                 case Script.Operator.Decrement: return new string(Parser.Subtract' 2);;                 case Script.Operator.Dereference: return Parser.Dereference.ToString();                 case Script.Operator.Divide: return Parser.Divide.ToString();                 case Script.Operator.FloorDivide: return new string(Parser.Divide' 2);                 case Script.Operator.GreaterThan: return Parser.Greater.ToString();                 case Script.Operator.GreaterThanOrEqual: return new string(new[] { Parser.Greater' Parser.Equal });                 case Script.Operator.IdentityEquality: return new string(Parser.Equal' 2);                 case Script.Operator.IdentityInequality: return new string(new[] { Parser.Not' Parser.Equal' Parser.Equal });                 case Script.Operator.Increment: return new string(Parser.Add' 2);                 case Script.Operator.LessThan: return Parser.Less.ToString();                 case Script.Operator.LessThanOrEqual: return new string(new[] { Parser.Less' Parser.Equal });                 case Script.Operator.LogicalNot: return Parser.Not.ToString();                 case Script.Operator.LogicalNotEx: return Parser.NotTxt;                 case Script.Operator.Minus: return Parser.Minus.ToString();                 case Script.Operator.Multiply: return Parser.Multiply.ToString();                 case Script.Operator.Power: return new string(Parser.Multiply' 2);                 case Script.Operator.Subtract: return Parser.Subtract.ToString();                 case Script.Operator.TernaryA: return Parser.TernaryA.ToString();                 case Script.Operator.TernaryB: return Parser.TernaryB.ToString(); ;                 case Script.Operator.ValueEquality: return Parser.Equal.ToString();                 case Script.Operator.ValueInequality: return new string(new[] { Parser.Not' Parser.Equal });                  default: throw new ArgumentOutOfRangeException("op");             }
Magic Number,IronAHK.Scripting,Emit,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,ScriptOperator,The following statement contains a magic number: switch (op)             {                 case Script.Operator.Add: return Parser.Add.ToString();                 case Script.Operator.Address: return Parser.Address.ToString();                 case Script.Operator.Assign: return new string(new[] { Parser.AssignPre' Parser.Equal });                 case Script.Operator.BitShiftLeft: return new string(Parser.Less' 2);                 case Script.Operator.BitShiftRight: return new string(Parser.Greater' 2);                 case Script.Operator.BitwiseAnd: return Parser.BitAND.ToString();                 case Script.Operator.BitwiseNot: return Parser.BitNOT.ToString();                 case Script.Operator.BitwiseOr: return Parser.BitOR.ToString();                 case Script.Operator.BitwiseXor: return Parser.BitXOR.ToString();                 case Script.Operator.BooleanAnd: return Parser.AndTxt;                 case Script.Operator.BooleanOr: return Parser.OrTxt;                 case Script.Operator.Concat: return Parser.Concatenate.ToString();                 case Script.Operator.Decrement: return new string(Parser.Subtract' 2);;                 case Script.Operator.Dereference: return Parser.Dereference.ToString();                 case Script.Operator.Divide: return Parser.Divide.ToString();                 case Script.Operator.FloorDivide: return new string(Parser.Divide' 2);                 case Script.Operator.GreaterThan: return Parser.Greater.ToString();                 case Script.Operator.GreaterThanOrEqual: return new string(new[] { Parser.Greater' Parser.Equal });                 case Script.Operator.IdentityEquality: return new string(Parser.Equal' 2);                 case Script.Operator.IdentityInequality: return new string(new[] { Parser.Not' Parser.Equal' Parser.Equal });                 case Script.Operator.Increment: return new string(Parser.Add' 2);                 case Script.Operator.LessThan: return Parser.Less.ToString();                 case Script.Operator.LessThanOrEqual: return new string(new[] { Parser.Less' Parser.Equal });                 case Script.Operator.LogicalNot: return Parser.Not.ToString();                 case Script.Operator.LogicalNotEx: return Parser.NotTxt;                 case Script.Operator.Minus: return Parser.Minus.ToString();                 case Script.Operator.Multiply: return Parser.Multiply.ToString();                 case Script.Operator.Power: return new string(Parser.Multiply' 2);                 case Script.Operator.Subtract: return Parser.Subtract.ToString();                 case Script.Operator.TernaryA: return Parser.TernaryA.ToString();                 case Script.Operator.TernaryB: return Parser.TernaryB.ToString(); ;                 case Script.Operator.ValueEquality: return Parser.Equal.ToString();                 case Script.Operator.ValueInequality: return new string(new[] { Parser.Not' Parser.Equal });                  default: throw new ArgumentOutOfRangeException("op");             }
Magic Number,IronAHK.Scripting,Emit,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,ScriptOperator,The following statement contains a magic number: switch (op)             {                 case Script.Operator.Add: return Parser.Add.ToString();                 case Script.Operator.Address: return Parser.Address.ToString();                 case Script.Operator.Assign: return new string(new[] { Parser.AssignPre' Parser.Equal });                 case Script.Operator.BitShiftLeft: return new string(Parser.Less' 2);                 case Script.Operator.BitShiftRight: return new string(Parser.Greater' 2);                 case Script.Operator.BitwiseAnd: return Parser.BitAND.ToString();                 case Script.Operator.BitwiseNot: return Parser.BitNOT.ToString();                 case Script.Operator.BitwiseOr: return Parser.BitOR.ToString();                 case Script.Operator.BitwiseXor: return Parser.BitXOR.ToString();                 case Script.Operator.BooleanAnd: return Parser.AndTxt;                 case Script.Operator.BooleanOr: return Parser.OrTxt;                 case Script.Operator.Concat: return Parser.Concatenate.ToString();                 case Script.Operator.Decrement: return new string(Parser.Subtract' 2);;                 case Script.Operator.Dereference: return Parser.Dereference.ToString();                 case Script.Operator.Divide: return Parser.Divide.ToString();                 case Script.Operator.FloorDivide: return new string(Parser.Divide' 2);                 case Script.Operator.GreaterThan: return Parser.Greater.ToString();                 case Script.Operator.GreaterThanOrEqual: return new string(new[] { Parser.Greater' Parser.Equal });                 case Script.Operator.IdentityEquality: return new string(Parser.Equal' 2);                 case Script.Operator.IdentityInequality: return new string(new[] { Parser.Not' Parser.Equal' Parser.Equal });                 case Script.Operator.Increment: return new string(Parser.Add' 2);                 case Script.Operator.LessThan: return Parser.Less.ToString();                 case Script.Operator.LessThanOrEqual: return new string(new[] { Parser.Less' Parser.Equal });                 case Script.Operator.LogicalNot: return Parser.Not.ToString();                 case Script.Operator.LogicalNotEx: return Parser.NotTxt;                 case Script.Operator.Minus: return Parser.Minus.ToString();                 case Script.Operator.Multiply: return Parser.Multiply.ToString();                 case Script.Operator.Power: return new string(Parser.Multiply' 2);                 case Script.Operator.Subtract: return Parser.Subtract.ToString();                 case Script.Operator.TernaryA: return Parser.TernaryA.ToString();                 case Script.Operator.TernaryB: return Parser.TernaryB.ToString(); ;                 case Script.Operator.ValueEquality: return Parser.Equal.ToString();                 case Script.Operator.ValueInequality: return new string(new[] { Parser.Not' Parser.Equal });                  default: throw new ArgumentOutOfRangeException("op");             }
Magic Number,IronAHK.Scripting,Emit,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,ScriptOperator,The following statement contains a magic number: switch (op)             {                 case Script.Operator.Add: return Parser.Add.ToString();                 case Script.Operator.Address: return Parser.Address.ToString();                 case Script.Operator.Assign: return new string(new[] { Parser.AssignPre' Parser.Equal });                 case Script.Operator.BitShiftLeft: return new string(Parser.Less' 2);                 case Script.Operator.BitShiftRight: return new string(Parser.Greater' 2);                 case Script.Operator.BitwiseAnd: return Parser.BitAND.ToString();                 case Script.Operator.BitwiseNot: return Parser.BitNOT.ToString();                 case Script.Operator.BitwiseOr: return Parser.BitOR.ToString();                 case Script.Operator.BitwiseXor: return Parser.BitXOR.ToString();                 case Script.Operator.BooleanAnd: return Parser.AndTxt;                 case Script.Operator.BooleanOr: return Parser.OrTxt;                 case Script.Operator.Concat: return Parser.Concatenate.ToString();                 case Script.Operator.Decrement: return new string(Parser.Subtract' 2);;                 case Script.Operator.Dereference: return Parser.Dereference.ToString();                 case Script.Operator.Divide: return Parser.Divide.ToString();                 case Script.Operator.FloorDivide: return new string(Parser.Divide' 2);                 case Script.Operator.GreaterThan: return Parser.Greater.ToString();                 case Script.Operator.GreaterThanOrEqual: return new string(new[] { Parser.Greater' Parser.Equal });                 case Script.Operator.IdentityEquality: return new string(Parser.Equal' 2);                 case Script.Operator.IdentityInequality: return new string(new[] { Parser.Not' Parser.Equal' Parser.Equal });                 case Script.Operator.Increment: return new string(Parser.Add' 2);                 case Script.Operator.LessThan: return Parser.Less.ToString();                 case Script.Operator.LessThanOrEqual: return new string(new[] { Parser.Less' Parser.Equal });                 case Script.Operator.LogicalNot: return Parser.Not.ToString();                 case Script.Operator.LogicalNotEx: return Parser.NotTxt;                 case Script.Operator.Minus: return Parser.Minus.ToString();                 case Script.Operator.Multiply: return Parser.Multiply.ToString();                 case Script.Operator.Power: return new string(Parser.Multiply' 2);                 case Script.Operator.Subtract: return Parser.Subtract.ToString();                 case Script.Operator.TernaryA: return Parser.TernaryA.ToString();                 case Script.Operator.TernaryB: return Parser.TernaryB.ToString(); ;                 case Script.Operator.ValueEquality: return Parser.Equal.ToString();                 case Script.Operator.ValueInequality: return new string(new[] { Parser.Not' Parser.Equal });                  default: throw new ArgumentOutOfRangeException("op");             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,MergeObjectAssignmentAt,The following statement contains a magic number: invoke.Parameters.Count == 2 && invoke.Method.MethodName == InternalMethods.Index.MethodName
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsOptimisableExpression,The following statement contains a magic number: return invoke.Method.MethodName == InternalMethods.Operate.MethodName && invoke.Parameters.Count == 3;
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OptimiseExpression,The following statement contains a magic number: i < 3
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OptimiseExpression,The following statement contains a magic number: result = Script.Operate((Script.Operator)invoke.Parameters[0].UserData[RawData]'                         ((CodePrimitiveExpression)invoke.Parameters[1]).Value'                         ((CodePrimitiveExpression)invoke.Parameters[2]).Value);
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OptimiseExpression,The following statement contains a magic number: invoke.Parameters[1] is CodePrimitiveExpression && invoke.Parameters[2] is CodePrimitiveExpression
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OptimiseLoneExpression,The following statement contains a magic number: i < 3
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OptimiseLoneExpression,The following statement contains a magic number: bool left = invoke.Parameters[1] is CodePrimitiveExpression' right = invoke.Parameters[2] is CodeExpression;
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OptimiseLoneExpression,The following statement contains a magic number: return invoke.Parameters[2];
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseObject,The following statement contains a magic number: name = name.Substring(1' name.Length - 2);
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseObject,The following statement contains a magic number: name.Length > 2 && name[0] == StringBound && name[name.Length - 1] == StringBound
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Set,The following statement contains a magic number: levels[0] != 0 || levels[1] != 0 || levels[2] != 0
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorFromString,The following statement contains a magic number: switch (op[0])             {                 case Add:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Add;                          case 2:                             return Script.Operator.Increment;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Minus:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Subtract;                          case 2:                             return Script.Operator.Decrement;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Multiply:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Multiply;                          case 2:                             return Script.Operator.Power;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Divide:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Divide;                          case 2:                             return Script.Operator.FloorDivide;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Greater:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.GreaterThan;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.BitShiftRight;                             else if (op[1] == Equal)                                 return Script.Operator.GreaterThanOrEqual;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case Less:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.LessThan;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.BitShiftLeft;                             else if (op[1] == Equal)                                 return Script.Operator.LessThanOrEqual;                             else if (op[1] == Greater)                                 return Script.Operator.ValueInequality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitAND:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseAnd;                          case 2:                             if (op[0] == op[1])                                 return Script.Operator.BooleanAnd;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitOR:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseOr;                          case 2:                             if (op[0] == op[1])                                 return Script.Operator.BooleanOr;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitXOR:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseXor;                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitNOT:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseNot;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Equal:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.ValueEquality;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.IdentityEquality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case Not:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.LogicalNot;                          case 2:                             if (op[1] == Equal)                                 return Script.Operator.ValueInequality;                             else                                 throw new ParseException(ExUnexpected);                          case 3:                             if (op[1] == Equal && op[2] == Equal)                                 return Script.Operator.IdentityInequality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case AssignPre:                     if (op.Length > 1 && op[1] == Equal)                         return Script.Operator.Assign;                     else                         return Script.Operator.TernaryB;                  case Concatenate:                     return Script.Operator.Concat;                  case TernaryA:                     if (op.Length > 1 && op[1] == TernaryA)                         return Script.Operator.NullAssign;                     else                         return Script.Operator.TernaryA;                  default:                     switch (code.ToLowerInvariant())                     {                         case NotTxt:                             return Script.Operator.LogicalNotEx;                          case AndTxt:                             return Script.Operator.BooleanAnd;                          case OrTxt:                             return Script.Operator.BooleanOr;                          case IsTxt:                             return Script.Operator.Is;                     }                     throw new ArgumentOutOfRangeException();             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorFromString,The following statement contains a magic number: switch (op[0])             {                 case Add:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Add;                          case 2:                             return Script.Operator.Increment;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Minus:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Subtract;                          case 2:                             return Script.Operator.Decrement;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Multiply:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Multiply;                          case 2:                             return Script.Operator.Power;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Divide:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Divide;                          case 2:                             return Script.Operator.FloorDivide;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Greater:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.GreaterThan;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.BitShiftRight;                             else if (op[1] == Equal)                                 return Script.Operator.GreaterThanOrEqual;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case Less:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.LessThan;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.BitShiftLeft;                             else if (op[1] == Equal)                                 return Script.Operator.LessThanOrEqual;                             else if (op[1] == Greater)                                 return Script.Operator.ValueInequality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitAND:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseAnd;                          case 2:                             if (op[0] == op[1])                                 return Script.Operator.BooleanAnd;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitOR:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseOr;                          case 2:                             if (op[0] == op[1])                                 return Script.Operator.BooleanOr;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitXOR:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseXor;                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitNOT:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseNot;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Equal:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.ValueEquality;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.IdentityEquality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case Not:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.LogicalNot;                          case 2:                             if (op[1] == Equal)                                 return Script.Operator.ValueInequality;                             else                                 throw new ParseException(ExUnexpected);                          case 3:                             if (op[1] == Equal && op[2] == Equal)                                 return Script.Operator.IdentityInequality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case AssignPre:                     if (op.Length > 1 && op[1] == Equal)                         return Script.Operator.Assign;                     else                         return Script.Operator.TernaryB;                  case Concatenate:                     return Script.Operator.Concat;                  case TernaryA:                     if (op.Length > 1 && op[1] == TernaryA)                         return Script.Operator.NullAssign;                     else                         return Script.Operator.TernaryA;                  default:                     switch (code.ToLowerInvariant())                     {                         case NotTxt:                             return Script.Operator.LogicalNotEx;                          case AndTxt:                             return Script.Operator.BooleanAnd;                          case OrTxt:                             return Script.Operator.BooleanOr;                          case IsTxt:                             return Script.Operator.Is;                     }                     throw new ArgumentOutOfRangeException();             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorFromString,The following statement contains a magic number: switch (op[0])             {                 case Add:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Add;                          case 2:                             return Script.Operator.Increment;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Minus:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Subtract;                          case 2:                             return Script.Operator.Decrement;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Multiply:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Multiply;                          case 2:                             return Script.Operator.Power;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Divide:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Divide;                          case 2:                             return Script.Operator.FloorDivide;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Greater:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.GreaterThan;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.BitShiftRight;                             else if (op[1] == Equal)                                 return Script.Operator.GreaterThanOrEqual;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case Less:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.LessThan;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.BitShiftLeft;                             else if (op[1] == Equal)                                 return Script.Operator.LessThanOrEqual;                             else if (op[1] == Greater)                                 return Script.Operator.ValueInequality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitAND:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseAnd;                          case 2:                             if (op[0] == op[1])                                 return Script.Operator.BooleanAnd;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitOR:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseOr;                          case 2:                             if (op[0] == op[1])                                 return Script.Operator.BooleanOr;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitXOR:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseXor;                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitNOT:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseNot;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Equal:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.ValueEquality;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.IdentityEquality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case Not:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.LogicalNot;                          case 2:                             if (op[1] == Equal)                                 return Script.Operator.ValueInequality;                             else                                 throw new ParseException(ExUnexpected);                          case 3:                             if (op[1] == Equal && op[2] == Equal)                                 return Script.Operator.IdentityInequality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case AssignPre:                     if (op.Length > 1 && op[1] == Equal)                         return Script.Operator.Assign;                     else                         return Script.Operator.TernaryB;                  case Concatenate:                     return Script.Operator.Concat;                  case TernaryA:                     if (op.Length > 1 && op[1] == TernaryA)                         return Script.Operator.NullAssign;                     else                         return Script.Operator.TernaryA;                  default:                     switch (code.ToLowerInvariant())                     {                         case NotTxt:                             return Script.Operator.LogicalNotEx;                          case AndTxt:                             return Script.Operator.BooleanAnd;                          case OrTxt:                             return Script.Operator.BooleanOr;                          case IsTxt:                             return Script.Operator.Is;                     }                     throw new ArgumentOutOfRangeException();             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorFromString,The following statement contains a magic number: switch (op[0])             {                 case Add:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Add;                          case 2:                             return Script.Operator.Increment;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Minus:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Subtract;                          case 2:                             return Script.Operator.Decrement;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Multiply:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Multiply;                          case 2:                             return Script.Operator.Power;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Divide:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Divide;                          case 2:                             return Script.Operator.FloorDivide;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Greater:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.GreaterThan;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.BitShiftRight;                             else if (op[1] == Equal)                                 return Script.Operator.GreaterThanOrEqual;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case Less:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.LessThan;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.BitShiftLeft;                             else if (op[1] == Equal)                                 return Script.Operator.LessThanOrEqual;                             else if (op[1] == Greater)                                 return Script.Operator.ValueInequality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitAND:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseAnd;                          case 2:                             if (op[0] == op[1])                                 return Script.Operator.BooleanAnd;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitOR:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseOr;                          case 2:                             if (op[0] == op[1])                                 return Script.Operator.BooleanOr;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitXOR:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseXor;                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitNOT:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseNot;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Equal:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.ValueEquality;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.IdentityEquality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case Not:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.LogicalNot;                          case 2:                             if (op[1] == Equal)                                 return Script.Operator.ValueInequality;                             else                                 throw new ParseException(ExUnexpected);                          case 3:                             if (op[1] == Equal && op[2] == Equal)                                 return Script.Operator.IdentityInequality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case AssignPre:                     if (op.Length > 1 && op[1] == Equal)                         return Script.Operator.Assign;                     else                         return Script.Operator.TernaryB;                  case Concatenate:                     return Script.Operator.Concat;                  case TernaryA:                     if (op.Length > 1 && op[1] == TernaryA)                         return Script.Operator.NullAssign;                     else                         return Script.Operator.TernaryA;                  default:                     switch (code.ToLowerInvariant())                     {                         case NotTxt:                             return Script.Operator.LogicalNotEx;                          case AndTxt:                             return Script.Operator.BooleanAnd;                          case OrTxt:                             return Script.Operator.BooleanOr;                          case IsTxt:                             return Script.Operator.Is;                     }                     throw new ArgumentOutOfRangeException();             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorFromString,The following statement contains a magic number: switch (op[0])             {                 case Add:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Add;                          case 2:                             return Script.Operator.Increment;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Minus:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Subtract;                          case 2:                             return Script.Operator.Decrement;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Multiply:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Multiply;                          case 2:                             return Script.Operator.Power;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Divide:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Divide;                          case 2:                             return Script.Operator.FloorDivide;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Greater:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.GreaterThan;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.BitShiftRight;                             else if (op[1] == Equal)                                 return Script.Operator.GreaterThanOrEqual;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case Less:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.LessThan;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.BitShiftLeft;                             else if (op[1] == Equal)                                 return Script.Operator.LessThanOrEqual;                             else if (op[1] == Greater)                                 return Script.Operator.ValueInequality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitAND:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseAnd;                          case 2:                             if (op[0] == op[1])                                 return Script.Operator.BooleanAnd;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitOR:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseOr;                          case 2:                             if (op[0] == op[1])                                 return Script.Operator.BooleanOr;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitXOR:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseXor;                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitNOT:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseNot;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Equal:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.ValueEquality;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.IdentityEquality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case Not:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.LogicalNot;                          case 2:                             if (op[1] == Equal)                                 return Script.Operator.ValueInequality;                             else                                 throw new ParseException(ExUnexpected);                          case 3:                             if (op[1] == Equal && op[2] == Equal)                                 return Script.Operator.IdentityInequality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case AssignPre:                     if (op.Length > 1 && op[1] == Equal)                         return Script.Operator.Assign;                     else                         return Script.Operator.TernaryB;                  case Concatenate:                     return Script.Operator.Concat;                  case TernaryA:                     if (op.Length > 1 && op[1] == TernaryA)                         return Script.Operator.NullAssign;                     else                         return Script.Operator.TernaryA;                  default:                     switch (code.ToLowerInvariant())                     {                         case NotTxt:                             return Script.Operator.LogicalNotEx;                          case AndTxt:                             return Script.Operator.BooleanAnd;                          case OrTxt:                             return Script.Operator.BooleanOr;                          case IsTxt:                             return Script.Operator.Is;                     }                     throw new ArgumentOutOfRangeException();             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorFromString,The following statement contains a magic number: switch (op[0])             {                 case Add:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Add;                          case 2:                             return Script.Operator.Increment;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Minus:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Subtract;                          case 2:                             return Script.Operator.Decrement;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Multiply:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Multiply;                          case 2:                             return Script.Operator.Power;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Divide:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Divide;                          case 2:                             return Script.Operator.FloorDivide;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Greater:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.GreaterThan;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.BitShiftRight;                             else if (op[1] == Equal)                                 return Script.Operator.GreaterThanOrEqual;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case Less:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.LessThan;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.BitShiftLeft;                             else if (op[1] == Equal)                                 return Script.Operator.LessThanOrEqual;                             else if (op[1] == Greater)                                 return Script.Operator.ValueInequality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitAND:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseAnd;                          case 2:                             if (op[0] == op[1])                                 return Script.Operator.BooleanAnd;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitOR:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseOr;                          case 2:                             if (op[0] == op[1])                                 return Script.Operator.BooleanOr;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitXOR:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseXor;                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitNOT:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseNot;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Equal:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.ValueEquality;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.IdentityEquality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case Not:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.LogicalNot;                          case 2:                             if (op[1] == Equal)                                 return Script.Operator.ValueInequality;                             else                                 throw new ParseException(ExUnexpected);                          case 3:                             if (op[1] == Equal && op[2] == Equal)                                 return Script.Operator.IdentityInequality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case AssignPre:                     if (op.Length > 1 && op[1] == Equal)                         return Script.Operator.Assign;                     else                         return Script.Operator.TernaryB;                  case Concatenate:                     return Script.Operator.Concat;                  case TernaryA:                     if (op.Length > 1 && op[1] == TernaryA)                         return Script.Operator.NullAssign;                     else                         return Script.Operator.TernaryA;                  default:                     switch (code.ToLowerInvariant())                     {                         case NotTxt:                             return Script.Operator.LogicalNotEx;                          case AndTxt:                             return Script.Operator.BooleanAnd;                          case OrTxt:                             return Script.Operator.BooleanOr;                          case IsTxt:                             return Script.Operator.Is;                     }                     throw new ArgumentOutOfRangeException();             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorFromString,The following statement contains a magic number: switch (op[0])             {                 case Add:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Add;                          case 2:                             return Script.Operator.Increment;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Minus:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Subtract;                          case 2:                             return Script.Operator.Decrement;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Multiply:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Multiply;                          case 2:                             return Script.Operator.Power;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Divide:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Divide;                          case 2:                             return Script.Operator.FloorDivide;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Greater:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.GreaterThan;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.BitShiftRight;                             else if (op[1] == Equal)                                 return Script.Operator.GreaterThanOrEqual;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case Less:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.LessThan;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.BitShiftLeft;                             else if (op[1] == Equal)                                 return Script.Operator.LessThanOrEqual;                             else if (op[1] == Greater)                                 return Script.Operator.ValueInequality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitAND:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseAnd;                          case 2:                             if (op[0] == op[1])                                 return Script.Operator.BooleanAnd;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitOR:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseOr;                          case 2:                             if (op[0] == op[1])                                 return Script.Operator.BooleanOr;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitXOR:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseXor;                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitNOT:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseNot;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Equal:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.ValueEquality;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.IdentityEquality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case Not:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.LogicalNot;                          case 2:                             if (op[1] == Equal)                                 return Script.Operator.ValueInequality;                             else                                 throw new ParseException(ExUnexpected);                          case 3:                             if (op[1] == Equal && op[2] == Equal)                                 return Script.Operator.IdentityInequality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case AssignPre:                     if (op.Length > 1 && op[1] == Equal)                         return Script.Operator.Assign;                     else                         return Script.Operator.TernaryB;                  case Concatenate:                     return Script.Operator.Concat;                  case TernaryA:                     if (op.Length > 1 && op[1] == TernaryA)                         return Script.Operator.NullAssign;                     else                         return Script.Operator.TernaryA;                  default:                     switch (code.ToLowerInvariant())                     {                         case NotTxt:                             return Script.Operator.LogicalNotEx;                          case AndTxt:                             return Script.Operator.BooleanAnd;                          case OrTxt:                             return Script.Operator.BooleanOr;                          case IsTxt:                             return Script.Operator.Is;                     }                     throw new ArgumentOutOfRangeException();             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorFromString,The following statement contains a magic number: switch (op[0])             {                 case Add:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Add;                          case 2:                             return Script.Operator.Increment;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Minus:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Subtract;                          case 2:                             return Script.Operator.Decrement;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Multiply:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Multiply;                          case 2:                             return Script.Operator.Power;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Divide:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Divide;                          case 2:                             return Script.Operator.FloorDivide;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Greater:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.GreaterThan;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.BitShiftRight;                             else if (op[1] == Equal)                                 return Script.Operator.GreaterThanOrEqual;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case Less:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.LessThan;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.BitShiftLeft;                             else if (op[1] == Equal)                                 return Script.Operator.LessThanOrEqual;                             else if (op[1] == Greater)                                 return Script.Operator.ValueInequality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitAND:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseAnd;                          case 2:                             if (op[0] == op[1])                                 return Script.Operator.BooleanAnd;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitOR:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseOr;                          case 2:                             if (op[0] == op[1])                                 return Script.Operator.BooleanOr;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitXOR:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseXor;                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitNOT:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseNot;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Equal:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.ValueEquality;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.IdentityEquality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case Not:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.LogicalNot;                          case 2:                             if (op[1] == Equal)                                 return Script.Operator.ValueInequality;                             else                                 throw new ParseException(ExUnexpected);                          case 3:                             if (op[1] == Equal && op[2] == Equal)                                 return Script.Operator.IdentityInequality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case AssignPre:                     if (op.Length > 1 && op[1] == Equal)                         return Script.Operator.Assign;                     else                         return Script.Operator.TernaryB;                  case Concatenate:                     return Script.Operator.Concat;                  case TernaryA:                     if (op.Length > 1 && op[1] == TernaryA)                         return Script.Operator.NullAssign;                     else                         return Script.Operator.TernaryA;                  default:                     switch (code.ToLowerInvariant())                     {                         case NotTxt:                             return Script.Operator.LogicalNotEx;                          case AndTxt:                             return Script.Operator.BooleanAnd;                          case OrTxt:                             return Script.Operator.BooleanOr;                          case IsTxt:                             return Script.Operator.Is;                     }                     throw new ArgumentOutOfRangeException();             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorFromString,The following statement contains a magic number: switch (op[0])             {                 case Add:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Add;                          case 2:                             return Script.Operator.Increment;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Minus:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Subtract;                          case 2:                             return Script.Operator.Decrement;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Multiply:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Multiply;                          case 2:                             return Script.Operator.Power;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Divide:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Divide;                          case 2:                             return Script.Operator.FloorDivide;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Greater:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.GreaterThan;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.BitShiftRight;                             else if (op[1] == Equal)                                 return Script.Operator.GreaterThanOrEqual;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case Less:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.LessThan;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.BitShiftLeft;                             else if (op[1] == Equal)                                 return Script.Operator.LessThanOrEqual;                             else if (op[1] == Greater)                                 return Script.Operator.ValueInequality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitAND:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseAnd;                          case 2:                             if (op[0] == op[1])                                 return Script.Operator.BooleanAnd;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitOR:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseOr;                          case 2:                             if (op[0] == op[1])                                 return Script.Operator.BooleanOr;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitXOR:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseXor;                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitNOT:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseNot;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Equal:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.ValueEquality;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.IdentityEquality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case Not:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.LogicalNot;                          case 2:                             if (op[1] == Equal)                                 return Script.Operator.ValueInequality;                             else                                 throw new ParseException(ExUnexpected);                          case 3:                             if (op[1] == Equal && op[2] == Equal)                                 return Script.Operator.IdentityInequality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case AssignPre:                     if (op.Length > 1 && op[1] == Equal)                         return Script.Operator.Assign;                     else                         return Script.Operator.TernaryB;                  case Concatenate:                     return Script.Operator.Concat;                  case TernaryA:                     if (op.Length > 1 && op[1] == TernaryA)                         return Script.Operator.NullAssign;                     else                         return Script.Operator.TernaryA;                  default:                     switch (code.ToLowerInvariant())                     {                         case NotTxt:                             return Script.Operator.LogicalNotEx;                          case AndTxt:                             return Script.Operator.BooleanAnd;                          case OrTxt:                             return Script.Operator.BooleanOr;                          case IsTxt:                             return Script.Operator.Is;                     }                     throw new ArgumentOutOfRangeException();             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorFromString,The following statement contains a magic number: switch (op[0])             {                 case Add:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Add;                          case 2:                             return Script.Operator.Increment;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Minus:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Subtract;                          case 2:                             return Script.Operator.Decrement;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Multiply:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Multiply;                          case 2:                             return Script.Operator.Power;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Divide:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Divide;                          case 2:                             return Script.Operator.FloorDivide;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Greater:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.GreaterThan;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.BitShiftRight;                             else if (op[1] == Equal)                                 return Script.Operator.GreaterThanOrEqual;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case Less:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.LessThan;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.BitShiftLeft;                             else if (op[1] == Equal)                                 return Script.Operator.LessThanOrEqual;                             else if (op[1] == Greater)                                 return Script.Operator.ValueInequality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitAND:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseAnd;                          case 2:                             if (op[0] == op[1])                                 return Script.Operator.BooleanAnd;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitOR:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseOr;                          case 2:                             if (op[0] == op[1])                                 return Script.Operator.BooleanOr;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitXOR:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseXor;                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitNOT:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseNot;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Equal:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.ValueEquality;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.IdentityEquality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case Not:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.LogicalNot;                          case 2:                             if (op[1] == Equal)                                 return Script.Operator.ValueInequality;                             else                                 throw new ParseException(ExUnexpected);                          case 3:                             if (op[1] == Equal && op[2] == Equal)                                 return Script.Operator.IdentityInequality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case AssignPre:                     if (op.Length > 1 && op[1] == Equal)                         return Script.Operator.Assign;                     else                         return Script.Operator.TernaryB;                  case Concatenate:                     return Script.Operator.Concat;                  case TernaryA:                     if (op.Length > 1 && op[1] == TernaryA)                         return Script.Operator.NullAssign;                     else                         return Script.Operator.TernaryA;                  default:                     switch (code.ToLowerInvariant())                     {                         case NotTxt:                             return Script.Operator.LogicalNotEx;                          case AndTxt:                             return Script.Operator.BooleanAnd;                          case OrTxt:                             return Script.Operator.BooleanOr;                          case IsTxt:                             return Script.Operator.Is;                     }                     throw new ArgumentOutOfRangeException();             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorFromString,The following statement contains a magic number: switch (op[0])             {                 case Add:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Add;                          case 2:                             return Script.Operator.Increment;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Minus:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Subtract;                          case 2:                             return Script.Operator.Decrement;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Multiply:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Multiply;                          case 2:                             return Script.Operator.Power;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Divide:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Divide;                          case 2:                             return Script.Operator.FloorDivide;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Greater:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.GreaterThan;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.BitShiftRight;                             else if (op[1] == Equal)                                 return Script.Operator.GreaterThanOrEqual;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case Less:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.LessThan;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.BitShiftLeft;                             else if (op[1] == Equal)                                 return Script.Operator.LessThanOrEqual;                             else if (op[1] == Greater)                                 return Script.Operator.ValueInequality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitAND:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseAnd;                          case 2:                             if (op[0] == op[1])                                 return Script.Operator.BooleanAnd;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitOR:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseOr;                          case 2:                             if (op[0] == op[1])                                 return Script.Operator.BooleanOr;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitXOR:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseXor;                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitNOT:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseNot;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Equal:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.ValueEquality;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.IdentityEquality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case Not:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.LogicalNot;                          case 2:                             if (op[1] == Equal)                                 return Script.Operator.ValueInequality;                             else                                 throw new ParseException(ExUnexpected);                          case 3:                             if (op[1] == Equal && op[2] == Equal)                                 return Script.Operator.IdentityInequality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case AssignPre:                     if (op.Length > 1 && op[1] == Equal)                         return Script.Operator.Assign;                     else                         return Script.Operator.TernaryB;                  case Concatenate:                     return Script.Operator.Concat;                  case TernaryA:                     if (op.Length > 1 && op[1] == TernaryA)                         return Script.Operator.NullAssign;                     else                         return Script.Operator.TernaryA;                  default:                     switch (code.ToLowerInvariant())                     {                         case NotTxt:                             return Script.Operator.LogicalNotEx;                          case AndTxt:                             return Script.Operator.BooleanAnd;                          case OrTxt:                             return Script.Operator.BooleanOr;                          case IsTxt:                             return Script.Operator.Is;                     }                     throw new ArgumentOutOfRangeException();             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorFromString,The following statement contains a magic number: switch (op[0])             {                 case Add:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Add;                          case 2:                             return Script.Operator.Increment;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Minus:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Subtract;                          case 2:                             return Script.Operator.Decrement;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Multiply:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Multiply;                          case 2:                             return Script.Operator.Power;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Divide:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.Divide;                          case 2:                             return Script.Operator.FloorDivide;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Greater:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.GreaterThan;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.BitShiftRight;                             else if (op[1] == Equal)                                 return Script.Operator.GreaterThanOrEqual;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case Less:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.LessThan;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.BitShiftLeft;                             else if (op[1] == Equal)                                 return Script.Operator.LessThanOrEqual;                             else if (op[1] == Greater)                                 return Script.Operator.ValueInequality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitAND:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseAnd;                          case 2:                             if (op[0] == op[1])                                 return Script.Operator.BooleanAnd;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitOR:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseOr;                          case 2:                             if (op[0] == op[1])                                 return Script.Operator.BooleanOr;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitXOR:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseXor;                          default:                             throw new ParseException(ExUnexpected);                     }                  case BitNOT:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.BitwiseNot;                          default:                             throw new ParseException(ExUnexpected);                     }                  case Equal:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.ValueEquality;                          case 2:                             if (op[1] == op[0])                                 return Script.Operator.IdentityEquality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case Not:                     switch (op.Length)                     {                         case 1:                             return Script.Operator.LogicalNot;                          case 2:                             if (op[1] == Equal)                                 return Script.Operator.ValueInequality;                             else                                 throw new ParseException(ExUnexpected);                          case 3:                             if (op[1] == Equal && op[2] == Equal)                                 return Script.Operator.IdentityInequality;                             else                                 throw new ParseException(ExUnexpected);                          default:                             throw new ParseException(ExUnexpected);                     }                  case AssignPre:                     if (op.Length > 1 && op[1] == Equal)                         return Script.Operator.Assign;                     else                         return Script.Operator.TernaryB;                  case Concatenate:                     return Script.Operator.Concat;                  case TernaryA:                     if (op.Length > 1 && op[1] == TernaryA)                         return Script.Operator.NullAssign;                     else                         return Script.Operator.TernaryA;                  default:                     switch (code.ToLowerInvariant())                     {                         case NotTxt:                             return Script.Operator.LogicalNotEx;                          case AndTxt:                             return Script.Operator.BooleanAnd;                          case OrTxt:                             return Script.Operator.BooleanOr;                          case IsTxt:                             return Script.Operator.Is;                     }                     throw new ArgumentOutOfRangeException();             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorPrecedence,The following statement contains a magic number: switch (op)             {                 case Script.Operator.Power:                     return -1;                  case Script.Operator.Minus:                 case Script.Operator.LogicalNot:                 case Script.Operator.BitwiseNot:                 case Script.Operator.Address:                 case Script.Operator.Dereference:                     return -2;                  case Script.Operator.Multiply:                 case Script.Operator.Divide:                 case Script.Operator.FloorDivide:                     return -3;                  case Script.Operator.Add:                 case Script.Operator.Subtract:                     return -4;                  case Script.Operator.BitShiftLeft:                 case Script.Operator.BitShiftRight:                     return -5;                  case Script.Operator.BitwiseAnd:                 case Script.Operator.BitwiseXor:                 case Script.Operator.BitwiseOr:                     return -6;                  case Script.Operator.Concat:                     return -7;                  case Script.Operator.GreaterThan:                 case Script.Operator.LessThan:                 case Script.Operator.GreaterThanOrEqual:                 case Script.Operator.LessThanOrEqual:                 case Script.Operator.Is:                     return -8;                  case Script.Operator.ValueEquality:                 case Script.Operator.IdentityEquality:                 case Script.Operator.ValueInequality:                 case Script.Operator.IdentityInequality:                     return -9;                  case Script.Operator.LogicalNotEx:                     return -10;                  case Script.Operator.BooleanAnd:                 case Script.Operator.BooleanOr:                     return -11;                  case Script.Operator.TernaryA:                 case Script.Operator.TernaryB:                 case Script.Operator.NullAssign:                     return -12;                  case Script.Operator.Assign:                     return -13;                  default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorPrecedence,The following statement contains a magic number: switch (op)             {                 case Script.Operator.Power:                     return -1;                  case Script.Operator.Minus:                 case Script.Operator.LogicalNot:                 case Script.Operator.BitwiseNot:                 case Script.Operator.Address:                 case Script.Operator.Dereference:                     return -2;                  case Script.Operator.Multiply:                 case Script.Operator.Divide:                 case Script.Operator.FloorDivide:                     return -3;                  case Script.Operator.Add:                 case Script.Operator.Subtract:                     return -4;                  case Script.Operator.BitShiftLeft:                 case Script.Operator.BitShiftRight:                     return -5;                  case Script.Operator.BitwiseAnd:                 case Script.Operator.BitwiseXor:                 case Script.Operator.BitwiseOr:                     return -6;                  case Script.Operator.Concat:                     return -7;                  case Script.Operator.GreaterThan:                 case Script.Operator.LessThan:                 case Script.Operator.GreaterThanOrEqual:                 case Script.Operator.LessThanOrEqual:                 case Script.Operator.Is:                     return -8;                  case Script.Operator.ValueEquality:                 case Script.Operator.IdentityEquality:                 case Script.Operator.ValueInequality:                 case Script.Operator.IdentityInequality:                     return -9;                  case Script.Operator.LogicalNotEx:                     return -10;                  case Script.Operator.BooleanAnd:                 case Script.Operator.BooleanOr:                     return -11;                  case Script.Operator.TernaryA:                 case Script.Operator.TernaryB:                 case Script.Operator.NullAssign:                     return -12;                  case Script.Operator.Assign:                     return -13;                  default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorPrecedence,The following statement contains a magic number: switch (op)             {                 case Script.Operator.Power:                     return -1;                  case Script.Operator.Minus:                 case Script.Operator.LogicalNot:                 case Script.Operator.BitwiseNot:                 case Script.Operator.Address:                 case Script.Operator.Dereference:                     return -2;                  case Script.Operator.Multiply:                 case Script.Operator.Divide:                 case Script.Operator.FloorDivide:                     return -3;                  case Script.Operator.Add:                 case Script.Operator.Subtract:                     return -4;                  case Script.Operator.BitShiftLeft:                 case Script.Operator.BitShiftRight:                     return -5;                  case Script.Operator.BitwiseAnd:                 case Script.Operator.BitwiseXor:                 case Script.Operator.BitwiseOr:                     return -6;                  case Script.Operator.Concat:                     return -7;                  case Script.Operator.GreaterThan:                 case Script.Operator.LessThan:                 case Script.Operator.GreaterThanOrEqual:                 case Script.Operator.LessThanOrEqual:                 case Script.Operator.Is:                     return -8;                  case Script.Operator.ValueEquality:                 case Script.Operator.IdentityEquality:                 case Script.Operator.ValueInequality:                 case Script.Operator.IdentityInequality:                     return -9;                  case Script.Operator.LogicalNotEx:                     return -10;                  case Script.Operator.BooleanAnd:                 case Script.Operator.BooleanOr:                     return -11;                  case Script.Operator.TernaryA:                 case Script.Operator.TernaryB:                 case Script.Operator.NullAssign:                     return -12;                  case Script.Operator.Assign:                     return -13;                  default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorPrecedence,The following statement contains a magic number: switch (op)             {                 case Script.Operator.Power:                     return -1;                  case Script.Operator.Minus:                 case Script.Operator.LogicalNot:                 case Script.Operator.BitwiseNot:                 case Script.Operator.Address:                 case Script.Operator.Dereference:                     return -2;                  case Script.Operator.Multiply:                 case Script.Operator.Divide:                 case Script.Operator.FloorDivide:                     return -3;                  case Script.Operator.Add:                 case Script.Operator.Subtract:                     return -4;                  case Script.Operator.BitShiftLeft:                 case Script.Operator.BitShiftRight:                     return -5;                  case Script.Operator.BitwiseAnd:                 case Script.Operator.BitwiseXor:                 case Script.Operator.BitwiseOr:                     return -6;                  case Script.Operator.Concat:                     return -7;                  case Script.Operator.GreaterThan:                 case Script.Operator.LessThan:                 case Script.Operator.GreaterThanOrEqual:                 case Script.Operator.LessThanOrEqual:                 case Script.Operator.Is:                     return -8;                  case Script.Operator.ValueEquality:                 case Script.Operator.IdentityEquality:                 case Script.Operator.ValueInequality:                 case Script.Operator.IdentityInequality:                     return -9;                  case Script.Operator.LogicalNotEx:                     return -10;                  case Script.Operator.BooleanAnd:                 case Script.Operator.BooleanOr:                     return -11;                  case Script.Operator.TernaryA:                 case Script.Operator.TernaryB:                 case Script.Operator.NullAssign:                     return -12;                  case Script.Operator.Assign:                     return -13;                  default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorPrecedence,The following statement contains a magic number: switch (op)             {                 case Script.Operator.Power:                     return -1;                  case Script.Operator.Minus:                 case Script.Operator.LogicalNot:                 case Script.Operator.BitwiseNot:                 case Script.Operator.Address:                 case Script.Operator.Dereference:                     return -2;                  case Script.Operator.Multiply:                 case Script.Operator.Divide:                 case Script.Operator.FloorDivide:                     return -3;                  case Script.Operator.Add:                 case Script.Operator.Subtract:                     return -4;                  case Script.Operator.BitShiftLeft:                 case Script.Operator.BitShiftRight:                     return -5;                  case Script.Operator.BitwiseAnd:                 case Script.Operator.BitwiseXor:                 case Script.Operator.BitwiseOr:                     return -6;                  case Script.Operator.Concat:                     return -7;                  case Script.Operator.GreaterThan:                 case Script.Operator.LessThan:                 case Script.Operator.GreaterThanOrEqual:                 case Script.Operator.LessThanOrEqual:                 case Script.Operator.Is:                     return -8;                  case Script.Operator.ValueEquality:                 case Script.Operator.IdentityEquality:                 case Script.Operator.ValueInequality:                 case Script.Operator.IdentityInequality:                     return -9;                  case Script.Operator.LogicalNotEx:                     return -10;                  case Script.Operator.BooleanAnd:                 case Script.Operator.BooleanOr:                     return -11;                  case Script.Operator.TernaryA:                 case Script.Operator.TernaryB:                 case Script.Operator.NullAssign:                     return -12;                  case Script.Operator.Assign:                     return -13;                  default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorPrecedence,The following statement contains a magic number: switch (op)             {                 case Script.Operator.Power:                     return -1;                  case Script.Operator.Minus:                 case Script.Operator.LogicalNot:                 case Script.Operator.BitwiseNot:                 case Script.Operator.Address:                 case Script.Operator.Dereference:                     return -2;                  case Script.Operator.Multiply:                 case Script.Operator.Divide:                 case Script.Operator.FloorDivide:                     return -3;                  case Script.Operator.Add:                 case Script.Operator.Subtract:                     return -4;                  case Script.Operator.BitShiftLeft:                 case Script.Operator.BitShiftRight:                     return -5;                  case Script.Operator.BitwiseAnd:                 case Script.Operator.BitwiseXor:                 case Script.Operator.BitwiseOr:                     return -6;                  case Script.Operator.Concat:                     return -7;                  case Script.Operator.GreaterThan:                 case Script.Operator.LessThan:                 case Script.Operator.GreaterThanOrEqual:                 case Script.Operator.LessThanOrEqual:                 case Script.Operator.Is:                     return -8;                  case Script.Operator.ValueEquality:                 case Script.Operator.IdentityEquality:                 case Script.Operator.ValueInequality:                 case Script.Operator.IdentityInequality:                     return -9;                  case Script.Operator.LogicalNotEx:                     return -10;                  case Script.Operator.BooleanAnd:                 case Script.Operator.BooleanOr:                     return -11;                  case Script.Operator.TernaryA:                 case Script.Operator.TernaryB:                 case Script.Operator.NullAssign:                     return -12;                  case Script.Operator.Assign:                     return -13;                  default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorPrecedence,The following statement contains a magic number: switch (op)             {                 case Script.Operator.Power:                     return -1;                  case Script.Operator.Minus:                 case Script.Operator.LogicalNot:                 case Script.Operator.BitwiseNot:                 case Script.Operator.Address:                 case Script.Operator.Dereference:                     return -2;                  case Script.Operator.Multiply:                 case Script.Operator.Divide:                 case Script.Operator.FloorDivide:                     return -3;                  case Script.Operator.Add:                 case Script.Operator.Subtract:                     return -4;                  case Script.Operator.BitShiftLeft:                 case Script.Operator.BitShiftRight:                     return -5;                  case Script.Operator.BitwiseAnd:                 case Script.Operator.BitwiseXor:                 case Script.Operator.BitwiseOr:                     return -6;                  case Script.Operator.Concat:                     return -7;                  case Script.Operator.GreaterThan:                 case Script.Operator.LessThan:                 case Script.Operator.GreaterThanOrEqual:                 case Script.Operator.LessThanOrEqual:                 case Script.Operator.Is:                     return -8;                  case Script.Operator.ValueEquality:                 case Script.Operator.IdentityEquality:                 case Script.Operator.ValueInequality:                 case Script.Operator.IdentityInequality:                     return -9;                  case Script.Operator.LogicalNotEx:                     return -10;                  case Script.Operator.BooleanAnd:                 case Script.Operator.BooleanOr:                     return -11;                  case Script.Operator.TernaryA:                 case Script.Operator.TernaryB:                 case Script.Operator.NullAssign:                     return -12;                  case Script.Operator.Assign:                     return -13;                  default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorPrecedence,The following statement contains a magic number: switch (op)             {                 case Script.Operator.Power:                     return -1;                  case Script.Operator.Minus:                 case Script.Operator.LogicalNot:                 case Script.Operator.BitwiseNot:                 case Script.Operator.Address:                 case Script.Operator.Dereference:                     return -2;                  case Script.Operator.Multiply:                 case Script.Operator.Divide:                 case Script.Operator.FloorDivide:                     return -3;                  case Script.Operator.Add:                 case Script.Operator.Subtract:                     return -4;                  case Script.Operator.BitShiftLeft:                 case Script.Operator.BitShiftRight:                     return -5;                  case Script.Operator.BitwiseAnd:                 case Script.Operator.BitwiseXor:                 case Script.Operator.BitwiseOr:                     return -6;                  case Script.Operator.Concat:                     return -7;                  case Script.Operator.GreaterThan:                 case Script.Operator.LessThan:                 case Script.Operator.GreaterThanOrEqual:                 case Script.Operator.LessThanOrEqual:                 case Script.Operator.Is:                     return -8;                  case Script.Operator.ValueEquality:                 case Script.Operator.IdentityEquality:                 case Script.Operator.ValueInequality:                 case Script.Operator.IdentityInequality:                     return -9;                  case Script.Operator.LogicalNotEx:                     return -10;                  case Script.Operator.BooleanAnd:                 case Script.Operator.BooleanOr:                     return -11;                  case Script.Operator.TernaryA:                 case Script.Operator.TernaryB:                 case Script.Operator.NullAssign:                     return -12;                  case Script.Operator.Assign:                     return -13;                  default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorPrecedence,The following statement contains a magic number: switch (op)             {                 case Script.Operator.Power:                     return -1;                  case Script.Operator.Minus:                 case Script.Operator.LogicalNot:                 case Script.Operator.BitwiseNot:                 case Script.Operator.Address:                 case Script.Operator.Dereference:                     return -2;                  case Script.Operator.Multiply:                 case Script.Operator.Divide:                 case Script.Operator.FloorDivide:                     return -3;                  case Script.Operator.Add:                 case Script.Operator.Subtract:                     return -4;                  case Script.Operator.BitShiftLeft:                 case Script.Operator.BitShiftRight:                     return -5;                  case Script.Operator.BitwiseAnd:                 case Script.Operator.BitwiseXor:                 case Script.Operator.BitwiseOr:                     return -6;                  case Script.Operator.Concat:                     return -7;                  case Script.Operator.GreaterThan:                 case Script.Operator.LessThan:                 case Script.Operator.GreaterThanOrEqual:                 case Script.Operator.LessThanOrEqual:                 case Script.Operator.Is:                     return -8;                  case Script.Operator.ValueEquality:                 case Script.Operator.IdentityEquality:                 case Script.Operator.ValueInequality:                 case Script.Operator.IdentityInequality:                     return -9;                  case Script.Operator.LogicalNotEx:                     return -10;                  case Script.Operator.BooleanAnd:                 case Script.Operator.BooleanOr:                     return -11;                  case Script.Operator.TernaryA:                 case Script.Operator.TernaryB:                 case Script.Operator.NullAssign:                     return -12;                  case Script.Operator.Assign:                     return -13;                  default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorPrecedence,The following statement contains a magic number: switch (op)             {                 case Script.Operator.Power:                     return -1;                  case Script.Operator.Minus:                 case Script.Operator.LogicalNot:                 case Script.Operator.BitwiseNot:                 case Script.Operator.Address:                 case Script.Operator.Dereference:                     return -2;                  case Script.Operator.Multiply:                 case Script.Operator.Divide:                 case Script.Operator.FloorDivide:                     return -3;                  case Script.Operator.Add:                 case Script.Operator.Subtract:                     return -4;                  case Script.Operator.BitShiftLeft:                 case Script.Operator.BitShiftRight:                     return -5;                  case Script.Operator.BitwiseAnd:                 case Script.Operator.BitwiseXor:                 case Script.Operator.BitwiseOr:                     return -6;                  case Script.Operator.Concat:                     return -7;                  case Script.Operator.GreaterThan:                 case Script.Operator.LessThan:                 case Script.Operator.GreaterThanOrEqual:                 case Script.Operator.LessThanOrEqual:                 case Script.Operator.Is:                     return -8;                  case Script.Operator.ValueEquality:                 case Script.Operator.IdentityEquality:                 case Script.Operator.ValueInequality:                 case Script.Operator.IdentityInequality:                     return -9;                  case Script.Operator.LogicalNotEx:                     return -10;                  case Script.Operator.BooleanAnd:                 case Script.Operator.BooleanOr:                     return -11;                  case Script.Operator.TernaryA:                 case Script.Operator.TernaryB:                 case Script.Operator.NullAssign:                     return -12;                  case Script.Operator.Assign:                     return -13;                  default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorPrecedence,The following statement contains a magic number: switch (op)             {                 case Script.Operator.Power:                     return -1;                  case Script.Operator.Minus:                 case Script.Operator.LogicalNot:                 case Script.Operator.BitwiseNot:                 case Script.Operator.Address:                 case Script.Operator.Dereference:                     return -2;                  case Script.Operator.Multiply:                 case Script.Operator.Divide:                 case Script.Operator.FloorDivide:                     return -3;                  case Script.Operator.Add:                 case Script.Operator.Subtract:                     return -4;                  case Script.Operator.BitShiftLeft:                 case Script.Operator.BitShiftRight:                     return -5;                  case Script.Operator.BitwiseAnd:                 case Script.Operator.BitwiseXor:                 case Script.Operator.BitwiseOr:                     return -6;                  case Script.Operator.Concat:                     return -7;                  case Script.Operator.GreaterThan:                 case Script.Operator.LessThan:                 case Script.Operator.GreaterThanOrEqual:                 case Script.Operator.LessThanOrEqual:                 case Script.Operator.Is:                     return -8;                  case Script.Operator.ValueEquality:                 case Script.Operator.IdentityEquality:                 case Script.Operator.ValueInequality:                 case Script.Operator.IdentityInequality:                     return -9;                  case Script.Operator.LogicalNotEx:                     return -10;                  case Script.Operator.BooleanAnd:                 case Script.Operator.BooleanOr:                     return -11;                  case Script.Operator.TernaryA:                 case Script.Operator.TernaryB:                 case Script.Operator.NullAssign:                     return -12;                  case Script.Operator.Assign:                     return -13;                  default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorPrecedence,The following statement contains a magic number: switch (op)             {                 case Script.Operator.Power:                     return -1;                  case Script.Operator.Minus:                 case Script.Operator.LogicalNot:                 case Script.Operator.BitwiseNot:                 case Script.Operator.Address:                 case Script.Operator.Dereference:                     return -2;                  case Script.Operator.Multiply:                 case Script.Operator.Divide:                 case Script.Operator.FloorDivide:                     return -3;                  case Script.Operator.Add:                 case Script.Operator.Subtract:                     return -4;                  case Script.Operator.BitShiftLeft:                 case Script.Operator.BitShiftRight:                     return -5;                  case Script.Operator.BitwiseAnd:                 case Script.Operator.BitwiseXor:                 case Script.Operator.BitwiseOr:                     return -6;                  case Script.Operator.Concat:                     return -7;                  case Script.Operator.GreaterThan:                 case Script.Operator.LessThan:                 case Script.Operator.GreaterThanOrEqual:                 case Script.Operator.LessThanOrEqual:                 case Script.Operator.Is:                     return -8;                  case Script.Operator.ValueEquality:                 case Script.Operator.IdentityEquality:                 case Script.Operator.ValueInequality:                 case Script.Operator.IdentityInequality:                     return -9;                  case Script.Operator.LogicalNotEx:                     return -10;                  case Script.Operator.BooleanAnd:                 case Script.Operator.BooleanOr:                     return -11;                  case Script.Operator.TernaryA:                 case Script.Operator.TernaryB:                 case Script.Operator.NullAssign:                     return -12;                  case Script.Operator.Assign:                     return -13;                  default:                     throw new ArgumentOutOfRangeException();             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsAssignOp,The following statement contains a magic number: !(code.Length == 2 || code.Length == 3)
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsAssignOp,The following statement contains a magic number: !(code.Length == 2 || code.Length == 3)
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsAssignOp,The following statement contains a magic number: code.Length == 3
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParameterPrepend,The following statement contains a magic number: var buffer = new StringBuilder(param.Length + insert.Length + 2);
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParameterPrepend,The following statement contains a magic number: buffer.Append(param' 2' param.Length - 2);
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParameterPrepend,The following statement contains a magic number: buffer.Append(param' 2' param.Length - 2);
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,CloseBlock,The following statement contains a magic number: blocks.Count < (skip ? 2 : 1)
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsIdentifier,The following statement contains a magic number: token[0] == TernaryA && (token.Length == 1 || token.Length == 2 && token[1] == TernaryA)
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsPrimativeObject,The following statement contains a magic number: result = (double)result * Math.Pow(10' x);
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsLegacyIf,The following statement contains a magic number: string[] part = code.TrimStart(Spaces).Split(Spaces' 3);
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsLegacyIf,The following statement contains a magic number: part.Length < 2 || !IsIdentifier(part[0])
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseHotkey,The following statement contains a magic number: string[] parts = code.Split(new[] { HotkeySignal }' 2' StringSplitOptions.None);
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseHotkey,The following statement contains a magic number: string options = mode.Substring(1' mode.Length - 2);
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,MultilineString,The following statement contains a magic number: line.Length > 2
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,MultilineString,The following statement contains a magic number: var escapeEscaped = new string(Escape' 2);
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,EscapedString,The following statement contains a magic number: var buffer = new StringBuilder(code.Length + 32);
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseAssign,The following statement contains a magic number: CodeExpression result = value == null ? new CodePrimitiveExpression(null) :                 IsExpressionParameter(value) ? ParseSingleExpression(value.TrimStart(Spaces).Substring(2)) : VarIdExpand(value);
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitCommandParameters,The following statement contains a magic number: switch (sym)                     {                         case StringBound: str = !str; break;                         case ParenOpen: levels[0]++; break;                         case ParenClose: levels[0]--; break;                         case BlockOpen: levels[1]++; break;                         case BlockClose: levels[1]--; break;                         case ArrayOpen: levels[2]++; break;                         case ArrayClose: levels[2]--; break;                     }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitCommandParameters,The following statement contains a magic number: switch (sym)                     {                         case StringBound: str = !str; break;                         case ParenOpen: levels[0]++; break;                         case ParenClose: levels[0]--; break;                         case BlockOpen: levels[1]++; break;                         case BlockClose: levels[1]--; break;                         case ArrayOpen: levels[2]++; break;                         case ArrayClose: levels[2]--; break;                     }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseCommandParameter,The following statement contains a magic number: code = code.Substring(1' code.Length - 2);
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseCommandParameter,The following statement contains a magic number: expr && code.Length > 2 && code[0] == Resolve && code[code.Length - 1] == Resolve
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseCommandParameter,The following statement contains a magic number: code = code.Substring(2);
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseDirective,The following statement contains a magic number: code.Length < 2
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseDirective,The following statement contains a magic number: string[] parts = code.Split(delim' 2);
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseDirective,The following statement contains a magic number: parts.Length != 2
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseDirective,The following statement contains a magic number: switch (cmd.ToUpperInvariant())             {                 #region Assembly manifest                  case "ASSEMBLYTITLE":                     if (!string.IsNullOrEmpty(parts[1]))                         AddAssemblyAttribute(typeof(AssemblyTitleAttribute)' parts[1]);                     break;                  case "ASSEMBLYDESCRIPTION":                     if (!string.IsNullOrEmpty(parts[1]))                         AddAssemblyAttribute(typeof(AssemblyDescriptionAttribute)' parts[1]);                     break;                  case "ASSEMBLYCONFIGURATION":                     if (!string.IsNullOrEmpty(parts[1]))                         AddAssemblyAttribute(typeof(AssemblyConfigurationAttribute)' parts[1]);                     break;                  case "ASSEMBLYCOMPANY":                     if (!string.IsNullOrEmpty(parts[1]))                         AddAssemblyAttribute(typeof(AssemblyCompanyAttribute)' parts[1]);                     break;                  case "ASSEMBLYPRODUCT":                     if (!string.IsNullOrEmpty(parts[1]))                         AddAssemblyAttribute(typeof(AssemblyProductAttribute)' parts[1]);                     break;                  case "ASSEMBLYCOPYRIGHT":                     if (!string.IsNullOrEmpty(parts[1]))                         AddAssemblyAttribute(typeof(AssemblyCopyrightAttribute)' parts[1]);                     break;                  case "ASSEMBLYTRADEMARK":                     if (!string.IsNullOrEmpty(parts[1]))                         AddAssemblyAttribute(typeof(AssemblyTrademarkAttribute)' parts[1]);                     break;                  case "ASSEMBLYCULTURE":                     if (!string.IsNullOrEmpty(parts[1]))                         AddAssemblyAttribute(typeof(AssemblyCultureAttribute)' parts[1]);                     break;                  case "ASSEMBLYVERSION":                     if (!string.IsNullOrEmpty(parts[1]))                         AddAssemblyAttribute(typeof(AssemblyVersionAttribute)' parts[1]);                     break;                  case "ASSEMBLYMERGE":                     if (CompilerParameters is IACompilerParameters)                     {                         var options = (IACompilerParameters)CompilerParameters;                         options.Merge = true;                          switch (parts[1].ToUpperInvariant())                         {                             case "FORCE":                                 options.MergeFallbackToLink = false;                                 break;                              case "OFF":                                 options.Merge = false;                                 break;                         }                     }                     break;                  #endregion                  case "CLIPBOARDTIMEOUT":                     ClipboardTimeout = numeric ? value : ClipboardTimeoutDefault;                        break;                  case "COMMENTFLAG":                     if (parts[1].Length == 2 && parts[1][0] == MultiComA && parts[1][1] == MultiComB)                         throw new ParseException(ExIllegalCommentFlag);                     Comment = parts[1];                     break;                  case "DEREFCHAR":                     Resolve = parts[1][0];                     break;                  case "ESCAPECHAR":                     Escape = parts[1][0];                     break;                  case "DELIMITER":                     Multicast = parts[1][0];                     break;                  case "HOTSTRING":                     HotstringNewOptions = parts[1];                     break;                  case "IFWINACTIVE":                     IfWinActive_WinTitle = sub[0];                     IfWinActive_WinText = sub[1];                     goto case res;                  case "IFWINEXIST":                     IfWinExist_WinTitle = sub[0];                     IfWinExist_WinText = sub[1];                     goto case res;                  case "IFWINNOTACTIVE":                     IfWinNotExist_WinTitle = sub[0];                     IfWinNotActive_WinText = sub[1];                     goto case res;                  case "IFWINNOTEXIST":                     IfWinNotExist_WinTitle = sub[0];                     IfWinNotExist_WinText = sub[1];                     goto case res;                  case res:                     var cond = (CodeMethodInvokeExpression)InternalMethods.Hotkey;                     cond.Parameters.Add(new CodePrimitiveExpression(cmd));                     cond.Parameters.Add(new CodePrimitiveExpression(sub[0]));                     cond.Parameters.Add(new CodePrimitiveExpression(sub[1]));                     prepend.Add(cond);                     break;                  case "LTRIM":                     switch (sub[0].ToUpperInvariant())                     {                         case "":                         case "ON":                             LTrimForced = true;                             break;                          case "OFF":                             LTrimForced = false;                             break;                          default:                             throw new ParseException("Directive parameter must be either \"on\" or \"off\"");                     }                     break;                  default:                     throw new ParseException(ExUnknownDirv);             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseMultiExpression,The following statement contains a magic number: int n = tokens.Count - 2;
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The following statement contains a magic number: n -= 2;
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The following statement contains a magic number: MergeAssignmentAt(parts' i + 2);
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The following statement contains a magic number: MergeAssignmentAt(parts' i + 2);
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The following statement contains a magic number: i + 3 < parts.Count && IsVarReference(parts[i + 1]) && parts[i + 2] as CodeBinaryOperatorType? == CodeBinaryOperatorType.Assign
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The following statement contains a magic number: i + 3 < parts.Count && IsVarReference(parts[i + 1]) && parts[i + 2] as CodeBinaryOperatorType? == CodeBinaryOperatorType.Assign
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The following statement contains a magic number: i % 2 == 1
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseFlow,The following statement contains a magic number: switch (parts[0].ToLowerInvariant())             {                 #region If/Else                  case FlowIf:                     {                         if (parts.Length < 1)                             throw new ParseException("If requires a parameter");                          bool blockOpen = false;                         CodeExpression condition = ParseFlowParameter(parts[1]' true' out blockOpen' false);                         var ifelse = new CodeConditionStatement { Condition = condition };                          var block = new CodeBlock(line' Scope' ifelse.TrueStatements' CodeBlock.BlockKind.IfElse' blocks.Count == 0 ? null : blocks.Peek());                         block.Type = blockOpen ? CodeBlock.BlockType.Within : CodeBlock.BlockType.Expect;                         CloseTopSingleBlock();                         blocks.Push(block);                          elses.Push(ifelse.FalseStatements);                         return new CodeStatement[] { ifelse };                     }                  case FlowElse:                     {                         if (elses.Count == 0)                             throw new ParseException("Else with no preceeding if block");                          string next = line.Code.TrimStart(Spaces).Substring(FlowElse.Length).TrimStart(Spaces);                          if (!IsEmptyStatement(next))                             lines.Insert(index + 1' new CodeLine(lines[index].FileName' lines[index].LineNumber' next));                          var type = parts.Length > 1 && parts[1][0] == BlockOpen ? CodeBlock.BlockType.Within : CodeBlock.BlockType.Expect;                         var block = new CodeBlock(lines[index]' Scope' elses.Pop()' CodeBlock.BlockKind.IfElse' blocks.Count == 0 ? null : blocks.Peek()) { Type = type };                         CloseTopSingleBlock();                         blocks.Push(block);                     }                     break;                  #endregion                  #region Goto                  case FlowGosub:                     {                         if (parts.Length < 1)                             throw new ParseException("No label specified");                         return new CodeStatement[] { new CodeExpressionStatement(LocalLabelInvoke(parts[1])) };                     }                  case FlowGoto:                     {                         if (parts.Length < 1)                             throw new ParseException("No label specified");                         return new CodeStatement[] { new CodeExpressionStatement(LocalLabelInvoke(parts[1]))' new CodeMethodReturnStatement() };                     }                  #endregion                  #region Loops                  case FlowLoop:                     {                         bool blockOpen = false;                         CodeMethodInvokeExpression iterator;                         bool skip = true;                         bool checkBrace = true;                         bool byref = false;                          #region Loop types                         if (parts.Length > 1)                         {                             string[] sub = parts[1].Split(new[] { Multicast }' 2);                             sub = new[] { sub[0].Trim()' sub.Length > 1 ? sub[1].Trim() : string.Empty };                              switch (sub[0].ToUpperInvariant())                             {                                 case "READ":                                     byref = true;                                     iterator = (CodeMethodInvokeExpression)InternalMethods.LoopRead;                                     break;                                  case "PARSE":                                     checkBrace = false;                                     byref = true;                                     iterator = (CodeMethodInvokeExpression)InternalMethods.LoopParse;                                     break;                                  case "HKEY_LOCAL_MACHINE":                                 case "HKLM":                                 case "HKEY_USERS":                                 case "HKU":                                 case "HKEY_CURRENT_USER":                                 case "HKCU":                                 case "HKEY_CLASSES_ROOT":                                 case "HKCR":                                 case "HKEY_CURRENT_CONFIG":                                 case "HKCC":                                     iterator = (CodeMethodInvokeExpression)InternalMethods.LoopRegistry;                                     break;                                  case "EACH":                                     byref = true;                                     iterator = (CodeMethodInvokeExpression)InternalMethods.LoopEach;                                     break;                                  default:                                     {                                         var file = false;                                          if (parts[1].IndexOf(Multicast) != -1)                                             file = true;                                          // TODO: check file/iteration loop types                                          skip = false;                                         iterator = (CodeMethodInvokeExpression)(file ? InternalMethods.LoopFile : InternalMethods.Loop);                                     }                                     break;                             }                              if (skip)                                 parts[1] = sub[1];                              if (checkBrace)                             {                                 // TODO: check expression parameters before stripping comments                                 int x = parts.Length == 1 ? 0 : 1;                                 string part = StripComment(parts[x]).TrimEnd(Spaces);                                 int l = part.Length - 1;                                 if (part.Length > 0 && part[l] == BlockOpen)                                 {                                     blockOpen = true;                                     parts[x] = part.Substring(0' l);                                 }                             }                              if (skip && parts[1].Length == 0)                                 throw new ParseException("Loop type must have an argument");                              foreach (var arg in SplitCommandParameters(parts[1]))                                 iterator.Parameters.Add(ParseCommandParameter(arg));                              if (LegacyLoop && byref)                                 iterator.Parameters[0] = VarId(iterator.Parameters[0]);                         }                         else                         {                             iterator = (CodeMethodInvokeExpression)InternalMethods.Loop;                             iterator.Parameters.Add(new CodePrimitiveExpression(int.MaxValue));                         }                         #endregion                          string id = InternalID;                          var init = new CodeVariableDeclarationStatement();                         init.Name = id;                         init.Type = new CodeTypeReference(typeof(IEnumerable));                         init.InitExpression = new CodeMethodInvokeExpression(iterator' "GetEnumerator"' new CodeExpression[] { });                          var condition = new CodeMethodInvokeExpression();                         condition.Method.TargetObject = new CodeVariableReferenceExpression(id);                         condition.Method.MethodName = "MoveNext";                          var loop = new CodeIterationStatement();                         loop.InitStatement = init;                         loop.IncrementStatement = new CodeCommentStatement(string.Empty); // for C# display                         loop.TestExpression = condition;                          var block = new CodeBlock(line' Scope' loop.Statements' CodeBlock.BlockKind.Loop' blocks.Count == 0 ? null : blocks.Peek()' InternalID' InternalID);                         block.Type = blockOpen ? CodeBlock.BlockType.Within : CodeBlock.BlockType.Expect;                         CloseTopSingleBlock();                         blocks.Push(block);                          return new CodeStatement[] { loop' new CodeLabeledStatement(block.ExitLabel) };                     }                  case FlowWhile:                     {                         bool blockOpen = false;                         CodeExpression condition = parts.Length > 1 ? ParseFlowParameter(parts[1]' true' out blockOpen' true) : new CodePrimitiveExpression(true);                         var loop = new CodeIterationStatement();                         loop.TestExpression = condition;                         loop.InitStatement = new CodeCommentStatement(string.Empty);                          var block = new CodeBlock(line' Scope' loop.Statements' CodeBlock.BlockKind.Loop' blocks.Count == 0 ? null : blocks.Peek()' InternalID' InternalID);                         block.Type = blockOpen ? CodeBlock.BlockType.Within : CodeBlock.BlockType.Expect;                         CloseTopSingleBlock();                         blocks.Push(block);                          return new CodeStatement[] { loop' new CodeLabeledStatement(block.ExitLabel) };                     }                  case FlowBreak:                     int b = 1;                     if (parts.Length > 1)                     {                         parts[1] = StripCommentSingle(parts[1]);                         if (!int.TryParse(parts[1]' out b) || b < 1)                             throw new ParseException("Break parameter must be a static integer greater than zero.");                     }                     string exit = PeekLoopLabel(true' b);                     if (exit == null)                         throw new ParseException("Cannot break outside a loop");                     return new CodeStatement[] { new CodeGotoStatement(exit) };                  case FlowContinue:                     int c = 1;                     if (parts.Length > 1)                     {                         parts[1] = StripCommentSingle(parts[1]);                         if (!int.TryParse(parts[1]' out c) || c < 1)                             throw new ParseException("Continue parameter must be a static integer greater than zero.");                     }                     string cont = PeekLoopLabel(false' c);                     if (cont == null)                         throw new ParseException("Cannot continue outside a loop");                     return new CodeStatement[] { new CodeGotoStatement(cont) };                  #endregion                  #region Return                  case FlowReturn:                     if (Scope == mainScope)                     {                         if (parts.Length > 1)                             throw new ParseException("Cannot have return parameter for entry point method");                         return new CodeStatement[] { new CodeMethodReturnStatement() };                     }                     else                     {                         var result = parts.Length > 1 ? ParseSingleExpression(parts[1]) : new CodePrimitiveExpression(null);                         return new CodeStatement[] { new CodeMethodReturnStatement(result) };                     }                  #endregion                  #region Function                  case FunctionLocal:                 case FunctionGlobal:                 case FunctionStatic:                     // TODO: function local/global/static scoping modifiers                     break;                  #endregion                  default:                     throw new ParseException(ExUnexpected);             }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseInequality,The following statement contains a magic number: str = str.Replace(StringBound.ToString()' new string(StringBound' 2));
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseLegacyIf,The following statement contains a magic number: string[] parts = code.TrimStart(Spaces).Split(Spaces' 3);
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseLegacyIf,The following statement contains a magic number: parts.Length != 3
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseLegacyIf,The following statement contains a magic number: string[] sub = parts[2].Split(Spaces' 2);
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseLegacyIf,The following statement contains a magic number: string[] sub = parts[2].Split(Spaces' 2);
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseLegacyIf,The following statement contains a magic number: parts[2] = sub[1];
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseLegacyIf,The following statement contains a magic number: invoke.Parameters.Add(ParseCommandParameter(parts[2]));
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ValidateParameterLiteral,The following statement contains a magic number: code = code.Substring(1' code.Length - 2);
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ValidateParameterLiteral,The following statement contains a magic number: code.Replace(new string(StringBound' 2)' string.Empty);
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseLabel,The following statement contains a magic number: code.Length < 2 || code[z] != HotkeyBound
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Read,The following statement contains a magic number: line == 1 && code.Length > 2 && code[0] == '#' && code[1] == '!'
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Read,The following statement contains a magic number: code = codeTrim = codeTrim.Substring(2);
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Read,The following statement contains a magic number: codeTrim.Length < 2
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Read,The following statement contains a magic number: string[] sub = codeTrim.Split(delim' 2);
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Read,The following statement contains a magic number: switch (parts[0].Substring(1).ToUpperInvariant())                     {                         case "INCLUDE":                             includeOnce = true;                             goto case "INCLUDEAGAIN";                          case "INCLUDEAGAIN":                             {                                 var replace = new[']                                 {                                     { "A_ScriptDir"' Path.GetDirectoryName(name) }'                                     { "A_AppData"' Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) }'                                     { "A_AppDataCommon"' Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData) }'                                     { "ProgramFiles"' Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles) }'                                 };                                  for (int i = 0; i < replace.Length / 2; i++)                                     parts[1] = Replace(parts[1]' string.Format("{0}{1}{0}"' Resolve' replace[i' 0])' replace[i' 1]);                                  bool silent = false;                                  if (parts[1].Length > 3 && parts[1][0] == '*' && (parts[1][1] == 'i' || parts[1][1] == 'I') && IsSpace(parts[1][2]))                                 {                                     parts[1] = parts[1].Substring(3);                                     silent = true;                                 }                                  string path = parts[1];                                  if (!Path.IsPathRooted(path) && Directory.Exists(includePath))                                     path = Path.Combine(includePath' path);                                 else if(!Path.IsPathRooted(path))                                     path = Path.Combine(Path.GetDirectoryName(name)' path);                                  path = Path.GetFullPath(path);                                  if (!File.Exists(path))                                 {                                     if (!silent)                                         throw new ParseException(ExIncludeNotFound' line);                                     break;                                 }                                  if (includeOnce && includes.Contains(path))                                     break;                                  var newlist = Read(new StreamReader(path)' path);                                 list.AddRange(newlist);                                  if (!includes.Contains(path))                                     includes.Add(path);                             }                             break;                          case "NODYNAMICVARS":                             DynamicVars = false;                             break;                          case "NOENV":                             NoEnv = true;                             break;                          case "NOTRAYICON":                             NoTrayIcon = true;                             break;                          case "PERSISTENT":                             Persistent = true;                             break;                          case "SINGLEINSTANCE":                             switch (parts[1].ToUpperInvariant())                             {                                 case "FORCE":                                     SingleInstance = true;                                     break;                                 case "IGNORE":                                     SingleInstance = null;                                     break;                                 case "OFF":                                     SingleInstance = false;                                     break;                                 default:                                     break;                             }                             break;                          case "WINACTIVATEFORCE":                             WinActivateForce = true;                             break;                          case "HOTSTRING":                             switch (parts[1].ToUpperInvariant())                             {                                 case "NOMOUSE":                                     HotstringNoMouse = true;                                     break;                                 case "ENDCHARS":                                     HotstringEndChars = parts[1];                                     break;                                 default:                                     next = false;                                     break;                             }                             break;                          case "ALLOWSAMELINECOMMENTS":                         case "ERRORSTDOUT":                         case "HOTKEYINTERVAL":                         case "HOTKEYMODIFIERTIMEOUT":                         case "INSTALLKEYBDHOOK":                         case "INSTALLMOUSEHOOK":                         case "KEYHISTORY":                         case "MAXHOTKEYSPERINTERVAL":                         case "MAXMEM":                         case "MAXTHREADS":                         case "MAXTHREADSBUFFER":                         case "MAXTHREADSPERHOTKEY":                         case "USEHOOK":                             // deprecated directives                             break;                          default:                             next = false;                             break;                     }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Read,The following statement contains a magic number: switch (parts[0].Substring(1).ToUpperInvariant())                     {                         case "INCLUDE":                             includeOnce = true;                             goto case "INCLUDEAGAIN";                          case "INCLUDEAGAIN":                             {                                 var replace = new[']                                 {                                     { "A_ScriptDir"' Path.GetDirectoryName(name) }'                                     { "A_AppData"' Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) }'                                     { "A_AppDataCommon"' Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData) }'                                     { "ProgramFiles"' Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles) }'                                 };                                  for (int i = 0; i < replace.Length / 2; i++)                                     parts[1] = Replace(parts[1]' string.Format("{0}{1}{0}"' Resolve' replace[i' 0])' replace[i' 1]);                                  bool silent = false;                                  if (parts[1].Length > 3 && parts[1][0] == '*' && (parts[1][1] == 'i' || parts[1][1] == 'I') && IsSpace(parts[1][2]))                                 {                                     parts[1] = parts[1].Substring(3);                                     silent = true;                                 }                                  string path = parts[1];                                  if (!Path.IsPathRooted(path) && Directory.Exists(includePath))                                     path = Path.Combine(includePath' path);                                 else if(!Path.IsPathRooted(path))                                     path = Path.Combine(Path.GetDirectoryName(name)' path);                                  path = Path.GetFullPath(path);                                  if (!File.Exists(path))                                 {                                     if (!silent)                                         throw new ParseException(ExIncludeNotFound' line);                                     break;                                 }                                  if (includeOnce && includes.Contains(path))                                     break;                                  var newlist = Read(new StreamReader(path)' path);                                 list.AddRange(newlist);                                  if (!includes.Contains(path))                                     includes.Add(path);                             }                             break;                          case "NODYNAMICVARS":                             DynamicVars = false;                             break;                          case "NOENV":                             NoEnv = true;                             break;                          case "NOTRAYICON":                             NoTrayIcon = true;                             break;                          case "PERSISTENT":                             Persistent = true;                             break;                          case "SINGLEINSTANCE":                             switch (parts[1].ToUpperInvariant())                             {                                 case "FORCE":                                     SingleInstance = true;                                     break;                                 case "IGNORE":                                     SingleInstance = null;                                     break;                                 case "OFF":                                     SingleInstance = false;                                     break;                                 default:                                     break;                             }                             break;                          case "WINACTIVATEFORCE":                             WinActivateForce = true;                             break;                          case "HOTSTRING":                             switch (parts[1].ToUpperInvariant())                             {                                 case "NOMOUSE":                                     HotstringNoMouse = true;                                     break;                                 case "ENDCHARS":                                     HotstringEndChars = parts[1];                                     break;                                 default:                                     next = false;                                     break;                             }                             break;                          case "ALLOWSAMELINECOMMENTS":                         case "ERRORSTDOUT":                         case "HOTKEYINTERVAL":                         case "HOTKEYMODIFIERTIMEOUT":                         case "INSTALLKEYBDHOOK":                         case "INSTALLMOUSEHOOK":                         case "KEYHISTORY":                         case "MAXHOTKEYSPERINTERVAL":                         case "MAXMEM":                         case "MAXTHREADS":                         case "MAXTHREADSBUFFER":                         case "MAXTHREADSPERHOTKEY":                         case "USEHOOK":                             // deprecated directives                             break;                          default:                             next = false;                             break;                     }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Read,The following statement contains a magic number: switch (parts[0].Substring(1).ToUpperInvariant())                     {                         case "INCLUDE":                             includeOnce = true;                             goto case "INCLUDEAGAIN";                          case "INCLUDEAGAIN":                             {                                 var replace = new[']                                 {                                     { "A_ScriptDir"' Path.GetDirectoryName(name) }'                                     { "A_AppData"' Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) }'                                     { "A_AppDataCommon"' Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData) }'                                     { "ProgramFiles"' Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles) }'                                 };                                  for (int i = 0; i < replace.Length / 2; i++)                                     parts[1] = Replace(parts[1]' string.Format("{0}{1}{0}"' Resolve' replace[i' 0])' replace[i' 1]);                                  bool silent = false;                                  if (parts[1].Length > 3 && parts[1][0] == '*' && (parts[1][1] == 'i' || parts[1][1] == 'I') && IsSpace(parts[1][2]))                                 {                                     parts[1] = parts[1].Substring(3);                                     silent = true;                                 }                                  string path = parts[1];                                  if (!Path.IsPathRooted(path) && Directory.Exists(includePath))                                     path = Path.Combine(includePath' path);                                 else if(!Path.IsPathRooted(path))                                     path = Path.Combine(Path.GetDirectoryName(name)' path);                                  path = Path.GetFullPath(path);                                  if (!File.Exists(path))                                 {                                     if (!silent)                                         throw new ParseException(ExIncludeNotFound' line);                                     break;                                 }                                  if (includeOnce && includes.Contains(path))                                     break;                                  var newlist = Read(new StreamReader(path)' path);                                 list.AddRange(newlist);                                  if (!includes.Contains(path))                                     includes.Add(path);                             }                             break;                          case "NODYNAMICVARS":                             DynamicVars = false;                             break;                          case "NOENV":                             NoEnv = true;                             break;                          case "NOTRAYICON":                             NoTrayIcon = true;                             break;                          case "PERSISTENT":                             Persistent = true;                             break;                          case "SINGLEINSTANCE":                             switch (parts[1].ToUpperInvariant())                             {                                 case "FORCE":                                     SingleInstance = true;                                     break;                                 case "IGNORE":                                     SingleInstance = null;                                     break;                                 case "OFF":                                     SingleInstance = false;                                     break;                                 default:                                     break;                             }                             break;                          case "WINACTIVATEFORCE":                             WinActivateForce = true;                             break;                          case "HOTSTRING":                             switch (parts[1].ToUpperInvariant())                             {                                 case "NOMOUSE":                                     HotstringNoMouse = true;                                     break;                                 case "ENDCHARS":                                     HotstringEndChars = parts[1];                                     break;                                 default:                                     next = false;                                     break;                             }                             break;                          case "ALLOWSAMELINECOMMENTS":                         case "ERRORSTDOUT":                         case "HOTKEYINTERVAL":                         case "HOTKEYMODIFIERTIMEOUT":                         case "INSTALLKEYBDHOOK":                         case "INSTALLMOUSEHOOK":                         case "KEYHISTORY":                         case "MAXHOTKEYSPERINTERVAL":                         case "MAXMEM":                         case "MAXTHREADS":                         case "MAXTHREADSBUFFER":                         case "MAXTHREADSPERHOTKEY":                         case "USEHOOK":                             // deprecated directives                             break;                          default:                             next = false;                             break;                     }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Read,The following statement contains a magic number: switch (parts[0].Substring(1).ToUpperInvariant())                     {                         case "INCLUDE":                             includeOnce = true;                             goto case "INCLUDEAGAIN";                          case "INCLUDEAGAIN":                             {                                 var replace = new[']                                 {                                     { "A_ScriptDir"' Path.GetDirectoryName(name) }'                                     { "A_AppData"' Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) }'                                     { "A_AppDataCommon"' Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData) }'                                     { "ProgramFiles"' Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles) }'                                 };                                  for (int i = 0; i < replace.Length / 2; i++)                                     parts[1] = Replace(parts[1]' string.Format("{0}{1}{0}"' Resolve' replace[i' 0])' replace[i' 1]);                                  bool silent = false;                                  if (parts[1].Length > 3 && parts[1][0] == '*' && (parts[1][1] == 'i' || parts[1][1] == 'I') && IsSpace(parts[1][2]))                                 {                                     parts[1] = parts[1].Substring(3);                                     silent = true;                                 }                                  string path = parts[1];                                  if (!Path.IsPathRooted(path) && Directory.Exists(includePath))                                     path = Path.Combine(includePath' path);                                 else if(!Path.IsPathRooted(path))                                     path = Path.Combine(Path.GetDirectoryName(name)' path);                                  path = Path.GetFullPath(path);                                  if (!File.Exists(path))                                 {                                     if (!silent)                                         throw new ParseException(ExIncludeNotFound' line);                                     break;                                 }                                  if (includeOnce && includes.Contains(path))                                     break;                                  var newlist = Read(new StreamReader(path)' path);                                 list.AddRange(newlist);                                  if (!includes.Contains(path))                                     includes.Add(path);                             }                             break;                          case "NODYNAMICVARS":                             DynamicVars = false;                             break;                          case "NOENV":                             NoEnv = true;                             break;                          case "NOTRAYICON":                             NoTrayIcon = true;                             break;                          case "PERSISTENT":                             Persistent = true;                             break;                          case "SINGLEINSTANCE":                             switch (parts[1].ToUpperInvariant())                             {                                 case "FORCE":                                     SingleInstance = true;                                     break;                                 case "IGNORE":                                     SingleInstance = null;                                     break;                                 case "OFF":                                     SingleInstance = false;                                     break;                                 default:                                     break;                             }                             break;                          case "WINACTIVATEFORCE":                             WinActivateForce = true;                             break;                          case "HOTSTRING":                             switch (parts[1].ToUpperInvariant())                             {                                 case "NOMOUSE":                                     HotstringNoMouse = true;                                     break;                                 case "ENDCHARS":                                     HotstringEndChars = parts[1];                                     break;                                 default:                                     next = false;                                     break;                             }                             break;                          case "ALLOWSAMELINECOMMENTS":                         case "ERRORSTDOUT":                         case "HOTKEYINTERVAL":                         case "HOTKEYMODIFIERTIMEOUT":                         case "INSTALLKEYBDHOOK":                         case "INSTALLMOUSEHOOK":                         case "KEYHISTORY":                         case "MAXHOTKEYSPERINTERVAL":                         case "MAXMEM":                         case "MAXTHREADS":                         case "MAXTHREADSBUFFER":                         case "MAXTHREADSPERHOTKEY":                         case "USEHOOK":                             // deprecated directives                             break;                          default:                             next = false;                             break;                     }
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Read,The following statement contains a magic number: code = code.Substring(2);
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsFlowOperator,The following statement contains a magic number: const int offset = 3;
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsFlowOperator,The following statement contains a magic number: delimiters[2] = ParenOpen;
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsFlowOperator,The following statement contains a magic number: string word = code.Split(delimiters' 2)[0].ToLowerInvariant();
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsDirective,The following statement contains a magic number: return code.Length > 2 && code[0] == Directive;
Magic Number,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsFunction,The following statement contains a magic number: switch (stage)                 {                     case 0:                         if (sym == ParenOpen)                             stage++;                         else if (!IsIdentifier(sym))                             return false;                         break;                      case 1:                         if (sym == StringBound)                             str = !str;                         else if (!str && sym == ParenClose)                             stage++;                         break;                      case 2:                         if (sym == BlockOpen)                             return true;                         else if (IsCommentAt(code' i))                             goto next;                         else if (!IsSpace(sym))                             return false;                         break;                 }
Magic Number,IronAHK.Scripting,Script,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Script\Call.cs,FunctionCall,The following statement contains a magic number: i < 3
Magic Number,IronAHK.Scripting,Script,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Script\Call.cs,IfLegacy,The following statement contains a magic number: switch (op)             {                 case Between:                     {                         int z = var.IndexOf(And' StringComparison.OrdinalIgnoreCase);                          if (z == -1)                             z = var.Length;                          double low = double.MinValue' high = double.MaxValue;                          if (double.TryParse(var.Substring(0' z)' out low) && double.TryParse(var.Substring(z + And.Length)' out high))                         {                             var d = ForceDouble(subject);                             return d >= low && d <= high;                         }                     }                     return false;                  case In:                     foreach (var sub in test.Split(Delimiter))                         if (var.Equals(sub' StringComparison.OrdinalIgnoreCase))                             return true;                     return false;                  case Contains:                     foreach (var sub in test.Split(Delimiter))                         if (var.IndexOf(sub' StringComparison.OrdinalIgnoreCase) != -1)                             return true;                     return false;                  case Is:                     test = test.ToLowerInvariant();                     if (subject != null)                     {                         var type = subject.GetType();                         switch (test)                         {                             case Object:                                 return typeof(IDictionary).IsAssignableFrom(type);                              case Array:                                 return type.IsArray;                         }                     }                     switch (test)                     {                         case Integer:                         case Number:                             var = var.Trim().TrimStart(new[] { '+'' '-' });                             goto case Xdigit;                          case Xdigit:                             if (var.Length > 3 && var[0] == '0' && (var[1] == 'x' || var[1] == 'X'))                                 var = var.Substring(2);                             break;                     }                     switch (test)                     {                         case Float:                             if (!var.Contains("."))                                 return false;                             goto case Number;                          case Number:                             {                                 bool dot = false;                                  foreach (var sym in var)                                 {                                     if (sym == '.')                                     {                                         if (dot)                                             return false;                                         dot = true;                                     }                                     else if (!char.IsDigit(sym))                                         return false;                                 }                                  return true;                             }                          case Digit:                             foreach (var sym in var)                                 if (!char.IsDigit(sym))                                     return false;                             return true;                          case Integer:                         case Xdigit:                             {                                 foreach (var sym in var)                                     if (!(char.IsDigit(sym) || (sym > 'a' - 1 && sym < 'f' + 1) || (sym > 'A' - 1 && sym < 'F' + 1)))                                         return false;                                 return true;                             }                          case Alpha:                             foreach (var sym in var)                                 if (!char.IsLetter(sym))                                     return false;                             return true;                          case Upper:                             foreach (var sym in var)                                 if (!char.IsUpper(sym))                                     return false;                             return true;                          case Lower:                             foreach (var sym in var)                                 if (!char.IsLower(sym))                                     return false;                             return true;                          case Alnum:                             foreach (var sym in var)                                 if (!char.IsLetterOrDigit(sym))                                     return false;                             return true;                          case Space:                             foreach (var sym in var)                                 if (!char.IsWhiteSpace(sym))                                     return false;                             return true;                          case Time:                             if (!IsNumeric(var))                                 return false;                             return ForceLong(var) < 99991231125959;                          default:                             return false;                     }             }
Magic Number,IronAHK.Scripting,Script,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Script\Call.cs,IfLegacy,The following statement contains a magic number: switch (op)             {                 case Between:                     {                         int z = var.IndexOf(And' StringComparison.OrdinalIgnoreCase);                          if (z == -1)                             z = var.Length;                          double low = double.MinValue' high = double.MaxValue;                          if (double.TryParse(var.Substring(0' z)' out low) && double.TryParse(var.Substring(z + And.Length)' out high))                         {                             var d = ForceDouble(subject);                             return d >= low && d <= high;                         }                     }                     return false;                  case In:                     foreach (var sub in test.Split(Delimiter))                         if (var.Equals(sub' StringComparison.OrdinalIgnoreCase))                             return true;                     return false;                  case Contains:                     foreach (var sub in test.Split(Delimiter))                         if (var.IndexOf(sub' StringComparison.OrdinalIgnoreCase) != -1)                             return true;                     return false;                  case Is:                     test = test.ToLowerInvariant();                     if (subject != null)                     {                         var type = subject.GetType();                         switch (test)                         {                             case Object:                                 return typeof(IDictionary).IsAssignableFrom(type);                              case Array:                                 return type.IsArray;                         }                     }                     switch (test)                     {                         case Integer:                         case Number:                             var = var.Trim().TrimStart(new[] { '+'' '-' });                             goto case Xdigit;                          case Xdigit:                             if (var.Length > 3 && var[0] == '0' && (var[1] == 'x' || var[1] == 'X'))                                 var = var.Substring(2);                             break;                     }                     switch (test)                     {                         case Float:                             if (!var.Contains("."))                                 return false;                             goto case Number;                          case Number:                             {                                 bool dot = false;                                  foreach (var sym in var)                                 {                                     if (sym == '.')                                     {                                         if (dot)                                             return false;                                         dot = true;                                     }                                     else if (!char.IsDigit(sym))                                         return false;                                 }                                  return true;                             }                          case Digit:                             foreach (var sym in var)                                 if (!char.IsDigit(sym))                                     return false;                             return true;                          case Integer:                         case Xdigit:                             {                                 foreach (var sym in var)                                     if (!(char.IsDigit(sym) || (sym > 'a' - 1 && sym < 'f' + 1) || (sym > 'A' - 1 && sym < 'F' + 1)))                                         return false;                                 return true;                             }                          case Alpha:                             foreach (var sym in var)                                 if (!char.IsLetter(sym))                                     return false;                             return true;                          case Upper:                             foreach (var sym in var)                                 if (!char.IsUpper(sym))                                     return false;                             return true;                          case Lower:                             foreach (var sym in var)                                 if (!char.IsLower(sym))                                     return false;                             return true;                          case Alnum:                             foreach (var sym in var)                                 if (!char.IsLetterOrDigit(sym))                                     return false;                             return true;                          case Space:                             foreach (var sym in var)                                 if (!char.IsWhiteSpace(sym))                                     return false;                             return true;                          case Time:                             if (!IsNumeric(var))                                 return false;                             return ForceLong(var) < 99991231125959;                          default:                             return false;                     }             }
Magic Number,IronAHK.Scripting,Script,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Script\Call.cs,IfLegacy,The following statement contains a magic number: switch (op)             {                 case Between:                     {                         int z = var.IndexOf(And' StringComparison.OrdinalIgnoreCase);                          if (z == -1)                             z = var.Length;                          double low = double.MinValue' high = double.MaxValue;                          if (double.TryParse(var.Substring(0' z)' out low) && double.TryParse(var.Substring(z + And.Length)' out high))                         {                             var d = ForceDouble(subject);                             return d >= low && d <= high;                         }                     }                     return false;                  case In:                     foreach (var sub in test.Split(Delimiter))                         if (var.Equals(sub' StringComparison.OrdinalIgnoreCase))                             return true;                     return false;                  case Contains:                     foreach (var sub in test.Split(Delimiter))                         if (var.IndexOf(sub' StringComparison.OrdinalIgnoreCase) != -1)                             return true;                     return false;                  case Is:                     test = test.ToLowerInvariant();                     if (subject != null)                     {                         var type = subject.GetType();                         switch (test)                         {                             case Object:                                 return typeof(IDictionary).IsAssignableFrom(type);                              case Array:                                 return type.IsArray;                         }                     }                     switch (test)                     {                         case Integer:                         case Number:                             var = var.Trim().TrimStart(new[] { '+'' '-' });                             goto case Xdigit;                          case Xdigit:                             if (var.Length > 3 && var[0] == '0' && (var[1] == 'x' || var[1] == 'X'))                                 var = var.Substring(2);                             break;                     }                     switch (test)                     {                         case Float:                             if (!var.Contains("."))                                 return false;                             goto case Number;                          case Number:                             {                                 bool dot = false;                                  foreach (var sym in var)                                 {                                     if (sym == '.')                                     {                                         if (dot)                                             return false;                                         dot = true;                                     }                                     else if (!char.IsDigit(sym))                                         return false;                                 }                                  return true;                             }                          case Digit:                             foreach (var sym in var)                                 if (!char.IsDigit(sym))                                     return false;                             return true;                          case Integer:                         case Xdigit:                             {                                 foreach (var sym in var)                                     if (!(char.IsDigit(sym) || (sym > 'a' - 1 && sym < 'f' + 1) || (sym > 'A' - 1 && sym < 'F' + 1)))                                         return false;                                 return true;                             }                          case Alpha:                             foreach (var sym in var)                                 if (!char.IsLetter(sym))                                     return false;                             return true;                          case Upper:                             foreach (var sym in var)                                 if (!char.IsUpper(sym))                                     return false;                             return true;                          case Lower:                             foreach (var sym in var)                                 if (!char.IsLower(sym))                                     return false;                             return true;                          case Alnum:                             foreach (var sym in var)                                 if (!char.IsLetterOrDigit(sym))                                     return false;                             return true;                          case Space:                             foreach (var sym in var)                                 if (!char.IsWhiteSpace(sym))                                     return false;                             return true;                          case Time:                             if (!IsNumeric(var))                                 return false;                             return ForceLong(var) < 99991231125959;                          default:                             return false;                     }             }
Magic Number,IronAHK.Scripting,Generator,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Generator\Generator.cs,GetTypeOutput,The following statement contains a magic number: var name = new StringBuilder(type.BaseType.Length + type.ArrayRank * 2);
Magic Number,IronAHK.Scripting,Generator,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Generator\Generator.cs,CreateEscapedIdentifier,The following statement contains a magic number: var result = new StringBuilder(value.Length * 5);
Magic Number,IronAHK.Scripting,ILMirror,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,CopyOpcode,The following statement contains a magic number: i += 4;
Magic Number,IronAHK.Scripting,ILMirror,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,CopyOpcode,The following statement contains a magic number: Code == OpCodes.Leave && ExceptionTrinkets.Contains(i + 5)
Magic Number,IronAHK.Scripting,ILMirror,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,CopyOpcode,The following statement contains a magic number: switch(Code.OperandType)             {                 // If no argument' then re-emit the opcode                 case OperandType.InlineNone:                 {                     Gen.Emit(Code);                     break;                 }                                      // If argument is a method' re-emit the method reference                 case OperandType.InlineMethod:                 {                     int Token = BitHelper.ReadInteger(Bytes' ref i);                     MethodBase Base = Origin.ResolveMethod(Token);                                          if(Base is MethodInfo)                         Gen.Emit(Code' GrabMethod(Base as MethodInfo));                     else if(Base is ConstructorInfo)                         Gen.Emit(Code' GrabConstructor(Base as ConstructorInfo));                     else throw new InvalidOperationException("Inline method is neither method nor constructor.");                                          break;                 }                                      // Argument is a field reference                 case OperandType.InlineField:                 {                     int Token = BitHelper.ReadInteger(Bytes' ref i);                     FieldInfo Field = Origin.ResolveField(Token);                     Gen.Emit(Code' GrabField(Field));                     break;                 }                                      // Argument is a type reference                 case OperandType.InlineType:                 {                     int Token = BitHelper.ReadInteger(Bytes' ref i);                     Type Ref = Origin.ResolveType(Token);                     Gen.Emit(Code' GrabType(Ref));                     break;                 }                                      // Argument is an inline string                 case OperandType.InlineString:                 {                     int Token = BitHelper.ReadInteger(Bytes' ref i);                     string Copy = Origin.ResolveString(Token);                     Gen.Emit(Code' Copy);                     break;                 }                                   // Argument is a metadata token                 case OperandType.InlineTok:                 {                     int Token = BitHelper.ReadInteger(Bytes' ref i);                     MemberInfo Info = Origin.ResolveMember(Token);                                          if(Info.MemberType == MemberTypes.Field)                     {                         if(Code != OpCodes.Ldtoken || !TryReplaceBackingField(Bytes' i' Gen' Origin))                             Gen.Emit(Code' GrabField(Info as FieldInfo));                     }                     else if(Info.MemberType == MemberTypes.Method)                         Gen.Emit(Code' GrabMethod(Info as MethodInfo));                     else if(Info.MemberType == MemberTypes.TypeInfo || Info.MemberType == MemberTypes.NestedType)                         Gen.Emit(Code' GrabType(Info as Type));                     else throw new InvalidOperationException("Inline token is neither field' nor method' nor type");                                          break;                 }                                      // Argument is a switch map                 case OperandType.InlineSwitch:                 {                     if(!LabelOrigins.ContainsKey(i))                         throw new Exception("No switchmap found for RVA "+i.ToString("X"));                                              Label[] Labels = LabelOrigins[i];                     i += 4 + Labels.Length*4;                     Gen.Emit(Code' Labels);                                          break;                 }                                      // Argument is a single-byte branch target                 case OperandType.ShortInlineBrTarget:                 {                     if(!LabelOrigins.ContainsKey(i))                         throw new Exception("No label origin found for RVA "+i.ToString("X"));                      // messy fix to convert short branch targets to normal ones' since there's no easy way to calculate offsets via reflection                     const string s = ".s";                     string name = Code.Name;                     if (name.EndsWith(s))                     {                         name = name.Substring(0' name.Length - s.Length);                         foreach (var field in typeof(OpCodes).GetFields(BindingFlags.Public | BindingFlags.Static))                         {                             var opcode = (OpCode)field.GetValue(null);                             if (opcode.Name.Equals(name))                             {                                 Code = opcode;                                 break;                             }                         }                     }                      Gen.Emit(Code' LabelOrigins[i][0]);                     i++;                                          break;                 }                                      // Argument is a byte                 case OperandType.ShortInlineI:                 case OperandType.ShortInlineVar:                 {                     Gen.Emit(Code' Bytes[++i]);                     break;                 }                                  // Argument is a short                 case OperandType.InlineVar:                 {                     Gen.Emit(Code' BitHelper.ReadShort(Bytes' ref i));                     break;                 }                                      case OperandType.InlineBrTarget:                 {                     if(!LabelOrigins.ContainsKey(i))                         throw new Exception("No label origin found for RVA "+i.ToString("X"));                                          Gen.Emit(Code' LabelOrigins[i][0]);                     i += 4;                                          break;                 }                                      // Argument is a 32-bit integer                 case OperandType.InlineI:                 case OperandType.ShortInlineR: // This is actually a 32-bit float' but we don't care                 {                     Gen.Emit(Code' BitHelper.ReadInteger(Bytes' ref i));                     break;                 }                                      // Argument is a 64-bit integer                 case OperandType.InlineI8:                 {                     Gen.Emit(Code' BitHelper.ReadLong(Bytes' ref i));                     break;                 }                                      // Argument is a 64-bit float                 case OperandType.InlineR:                 {                     Gen.Emit(Code' BitHelper.ReadDouble(Bytes' ref i));                     break;                 }                                       // If ever we run across OpCodes.Calli this'll probably happen                 default:                     throw new InvalidOperationException("The method copier ran across an unknown opcode.");             }
Magic Number,IronAHK.Scripting,ILMirror,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,CopyOpcode,The following statement contains a magic number: switch(Code.OperandType)             {                 // If no argument' then re-emit the opcode                 case OperandType.InlineNone:                 {                     Gen.Emit(Code);                     break;                 }                                      // If argument is a method' re-emit the method reference                 case OperandType.InlineMethod:                 {                     int Token = BitHelper.ReadInteger(Bytes' ref i);                     MethodBase Base = Origin.ResolveMethod(Token);                                          if(Base is MethodInfo)                         Gen.Emit(Code' GrabMethod(Base as MethodInfo));                     else if(Base is ConstructorInfo)                         Gen.Emit(Code' GrabConstructor(Base as ConstructorInfo));                     else throw new InvalidOperationException("Inline method is neither method nor constructor.");                                          break;                 }                                      // Argument is a field reference                 case OperandType.InlineField:                 {                     int Token = BitHelper.ReadInteger(Bytes' ref i);                     FieldInfo Field = Origin.ResolveField(Token);                     Gen.Emit(Code' GrabField(Field));                     break;                 }                                      // Argument is a type reference                 case OperandType.InlineType:                 {                     int Token = BitHelper.ReadInteger(Bytes' ref i);                     Type Ref = Origin.ResolveType(Token);                     Gen.Emit(Code' GrabType(Ref));                     break;                 }                                      // Argument is an inline string                 case OperandType.InlineString:                 {                     int Token = BitHelper.ReadInteger(Bytes' ref i);                     string Copy = Origin.ResolveString(Token);                     Gen.Emit(Code' Copy);                     break;                 }                                   // Argument is a metadata token                 case OperandType.InlineTok:                 {                     int Token = BitHelper.ReadInteger(Bytes' ref i);                     MemberInfo Info = Origin.ResolveMember(Token);                                          if(Info.MemberType == MemberTypes.Field)                     {                         if(Code != OpCodes.Ldtoken || !TryReplaceBackingField(Bytes' i' Gen' Origin))                             Gen.Emit(Code' GrabField(Info as FieldInfo));                     }                     else if(Info.MemberType == MemberTypes.Method)                         Gen.Emit(Code' GrabMethod(Info as MethodInfo));                     else if(Info.MemberType == MemberTypes.TypeInfo || Info.MemberType == MemberTypes.NestedType)                         Gen.Emit(Code' GrabType(Info as Type));                     else throw new InvalidOperationException("Inline token is neither field' nor method' nor type");                                          break;                 }                                      // Argument is a switch map                 case OperandType.InlineSwitch:                 {                     if(!LabelOrigins.ContainsKey(i))                         throw new Exception("No switchmap found for RVA "+i.ToString("X"));                                              Label[] Labels = LabelOrigins[i];                     i += 4 + Labels.Length*4;                     Gen.Emit(Code' Labels);                                          break;                 }                                      // Argument is a single-byte branch target                 case OperandType.ShortInlineBrTarget:                 {                     if(!LabelOrigins.ContainsKey(i))                         throw new Exception("No label origin found for RVA "+i.ToString("X"));                      // messy fix to convert short branch targets to normal ones' since there's no easy way to calculate offsets via reflection                     const string s = ".s";                     string name = Code.Name;                     if (name.EndsWith(s))                     {                         name = name.Substring(0' name.Length - s.Length);                         foreach (var field in typeof(OpCodes).GetFields(BindingFlags.Public | BindingFlags.Static))                         {                             var opcode = (OpCode)field.GetValue(null);                             if (opcode.Name.Equals(name))                             {                                 Code = opcode;                                 break;                             }                         }                     }                      Gen.Emit(Code' LabelOrigins[i][0]);                     i++;                                          break;                 }                                      // Argument is a byte                 case OperandType.ShortInlineI:                 case OperandType.ShortInlineVar:                 {                     Gen.Emit(Code' Bytes[++i]);                     break;                 }                                  // Argument is a short                 case OperandType.InlineVar:                 {                     Gen.Emit(Code' BitHelper.ReadShort(Bytes' ref i));                     break;                 }                                      case OperandType.InlineBrTarget:                 {                     if(!LabelOrigins.ContainsKey(i))                         throw new Exception("No label origin found for RVA "+i.ToString("X"));                                          Gen.Emit(Code' LabelOrigins[i][0]);                     i += 4;                                          break;                 }                                      // Argument is a 32-bit integer                 case OperandType.InlineI:                 case OperandType.ShortInlineR: // This is actually a 32-bit float' but we don't care                 {                     Gen.Emit(Code' BitHelper.ReadInteger(Bytes' ref i));                     break;                 }                                      // Argument is a 64-bit integer                 case OperandType.InlineI8:                 {                     Gen.Emit(Code' BitHelper.ReadLong(Bytes' ref i));                     break;                 }                                      // Argument is a 64-bit float                 case OperandType.InlineR:                 {                     Gen.Emit(Code' BitHelper.ReadDouble(Bytes' ref i));                     break;                 }                                       // If ever we run across OpCodes.Calli this'll probably happen                 default:                     throw new InvalidOperationException("The method copier ran across an unknown opcode.");             }
Magic Number,IronAHK.Scripting,ILMirror,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,CopyOpcode,The following statement contains a magic number: switch(Code.OperandType)             {                 // If no argument' then re-emit the opcode                 case OperandType.InlineNone:                 {                     Gen.Emit(Code);                     break;                 }                                      // If argument is a method' re-emit the method reference                 case OperandType.InlineMethod:                 {                     int Token = BitHelper.ReadInteger(Bytes' ref i);                     MethodBase Base = Origin.ResolveMethod(Token);                                          if(Base is MethodInfo)                         Gen.Emit(Code' GrabMethod(Base as MethodInfo));                     else if(Base is ConstructorInfo)                         Gen.Emit(Code' GrabConstructor(Base as ConstructorInfo));                     else throw new InvalidOperationException("Inline method is neither method nor constructor.");                                          break;                 }                                      // Argument is a field reference                 case OperandType.InlineField:                 {                     int Token = BitHelper.ReadInteger(Bytes' ref i);                     FieldInfo Field = Origin.ResolveField(Token);                     Gen.Emit(Code' GrabField(Field));                     break;                 }                                      // Argument is a type reference                 case OperandType.InlineType:                 {                     int Token = BitHelper.ReadInteger(Bytes' ref i);                     Type Ref = Origin.ResolveType(Token);                     Gen.Emit(Code' GrabType(Ref));                     break;                 }                                      // Argument is an inline string                 case OperandType.InlineString:                 {                     int Token = BitHelper.ReadInteger(Bytes' ref i);                     string Copy = Origin.ResolveString(Token);                     Gen.Emit(Code' Copy);                     break;                 }                                   // Argument is a metadata token                 case OperandType.InlineTok:                 {                     int Token = BitHelper.ReadInteger(Bytes' ref i);                     MemberInfo Info = Origin.ResolveMember(Token);                                          if(Info.MemberType == MemberTypes.Field)                     {                         if(Code != OpCodes.Ldtoken || !TryReplaceBackingField(Bytes' i' Gen' Origin))                             Gen.Emit(Code' GrabField(Info as FieldInfo));                     }                     else if(Info.MemberType == MemberTypes.Method)                         Gen.Emit(Code' GrabMethod(Info as MethodInfo));                     else if(Info.MemberType == MemberTypes.TypeInfo || Info.MemberType == MemberTypes.NestedType)                         Gen.Emit(Code' GrabType(Info as Type));                     else throw new InvalidOperationException("Inline token is neither field' nor method' nor type");                                          break;                 }                                      // Argument is a switch map                 case OperandType.InlineSwitch:                 {                     if(!LabelOrigins.ContainsKey(i))                         throw new Exception("No switchmap found for RVA "+i.ToString("X"));                                              Label[] Labels = LabelOrigins[i];                     i += 4 + Labels.Length*4;                     Gen.Emit(Code' Labels);                                          break;                 }                                      // Argument is a single-byte branch target                 case OperandType.ShortInlineBrTarget:                 {                     if(!LabelOrigins.ContainsKey(i))                         throw new Exception("No label origin found for RVA "+i.ToString("X"));                      // messy fix to convert short branch targets to normal ones' since there's no easy way to calculate offsets via reflection                     const string s = ".s";                     string name = Code.Name;                     if (name.EndsWith(s))                     {                         name = name.Substring(0' name.Length - s.Length);                         foreach (var field in typeof(OpCodes).GetFields(BindingFlags.Public | BindingFlags.Static))                         {                             var opcode = (OpCode)field.GetValue(null);                             if (opcode.Name.Equals(name))                             {                                 Code = opcode;                                 break;                             }                         }                     }                      Gen.Emit(Code' LabelOrigins[i][0]);                     i++;                                          break;                 }                                      // Argument is a byte                 case OperandType.ShortInlineI:                 case OperandType.ShortInlineVar:                 {                     Gen.Emit(Code' Bytes[++i]);                     break;                 }                                  // Argument is a short                 case OperandType.InlineVar:                 {                     Gen.Emit(Code' BitHelper.ReadShort(Bytes' ref i));                     break;                 }                                      case OperandType.InlineBrTarget:                 {                     if(!LabelOrigins.ContainsKey(i))                         throw new Exception("No label origin found for RVA "+i.ToString("X"));                                          Gen.Emit(Code' LabelOrigins[i][0]);                     i += 4;                                          break;                 }                                      // Argument is a 32-bit integer                 case OperandType.InlineI:                 case OperandType.ShortInlineR: // This is actually a 32-bit float' but we don't care                 {                     Gen.Emit(Code' BitHelper.ReadInteger(Bytes' ref i));                     break;                 }                                      // Argument is a 64-bit integer                 case OperandType.InlineI8:                 {                     Gen.Emit(Code' BitHelper.ReadLong(Bytes' ref i));                     break;                 }                                      // Argument is a 64-bit float                 case OperandType.InlineR:                 {                     Gen.Emit(Code' BitHelper.ReadDouble(Bytes' ref i));                     break;                 }                                       // If ever we run across OpCodes.Calli this'll probably happen                 default:                     throw new InvalidOperationException("The method copier ran across an unknown opcode.");             }
Magic Number,IronAHK.Scripting,ILMirror,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,TryReplaceBackingField,The following statement contains a magic number: Bytes[i+6] != (byte) OpCodes.Stsfld.Value
Magic Number,IronAHK.Scripting,ILMirror,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,TryReplaceBackingField,The following statement contains a magic number: i += 6;
Magic Number,IronAHK.Scripting,ILMirror,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,MineLabels,The following statement contains a magic number: int Zero = i+Count*4+1;
Magic Number,IronAHK.Scripting,ILMirror,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,CodeArgumentSize,The following statement contains a magic number: switch(Code.OperandType)             {                 case OperandType.InlineNone:                     return 0;                                      // All tokens are 32-bit integers                 case OperandType.InlineMethod:                 case OperandType.InlineField:                 case OperandType.InlineType:                 case OperandType.InlineString:                 case OperandType.InlineTok:                 case OperandType.InlineBrTarget:                 case OperandType.InlineI:                 case OperandType.ShortInlineR:                      return 4;                                      // Variable length                 case OperandType.InlineSwitch:                     throw new ArgumentException("InlineSwitch has variable argument length"' "Code");                                      // Argument is a byte                 case OperandType.ShortInlineBrTarget:                 case OperandType.ShortInlineI:                 case OperandType.ShortInlineVar:                     return 1;                                  // Argument is a short                 case OperandType.InlineVar:                     return 2;                                      // Argument is a 64-bit integer                 case OperandType.InlineI8:                 case OperandType.InlineR:                     return 8;                                  default:                     throw new InvalidOperationException("Could not determine argument size for opcode "+Code);             }
Magic Number,IronAHK.Scripting,ILMirror,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,CodeArgumentSize,The following statement contains a magic number: switch(Code.OperandType)             {                 case OperandType.InlineNone:                     return 0;                                      // All tokens are 32-bit integers                 case OperandType.InlineMethod:                 case OperandType.InlineField:                 case OperandType.InlineType:                 case OperandType.InlineString:                 case OperandType.InlineTok:                 case OperandType.InlineBrTarget:                 case OperandType.InlineI:                 case OperandType.ShortInlineR:                      return 4;                                      // Variable length                 case OperandType.InlineSwitch:                     throw new ArgumentException("InlineSwitch has variable argument length"' "Code");                                      // Argument is a byte                 case OperandType.ShortInlineBrTarget:                 case OperandType.ShortInlineI:                 case OperandType.ShortInlineVar:                     return 1;                                  // Argument is a short                 case OperandType.InlineVar:                     return 2;                                      // Argument is a 64-bit integer                 case OperandType.InlineI8:                 case OperandType.InlineR:                     return 8;                                  default:                     throw new InvalidOperationException("Could not determine argument size for opcode "+Code);             }
Magic Number,IronAHK.Scripting,ILMirror,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,CodeArgumentSize,The following statement contains a magic number: switch(Code.OperandType)             {                 case OperandType.InlineNone:                     return 0;                                      // All tokens are 32-bit integers                 case OperandType.InlineMethod:                 case OperandType.InlineField:                 case OperandType.InlineType:                 case OperandType.InlineString:                 case OperandType.InlineTok:                 case OperandType.InlineBrTarget:                 case OperandType.InlineI:                 case OperandType.ShortInlineR:                      return 4;                                      // Variable length                 case OperandType.InlineSwitch:                     throw new ArgumentException("InlineSwitch has variable argument length"' "Code");                                      // Argument is a byte                 case OperandType.ShortInlineBrTarget:                 case OperandType.ShortInlineI:                 case OperandType.ShortInlineVar:                     return 1;                                  // Argument is a short                 case OperandType.InlineVar:                     return 2;                                      // Argument is a 64-bit integer                 case OperandType.InlineI8:                 case OperandType.InlineR:                     return 8;                                  default:                     throw new InvalidOperationException("Could not determine argument size for opcode "+Code);             }
Magic Number,IronAHK.Scripting,BitHelper,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,ReadUnsignedInteger,The following statement contains a magic number: i += 3;
Magic Number,IronAHK.Scripting,BitHelper,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,ReadInteger,The following statement contains a magic number: i += 3;
Magic Number,IronAHK.Scripting,BitHelper,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,ReadLong,The following statement contains a magic number: i += 7;
Magic Number,IronAHK.Scripting,BitHelper,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,ReadFloat,The following statement contains a magic number: i += 3;
Magic Number,IronAHK.Scripting,BitHelper,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,ReadDouble,The following statement contains a magic number: i += 7;
Missing Default,IronAHK.Scripting,Emit,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,EmitMethod,The following switch statement is missing a default case: switch (param.Direction)                 {                     case FieldDirection.Out:                         throw new NotSupportedException();                      case FieldDirection.Ref:                         writer.Write(Parser.FunctionParamRef);                         writer.Write(Parser.SingleSpace);                         break;                 }
Missing Default,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Set,The following switch statement is missing a default case: switch (first[0])                 {                     case BlockOpen:                         expect = BlockClose;                         levels[1]++;                         break;                      case ArrayOpen:                         expect = ArrayClose;                         levels[2]++;                         break;                      case ParenOpen:                         expect = ParenClose;                         levels[0]++;                         break;                 }
Missing Default,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Set,The following switch statement is missing a default case: switch (current[0])                     {                         case BlockOpen:                             levels[1]++;                             break;                          case BlockClose:                             levels[1]--;                             if (levels[1] < 0)                                 throw new ParseException(ExUnbalancedParens);                             else if (expect == BlockClose && levels[0] == 0 && levels[1] == 0 && levels[2] == 0)                                 return position;                             break;                          case ArrayOpen:                             levels[2]++;                             break;                          case ArrayClose:                             levels[2]--;                             if (levels[2] < 0)                                 throw new ParseException(ExUnbalancedParens);                             else if (expect == ArrayClose && levels[0] == 0 && levels[1] == 0 && levels[2] == 0)                                 return position;                             break;                          case ParenOpen:                             levels[0]++;                             break;                          case ParenClose:                             levels[0]--;                             if (levels[0] < 0)                                 throw new ParseException(ExUnbalancedParens);                             else if (expect == ParenClose && levels[0] == 0 && levels[1] == 0 && levels[2] == 0)                                 return position;                             break;                     }
Missing Default,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorFromString,The following switch statement is missing a default case: switch (code.ToLowerInvariant())                     {                         case NotTxt:                             return Script.Operator.LogicalNotEx;                          case AndTxt:                             return Script.Operator.BooleanAnd;                          case OrTxt:                             return Script.Operator.BooleanOr;                          case IsTxt:                             return Script.Operator.Is;                     }
Missing Default,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitTokens,The following switch statement is missing a default case: switch (sym)                         {                             case Divide:                             case Greater:                             case Less:                                 peekAssign = true;                                 goto case Add;                              case Add:                             case Minus:                             case Multiply:                             case BitOR:                             case BitAND:                                 op.Append(sym);                                 op.Append(symNext);                                 i++;                                 tri = true;                                 if (peekAssign)                                 {                                     n = i + 1;                                     if (n < code.Length && code[n] == Equal)                                     {                                         op.Append(code[n]);                                         i = n;                                     }                                 }                                 break;                         }
Missing Default,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitTokens,The following switch statement is missing a default case: switch (sym)                             {                                 case AssignPre:                                 case Add:                                 case Minus:                                 case Multiply:                                 case Divide:                                 case Concatenate:                                 case BitAND:                                 case BitXOR:                                 case BitOR:                                 case Not:                                 case Equal:                                 case Greater:                                 case Less:                                     op.Append(sym);                                     op.Append(symNext);                                     i++;                                     break;                             }
Missing Default,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,RemoveExcessParentheses,The following switch statement is missing a default case: switch (check[check.Length - 1])                     {                         case ParenOpen:                             level++;                             break;                          case ParenClose:                             if (check.Length != 1)                                 break;                             else if (--level < 0)                                 throw new ParseException(ExUnbalancedParens);                             break;                     }
Missing Default,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following switch statement is missing a default case: switch (cmd.ToLowerInvariant())             {                 #region Repeat                  case "repeat":                     param = StripCommentSingle(param);                     if (param.Length > 0 && !IsPrimativeObject(param))                             param = string.Empty;                     replaced.Append("Loop ");                     replaced.Append(param);                     replaced.Append(SingleSpace);                     replaced.Append(BlockOpen);                     break;                  case "endrepeat":                     replaced.Append(BlockClose);                     replaced.Append(param);                     break;                  #endregion                  #region Setters                  case "setbatchlines":                 case "setcontroldelay":                 case "setdefaultmousespeed":                 case "setkeydelay":                 case "setmousedelay":                 case "setstorecapslockmode":                 case "settitlematchmode":                 case "setwindelay":                 case "setworkingdir":                     replaced.Append("A_");                     replaced.Append(cmd' 3' cmd.Length - 3);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  case "setenv":                     replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     else                         replaced.Append(NullTxt);                     break;                  case "setformat":                     if (parts.Length != 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append("A_Format");                     const string fast = "fast";                     parts[0] = parts[0].Substring(1' parts[0].Length - 2);                     if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                         parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append(parts[1]);                     break;                  case "autotrim":                 case "detecthiddentext":                 case "detecthiddenwindows":                 case "stringcasesense":                     replaced.Append("A_");                     replaced.Append(cmd);                     replaced.Append(Equal);                     replaced.Append(param);                     break;                  #endregion                  #region If                  #region Equality                  // TODO: push single conditional command on same line as legacy converted equality-if statements                  case "ifequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifnotequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Not);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreater":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifgreaterorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Greater);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "ifless":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  case "iflessorequal":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(parts[0]);                     replaced.Append(Less);                     replaced.Append(Equal);                     if (parts.Length > 1)                         replaced.Append(parts[1]);                     break;                  #endregion                  case "ifexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotexist":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("FileExist");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifnotinstring":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[0]);                     replaced.Append(Multicast);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose' 2);                     break;                  case "ifmsgbox":                     if (parts.Length < 1)                         throw new ParseException(ExTooFewParams);                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("A_MsgBox");                     replaced.Append(Equal);                     replaced.Append(parts[0]);                     replaced.Append(ParenClose);                     break;                  case "ifwinactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotactive":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinActive");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  case "ifwinnotexist":                     replaced.Append(FlowIf);                     replaced.Append(SingleSpace);                     replaced.Append(ParenOpen);                     replaced.Append(Not);                     replaced.Append("WinExist");                     replaced.Append(ParenOpen);                     foreach (var part in parts)                     {                         replaced.Append(part);                         replaced.Append(Multicast);                     }                     if (parts.Length > 1)                         replaced.Remove(replaced.Length - 1' 1);                     replaced.Append(ParenClose' 2);                     break;                  #endregion                  #region Strings                  // HACK: convert L/R paramter for legacy StringGetPos command                 case "stringgetpos":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0].Trim(StringBound));                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("InStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(Multicast);                     replaced.Append(FalseTxt);                     replaced.Append(Multicast);                     replaced.Append(parts.Length > 4 ? parts[4] : "0");                     replaced.Append(ParenClose);                     break;                  case "stringleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringlen":                     if (parts.Length < 2)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("StrLen");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(ParenClose);                     break;                  case "stringmid":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append(parts[2]);                     if (parts.Length > 3)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[3]);                     }                     if (parts.Length > 4)                     {                         replaced.Append(Multicast);                         replaced.Append(parts[4]);                     }                     replaced.Append(ParenClose);                     break;                  case "stringright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  case "stringtrimleft":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Add);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     break;                  case "stringtrimright":                     if (parts.Length < 3)                         throw new ParseException(ExTooFewParams);                     replaced.Append(parts[0]);                     replaced.Append(AssignPre);                     replaced.Append(Equal);                     replaced.Append("SubStr");                     replaced.Append(ParenOpen);                     replaced.Append(parts[1]);                     replaced.Append(Multicast);                     replaced.Append("1");                     replaced.Append(Multicast);                     replaced.Append(Minus);                     replaced.Append(ParenOpen);                     replaced.Append(parts[2]);                     replaced.Append(ParenClose);                     replaced.Append(ParenClose);                     break;                  #endregion                  #region Arithmetic                  // TODO: translate legacy EnvMult' EnvDiv etc                  #endregion                  #region Send                  case "sendevent":                 case "sendinput":                 case "sendplay":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  case "sendraw":                     replaced.Append("Send");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "controlsendraw":                     replaced.Append("ControlSend");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     ParameterPrepend(ref param' "{Raw}");                     replaced.Append(param);                     break;                  case "sendmode":                     code = string.Empty;                     break;                  case "setcapslockstate":                 case "setnumlockstate":                 case "setscrolllockstate":                     replaced.Append("SetLockState");                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(cmd' 3' cmd.Length - 3 - 5);                     replaced.Append(Multicast);                     replaced.Append(SingleSpace);                     replaced.Append(param);                     break;                  #endregion                  #region Mouse                  case "leftclick":                 case "mouseclick":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "leftclickdrag":                     replaced.Append("MouseClickDrag");                     replaced.Append(Multicast);                     replaced.Append("Left");                     replaced.Append(Multicast);                     replaced.Append(param);                     break;                  case "mousemove":                     replaced.Append("Click");                     replaced.Append(Multicast);                     replaced.Append(param);                     replaced.Append(Multicast);                     replaced.Append("0");                     break;                  #endregion                  #region Debug                  case "edit":                 case "listlines":                 case "listvars":                     replaced = null;                     break;                  #endregion                  #region Other                  case "filegetattrib":                     if (parts.Length != 2)                         replaced = null;                     else                     {                         replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                         replaced.Append(AssignPre);                         replaced.Append(Equal);                         replaced.Append("FileExist");                         replaced.Append(ParenOpen);                         replaced.Append(parts[1]);                         replaced.Append(ParenClose);                     }                     break;                  #endregion             }
Missing Default,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,CheckPersistent,The following switch statement is missing a default case: switch (name.ToLowerInvariant())             {                 case "settimer":                 case "menu":                 case "hotkey":                 case "hotstring":                 case "onmessage":                 case "gui":                     persistent = true;                     break;             }
Missing Default,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsPrimativeObject,The following switch statement is missing a default case: switch (code.ToLowerInvariant())             {                 case TrueTxt:                     result = true;                     return true;                  case FalseTxt:                     result = false;                     return true;                  case NullTxt:                     return true;             }
Missing Default,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsExpressionIf,The following switch statement is missing a default case: switch (code[i])             {                 case Equal:                 case Not:                 case Greater:                 case Less:                     return false;             }
Missing Default,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsLegacyIf,The following switch statement is missing a default case: switch (part[1].ToLowerInvariant())             {                 case NotTxt:                 case BetweenTxt:                 case InTxt:                 case ContainsTxt:                 case IsTxt:                     return true;             }
Missing Default,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitCommandParameters,The following switch statement is missing a default case: switch (sym)                     {                         case StringBound: str = !str; break;                         case ParenOpen: levels[0]++; break;                         case ParenClose: levels[0]--; break;                         case BlockOpen: levels[1]++; break;                         case BlockClose: levels[1]--; break;                         case ArrayOpen: levels[2]++; break;                         case ArrayClose: levels[2]--; break;                     }
Missing Default,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseDirective,The following switch statement is missing a default case: switch (parts[1].ToUpperInvariant())                         {                             case "FORCE":                                 options.MergeFallbackToLink = false;                                 break;                              case "OFF":                                 options.Merge = false;                                 break;                         }
Missing Default,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseMultiExpression,The following switch statement is missing a default case: switch (arg)                 {                     case "S":                     case "SECOND":                     case "M":                     case "MINUTE":                     case "H":                     case "HOUR":                     case "D":                     case "DAY":                         return new[] { new CodeExpressionStatement(ParseDateExpression(code)) };                 }
Missing Default,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The following switch statement is missing a default case: switch (parts[i] as Script.Operator?)                                 {                                     case Script.Operator.TernaryA:                                         depth++;                                         break;                                      case Script.Operator.TernaryB:                                         depth--;                                         break;                                 }
Missing Default,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsFlowOperator,The following switch statement is missing a default case: switch (word)             {                 case FlowBreak:                 case FlowContinue:                 case FlowElse:                 case FlowGosub:                 case FlowGoto:                 case FlowIf:                 case FlowLoop:                 case FlowReturn:                 case FlowWhile:                 case FunctionLocal:                 case FunctionGlobal:                 case FunctionStatic:                     return true;             }
Missing Default,IronAHK.Scripting,Parser,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsFunction,The following switch statement is missing a default case: switch (stage)                 {                     case 0:                         if (sym == ParenOpen)                             stage++;                         else if (!IsIdentifier(sym))                             return false;                         break;                      case 1:                         if (sym == StringBound)                             str = !str;                         else if (!str && sym == ParenClose)                             stage++;                         break;                      case 2:                         if (sym == BlockOpen)                             return true;                         else if (IsCommentAt(code' i))                             goto next;                         else if (!IsSpace(sym))                             return false;                         break;                 }
Missing Default,IronAHK.Scripting,Script,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Script\Call.cs,IfLegacy,The following switch statement is missing a default case: switch (test)                         {                             case Object:                                 return typeof(IDictionary).IsAssignableFrom(type);                              case Array:                                 return type.IsArray;                         }
Missing Default,IronAHK.Scripting,Script,C:\research\architectureSmells\repos\polyethene_IronAHK\Scripting\Script\Call.cs,IfLegacy,The following switch statement is missing a default case: switch (test)                     {                         case Integer:                         case Number:                             var = var.Trim().TrimStart(new[] { '+'' '-' });                             goto case Xdigit;                          case Xdigit:                             if (var.Length > 3 && var[0] == '0' && (var[1] == 'x' || var[1] == 'X'))                                 var = var.Substring(2);                             break;                     }
