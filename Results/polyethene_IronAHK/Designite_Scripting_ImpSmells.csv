Implementation smell,Namespace,Class,File,Method,Description
Long Method,IronAHK.Scripting,Emit,C:\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,EmitInvoke,The method has 110 lines of code.
Long Method,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorFromString,The method has 176 lines of code.
Long Method,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitTokens,The method has 226 lines of code.
Long Method,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The method has 514 lines of code.
Long Method,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Statements,The method has 149 lines of code.
Long Method,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseDirective,The method has 143 lines of code.
Long Method,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The method has 652 lines of code.
Long Method,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseFlow,The method has 229 lines of code.
Long Method,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Read,The method has 215 lines of code.
Long Method,IronAHK.Scripting,Script,C:\repos\polyethene_IronAHK\Scripting\Script\Call.cs,IfLegacy,The method has 140 lines of code.
Long Method,IronAHK.Scripting,MethodWriter,C:\repos\polyethene_IronAHK\Scripting\Compiler\Emission\MethodWriter.cs,EmitMethodInvoke,The method has 174 lines of code.
Long Method,IronAHK.Scripting,ILMirror,C:\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,CopyOpcode,The method has 182 lines of code.
Long Method,IronAHK.Scripting,ILMirror,C:\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,GrabType,The method has 100 lines of code.
Complex Method,IronAHK.Scripting,Emit,C:\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,EmitConditionStatement,Cyclomatic complexity of the method is 8
Complex Method,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseObject,Cyclomatic complexity of the method is 17
Complex Method,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Set,Cyclomatic complexity of the method is 9
Complex Method,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ScanLibrary,Cyclomatic complexity of the method is 9
Complex Method,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,Cyclomatic complexity of the method is 8
Complex Method,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,VarIdExpand,Cyclomatic complexity of the method is 10
Complex Method,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,StdLib,Cyclomatic complexity of the method is 9
Complex Method,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsPrimativeObject,Cyclomatic complexity of the method is 8
Complex Method,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsExpressionIf,Cyclomatic complexity of the method is 8
Complex Method,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Statements,Cyclomatic complexity of the method is 10
Complex Method,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseHotkey,Cyclomatic complexity of the method is 9
Complex Method,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,MultilineString,Cyclomatic complexity of the method is 15
Complex Method,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseAssign,Cyclomatic complexity of the method is 9
Complex Method,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitCommandParameters,Cyclomatic complexity of the method is 9
Complex Method,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,Cyclomatic complexity of the method is 43
Complex Method,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseInequality,Cyclomatic complexity of the method is 10
Complex Method,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseFunction,Cyclomatic complexity of the method is 12
Complex Method,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseFunctionParameters,Cyclomatic complexity of the method is 12
Complex Method,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ValidateParameterLiteral,Cyclomatic complexity of the method is 8
Complex Method,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Read,Cyclomatic complexity of the method is 19
Complex Method,IronAHK.Scripting,Script,C:\repos\polyethene_IronAHK\Scripting\Script\Call.cs,ForceString,Cyclomatic complexity of the method is 8
Complex Method,IronAHK.Scripting,Script,C:\repos\polyethene_IronAHK\Scripting\Script\Call.cs,Index,Cyclomatic complexity of the method is 9
Complex Method,IronAHK.Scripting,Script,C:\repos\polyethene_IronAHK\Scripting\Script\Call.cs,SetObject,Cyclomatic complexity of the method is 11
Complex Method,IronAHK.Scripting,MethodWriter,C:\repos\polyethene_IronAHK\Scripting\Compiler\Emission\MethodWriter.cs,EmitBinaryOperator,Cyclomatic complexity of the method is 9
Complex Method,IronAHK.Scripting,MethodWriter,C:\repos\polyethene_IronAHK\Scripting\Compiler\Emission\MethodWriter.cs,EmitMethodInvoke,Cyclomatic complexity of the method is 27
Complex Method,IronAHK.Scripting,ILMirror,C:\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,GrabMethod,Cyclomatic complexity of the method is 10
Complex Method,IronAHK.Scripting,ILMirror,C:\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,GrabField,Cyclomatic complexity of the method is 9
Complex Method,IronAHK.Scripting,ILMirror,C:\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,GrabProperty,Cyclomatic complexity of the method is 8
Complex Method,IronAHK.Scripting,ILMirror,C:\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,GrabType,Cyclomatic complexity of the method is 17
Complex Method,IronAHK.Scripting,ILMirror,C:\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,CopyTryCatch,Cyclomatic complexity of the method is 8
Long Parameter List,IronAHK.Scripting,CodeBlock,C:\repos\polyethene_IronAHK\Scripting\Parser\CodeDom\CodeBlock.cs,CodeBlock,The method has 5 parameters. Parameters: line' method' statements' kind' parent
Long Parameter List,IronAHK.Scripting,CodeBlock,C:\repos\polyethene_IronAHK\Scripting\Parser\CodeDom\CodeBlock.cs,CodeBlock,The method has 7 parameters. Parameters: line' method' statements' kind' parent' endLabel' exitLabel
Long Parameter List,IronAHK.Scripting,ILMirror,C:\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,CopyOpcode,The method has 6 parameters. Parameters: Bytes' i' Gen' Origin' ExceptionTrinkets' LabelOrigins
Long Statement,IronAHK.Scripting,Compiler,C:\repos\polyethene_IronAHK\Scripting\Compiler\CompilerSetup.cs,Setup,The length of the statement  "                    Options.OutputAssembly = Path.Combine(Path.GetTempPath()' Path.GetFileNameWithoutExtension(Path.GetRandomFileName()) + ".exe"); " is 127.
Long Statement,IronAHK.Scripting,Emit,C:\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,EmitInvoke,The length of the statement  "                    invoke.Parameters[1] is CodePrimitiveExpression && (((CodePrimitiveExpression)invoke.Parameters[1]).Value as string) == Parser.IsTxt) " is 133.
Long Statement,IronAHK.Scripting,Emit,C:\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,EmitInvoke,The length of the statement  "                    var op = (Script.Operator)Enum.Parse(typeof(Script.Operator)' ((CodeFieldReferenceExpression)invoke.Parameters[0]).FieldName); " is 126.
Long Statement,IronAHK.Scripting,Emit,C:\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,EmitInvoke,The length of the statement  "                !(invoke.Method.TargetObject is CodeTypeReferenceExpression && IsInternalType((CodeTypeReferenceExpression)invoke.Method.TargetObject))) " is 136.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsJsonObject,The length of the statement  "            return item is CodeMethodInvokeExpression && ((CodeMethodInvokeExpression)item).Method.MethodName == InternalMethods.Index.MethodName; " is 134.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsArrayExtension,The length of the statement  "            return item is CodeMethodInvokeExpression && ((CodeMethodInvokeExpression)item).Method.MethodName == InternalMethods.ExtendArray.MethodName; " is 140.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitTokens,The length of the statement  "                else if (IsIdentifier(sym) || sym == Resolve || (sym == Concatenate && i + 1 < code.Length && IsIdentifier(code[i + 1]))) " is 121.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitTokens,The length of the statement  "                        if ((sym == 'e' || sym == 'E') && IsPrimativeObject(id.ToString()) && id.ToString().IndexOf("0x") != 0 && i + 1 < code.Length) " is 126.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitTokens,The length of the statement  "                        else if (IsIdentifier(sym) || sym == Resolve || (sym == Concatenate && (i + 1 < code.Length ? code[i + 1] != Equal : true))) " is 124.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsVarAssignment,The length of the statement  "            return expr is CodeBinaryOperatorExpression && ((CodeBinaryOperatorExpression)expr).Operator == CodeBinaryOperatorType.Assign; " is 126.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,VarMixedExpr,The length of the statement  "            return IsVarReference(part) ? VarRefOrPrimitive(part) : IsVarAssignment(part) ? (CodeBinaryOperatorExpression)part : part is CodeExpression ? (CodeExpression)part : new CodePrimitiveExpression(part); " is 199.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,StdLib,The length of the statement  "                search.Append(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments)' Path.Combine("AutoHotkey"' LibDir))); " is 130.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,StdLib,The length of the statement  "                    var obj = new CodeArrayCreateExpression { Size = invoke.Parameters.Count' CreateType = new CodeTypeReference(typeof(object)) }; " is 127.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsContinuationLine,The length of the statement  "            if (code.Length >= AndTxt.Length && code.Substring(0' AndTxt.Length).Equals(AndTxt' StringComparison.OrdinalIgnoreCase)) " is 120.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsContinuationLine,The length of the statement  "            else if (code.Length >= OrTxt.Length && code.Substring(0' OrTxt.Length).Equals(OrTxt' StringComparison.OrdinalIgnoreCase)) " is 122.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Statements,The length of the statement  "                                block = new CodeBlock(lines[i]' Scope' new CodeStatementCollection()' CodeBlock.BlockKind.Dummy' blocks.Count == 0 ? null : blocks.Peek()); " is 139.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,MultilineString,The length of the statement  "                            if (option.Length > joinOpt.Length && option.Substring(0' joinOpt.Length).Equals(joinOpt' StringComparison.OrdinalIgnoreCase)) " is 126.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitCommandStatement,The length of the statement  "            var parts = new[] { code.Substring(0' i).TrimEnd(Spaces)' n >= code.Length ? string.Empty : code.Substring(n).TrimStart(Spaces) }; " is 130.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitCommandParameters,The length of the statement  "                if (sym == Multicast && (i == 0 || code[i - 1] != Escape) && !str && levels[0] == 0 && levels[1] == 0 && levels[2] == 0) " is 120.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The length of the statement  "                        if (call && parts[n] is CodeMethodInvokeExpression && ((CodeMethodInvokeExpression)parts[n]).Parameters[0] is CodeFieldReferenceExpression) " is 139.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The length of the statement  "                                    if ((x > 0 && (parts[x] is CodeBinaryOperatorExpression || parts[x] is CodeMethodInvokeExpression || parts[x] is CodePrimitiveExpression)) || " is 141.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The length of the statement  "                    (parts[i - 1] is Script.Operator || parts[i - 1] as CodeBinaryOperatorType? == CodeBinaryOperatorType.Assign || IsVarAssignment(parts[i - 1])) && " is 145.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The length of the statement  "                            while (parts[u] is Script.Operator && ((Script.Operator)parts[u] == Script.Operator.Add || (Script.Operator)parts[u] == Script.Operator.Subtract)) " is 146.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The length of the statement  "                        if (i + 3 < parts.Count && IsVarReference(parts[i + 1]) && parts[i + 2] as CodeBinaryOperatorType? == CodeBinaryOperatorType.Assign) " is 132.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The length of the statement  "                                boolean.Operator = op == Script.Operator.BooleanAnd ? CodeBinaryOperatorType.BooleanAnd : CodeBinaryOperatorType.BooleanOr; " is 123.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The length of the statement  "                                if (LaxExpressions && parts[i] is Script.Operator && (Script.Operator)parts[i] == Script.Operator.Concat && parts[x] as CodeBinaryOperatorType? == CodeBinaryOperatorType.Assign) " is 177.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The length of the statement  "                    if (!(typed || parts[i] is CodeMethodInvokeExpression || parts[i] is CodePrimitiveExpression || parts[i] is CodeTernaryOperatorExpression || parts[i] is CodeBinaryOperatorExpression || parts[i] is CodePropertyReferenceExpression)) " is 230.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseFlow,The length of the statement  "                        var block = new CodeBlock(line' Scope' ifelse.TrueStatements' CodeBlock.BlockKind.IfElse' blocks.Count == 0 ? null : blocks.Peek()); " is 132.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseFlow,The length of the statement  "                        var block = new CodeBlock(lines[index]' Scope' elses.Pop()' CodeBlock.BlockKind.IfElse' blocks.Count == 0 ? null : blocks.Peek()) { Type = type }; " is 146.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseFlow,The length of the statement  "                        return new CodeStatement[] { new CodeExpressionStatement(LocalLabelInvoke(parts[1]))' new CodeMethodReturnStatement() }; " is 120.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseFlow,The length of the statement  "                        var block = new CodeBlock(line' Scope' loop.Statements' CodeBlock.BlockKind.Loop' blocks.Count == 0 ? null : blocks.Peek()' InternalID' InternalID); " is 148.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseFlow,The length of the statement  "                        CodeExpression condition = parts.Length > 1 ? ParseFlowParameter(parts[1]' true' out blockOpen' true) : new CodePrimitiveExpression(true); " is 138.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseFlow,The length of the statement  "                        var block = new CodeBlock(line' Scope' loop.Statements' CodeBlock.BlockKind.Loop' blocks.Count == 0 ? null : blocks.Peek()' InternalID' InternalID); " is 148.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseFunction,The length of the statement  "            var block = new CodeBlock(line' method.Name' method.Statements' CodeBlock.BlockKind.Function' blocks.Count == 0 ? null : blocks.Peek()); " is 136.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseFunctionParameters,The length of the statement  "            List<CodePrimitiveExpression> names = new List<CodePrimitiveExpression>()' defaults = new List<CodePrimitiveExpression>(); " is 122.
Long Statement,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,PushLabel,The length of the statement  "            var block = new CodeBlock(line' method.Name' method.Statements' CodeBlock.BlockKind.Label' blocks.Count == 0 ? null : blocks.Peek()) " is 132.
Long Statement,IronAHK.Scripting,Script,C:\repos\polyethene_IronAHK\Scripting\Script\Call.cs,IsNumeric,The length of the statement  "            return type == typeof(int) || type == typeof(long) || type == typeof(float) || type == typeof(double) || type == typeof(decimal); " is 129.
Long Statement,IronAHK.Scripting,MethodWriter,C:\repos\polyethene_IronAHK\Scripting\Compiler\Emission\MethodWriter.cs,EmitBinaryOperator,The length of the statement  "            bool Shortcut = Binary.Operator == CodeBinaryOperatorType.BooleanAnd || Binary.Operator == CodeBinaryOperatorType.BooleanOr; " is 124.
Long Statement,IronAHK.Scripting,ILMirror,C:\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,GrabPInvokeImpl,The length of the statement  "            MethodBuilder PInvoke = On.DefinePInvokeMethod(Original.Name' Attr.Value' Original.Attributes' Original.CallingConvention'  " is 122.
Long Statement,IronAHK.Scripting,ILMirror,C:\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,CopyOpcode,The length of the statement  "                    // messy fix to convert short branch targets to normal ones' since there's no easy way to calculate offsets via reflection " is 122.
Complex Conditional,IronAHK.Scripting,Compiler,C:\repos\polyethene_IronAHK\Scripting\Compiler\CompilerSetup.cs,MineMethods,The conditional expression  "Method.IsPrivate || Method.IsAbstract || Method.IsConstructor || !Method.IsStatic || Method.IsGenericMethod ||                     Method.Name.StartsWith("get_") || Method.Name.StartsWith("set_")"  is complex.
Complex Conditional,IronAHK.Scripting,Emit,C:\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,EmitInvoke,The conditional expression  "name == Parser.InternalMethods.IfLegacy.MethodName && invoke.Parameters.Count == 3 &&                      invoke.Parameters[1] is CodePrimitiveExpression && (((CodePrimitiveExpression)invoke.Parameters[1]).Value as string) == Parser.IsTxt"  is complex.
Complex Conditional,IronAHK.Scripting,Emit,C:\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,EmitArrayIndexer,The conditional expression  "array.TargetObject is CodePropertyReferenceExpression &&                  ((CodePropertyReferenceExpression)array.TargetObject).PropertyName == Parser.VarProperty &&                  array.Indices.Count == 1 && array.Indices[0] is CodePrimitiveExpression"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Set,The conditional expression  "expect == BlockClose && levels[0] == 0 && levels[1] == 0 && levels[2] == 0"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Set,The conditional expression  "expect == ArrayClose && levels[0] == 0 && levels[1] == 0 && levels[2] == 0"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Set,The conditional expression  "expect == ParenClose && levels[0] == 0 && levels[1] == 0 && levels[2] == 0"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitTokens,The conditional expression  "IsIdentifier(sym) || sym == Resolve || (sym == Concatenate && i + 1 < code.Length && IsIdentifier(code[i + 1]))"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitTokens,The conditional expression  "(sym == 'e' || sym == 'E') && IsPrimativeObject(id.ToString()) && id.ToString().IndexOf("0x") != 0 && i + 1 < code.Length"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitTokens,The conditional expression  "IsIdentifier(sym) || sym == Resolve || (sym == Concatenate && (i + 1 < code.Length ? code[i + 1] != Equal : true))"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitTokens,The conditional expression  "(sym == Less && symNext == Greater) || (sym == TernaryA && symNext == TernaryA)"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,RemoveExcessParentheses,The conditional expression  "!(--last > 1 &&                      parts[0] is string && ((string)parts[0]).Length == 1 && ((string)parts[0])[0] == ParenOpen &&                      parts[last] is string && ((string)parts[last]).Length == 1 && ((string)parts[last])[0] == ParenClose)"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsIdentifier,The conditional expression  "token[0] == TernaryA && (token.Length == 1 || token.Length == 2 && token[1] == TernaryA)"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitCommandParameters,The conditional expression  "sym == Multicast && (i == 0 || code[i - 1] != Escape) && !str && levels[0] == 0 && levels[1] == 0 && levels[2] == 0"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseCommandParameter,The conditional expression  "expr && code.Length > 2 && code[0] == Resolve && code[code.Length - 1] == Resolve"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The conditional expression  "zx[1] < parts.Count &&                                              parts[zx[1]] is string && ((string)parts[zx[1]]).Length == 1 && ((string)parts[zx[1]])[0] == ParenClose &&                                              (parts[zx[0]] is string && IsDynamicReference((string)parts[zx[0]]) || IsVarReference(parts[zx[0]]))"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The conditional expression  "(x > 0 && (parts[x] is CodeBinaryOperatorExpression || parts[x] is CodeMethodInvokeExpression || parts[x] is CodePrimitiveExpression)) ||                                          (y < parts.Count && (parts[y] is string && !IsOperator(parts[y] as string) || parts[y] is Script.Operator))"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The conditional expression  "w < parts.Count && (parts[w] is string && IsAssignOp((string)parts[w]) || IsVarAssignment(parts[w]))"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The conditional expression  "y < parts.Count && (IsVarReference(parts[y]) ||                                          (parts[y] is string && IsIdentifier((string)parts[y]) && !IsKeyword((string)parts[y])))"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The conditional expression  "parts[i] is Script.Operator &&                      (parts[i - 1] is Script.Operator || parts[i - 1] as CodeBinaryOperatorType? == CodeBinaryOperatorType.Assign || IsVarAssignment(parts[i - 1])) &&                      IsUnaryOperator((Script.Operator)parts[i])"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The conditional expression  "LaxExpressions && parts[i] is Script.Operator && (Script.Operator)parts[i] == Script.Operator.Concat && parts[x] as CodeBinaryOperatorType? == CodeBinaryOperatorType.Assign"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The conditional expression  "!(typed || parts[i] is CodeMethodInvokeExpression || parts[i] is CodePrimitiveExpression || parts[i] is CodeTernaryOperatorExpression || parts[i] is CodeBinaryOperatorExpression || parts[i] is CodePropertyReferenceExpression)"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Read,The conditional expression  "line == 1 && code.Length > 2 && code[0] == '#' && code[1] == '!'"  is complex.
Complex Conditional,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Read,The conditional expression  "parts[1].Length > 3 && parts[1][0] == '*' && (parts[1][1] == 'i' || parts[1][1] == 'I') && IsSpace(parts[1][2])"  is complex.
Complex Conditional,IronAHK.Scripting,Script,C:\repos\polyethene_IronAHK\Scripting\Script\Call.cs,ForceBool,The conditional expression  "input is decimal || input is float || input is double || input is long || input is int"  is complex.
Complex Conditional,IronAHK.Scripting,Script,C:\repos\polyethene_IronAHK\Scripting\Script\Call.cs,IfLegacy,The conditional expression  "var.Length > 3 && var[0] == '0' && (var[1] == 'x' || var[1] == 'X')"  is complex.
Complex Conditional,IronAHK.Scripting,Script,C:\repos\polyethene_IronAHK\Scripting\Script\Call.cs,IfLegacy,The conditional expression  "!(char.IsDigit(sym) || (sym > 'a' - 1 && sym < 'f' + 1) || (sym > 'A' - 1 && sym < 'F' + 1))"  is complex.
Empty Catch Block,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OptimiseExpression,The method has an empty catch block.
Magic Number,IronAHK.Scripting,Emit,C:\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,ScriptOperator,The following statement contains a magic number: switch (op)              {                  case Script.Operator.Add: return Parser.Add.ToString();                  case Script.Operator.Address: return Parser.Address.ToString();                  case Script.Operator.Assign: return new string(new[] { Parser.AssignPre' Parser.Equal });                  case Script.Operator.BitShiftLeft: return new string(Parser.Less' 2);                  case Script.Operator.BitShiftRight: return new string(Parser.Greater' 2);                  case Script.Operator.BitwiseAnd: return Parser.BitAND.ToString();                  case Script.Operator.BitwiseNot: return Parser.BitNOT.ToString();                  case Script.Operator.BitwiseOr: return Parser.BitOR.ToString();                  case Script.Operator.BitwiseXor: return Parser.BitXOR.ToString();                  case Script.Operator.BooleanAnd: return Parser.AndTxt;                  case Script.Operator.BooleanOr: return Parser.OrTxt;                  case Script.Operator.Concat: return Parser.Concatenate.ToString();                  case Script.Operator.Decrement: return new string(Parser.Subtract' 2);;                  case Script.Operator.Dereference: return Parser.Dereference.ToString();                  case Script.Operator.Divide: return Parser.Divide.ToString();                  case Script.Operator.FloorDivide: return new string(Parser.Divide' 2);                  case Script.Operator.GreaterThan: return Parser.Greater.ToString();                  case Script.Operator.GreaterThanOrEqual: return new string(new[] { Parser.Greater' Parser.Equal });                  case Script.Operator.IdentityEquality: return new string(Parser.Equal' 2);                  case Script.Operator.IdentityInequality: return new string(new[] { Parser.Not' Parser.Equal' Parser.Equal });                  case Script.Operator.Increment: return new string(Parser.Add' 2);                  case Script.Operator.LessThan: return Parser.Less.ToString();                  case Script.Operator.LessThanOrEqual: return new string(new[] { Parser.Less' Parser.Equal });                  case Script.Operator.LogicalNot: return Parser.Not.ToString();                  case Script.Operator.LogicalNotEx: return Parser.NotTxt;                  case Script.Operator.Minus: return Parser.Minus.ToString();                  case Script.Operator.Multiply: return Parser.Multiply.ToString();                  case Script.Operator.Power: return new string(Parser.Multiply' 2);                  case Script.Operator.Subtract: return Parser.Subtract.ToString();                  case Script.Operator.TernaryA: return Parser.TernaryA.ToString();                  case Script.Operator.TernaryB: return Parser.TernaryB.ToString(); ;                  case Script.Operator.ValueEquality: return Parser.Equal.ToString();                  case Script.Operator.ValueInequality: return new string(new[] { Parser.Not' Parser.Equal });                    default: throw new ArgumentOutOfRangeException("op");              }
Magic Number,IronAHK.Scripting,Emit,C:\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,ScriptOperator,The following statement contains a magic number: switch (op)              {                  case Script.Operator.Add: return Parser.Add.ToString();                  case Script.Operator.Address: return Parser.Address.ToString();                  case Script.Operator.Assign: return new string(new[] { Parser.AssignPre' Parser.Equal });                  case Script.Operator.BitShiftLeft: return new string(Parser.Less' 2);                  case Script.Operator.BitShiftRight: return new string(Parser.Greater' 2);                  case Script.Operator.BitwiseAnd: return Parser.BitAND.ToString();                  case Script.Operator.BitwiseNot: return Parser.BitNOT.ToString();                  case Script.Operator.BitwiseOr: return Parser.BitOR.ToString();                  case Script.Operator.BitwiseXor: return Parser.BitXOR.ToString();                  case Script.Operator.BooleanAnd: return Parser.AndTxt;                  case Script.Operator.BooleanOr: return Parser.OrTxt;                  case Script.Operator.Concat: return Parser.Concatenate.ToString();                  case Script.Operator.Decrement: return new string(Parser.Subtract' 2);;                  case Script.Operator.Dereference: return Parser.Dereference.ToString();                  case Script.Operator.Divide: return Parser.Divide.ToString();                  case Script.Operator.FloorDivide: return new string(Parser.Divide' 2);                  case Script.Operator.GreaterThan: return Parser.Greater.ToString();                  case Script.Operator.GreaterThanOrEqual: return new string(new[] { Parser.Greater' Parser.Equal });                  case Script.Operator.IdentityEquality: return new string(Parser.Equal' 2);                  case Script.Operator.IdentityInequality: return new string(new[] { Parser.Not' Parser.Equal' Parser.Equal });                  case Script.Operator.Increment: return new string(Parser.Add' 2);                  case Script.Operator.LessThan: return Parser.Less.ToString();                  case Script.Operator.LessThanOrEqual: return new string(new[] { Parser.Less' Parser.Equal });                  case Script.Operator.LogicalNot: return Parser.Not.ToString();                  case Script.Operator.LogicalNotEx: return Parser.NotTxt;                  case Script.Operator.Minus: return Parser.Minus.ToString();                  case Script.Operator.Multiply: return Parser.Multiply.ToString();                  case Script.Operator.Power: return new string(Parser.Multiply' 2);                  case Script.Operator.Subtract: return Parser.Subtract.ToString();                  case Script.Operator.TernaryA: return Parser.TernaryA.ToString();                  case Script.Operator.TernaryB: return Parser.TernaryB.ToString(); ;                  case Script.Operator.ValueEquality: return Parser.Equal.ToString();                  case Script.Operator.ValueInequality: return new string(new[] { Parser.Not' Parser.Equal });                    default: throw new ArgumentOutOfRangeException("op");              }
Magic Number,IronAHK.Scripting,Emit,C:\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,ScriptOperator,The following statement contains a magic number: switch (op)              {                  case Script.Operator.Add: return Parser.Add.ToString();                  case Script.Operator.Address: return Parser.Address.ToString();                  case Script.Operator.Assign: return new string(new[] { Parser.AssignPre' Parser.Equal });                  case Script.Operator.BitShiftLeft: return new string(Parser.Less' 2);                  case Script.Operator.BitShiftRight: return new string(Parser.Greater' 2);                  case Script.Operator.BitwiseAnd: return Parser.BitAND.ToString();                  case Script.Operator.BitwiseNot: return Parser.BitNOT.ToString();                  case Script.Operator.BitwiseOr: return Parser.BitOR.ToString();                  case Script.Operator.BitwiseXor: return Parser.BitXOR.ToString();                  case Script.Operator.BooleanAnd: return Parser.AndTxt;                  case Script.Operator.BooleanOr: return Parser.OrTxt;                  case Script.Operator.Concat: return Parser.Concatenate.ToString();                  case Script.Operator.Decrement: return new string(Parser.Subtract' 2);;                  case Script.Operator.Dereference: return Parser.Dereference.ToString();                  case Script.Operator.Divide: return Parser.Divide.ToString();                  case Script.Operator.FloorDivide: return new string(Parser.Divide' 2);                  case Script.Operator.GreaterThan: return Parser.Greater.ToString();                  case Script.Operator.GreaterThanOrEqual: return new string(new[] { Parser.Greater' Parser.Equal });                  case Script.Operator.IdentityEquality: return new string(Parser.Equal' 2);                  case Script.Operator.IdentityInequality: return new string(new[] { Parser.Not' Parser.Equal' Parser.Equal });                  case Script.Operator.Increment: return new string(Parser.Add' 2);                  case Script.Operator.LessThan: return Parser.Less.ToString();                  case Script.Operator.LessThanOrEqual: return new string(new[] { Parser.Less' Parser.Equal });                  case Script.Operator.LogicalNot: return Parser.Not.ToString();                  case Script.Operator.LogicalNotEx: return Parser.NotTxt;                  case Script.Operator.Minus: return Parser.Minus.ToString();                  case Script.Operator.Multiply: return Parser.Multiply.ToString();                  case Script.Operator.Power: return new string(Parser.Multiply' 2);                  case Script.Operator.Subtract: return Parser.Subtract.ToString();                  case Script.Operator.TernaryA: return Parser.TernaryA.ToString();                  case Script.Operator.TernaryB: return Parser.TernaryB.ToString(); ;                  case Script.Operator.ValueEquality: return Parser.Equal.ToString();                  case Script.Operator.ValueInequality: return new string(new[] { Parser.Not' Parser.Equal });                    default: throw new ArgumentOutOfRangeException("op");              }
Magic Number,IronAHK.Scripting,Emit,C:\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,ScriptOperator,The following statement contains a magic number: switch (op)              {                  case Script.Operator.Add: return Parser.Add.ToString();                  case Script.Operator.Address: return Parser.Address.ToString();                  case Script.Operator.Assign: return new string(new[] { Parser.AssignPre' Parser.Equal });                  case Script.Operator.BitShiftLeft: return new string(Parser.Less' 2);                  case Script.Operator.BitShiftRight: return new string(Parser.Greater' 2);                  case Script.Operator.BitwiseAnd: return Parser.BitAND.ToString();                  case Script.Operator.BitwiseNot: return Parser.BitNOT.ToString();                  case Script.Operator.BitwiseOr: return Parser.BitOR.ToString();                  case Script.Operator.BitwiseXor: return Parser.BitXOR.ToString();                  case Script.Operator.BooleanAnd: return Parser.AndTxt;                  case Script.Operator.BooleanOr: return Parser.OrTxt;                  case Script.Operator.Concat: return Parser.Concatenate.ToString();                  case Script.Operator.Decrement: return new string(Parser.Subtract' 2);;                  case Script.Operator.Dereference: return Parser.Dereference.ToString();                  case Script.Operator.Divide: return Parser.Divide.ToString();                  case Script.Operator.FloorDivide: return new string(Parser.Divide' 2);                  case Script.Operator.GreaterThan: return Parser.Greater.ToString();                  case Script.Operator.GreaterThanOrEqual: return new string(new[] { Parser.Greater' Parser.Equal });                  case Script.Operator.IdentityEquality: return new string(Parser.Equal' 2);                  case Script.Operator.IdentityInequality: return new string(new[] { Parser.Not' Parser.Equal' Parser.Equal });                  case Script.Operator.Increment: return new string(Parser.Add' 2);                  case Script.Operator.LessThan: return Parser.Less.ToString();                  case Script.Operator.LessThanOrEqual: return new string(new[] { Parser.Less' Parser.Equal });                  case Script.Operator.LogicalNot: return Parser.Not.ToString();                  case Script.Operator.LogicalNotEx: return Parser.NotTxt;                  case Script.Operator.Minus: return Parser.Minus.ToString();                  case Script.Operator.Multiply: return Parser.Multiply.ToString();                  case Script.Operator.Power: return new string(Parser.Multiply' 2);                  case Script.Operator.Subtract: return Parser.Subtract.ToString();                  case Script.Operator.TernaryA: return Parser.TernaryA.ToString();                  case Script.Operator.TernaryB: return Parser.TernaryB.ToString(); ;                  case Script.Operator.ValueEquality: return Parser.Equal.ToString();                  case Script.Operator.ValueInequality: return new string(new[] { Parser.Not' Parser.Equal });                    default: throw new ArgumentOutOfRangeException("op");              }
Magic Number,IronAHK.Scripting,Emit,C:\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,ScriptOperator,The following statement contains a magic number: switch (op)              {                  case Script.Operator.Add: return Parser.Add.ToString();                  case Script.Operator.Address: return Parser.Address.ToString();                  case Script.Operator.Assign: return new string(new[] { Parser.AssignPre' Parser.Equal });                  case Script.Operator.BitShiftLeft: return new string(Parser.Less' 2);                  case Script.Operator.BitShiftRight: return new string(Parser.Greater' 2);                  case Script.Operator.BitwiseAnd: return Parser.BitAND.ToString();                  case Script.Operator.BitwiseNot: return Parser.BitNOT.ToString();                  case Script.Operator.BitwiseOr: return Parser.BitOR.ToString();                  case Script.Operator.BitwiseXor: return Parser.BitXOR.ToString();                  case Script.Operator.BooleanAnd: return Parser.AndTxt;                  case Script.Operator.BooleanOr: return Parser.OrTxt;                  case Script.Operator.Concat: return Parser.Concatenate.ToString();                  case Script.Operator.Decrement: return new string(Parser.Subtract' 2);;                  case Script.Operator.Dereference: return Parser.Dereference.ToString();                  case Script.Operator.Divide: return Parser.Divide.ToString();                  case Script.Operator.FloorDivide: return new string(Parser.Divide' 2);                  case Script.Operator.GreaterThan: return Parser.Greater.ToString();                  case Script.Operator.GreaterThanOrEqual: return new string(new[] { Parser.Greater' Parser.Equal });                  case Script.Operator.IdentityEquality: return new string(Parser.Equal' 2);                  case Script.Operator.IdentityInequality: return new string(new[] { Parser.Not' Parser.Equal' Parser.Equal });                  case Script.Operator.Increment: return new string(Parser.Add' 2);                  case Script.Operator.LessThan: return Parser.Less.ToString();                  case Script.Operator.LessThanOrEqual: return new string(new[] { Parser.Less' Parser.Equal });                  case Script.Operator.LogicalNot: return Parser.Not.ToString();                  case Script.Operator.LogicalNotEx: return Parser.NotTxt;                  case Script.Operator.Minus: return Parser.Minus.ToString();                  case Script.Operator.Multiply: return Parser.Multiply.ToString();                  case Script.Operator.Power: return new string(Parser.Multiply' 2);                  case Script.Operator.Subtract: return Parser.Subtract.ToString();                  case Script.Operator.TernaryA: return Parser.TernaryA.ToString();                  case Script.Operator.TernaryB: return Parser.TernaryB.ToString(); ;                  case Script.Operator.ValueEquality: return Parser.Equal.ToString();                  case Script.Operator.ValueInequality: return new string(new[] { Parser.Not' Parser.Equal });                    default: throw new ArgumentOutOfRangeException("op");              }
Magic Number,IronAHK.Scripting,Emit,C:\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,ScriptOperator,The following statement contains a magic number: switch (op)              {                  case Script.Operator.Add: return Parser.Add.ToString();                  case Script.Operator.Address: return Parser.Address.ToString();                  case Script.Operator.Assign: return new string(new[] { Parser.AssignPre' Parser.Equal });                  case Script.Operator.BitShiftLeft: return new string(Parser.Less' 2);                  case Script.Operator.BitShiftRight: return new string(Parser.Greater' 2);                  case Script.Operator.BitwiseAnd: return Parser.BitAND.ToString();                  case Script.Operator.BitwiseNot: return Parser.BitNOT.ToString();                  case Script.Operator.BitwiseOr: return Parser.BitOR.ToString();                  case Script.Operator.BitwiseXor: return Parser.BitXOR.ToString();                  case Script.Operator.BooleanAnd: return Parser.AndTxt;                  case Script.Operator.BooleanOr: return Parser.OrTxt;                  case Script.Operator.Concat: return Parser.Concatenate.ToString();                  case Script.Operator.Decrement: return new string(Parser.Subtract' 2);;                  case Script.Operator.Dereference: return Parser.Dereference.ToString();                  case Script.Operator.Divide: return Parser.Divide.ToString();                  case Script.Operator.FloorDivide: return new string(Parser.Divide' 2);                  case Script.Operator.GreaterThan: return Parser.Greater.ToString();                  case Script.Operator.GreaterThanOrEqual: return new string(new[] { Parser.Greater' Parser.Equal });                  case Script.Operator.IdentityEquality: return new string(Parser.Equal' 2);                  case Script.Operator.IdentityInequality: return new string(new[] { Parser.Not' Parser.Equal' Parser.Equal });                  case Script.Operator.Increment: return new string(Parser.Add' 2);                  case Script.Operator.LessThan: return Parser.Less.ToString();                  case Script.Operator.LessThanOrEqual: return new string(new[] { Parser.Less' Parser.Equal });                  case Script.Operator.LogicalNot: return Parser.Not.ToString();                  case Script.Operator.LogicalNotEx: return Parser.NotTxt;                  case Script.Operator.Minus: return Parser.Minus.ToString();                  case Script.Operator.Multiply: return Parser.Multiply.ToString();                  case Script.Operator.Power: return new string(Parser.Multiply' 2);                  case Script.Operator.Subtract: return Parser.Subtract.ToString();                  case Script.Operator.TernaryA: return Parser.TernaryA.ToString();                  case Script.Operator.TernaryB: return Parser.TernaryB.ToString(); ;                  case Script.Operator.ValueEquality: return Parser.Equal.ToString();                  case Script.Operator.ValueInequality: return new string(new[] { Parser.Not' Parser.Equal });                    default: throw new ArgumentOutOfRangeException("op");              }
Magic Number,IronAHK.Scripting,Emit,C:\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,ScriptOperator,The following statement contains a magic number: switch (op)              {                  case Script.Operator.Add: return Parser.Add.ToString();                  case Script.Operator.Address: return Parser.Address.ToString();                  case Script.Operator.Assign: return new string(new[] { Parser.AssignPre' Parser.Equal });                  case Script.Operator.BitShiftLeft: return new string(Parser.Less' 2);                  case Script.Operator.BitShiftRight: return new string(Parser.Greater' 2);                  case Script.Operator.BitwiseAnd: return Parser.BitAND.ToString();                  case Script.Operator.BitwiseNot: return Parser.BitNOT.ToString();                  case Script.Operator.BitwiseOr: return Parser.BitOR.ToString();                  case Script.Operator.BitwiseXor: return Parser.BitXOR.ToString();                  case Script.Operator.BooleanAnd: return Parser.AndTxt;                  case Script.Operator.BooleanOr: return Parser.OrTxt;                  case Script.Operator.Concat: return Parser.Concatenate.ToString();                  case Script.Operator.Decrement: return new string(Parser.Subtract' 2);;                  case Script.Operator.Dereference: return Parser.Dereference.ToString();                  case Script.Operator.Divide: return Parser.Divide.ToString();                  case Script.Operator.FloorDivide: return new string(Parser.Divide' 2);                  case Script.Operator.GreaterThan: return Parser.Greater.ToString();                  case Script.Operator.GreaterThanOrEqual: return new string(new[] { Parser.Greater' Parser.Equal });                  case Script.Operator.IdentityEquality: return new string(Parser.Equal' 2);                  case Script.Operator.IdentityInequality: return new string(new[] { Parser.Not' Parser.Equal' Parser.Equal });                  case Script.Operator.Increment: return new string(Parser.Add' 2);                  case Script.Operator.LessThan: return Parser.Less.ToString();                  case Script.Operator.LessThanOrEqual: return new string(new[] { Parser.Less' Parser.Equal });                  case Script.Operator.LogicalNot: return Parser.Not.ToString();                  case Script.Operator.LogicalNotEx: return Parser.NotTxt;                  case Script.Operator.Minus: return Parser.Minus.ToString();                  case Script.Operator.Multiply: return Parser.Multiply.ToString();                  case Script.Operator.Power: return new string(Parser.Multiply' 2);                  case Script.Operator.Subtract: return Parser.Subtract.ToString();                  case Script.Operator.TernaryA: return Parser.TernaryA.ToString();                  case Script.Operator.TernaryB: return Parser.TernaryB.ToString(); ;                  case Script.Operator.ValueEquality: return Parser.Equal.ToString();                  case Script.Operator.ValueInequality: return new string(new[] { Parser.Not' Parser.Equal });                    default: throw new ArgumentOutOfRangeException("op");              }
Magic Number,IronAHK.Scripting,Emit,C:\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,EmitInvoke,The following statement contains a magic number: if (invoke.Method.TargetObject is CodeTypeReferenceExpression &&                  Type.GetType(((CodeTypeReferenceExpression)invoke.Method.TargetObject).Type.BaseType) == typeof(Script))              {                  string name = invoke.Method.MethodName;                    if (name == Parser.InternalMethods.LabelCall.MethodName && invoke.Parameters.Count == 1)                  {                      EmitGoto(new CodeGotoStatement((string)((CodePrimitiveExpression)invoke.Parameters[0]).Value));                      return;                  }                  else if (name == Parser.InternalMethods.IfElse.MethodName && invoke.Parameters.Count == 1)                  {                      EmitExpression(invoke.Parameters[0]);                      return;                  }                  else if (name == Parser.InternalMethods.IfLegacy.MethodName && invoke.Parameters.Count == 3 &&                      invoke.Parameters[1] is CodePrimitiveExpression && (((CodePrimitiveExpression)invoke.Parameters[1]).Value as string) == Parser.IsTxt)                  {                      EmitExpression(invoke.Parameters[0]);                      writer.Write(Parser.SingleSpace);                      writer.Write(Parser.IsTxt);                      writer.Write(Parser.SingleSpace);                      EmitExpression(invoke.Parameters[2]);                      return;                  }                  else if (name == Parser.InternalMethods.Operate.MethodName && invoke.Parameters.Count == 3)                  {                      EmitExpression(invoke.Parameters[1]);                      writer.Write(Parser.SingleSpace);                        var op = (Script.Operator)Enum.Parse(typeof(Script.Operator)' ((CodeFieldReferenceExpression)invoke.Parameters[0]).FieldName);                      writer.Write(ScriptOperator(op));                        writer.Write(Parser.SingleSpace);                      EmitExpression(invoke.Parameters[2]);                      return;                  }                  else if (name == Parser.InternalMethods.ExtendArray.MethodName && invoke.Parameters.Count == 1)                      return;                  else if (name == Parser.InternalMethods.SetObject.MethodName && invoke.Parameters.Count == 4)                  {                      EmitExpression(invoke.Parameters[1]);                      EmitExpression(invoke.Parameters[2]);                      EmitExpression(invoke.Parameters[0]);                        writer.Write(Parser.SingleSpace);                      writer.Write(Parser.AssignPre);                      writer.Write(Parser.Equal);                      writer.Write(Parser.SingleSpace);                        EmitExpression(invoke.Parameters[3]);                        return;                  }                  else if (name == Parser.InternalMethods.Index.MethodName && invoke.Parameters.Count == 2)                  {                      EmitExpression(invoke.Parameters[0]);                      writer.Write(Parser.ArrayOpen);                      EmitExpression(invoke.Parameters[1]);                      writer.Write(Parser.ArrayClose);                        return;                  }                  else if (name == Parser.InternalMethods.Dictionary.MethodName && invoke.Parameters.Count == 2)                  {                      writer.Write(Parser.BlockOpen);                      writer.Write(Parser.SingleSpace);                        var parts = new CodeExpressionCollection[2];                        for (int i = 0; i < parts.Length; i++)                          parts[i] = ((CodeArrayCreateExpression)invoke.Parameters[i]).Initializers;                        bool first = true;                        for (int i = 0; i < parts[0].Count; i++)                      {                          if (first)                              first = false;                          else                          {                              writer.Write(Parser.DefaultMulticast);                              writer.Write(Parser.SingleSpace);                          }                            depth++;                          EmitExpression(parts[0][i]);                          writer.Write(Parser.SingleSpace);                          writer.Write(Parser.AssignPre);                          writer.Write(Parser.SingleSpace);                          EmitExpression(parts[1][i]);                          depth--;                      }                        writer.Write(Parser.SingleSpace);                      writer.Write(Parser.BlockClose);                        return;                  }              }
Magic Number,IronAHK.Scripting,Emit,C:\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,EmitInvoke,The following statement contains a magic number: if (invoke.Method.TargetObject is CodeTypeReferenceExpression &&                  Type.GetType(((CodeTypeReferenceExpression)invoke.Method.TargetObject).Type.BaseType) == typeof(Script))              {                  string name = invoke.Method.MethodName;                    if (name == Parser.InternalMethods.LabelCall.MethodName && invoke.Parameters.Count == 1)                  {                      EmitGoto(new CodeGotoStatement((string)((CodePrimitiveExpression)invoke.Parameters[0]).Value));                      return;                  }                  else if (name == Parser.InternalMethods.IfElse.MethodName && invoke.Parameters.Count == 1)                  {                      EmitExpression(invoke.Parameters[0]);                      return;                  }                  else if (name == Parser.InternalMethods.IfLegacy.MethodName && invoke.Parameters.Count == 3 &&                      invoke.Parameters[1] is CodePrimitiveExpression && (((CodePrimitiveExpression)invoke.Parameters[1]).Value as string) == Parser.IsTxt)                  {                      EmitExpression(invoke.Parameters[0]);                      writer.Write(Parser.SingleSpace);                      writer.Write(Parser.IsTxt);                      writer.Write(Parser.SingleSpace);                      EmitExpression(invoke.Parameters[2]);                      return;                  }                  else if (name == Parser.InternalMethods.Operate.MethodName && invoke.Parameters.Count == 3)                  {                      EmitExpression(invoke.Parameters[1]);                      writer.Write(Parser.SingleSpace);                        var op = (Script.Operator)Enum.Parse(typeof(Script.Operator)' ((CodeFieldReferenceExpression)invoke.Parameters[0]).FieldName);                      writer.Write(ScriptOperator(op));                        writer.Write(Parser.SingleSpace);                      EmitExpression(invoke.Parameters[2]);                      return;                  }                  else if (name == Parser.InternalMethods.ExtendArray.MethodName && invoke.Parameters.Count == 1)                      return;                  else if (name == Parser.InternalMethods.SetObject.MethodName && invoke.Parameters.Count == 4)                  {                      EmitExpression(invoke.Parameters[1]);                      EmitExpression(invoke.Parameters[2]);                      EmitExpression(invoke.Parameters[0]);                        writer.Write(Parser.SingleSpace);                      writer.Write(Parser.AssignPre);                      writer.Write(Parser.Equal);                      writer.Write(Parser.SingleSpace);                        EmitExpression(invoke.Parameters[3]);                        return;                  }                  else if (name == Parser.InternalMethods.Index.MethodName && invoke.Parameters.Count == 2)                  {                      EmitExpression(invoke.Parameters[0]);                      writer.Write(Parser.ArrayOpen);                      EmitExpression(invoke.Parameters[1]);                      writer.Write(Parser.ArrayClose);                        return;                  }                  else if (name == Parser.InternalMethods.Dictionary.MethodName && invoke.Parameters.Count == 2)                  {                      writer.Write(Parser.BlockOpen);                      writer.Write(Parser.SingleSpace);                        var parts = new CodeExpressionCollection[2];                        for (int i = 0; i < parts.Length; i++)                          parts[i] = ((CodeArrayCreateExpression)invoke.Parameters[i]).Initializers;                        bool first = true;                        for (int i = 0; i < parts[0].Count; i++)                      {                          if (first)                              first = false;                          else                          {                              writer.Write(Parser.DefaultMulticast);                              writer.Write(Parser.SingleSpace);                          }                            depth++;                          EmitExpression(parts[0][i]);                          writer.Write(Parser.SingleSpace);                          writer.Write(Parser.AssignPre);                          writer.Write(Parser.SingleSpace);                          EmitExpression(parts[1][i]);                          depth--;                      }                        writer.Write(Parser.SingleSpace);                      writer.Write(Parser.BlockClose);                        return;                  }              }
Magic Number,IronAHK.Scripting,Emit,C:\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,EmitInvoke,The following statement contains a magic number: if (invoke.Method.TargetObject is CodeTypeReferenceExpression &&                  Type.GetType(((CodeTypeReferenceExpression)invoke.Method.TargetObject).Type.BaseType) == typeof(Script))              {                  string name = invoke.Method.MethodName;                    if (name == Parser.InternalMethods.LabelCall.MethodName && invoke.Parameters.Count == 1)                  {                      EmitGoto(new CodeGotoStatement((string)((CodePrimitiveExpression)invoke.Parameters[0]).Value));                      return;                  }                  else if (name == Parser.InternalMethods.IfElse.MethodName && invoke.Parameters.Count == 1)                  {                      EmitExpression(invoke.Parameters[0]);                      return;                  }                  else if (name == Parser.InternalMethods.IfLegacy.MethodName && invoke.Parameters.Count == 3 &&                      invoke.Parameters[1] is CodePrimitiveExpression && (((CodePrimitiveExpression)invoke.Parameters[1]).Value as string) == Parser.IsTxt)                  {                      EmitExpression(invoke.Parameters[0]);                      writer.Write(Parser.SingleSpace);                      writer.Write(Parser.IsTxt);                      writer.Write(Parser.SingleSpace);                      EmitExpression(invoke.Parameters[2]);                      return;                  }                  else if (name == Parser.InternalMethods.Operate.MethodName && invoke.Parameters.Count == 3)                  {                      EmitExpression(invoke.Parameters[1]);                      writer.Write(Parser.SingleSpace);                        var op = (Script.Operator)Enum.Parse(typeof(Script.Operator)' ((CodeFieldReferenceExpression)invoke.Parameters[0]).FieldName);                      writer.Write(ScriptOperator(op));                        writer.Write(Parser.SingleSpace);                      EmitExpression(invoke.Parameters[2]);                      return;                  }                  else if (name == Parser.InternalMethods.ExtendArray.MethodName && invoke.Parameters.Count == 1)                      return;                  else if (name == Parser.InternalMethods.SetObject.MethodName && invoke.Parameters.Count == 4)                  {                      EmitExpression(invoke.Parameters[1]);                      EmitExpression(invoke.Parameters[2]);                      EmitExpression(invoke.Parameters[0]);                        writer.Write(Parser.SingleSpace);                      writer.Write(Parser.AssignPre);                      writer.Write(Parser.Equal);                      writer.Write(Parser.SingleSpace);                        EmitExpression(invoke.Parameters[3]);                        return;                  }                  else if (name == Parser.InternalMethods.Index.MethodName && invoke.Parameters.Count == 2)                  {                      EmitExpression(invoke.Parameters[0]);                      writer.Write(Parser.ArrayOpen);                      EmitExpression(invoke.Parameters[1]);                      writer.Write(Parser.ArrayClose);                        return;                  }                  else if (name == Parser.InternalMethods.Dictionary.MethodName && invoke.Parameters.Count == 2)                  {                      writer.Write(Parser.BlockOpen);                      writer.Write(Parser.SingleSpace);                        var parts = new CodeExpressionCollection[2];                        for (int i = 0; i < parts.Length; i++)                          parts[i] = ((CodeArrayCreateExpression)invoke.Parameters[i]).Initializers;                        bool first = true;                        for (int i = 0; i < parts[0].Count; i++)                      {                          if (first)                              first = false;                          else                          {                              writer.Write(Parser.DefaultMulticast);                              writer.Write(Parser.SingleSpace);                          }                            depth++;                          EmitExpression(parts[0][i]);                          writer.Write(Parser.SingleSpace);                          writer.Write(Parser.AssignPre);                          writer.Write(Parser.SingleSpace);                          EmitExpression(parts[1][i]);                          depth--;                      }                        writer.Write(Parser.SingleSpace);                      writer.Write(Parser.BlockClose);                        return;                  }              }
Magic Number,IronAHK.Scripting,Emit,C:\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,EmitInvoke,The following statement contains a magic number: if (invoke.Method.TargetObject is CodeTypeReferenceExpression &&                  Type.GetType(((CodeTypeReferenceExpression)invoke.Method.TargetObject).Type.BaseType) == typeof(Script))              {                  string name = invoke.Method.MethodName;                    if (name == Parser.InternalMethods.LabelCall.MethodName && invoke.Parameters.Count == 1)                  {                      EmitGoto(new CodeGotoStatement((string)((CodePrimitiveExpression)invoke.Parameters[0]).Value));                      return;                  }                  else if (name == Parser.InternalMethods.IfElse.MethodName && invoke.Parameters.Count == 1)                  {                      EmitExpression(invoke.Parameters[0]);                      return;                  }                  else if (name == Parser.InternalMethods.IfLegacy.MethodName && invoke.Parameters.Count == 3 &&                      invoke.Parameters[1] is CodePrimitiveExpression && (((CodePrimitiveExpression)invoke.Parameters[1]).Value as string) == Parser.IsTxt)                  {                      EmitExpression(invoke.Parameters[0]);                      writer.Write(Parser.SingleSpace);                      writer.Write(Parser.IsTxt);                      writer.Write(Parser.SingleSpace);                      EmitExpression(invoke.Parameters[2]);                      return;                  }                  else if (name == Parser.InternalMethods.Operate.MethodName && invoke.Parameters.Count == 3)                  {                      EmitExpression(invoke.Parameters[1]);                      writer.Write(Parser.SingleSpace);                        var op = (Script.Operator)Enum.Parse(typeof(Script.Operator)' ((CodeFieldReferenceExpression)invoke.Parameters[0]).FieldName);                      writer.Write(ScriptOperator(op));                        writer.Write(Parser.SingleSpace);                      EmitExpression(invoke.Parameters[2]);                      return;                  }                  else if (name == Parser.InternalMethods.ExtendArray.MethodName && invoke.Parameters.Count == 1)                      return;                  else if (name == Parser.InternalMethods.SetObject.MethodName && invoke.Parameters.Count == 4)                  {                      EmitExpression(invoke.Parameters[1]);                      EmitExpression(invoke.Parameters[2]);                      EmitExpression(invoke.Parameters[0]);                        writer.Write(Parser.SingleSpace);                      writer.Write(Parser.AssignPre);                      writer.Write(Parser.Equal);                      writer.Write(Parser.SingleSpace);                        EmitExpression(invoke.Parameters[3]);                        return;                  }                  else if (name == Parser.InternalMethods.Index.MethodName && invoke.Parameters.Count == 2)                  {                      EmitExpression(invoke.Parameters[0]);                      writer.Write(Parser.ArrayOpen);                      EmitExpression(invoke.Parameters[1]);                      writer.Write(Parser.ArrayClose);                        return;                  }                  else if (name == Parser.InternalMethods.Dictionary.MethodName && invoke.Parameters.Count == 2)                  {                      writer.Write(Parser.BlockOpen);                      writer.Write(Parser.SingleSpace);                        var parts = new CodeExpressionCollection[2];                        for (int i = 0; i < parts.Length; i++)                          parts[i] = ((CodeArrayCreateExpression)invoke.Parameters[i]).Initializers;                        bool first = true;                        for (int i = 0; i < parts[0].Count; i++)                      {                          if (first)                              first = false;                          else                          {                              writer.Write(Parser.DefaultMulticast);                              writer.Write(Parser.SingleSpace);                          }                            depth++;                          EmitExpression(parts[0][i]);                          writer.Write(Parser.SingleSpace);                          writer.Write(Parser.AssignPre);                          writer.Write(Parser.SingleSpace);                          EmitExpression(parts[1][i]);                          depth--;                      }                        writer.Write(Parser.SingleSpace);                      writer.Write(Parser.BlockClose);                        return;                  }              }
Magic Number,IronAHK.Scripting,Emit,C:\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,EmitInvoke,The following statement contains a magic number: if (invoke.Method.TargetObject is CodeTypeReferenceExpression &&                  Type.GetType(((CodeTypeReferenceExpression)invoke.Method.TargetObject).Type.BaseType) == typeof(Script))              {                  string name = invoke.Method.MethodName;                    if (name == Parser.InternalMethods.LabelCall.MethodName && invoke.Parameters.Count == 1)                  {                      EmitGoto(new CodeGotoStatement((string)((CodePrimitiveExpression)invoke.Parameters[0]).Value));                      return;                  }                  else if (name == Parser.InternalMethods.IfElse.MethodName && invoke.Parameters.Count == 1)                  {                      EmitExpression(invoke.Parameters[0]);                      return;                  }                  else if (name == Parser.InternalMethods.IfLegacy.MethodName && invoke.Parameters.Count == 3 &&                      invoke.Parameters[1] is CodePrimitiveExpression && (((CodePrimitiveExpression)invoke.Parameters[1]).Value as string) == Parser.IsTxt)                  {                      EmitExpression(invoke.Parameters[0]);                      writer.Write(Parser.SingleSpace);                      writer.Write(Parser.IsTxt);                      writer.Write(Parser.SingleSpace);                      EmitExpression(invoke.Parameters[2]);                      return;                  }                  else if (name == Parser.InternalMethods.Operate.MethodName && invoke.Parameters.Count == 3)                  {                      EmitExpression(invoke.Parameters[1]);                      writer.Write(Parser.SingleSpace);                        var op = (Script.Operator)Enum.Parse(typeof(Script.Operator)' ((CodeFieldReferenceExpression)invoke.Parameters[0]).FieldName);                      writer.Write(ScriptOperator(op));                        writer.Write(Parser.SingleSpace);                      EmitExpression(invoke.Parameters[2]);                      return;                  }                  else if (name == Parser.InternalMethods.ExtendArray.MethodName && invoke.Parameters.Count == 1)                      return;                  else if (name == Parser.InternalMethods.SetObject.MethodName && invoke.Parameters.Count == 4)                  {                      EmitExpression(invoke.Parameters[1]);                      EmitExpression(invoke.Parameters[2]);                      EmitExpression(invoke.Parameters[0]);                        writer.Write(Parser.SingleSpace);                      writer.Write(Parser.AssignPre);                      writer.Write(Parser.Equal);                      writer.Write(Parser.SingleSpace);                        EmitExpression(invoke.Parameters[3]);                        return;                  }                  else if (name == Parser.InternalMethods.Index.MethodName && invoke.Parameters.Count == 2)                  {                      EmitExpression(invoke.Parameters[0]);                      writer.Write(Parser.ArrayOpen);                      EmitExpression(invoke.Parameters[1]);                      writer.Write(Parser.ArrayClose);                        return;                  }                  else if (name == Parser.InternalMethods.Dictionary.MethodName && invoke.Parameters.Count == 2)                  {                      writer.Write(Parser.BlockOpen);                      writer.Write(Parser.SingleSpace);                        var parts = new CodeExpressionCollection[2];                        for (int i = 0; i < parts.Length; i++)                          parts[i] = ((CodeArrayCreateExpression)invoke.Parameters[i]).Initializers;                        bool first = true;                        for (int i = 0; i < parts[0].Count; i++)                      {                          if (first)                              first = false;                          else                          {                              writer.Write(Parser.DefaultMulticast);                              writer.Write(Parser.SingleSpace);                          }                            depth++;                          EmitExpression(parts[0][i]);                          writer.Write(Parser.SingleSpace);                          writer.Write(Parser.AssignPre);                          writer.Write(Parser.SingleSpace);                          EmitExpression(parts[1][i]);                          depth--;                      }                        writer.Write(Parser.SingleSpace);                      writer.Write(Parser.BlockClose);                        return;                  }              }
Magic Number,IronAHK.Scripting,Emit,C:\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,EmitInvoke,The following statement contains a magic number: if (invoke.Method.TargetObject is CodeTypeReferenceExpression &&                  Type.GetType(((CodeTypeReferenceExpression)invoke.Method.TargetObject).Type.BaseType) == typeof(Script))              {                  string name = invoke.Method.MethodName;                    if (name == Parser.InternalMethods.LabelCall.MethodName && invoke.Parameters.Count == 1)                  {                      EmitGoto(new CodeGotoStatement((string)((CodePrimitiveExpression)invoke.Parameters[0]).Value));                      return;                  }                  else if (name == Parser.InternalMethods.IfElse.MethodName && invoke.Parameters.Count == 1)                  {                      EmitExpression(invoke.Parameters[0]);                      return;                  }                  else if (name == Parser.InternalMethods.IfLegacy.MethodName && invoke.Parameters.Count == 3 &&                      invoke.Parameters[1] is CodePrimitiveExpression && (((CodePrimitiveExpression)invoke.Parameters[1]).Value as string) == Parser.IsTxt)                  {                      EmitExpression(invoke.Parameters[0]);                      writer.Write(Parser.SingleSpace);                      writer.Write(Parser.IsTxt);                      writer.Write(Parser.SingleSpace);                      EmitExpression(invoke.Parameters[2]);                      return;                  }                  else if (name == Parser.InternalMethods.Operate.MethodName && invoke.Parameters.Count == 3)                  {                      EmitExpression(invoke.Parameters[1]);                      writer.Write(Parser.SingleSpace);                        var op = (Script.Operator)Enum.Parse(typeof(Script.Operator)' ((CodeFieldReferenceExpression)invoke.Parameters[0]).FieldName);                      writer.Write(ScriptOperator(op));                        writer.Write(Parser.SingleSpace);                      EmitExpression(invoke.Parameters[2]);                      return;                  }                  else if (name == Parser.InternalMethods.ExtendArray.MethodName && invoke.Parameters.Count == 1)                      return;                  else if (name == Parser.InternalMethods.SetObject.MethodName && invoke.Parameters.Count == 4)                  {                      EmitExpression(invoke.Parameters[1]);                      EmitExpression(invoke.Parameters[2]);                      EmitExpression(invoke.Parameters[0]);                        writer.Write(Parser.SingleSpace);                      writer.Write(Parser.AssignPre);                      writer.Write(Parser.Equal);                      writer.Write(Parser.SingleSpace);                        EmitExpression(invoke.Parameters[3]);                        return;                  }                  else if (name == Parser.InternalMethods.Index.MethodName && invoke.Parameters.Count == 2)                  {                      EmitExpression(invoke.Parameters[0]);                      writer.Write(Parser.ArrayOpen);                      EmitExpression(invoke.Parameters[1]);                      writer.Write(Parser.ArrayClose);                        return;                  }                  else if (name == Parser.InternalMethods.Dictionary.MethodName && invoke.Parameters.Count == 2)                  {                      writer.Write(Parser.BlockOpen);                      writer.Write(Parser.SingleSpace);                        var parts = new CodeExpressionCollection[2];                        for (int i = 0; i < parts.Length; i++)                          parts[i] = ((CodeArrayCreateExpression)invoke.Parameters[i]).Initializers;                        bool first = true;                        for (int i = 0; i < parts[0].Count; i++)                      {                          if (first)                              first = false;                          else                          {                              writer.Write(Parser.DefaultMulticast);                              writer.Write(Parser.SingleSpace);                          }                            depth++;                          EmitExpression(parts[0][i]);                          writer.Write(Parser.SingleSpace);                          writer.Write(Parser.AssignPre);                          writer.Write(Parser.SingleSpace);                          EmitExpression(parts[1][i]);                          depth--;                      }                        writer.Write(Parser.SingleSpace);                      writer.Write(Parser.BlockClose);                        return;                  }              }
Magic Number,IronAHK.Scripting,Emit,C:\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,EmitInvoke,The following statement contains a magic number: if (invoke.Method.TargetObject is CodeTypeReferenceExpression &&                  Type.GetType(((CodeTypeReferenceExpression)invoke.Method.TargetObject).Type.BaseType) == typeof(Script))              {                  string name = invoke.Method.MethodName;                    if (name == Parser.InternalMethods.LabelCall.MethodName && invoke.Parameters.Count == 1)                  {                      EmitGoto(new CodeGotoStatement((string)((CodePrimitiveExpression)invoke.Parameters[0]).Value));                      return;                  }                  else if (name == Parser.InternalMethods.IfElse.MethodName && invoke.Parameters.Count == 1)                  {                      EmitExpression(invoke.Parameters[0]);                      return;                  }                  else if (name == Parser.InternalMethods.IfLegacy.MethodName && invoke.Parameters.Count == 3 &&                      invoke.Parameters[1] is CodePrimitiveExpression && (((CodePrimitiveExpression)invoke.Parameters[1]).Value as string) == Parser.IsTxt)                  {                      EmitExpression(invoke.Parameters[0]);                      writer.Write(Parser.SingleSpace);                      writer.Write(Parser.IsTxt);                      writer.Write(Parser.SingleSpace);                      EmitExpression(invoke.Parameters[2]);                      return;                  }                  else if (name == Parser.InternalMethods.Operate.MethodName && invoke.Parameters.Count == 3)                  {                      EmitExpression(invoke.Parameters[1]);                      writer.Write(Parser.SingleSpace);                        var op = (Script.Operator)Enum.Parse(typeof(Script.Operator)' ((CodeFieldReferenceExpression)invoke.Parameters[0]).FieldName);                      writer.Write(ScriptOperator(op));                        writer.Write(Parser.SingleSpace);                      EmitExpression(invoke.Parameters[2]);                      return;                  }                  else if (name == Parser.InternalMethods.ExtendArray.MethodName && invoke.Parameters.Count == 1)                      return;                  else if (name == Parser.InternalMethods.SetObject.MethodName && invoke.Parameters.Count == 4)                  {                      EmitExpression(invoke.Parameters[1]);                      EmitExpression(invoke.Parameters[2]);                      EmitExpression(invoke.Parameters[0]);                        writer.Write(Parser.SingleSpace);                      writer.Write(Parser.AssignPre);                      writer.Write(Parser.Equal);                      writer.Write(Parser.SingleSpace);                        EmitExpression(invoke.Parameters[3]);                        return;                  }                  else if (name == Parser.InternalMethods.Index.MethodName && invoke.Parameters.Count == 2)                  {                      EmitExpression(invoke.Parameters[0]);                      writer.Write(Parser.ArrayOpen);                      EmitExpression(invoke.Parameters[1]);                      writer.Write(Parser.ArrayClose);                        return;                  }                  else if (name == Parser.InternalMethods.Dictionary.MethodName && invoke.Parameters.Count == 2)                  {                      writer.Write(Parser.BlockOpen);                      writer.Write(Parser.SingleSpace);                        var parts = new CodeExpressionCollection[2];                        for (int i = 0; i < parts.Length; i++)                          parts[i] = ((CodeArrayCreateExpression)invoke.Parameters[i]).Initializers;                        bool first = true;                        for (int i = 0; i < parts[0].Count; i++)                      {                          if (first)                              first = false;                          else                          {                              writer.Write(Parser.DefaultMulticast);                              writer.Write(Parser.SingleSpace);                          }                            depth++;                          EmitExpression(parts[0][i]);                          writer.Write(Parser.SingleSpace);                          writer.Write(Parser.AssignPre);                          writer.Write(Parser.SingleSpace);                          EmitExpression(parts[1][i]);                          depth--;                      }                        writer.Write(Parser.SingleSpace);                      writer.Write(Parser.BlockClose);                        return;                  }              }
Magic Number,IronAHK.Scripting,Emit,C:\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,EmitInvoke,The following statement contains a magic number: if (invoke.Method.TargetObject is CodeTypeReferenceExpression &&                  Type.GetType(((CodeTypeReferenceExpression)invoke.Method.TargetObject).Type.BaseType) == typeof(Script))              {                  string name = invoke.Method.MethodName;                    if (name == Parser.InternalMethods.LabelCall.MethodName && invoke.Parameters.Count == 1)                  {                      EmitGoto(new CodeGotoStatement((string)((CodePrimitiveExpression)invoke.Parameters[0]).Value));                      return;                  }                  else if (name == Parser.InternalMethods.IfElse.MethodName && invoke.Parameters.Count == 1)                  {                      EmitExpression(invoke.Parameters[0]);                      return;                  }                  else if (name == Parser.InternalMethods.IfLegacy.MethodName && invoke.Parameters.Count == 3 &&                      invoke.Parameters[1] is CodePrimitiveExpression && (((CodePrimitiveExpression)invoke.Parameters[1]).Value as string) == Parser.IsTxt)                  {                      EmitExpression(invoke.Parameters[0]);                      writer.Write(Parser.SingleSpace);                      writer.Write(Parser.IsTxt);                      writer.Write(Parser.SingleSpace);                      EmitExpression(invoke.Parameters[2]);                      return;                  }                  else if (name == Parser.InternalMethods.Operate.MethodName && invoke.Parameters.Count == 3)                  {                      EmitExpression(invoke.Parameters[1]);                      writer.Write(Parser.SingleSpace);                        var op = (Script.Operator)Enum.Parse(typeof(Script.Operator)' ((CodeFieldReferenceExpression)invoke.Parameters[0]).FieldName);                      writer.Write(ScriptOperator(op));                        writer.Write(Parser.SingleSpace);                      EmitExpression(invoke.Parameters[2]);                      return;                  }                  else if (name == Parser.InternalMethods.ExtendArray.MethodName && invoke.Parameters.Count == 1)                      return;                  else if (name == Parser.InternalMethods.SetObject.MethodName && invoke.Parameters.Count == 4)                  {                      EmitExpression(invoke.Parameters[1]);                      EmitExpression(invoke.Parameters[2]);                      EmitExpression(invoke.Parameters[0]);                        writer.Write(Parser.SingleSpace);                      writer.Write(Parser.AssignPre);                      writer.Write(Parser.Equal);                      writer.Write(Parser.SingleSpace);                        EmitExpression(invoke.Parameters[3]);                        return;                  }                  else if (name == Parser.InternalMethods.Index.MethodName && invoke.Parameters.Count == 2)                  {                      EmitExpression(invoke.Parameters[0]);                      writer.Write(Parser.ArrayOpen);                      EmitExpression(invoke.Parameters[1]);                      writer.Write(Parser.ArrayClose);                        return;                  }                  else if (name == Parser.InternalMethods.Dictionary.MethodName && invoke.Parameters.Count == 2)                  {                      writer.Write(Parser.BlockOpen);                      writer.Write(Parser.SingleSpace);                        var parts = new CodeExpressionCollection[2];                        for (int i = 0; i < parts.Length; i++)                          parts[i] = ((CodeArrayCreateExpression)invoke.Parameters[i]).Initializers;                        bool first = true;                        for (int i = 0; i < parts[0].Count; i++)                      {                          if (first)                              first = false;                          else                          {                              writer.Write(Parser.DefaultMulticast);                              writer.Write(Parser.SingleSpace);                          }                            depth++;                          EmitExpression(parts[0][i]);                          writer.Write(Parser.SingleSpace);                          writer.Write(Parser.AssignPre);                          writer.Write(Parser.SingleSpace);                          EmitExpression(parts[1][i]);                          depth--;                      }                        writer.Write(Parser.SingleSpace);                      writer.Write(Parser.BlockClose);                        return;                  }              }
Magic Number,IronAHK.Scripting,Emit,C:\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,EmitInvoke,The following statement contains a magic number: if (invoke.Method.TargetObject is CodeTypeReferenceExpression &&                  Type.GetType(((CodeTypeReferenceExpression)invoke.Method.TargetObject).Type.BaseType) == typeof(Script))              {                  string name = invoke.Method.MethodName;                    if (name == Parser.InternalMethods.LabelCall.MethodName && invoke.Parameters.Count == 1)                  {                      EmitGoto(new CodeGotoStatement((string)((CodePrimitiveExpression)invoke.Parameters[0]).Value));                      return;                  }                  else if (name == Parser.InternalMethods.IfElse.MethodName && invoke.Parameters.Count == 1)                  {                      EmitExpression(invoke.Parameters[0]);                      return;                  }                  else if (name == Parser.InternalMethods.IfLegacy.MethodName && invoke.Parameters.Count == 3 &&                      invoke.Parameters[1] is CodePrimitiveExpression && (((CodePrimitiveExpression)invoke.Parameters[1]).Value as string) == Parser.IsTxt)                  {                      EmitExpression(invoke.Parameters[0]);                      writer.Write(Parser.SingleSpace);                      writer.Write(Parser.IsTxt);                      writer.Write(Parser.SingleSpace);                      EmitExpression(invoke.Parameters[2]);                      return;                  }                  else if (name == Parser.InternalMethods.Operate.MethodName && invoke.Parameters.Count == 3)                  {                      EmitExpression(invoke.Parameters[1]);                      writer.Write(Parser.SingleSpace);                        var op = (Script.Operator)Enum.Parse(typeof(Script.Operator)' ((CodeFieldReferenceExpression)invoke.Parameters[0]).FieldName);                      writer.Write(ScriptOperator(op));                        writer.Write(Parser.SingleSpace);                      EmitExpression(invoke.Parameters[2]);                      return;                  }                  else if (name == Parser.InternalMethods.ExtendArray.MethodName && invoke.Parameters.Count == 1)                      return;                  else if (name == Parser.InternalMethods.SetObject.MethodName && invoke.Parameters.Count == 4)                  {                      EmitExpression(invoke.Parameters[1]);                      EmitExpression(invoke.Parameters[2]);                      EmitExpression(invoke.Parameters[0]);                        writer.Write(Parser.SingleSpace);                      writer.Write(Parser.AssignPre);                      writer.Write(Parser.Equal);                      writer.Write(Parser.SingleSpace);                        EmitExpression(invoke.Parameters[3]);                        return;                  }                  else if (name == Parser.InternalMethods.Index.MethodName && invoke.Parameters.Count == 2)                  {                      EmitExpression(invoke.Parameters[0]);                      writer.Write(Parser.ArrayOpen);                      EmitExpression(invoke.Parameters[1]);                      writer.Write(Parser.ArrayClose);                        return;                  }                  else if (name == Parser.InternalMethods.Dictionary.MethodName && invoke.Parameters.Count == 2)                  {                      writer.Write(Parser.BlockOpen);                      writer.Write(Parser.SingleSpace);                        var parts = new CodeExpressionCollection[2];                        for (int i = 0; i < parts.Length; i++)                          parts[i] = ((CodeArrayCreateExpression)invoke.Parameters[i]).Initializers;                        bool first = true;                        for (int i = 0; i < parts[0].Count; i++)                      {                          if (first)                              first = false;                          else                          {                              writer.Write(Parser.DefaultMulticast);                              writer.Write(Parser.SingleSpace);                          }                            depth++;                          EmitExpression(parts[0][i]);                          writer.Write(Parser.SingleSpace);                          writer.Write(Parser.AssignPre);                          writer.Write(Parser.SingleSpace);                          EmitExpression(parts[1][i]);                          depth--;                      }                        writer.Write(Parser.SingleSpace);                      writer.Write(Parser.BlockClose);                        return;                  }              }
Magic Number,IronAHK.Scripting,Emit,C:\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,EmitInvoke,The following statement contains a magic number: if (invoke.Method.TargetObject is CodeTypeReferenceExpression &&                  Type.GetType(((CodeTypeReferenceExpression)invoke.Method.TargetObject).Type.BaseType) == typeof(Script))              {                  string name = invoke.Method.MethodName;                    if (name == Parser.InternalMethods.LabelCall.MethodName && invoke.Parameters.Count == 1)                  {                      EmitGoto(new CodeGotoStatement((string)((CodePrimitiveExpression)invoke.Parameters[0]).Value));                      return;                  }                  else if (name == Parser.InternalMethods.IfElse.MethodName && invoke.Parameters.Count == 1)                  {                      EmitExpression(invoke.Parameters[0]);                      return;                  }                  else if (name == Parser.InternalMethods.IfLegacy.MethodName && invoke.Parameters.Count == 3 &&                      invoke.Parameters[1] is CodePrimitiveExpression && (((CodePrimitiveExpression)invoke.Parameters[1]).Value as string) == Parser.IsTxt)                  {                      EmitExpression(invoke.Parameters[0]);                      writer.Write(Parser.SingleSpace);                      writer.Write(Parser.IsTxt);                      writer.Write(Parser.SingleSpace);                      EmitExpression(invoke.Parameters[2]);                      return;                  }                  else if (name == Parser.InternalMethods.Operate.MethodName && invoke.Parameters.Count == 3)                  {                      EmitExpression(invoke.Parameters[1]);                      writer.Write(Parser.SingleSpace);                        var op = (Script.Operator)Enum.Parse(typeof(Script.Operator)' ((CodeFieldReferenceExpression)invoke.Parameters[0]).FieldName);                      writer.Write(ScriptOperator(op));                        writer.Write(Parser.SingleSpace);                      EmitExpression(invoke.Parameters[2]);                      return;                  }                  else if (name == Parser.InternalMethods.ExtendArray.MethodName && invoke.Parameters.Count == 1)                      return;                  else if (name == Parser.InternalMethods.SetObject.MethodName && invoke.Parameters.Count == 4)                  {                      EmitExpression(invoke.Parameters[1]);                      EmitExpression(invoke.Parameters[2]);                      EmitExpression(invoke.Parameters[0]);                        writer.Write(Parser.SingleSpace);                      writer.Write(Parser.AssignPre);                      writer.Write(Parser.Equal);                      writer.Write(Parser.SingleSpace);                        EmitExpression(invoke.Parameters[3]);                        return;                  }                  else if (name == Parser.InternalMethods.Index.MethodName && invoke.Parameters.Count == 2)                  {                      EmitExpression(invoke.Parameters[0]);                      writer.Write(Parser.ArrayOpen);                      EmitExpression(invoke.Parameters[1]);                      writer.Write(Parser.ArrayClose);                        return;                  }                  else if (name == Parser.InternalMethods.Dictionary.MethodName && invoke.Parameters.Count == 2)                  {                      writer.Write(Parser.BlockOpen);                      writer.Write(Parser.SingleSpace);                        var parts = new CodeExpressionCollection[2];                        for (int i = 0; i < parts.Length; i++)                          parts[i] = ((CodeArrayCreateExpression)invoke.Parameters[i]).Initializers;                        bool first = true;                        for (int i = 0; i < parts[0].Count; i++)                      {                          if (first)                              first = false;                          else                          {                              writer.Write(Parser.DefaultMulticast);                              writer.Write(Parser.SingleSpace);                          }                            depth++;                          EmitExpression(parts[0][i]);                          writer.Write(Parser.SingleSpace);                          writer.Write(Parser.AssignPre);                          writer.Write(Parser.SingleSpace);                          EmitExpression(parts[1][i]);                          depth--;                      }                        writer.Write(Parser.SingleSpace);                      writer.Write(Parser.BlockClose);                        return;                  }              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,MergeObjectAssignmentAt,The following statement contains a magic number: while (invoke.Parameters.Count == 2 && invoke.Method.MethodName == InternalMethods.Index.MethodName)              {                  step.Add(invoke.Parameters[1]);                    if (invoke.Parameters[0] is CodeMethodInvokeExpression)                      invoke = (CodeMethodInvokeExpression)invoke.Parameters[0];                  else                  {                      target = invoke.Parameters[0];                      break;                  }              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsOptimisableExpression,The following statement contains a magic number: return invoke.Method.MethodName == InternalMethods.Operate.MethodName && invoke.Parameters.Count == 3;
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OptimiseExpression,The following statement contains a magic number: for (int i = 1; i < 3; i++)                  invoke.Parameters[i] = OptimiseExpression(invoke.Parameters[i]);
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OptimiseExpression,The following statement contains a magic number: if (invoke.Parameters[1] is CodePrimitiveExpression && invoke.Parameters[2] is CodePrimitiveExpression)              {                  object result = null;                    try                  {                      result = Script.Operate((Script.Operator)invoke.Parameters[0].UserData[RawData]'                          ((CodePrimitiveExpression)invoke.Parameters[1]).Value'                          ((CodePrimitiveExpression)invoke.Parameters[2]).Value);                  }                  catch (Exception) { }                    return new CodePrimitiveExpression(result);              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OptimiseExpression,The following statement contains a magic number: if (invoke.Parameters[1] is CodePrimitiveExpression && invoke.Parameters[2] is CodePrimitiveExpression)              {                  object result = null;                    try                  {                      result = Script.Operate((Script.Operator)invoke.Parameters[0].UserData[RawData]'                          ((CodePrimitiveExpression)invoke.Parameters[1]).Value'                          ((CodePrimitiveExpression)invoke.Parameters[2]).Value);                  }                  catch (Exception) { }                    return new CodePrimitiveExpression(result);              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OptimiseLoneExpression,The following statement contains a magic number: for (int i = 1; i < 3; i++)                  invoke.Parameters[i] = OptimiseExpression(invoke.Parameters[i]);
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OptimiseLoneExpression,The following statement contains a magic number: bool left = invoke.Parameters[1] is CodePrimitiveExpression' right = invoke.Parameters[2] is CodeExpression;
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OptimiseLoneExpression,The following statement contains a magic number: if (left)                  return invoke.Parameters[2];
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseObject,The following statement contains a magic number: for (int i = 0; i < parts.Count; i++)              {                  CodeExpression value = null;                    #region Name                    if (!(parts[i] is string))                      throw new ParseException(ExUnexpected);                    var name = (string)parts[i];                    if (name.Length > 2 && name[0] == StringBound && name[name.Length - 1] == StringBound)                      name = name.Substring(1' name.Length - 2);                    if (name.Length == 0 || !IsIdentifier(name))                      throw new ParseException(ExInvalidVarName);                    i++;                  if (i == parts.Count)                      goto collect;                    #endregion                    #region Assign                    if (!(parts[i] is string))                      throw new ParseException(ExUnexpected);                    var assign = (string)parts[i];                    if (assign.Length == 1 && assign[0] == Multicast)                      goto collect;                    if (!(assign.Length == 1 && (assign[0] == Equal || assign[0] == HotkeyBound)))                      throw new ParseException(ExUnexpected);                    i++;                  if (i == parts.Count)                      goto collect;                    #endregion                    #region Value                    var sub = new List<object>();                  int next = Set(parts' i);                    if (next == 0) // no enclosing set (...){...}[...] so scan until next bounary                  {                      for (next = i; next < parts.Count; next++)                      {                          if (parts[next] is string && ((string)parts[next])[0] == Multicast)                              break;                      }                  }                  else                      next++; // set function returns n-1 index                    for (; i < next; i++)                      sub.Add(parts[i]);                  i--;                    value = ParseExpression(sub);                    i++;                  if (i == parts.Count)                      goto collect;                    #endregion                    #region Delimiter                    if (!(parts[i] is string))                      throw new ParseException(ExUnexpected);                    var delim = (string)parts[i];                    if (!(delim.Length == 1 && delim[0] == Multicast))                      throw new ParseException(ExUnexpected);                    #endregion                    #region Collect                collect:                  names.Add(new CodePrimitiveExpression(name));                  entries.Add(value ?? new CodePrimitiveExpression(null));                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseObject,The following statement contains a magic number: for (int i = 0; i < parts.Count; i++)              {                  CodeExpression value = null;                    #region Name                    if (!(parts[i] is string))                      throw new ParseException(ExUnexpected);                    var name = (string)parts[i];                    if (name.Length > 2 && name[0] == StringBound && name[name.Length - 1] == StringBound)                      name = name.Substring(1' name.Length - 2);                    if (name.Length == 0 || !IsIdentifier(name))                      throw new ParseException(ExInvalidVarName);                    i++;                  if (i == parts.Count)                      goto collect;                    #endregion                    #region Assign                    if (!(parts[i] is string))                      throw new ParseException(ExUnexpected);                    var assign = (string)parts[i];                    if (assign.Length == 1 && assign[0] == Multicast)                      goto collect;                    if (!(assign.Length == 1 && (assign[0] == Equal || assign[0] == HotkeyBound)))                      throw new ParseException(ExUnexpected);                    i++;                  if (i == parts.Count)                      goto collect;                    #endregion                    #region Value                    var sub = new List<object>();                  int next = Set(parts' i);                    if (next == 0) // no enclosing set (...){...}[...] so scan until next bounary                  {                      for (next = i; next < parts.Count; next++)                      {                          if (parts[next] is string && ((string)parts[next])[0] == Multicast)                              break;                      }                  }                  else                      next++; // set function returns n-1 index                    for (; i < next; i++)                      sub.Add(parts[i]);                  i--;                    value = ParseExpression(sub);                    i++;                  if (i == parts.Count)                      goto collect;                    #endregion                    #region Delimiter                    if (!(parts[i] is string))                      throw new ParseException(ExUnexpected);                    var delim = (string)parts[i];                    if (!(delim.Length == 1 && delim[0] == Multicast))                      throw new ParseException(ExUnexpected);                    #endregion                    #region Collect                collect:                  names.Add(new CodePrimitiveExpression(name));                  entries.Add(value ?? new CodePrimitiveExpression(null));                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Set,The following statement contains a magic number: if (first.Length == 0)                  return 0;              else if (first.Length == 1)              {                  switch (first[0])                  {                      case BlockOpen:                          expect = BlockClose;                          levels[1]++;                          break;                        case ArrayOpen:                          expect = ArrayClose;                          levels[2]++;                          break;                        case ParenOpen:                          expect = ParenClose;                          levels[0]++;                          break;                  }              }              else if (first[first.Length - 1] == ParenOpen)              {                  expect = ParenClose;                  levels[0]++;              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Set,The following statement contains a magic number: while (e.MoveNext())              {                  position++;                    if (!(e.Current is string))                      continue;                    var current = (string)e.Current;                    if (current.Length == 0)                      continue;                  else if (current.Length == 1)                  {                      switch (current[0])                      {                          case BlockOpen:                              levels[1]++;                              break;                            case BlockClose:                              levels[1]--;                              if (levels[1] < 0)                                  throw new ParseException(ExUnbalancedParens);                              else if (expect == BlockClose && levels[0] == 0 && levels[1] == 0 && levels[2] == 0)                                  return position;                              break;                            case ArrayOpen:                              levels[2]++;                              break;                            case ArrayClose:                              levels[2]--;                              if (levels[2] < 0)                                  throw new ParseException(ExUnbalancedParens);                              else if (expect == ArrayClose && levels[0] == 0 && levels[1] == 0 && levels[2] == 0)                                  return position;                              break;                            case ParenOpen:                              levels[0]++;                              break;                            case ParenClose:                              levels[0]--;                              if (levels[0] < 0)                                  throw new ParseException(ExUnbalancedParens);                              else if (expect == ParenClose && levels[0] == 0 && levels[1] == 0 && levels[2] == 0)                                  return position;                              break;                      }                  }                  else if (current[current.Length - 1] == ParenOpen)                  {                      levels[0]++;                  }              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Set,The following statement contains a magic number: while (e.MoveNext())              {                  position++;                    if (!(e.Current is string))                      continue;                    var current = (string)e.Current;                    if (current.Length == 0)                      continue;                  else if (current.Length == 1)                  {                      switch (current[0])                      {                          case BlockOpen:                              levels[1]++;                              break;                            case BlockClose:                              levels[1]--;                              if (levels[1] < 0)                                  throw new ParseException(ExUnbalancedParens);                              else if (expect == BlockClose && levels[0] == 0 && levels[1] == 0 && levels[2] == 0)                                  return position;                              break;                            case ArrayOpen:                              levels[2]++;                              break;                            case ArrayClose:                              levels[2]--;                              if (levels[2] < 0)                                  throw new ParseException(ExUnbalancedParens);                              else if (expect == ArrayClose && levels[0] == 0 && levels[1] == 0 && levels[2] == 0)                                  return position;                              break;                            case ParenOpen:                              levels[0]++;                              break;                            case ParenClose:                              levels[0]--;                              if (levels[0] < 0)                                  throw new ParseException(ExUnbalancedParens);                              else if (expect == ParenClose && levels[0] == 0 && levels[1] == 0 && levels[2] == 0)                                  return position;                              break;                      }                  }                  else if (current[current.Length - 1] == ParenOpen)                  {                      levels[0]++;                  }              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Set,The following statement contains a magic number: while (e.MoveNext())              {                  position++;                    if (!(e.Current is string))                      continue;                    var current = (string)e.Current;                    if (current.Length == 0)                      continue;                  else if (current.Length == 1)                  {                      switch (current[0])                      {                          case BlockOpen:                              levels[1]++;                              break;                            case BlockClose:                              levels[1]--;                              if (levels[1] < 0)                                  throw new ParseException(ExUnbalancedParens);                              else if (expect == BlockClose && levels[0] == 0 && levels[1] == 0 && levels[2] == 0)                                  return position;                              break;                            case ArrayOpen:                              levels[2]++;                              break;                            case ArrayClose:                              levels[2]--;                              if (levels[2] < 0)                                  throw new ParseException(ExUnbalancedParens);                              else if (expect == ArrayClose && levels[0] == 0 && levels[1] == 0 && levels[2] == 0)                                  return position;                              break;                            case ParenOpen:                              levels[0]++;                              break;                            case ParenClose:                              levels[0]--;                              if (levels[0] < 0)                                  throw new ParseException(ExUnbalancedParens);                              else if (expect == ParenClose && levels[0] == 0 && levels[1] == 0 && levels[2] == 0)                                  return position;                              break;                      }                  }                  else if (current[current.Length - 1] == ParenOpen)                  {                      levels[0]++;                  }              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Set,The following statement contains a magic number: while (e.MoveNext())              {                  position++;                    if (!(e.Current is string))                      continue;                    var current = (string)e.Current;                    if (current.Length == 0)                      continue;                  else if (current.Length == 1)                  {                      switch (current[0])                      {                          case BlockOpen:                              levels[1]++;                              break;                            case BlockClose:                              levels[1]--;                              if (levels[1] < 0)                                  throw new ParseException(ExUnbalancedParens);                              else if (expect == BlockClose && levels[0] == 0 && levels[1] == 0 && levels[2] == 0)                                  return position;                              break;                            case ArrayOpen:                              levels[2]++;                              break;                            case ArrayClose:                              levels[2]--;                              if (levels[2] < 0)                                  throw new ParseException(ExUnbalancedParens);                              else if (expect == ArrayClose && levels[0] == 0 && levels[1] == 0 && levels[2] == 0)                                  return position;                              break;                            case ParenOpen:                              levels[0]++;                              break;                            case ParenClose:                              levels[0]--;                              if (levels[0] < 0)                                  throw new ParseException(ExUnbalancedParens);                              else if (expect == ParenClose && levels[0] == 0 && levels[1] == 0 && levels[2] == 0)                                  return position;                              break;                      }                  }                  else if (current[current.Length - 1] == ParenOpen)                  {                      levels[0]++;                  }              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Set,The following statement contains a magic number: while (e.MoveNext())              {                  position++;                    if (!(e.Current is string))                      continue;                    var current = (string)e.Current;                    if (current.Length == 0)                      continue;                  else if (current.Length == 1)                  {                      switch (current[0])                      {                          case BlockOpen:                              levels[1]++;                              break;                            case BlockClose:                              levels[1]--;                              if (levels[1] < 0)                                  throw new ParseException(ExUnbalancedParens);                              else if (expect == BlockClose && levels[0] == 0 && levels[1] == 0 && levels[2] == 0)                                  return position;                              break;                            case ArrayOpen:                              levels[2]++;                              break;                            case ArrayClose:                              levels[2]--;                              if (levels[2] < 0)                                  throw new ParseException(ExUnbalancedParens);                              else if (expect == ArrayClose && levels[0] == 0 && levels[1] == 0 && levels[2] == 0)                                  return position;                              break;                            case ParenOpen:                              levels[0]++;                              break;                            case ParenClose:                              levels[0]--;                              if (levels[0] < 0)                                  throw new ParseException(ExUnbalancedParens);                              else if (expect == ParenClose && levels[0] == 0 && levels[1] == 0 && levels[2] == 0)                                  return position;                              break;                      }                  }                  else if (current[current.Length - 1] == ParenOpen)                  {                      levels[0]++;                  }              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Set,The following statement contains a magic number: while (e.MoveNext())              {                  position++;                    if (!(e.Current is string))                      continue;                    var current = (string)e.Current;                    if (current.Length == 0)                      continue;                  else if (current.Length == 1)                  {                      switch (current[0])                      {                          case BlockOpen:                              levels[1]++;                              break;                            case BlockClose:                              levels[1]--;                              if (levels[1] < 0)                                  throw new ParseException(ExUnbalancedParens);                              else if (expect == BlockClose && levels[0] == 0 && levels[1] == 0 && levels[2] == 0)                                  return position;                              break;                            case ArrayOpen:                              levels[2]++;                              break;                            case ArrayClose:                              levels[2]--;                              if (levels[2] < 0)                                  throw new ParseException(ExUnbalancedParens);                              else if (expect == ArrayClose && levels[0] == 0 && levels[1] == 0 && levels[2] == 0)                                  return position;                              break;                            case ParenOpen:                              levels[0]++;                              break;                            case ParenClose:                              levels[0]--;                              if (levels[0] < 0)                                  throw new ParseException(ExUnbalancedParens);                              else if (expect == ParenClose && levels[0] == 0 && levels[1] == 0 && levels[2] == 0)                                  return position;                              break;                      }                  }                  else if (current[current.Length - 1] == ParenOpen)                  {                      levels[0]++;                  }              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Set,The following statement contains a magic number: if (levels[0] != 0 || levels[1] != 0 || levels[2] != 0)                  throw new ParseException(ExUnbalancedParens);
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorFromString,The following statement contains a magic number: switch (op[0])              {                  case Add:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Add;                            case 2:                              return Script.Operator.Increment;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Minus:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Subtract;                            case 2:                              return Script.Operator.Decrement;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Multiply:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Multiply;                            case 2:                              return Script.Operator.Power;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Divide:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Divide;                            case 2:                              return Script.Operator.FloorDivide;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Greater:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.GreaterThan;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.BitShiftRight;                              else if (op[1] == Equal)                                  return Script.Operator.GreaterThanOrEqual;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case Less:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.LessThan;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.BitShiftLeft;                              else if (op[1] == Equal)                                  return Script.Operator.LessThanOrEqual;                              else if (op[1] == Greater)                                  return Script.Operator.ValueInequality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitAND:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseAnd;                            case 2:                              if (op[0] == op[1])                                  return Script.Operator.BooleanAnd;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitOR:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseOr;                            case 2:                              if (op[0] == op[1])                                  return Script.Operator.BooleanOr;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitXOR:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseXor;                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitNOT:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseNot;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Equal:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.ValueEquality;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.IdentityEquality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case Not:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.LogicalNot;                            case 2:                              if (op[1] == Equal)                                  return Script.Operator.ValueInequality;                              else                                  throw new ParseException(ExUnexpected);                            case 3:                              if (op[1] == Equal && op[2] == Equal)                                  return Script.Operator.IdentityInequality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case AssignPre:                      if (op.Length > 1 && op[1] == Equal)                          return Script.Operator.Assign;                      else                          return Script.Operator.TernaryB;                    case Concatenate:                      return Script.Operator.Concat;                    case TernaryA:                      if (op.Length > 1 && op[1] == TernaryA)                          return Script.Operator.NullAssign;                      else                          return Script.Operator.TernaryA;                    default:                      switch (code.ToLowerInvariant())                      {                          case NotTxt:                              return Script.Operator.LogicalNotEx;                            case AndTxt:                              return Script.Operator.BooleanAnd;                            case OrTxt:                              return Script.Operator.BooleanOr;                            case IsTxt:                              return Script.Operator.Is;                      }                      throw new ArgumentOutOfRangeException();              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorFromString,The following statement contains a magic number: switch (op[0])              {                  case Add:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Add;                            case 2:                              return Script.Operator.Increment;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Minus:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Subtract;                            case 2:                              return Script.Operator.Decrement;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Multiply:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Multiply;                            case 2:                              return Script.Operator.Power;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Divide:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Divide;                            case 2:                              return Script.Operator.FloorDivide;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Greater:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.GreaterThan;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.BitShiftRight;                              else if (op[1] == Equal)                                  return Script.Operator.GreaterThanOrEqual;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case Less:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.LessThan;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.BitShiftLeft;                              else if (op[1] == Equal)                                  return Script.Operator.LessThanOrEqual;                              else if (op[1] == Greater)                                  return Script.Operator.ValueInequality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitAND:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseAnd;                            case 2:                              if (op[0] == op[1])                                  return Script.Operator.BooleanAnd;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitOR:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseOr;                            case 2:                              if (op[0] == op[1])                                  return Script.Operator.BooleanOr;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitXOR:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseXor;                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitNOT:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseNot;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Equal:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.ValueEquality;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.IdentityEquality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case Not:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.LogicalNot;                            case 2:                              if (op[1] == Equal)                                  return Script.Operator.ValueInequality;                              else                                  throw new ParseException(ExUnexpected);                            case 3:                              if (op[1] == Equal && op[2] == Equal)                                  return Script.Operator.IdentityInequality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case AssignPre:                      if (op.Length > 1 && op[1] == Equal)                          return Script.Operator.Assign;                      else                          return Script.Operator.TernaryB;                    case Concatenate:                      return Script.Operator.Concat;                    case TernaryA:                      if (op.Length > 1 && op[1] == TernaryA)                          return Script.Operator.NullAssign;                      else                          return Script.Operator.TernaryA;                    default:                      switch (code.ToLowerInvariant())                      {                          case NotTxt:                              return Script.Operator.LogicalNotEx;                            case AndTxt:                              return Script.Operator.BooleanAnd;                            case OrTxt:                              return Script.Operator.BooleanOr;                            case IsTxt:                              return Script.Operator.Is;                      }                      throw new ArgumentOutOfRangeException();              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorFromString,The following statement contains a magic number: switch (op[0])              {                  case Add:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Add;                            case 2:                              return Script.Operator.Increment;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Minus:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Subtract;                            case 2:                              return Script.Operator.Decrement;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Multiply:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Multiply;                            case 2:                              return Script.Operator.Power;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Divide:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Divide;                            case 2:                              return Script.Operator.FloorDivide;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Greater:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.GreaterThan;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.BitShiftRight;                              else if (op[1] == Equal)                                  return Script.Operator.GreaterThanOrEqual;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case Less:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.LessThan;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.BitShiftLeft;                              else if (op[1] == Equal)                                  return Script.Operator.LessThanOrEqual;                              else if (op[1] == Greater)                                  return Script.Operator.ValueInequality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitAND:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseAnd;                            case 2:                              if (op[0] == op[1])                                  return Script.Operator.BooleanAnd;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitOR:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseOr;                            case 2:                              if (op[0] == op[1])                                  return Script.Operator.BooleanOr;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitXOR:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseXor;                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitNOT:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseNot;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Equal:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.ValueEquality;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.IdentityEquality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case Not:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.LogicalNot;                            case 2:                              if (op[1] == Equal)                                  return Script.Operator.ValueInequality;                              else                                  throw new ParseException(ExUnexpected);                            case 3:                              if (op[1] == Equal && op[2] == Equal)                                  return Script.Operator.IdentityInequality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case AssignPre:                      if (op.Length > 1 && op[1] == Equal)                          return Script.Operator.Assign;                      else                          return Script.Operator.TernaryB;                    case Concatenate:                      return Script.Operator.Concat;                    case TernaryA:                      if (op.Length > 1 && op[1] == TernaryA)                          return Script.Operator.NullAssign;                      else                          return Script.Operator.TernaryA;                    default:                      switch (code.ToLowerInvariant())                      {                          case NotTxt:                              return Script.Operator.LogicalNotEx;                            case AndTxt:                              return Script.Operator.BooleanAnd;                            case OrTxt:                              return Script.Operator.BooleanOr;                            case IsTxt:                              return Script.Operator.Is;                      }                      throw new ArgumentOutOfRangeException();              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorFromString,The following statement contains a magic number: switch (op[0])              {                  case Add:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Add;                            case 2:                              return Script.Operator.Increment;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Minus:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Subtract;                            case 2:                              return Script.Operator.Decrement;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Multiply:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Multiply;                            case 2:                              return Script.Operator.Power;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Divide:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Divide;                            case 2:                              return Script.Operator.FloorDivide;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Greater:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.GreaterThan;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.BitShiftRight;                              else if (op[1] == Equal)                                  return Script.Operator.GreaterThanOrEqual;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case Less:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.LessThan;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.BitShiftLeft;                              else if (op[1] == Equal)                                  return Script.Operator.LessThanOrEqual;                              else if (op[1] == Greater)                                  return Script.Operator.ValueInequality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitAND:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseAnd;                            case 2:                              if (op[0] == op[1])                                  return Script.Operator.BooleanAnd;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitOR:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseOr;                            case 2:                              if (op[0] == op[1])                                  return Script.Operator.BooleanOr;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitXOR:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseXor;                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitNOT:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseNot;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Equal:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.ValueEquality;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.IdentityEquality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case Not:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.LogicalNot;                            case 2:                              if (op[1] == Equal)                                  return Script.Operator.ValueInequality;                              else                                  throw new ParseException(ExUnexpected);                            case 3:                              if (op[1] == Equal && op[2] == Equal)                                  return Script.Operator.IdentityInequality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case AssignPre:                      if (op.Length > 1 && op[1] == Equal)                          return Script.Operator.Assign;                      else                          return Script.Operator.TernaryB;                    case Concatenate:                      return Script.Operator.Concat;                    case TernaryA:                      if (op.Length > 1 && op[1] == TernaryA)                          return Script.Operator.NullAssign;                      else                          return Script.Operator.TernaryA;                    default:                      switch (code.ToLowerInvariant())                      {                          case NotTxt:                              return Script.Operator.LogicalNotEx;                            case AndTxt:                              return Script.Operator.BooleanAnd;                            case OrTxt:                              return Script.Operator.BooleanOr;                            case IsTxt:                              return Script.Operator.Is;                      }                      throw new ArgumentOutOfRangeException();              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorFromString,The following statement contains a magic number: switch (op[0])              {                  case Add:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Add;                            case 2:                              return Script.Operator.Increment;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Minus:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Subtract;                            case 2:                              return Script.Operator.Decrement;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Multiply:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Multiply;                            case 2:                              return Script.Operator.Power;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Divide:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Divide;                            case 2:                              return Script.Operator.FloorDivide;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Greater:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.GreaterThan;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.BitShiftRight;                              else if (op[1] == Equal)                                  return Script.Operator.GreaterThanOrEqual;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case Less:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.LessThan;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.BitShiftLeft;                              else if (op[1] == Equal)                                  return Script.Operator.LessThanOrEqual;                              else if (op[1] == Greater)                                  return Script.Operator.ValueInequality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitAND:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseAnd;                            case 2:                              if (op[0] == op[1])                                  return Script.Operator.BooleanAnd;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitOR:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseOr;                            case 2:                              if (op[0] == op[1])                                  return Script.Operator.BooleanOr;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitXOR:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseXor;                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitNOT:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseNot;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Equal:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.ValueEquality;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.IdentityEquality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case Not:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.LogicalNot;                            case 2:                              if (op[1] == Equal)                                  return Script.Operator.ValueInequality;                              else                                  throw new ParseException(ExUnexpected);                            case 3:                              if (op[1] == Equal && op[2] == Equal)                                  return Script.Operator.IdentityInequality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case AssignPre:                      if (op.Length > 1 && op[1] == Equal)                          return Script.Operator.Assign;                      else                          return Script.Operator.TernaryB;                    case Concatenate:                      return Script.Operator.Concat;                    case TernaryA:                      if (op.Length > 1 && op[1] == TernaryA)                          return Script.Operator.NullAssign;                      else                          return Script.Operator.TernaryA;                    default:                      switch (code.ToLowerInvariant())                      {                          case NotTxt:                              return Script.Operator.LogicalNotEx;                            case AndTxt:                              return Script.Operator.BooleanAnd;                            case OrTxt:                              return Script.Operator.BooleanOr;                            case IsTxt:                              return Script.Operator.Is;                      }                      throw new ArgumentOutOfRangeException();              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorFromString,The following statement contains a magic number: switch (op[0])              {                  case Add:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Add;                            case 2:                              return Script.Operator.Increment;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Minus:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Subtract;                            case 2:                              return Script.Operator.Decrement;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Multiply:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Multiply;                            case 2:                              return Script.Operator.Power;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Divide:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Divide;                            case 2:                              return Script.Operator.FloorDivide;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Greater:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.GreaterThan;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.BitShiftRight;                              else if (op[1] == Equal)                                  return Script.Operator.GreaterThanOrEqual;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case Less:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.LessThan;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.BitShiftLeft;                              else if (op[1] == Equal)                                  return Script.Operator.LessThanOrEqual;                              else if (op[1] == Greater)                                  return Script.Operator.ValueInequality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitAND:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseAnd;                            case 2:                              if (op[0] == op[1])                                  return Script.Operator.BooleanAnd;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitOR:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseOr;                            case 2:                              if (op[0] == op[1])                                  return Script.Operator.BooleanOr;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitXOR:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseXor;                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitNOT:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseNot;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Equal:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.ValueEquality;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.IdentityEquality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case Not:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.LogicalNot;                            case 2:                              if (op[1] == Equal)                                  return Script.Operator.ValueInequality;                              else                                  throw new ParseException(ExUnexpected);                            case 3:                              if (op[1] == Equal && op[2] == Equal)                                  return Script.Operator.IdentityInequality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case AssignPre:                      if (op.Length > 1 && op[1] == Equal)                          return Script.Operator.Assign;                      else                          return Script.Operator.TernaryB;                    case Concatenate:                      return Script.Operator.Concat;                    case TernaryA:                      if (op.Length > 1 && op[1] == TernaryA)                          return Script.Operator.NullAssign;                      else                          return Script.Operator.TernaryA;                    default:                      switch (code.ToLowerInvariant())                      {                          case NotTxt:                              return Script.Operator.LogicalNotEx;                            case AndTxt:                              return Script.Operator.BooleanAnd;                            case OrTxt:                              return Script.Operator.BooleanOr;                            case IsTxt:                              return Script.Operator.Is;                      }                      throw new ArgumentOutOfRangeException();              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorFromString,The following statement contains a magic number: switch (op[0])              {                  case Add:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Add;                            case 2:                              return Script.Operator.Increment;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Minus:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Subtract;                            case 2:                              return Script.Operator.Decrement;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Multiply:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Multiply;                            case 2:                              return Script.Operator.Power;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Divide:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Divide;                            case 2:                              return Script.Operator.FloorDivide;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Greater:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.GreaterThan;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.BitShiftRight;                              else if (op[1] == Equal)                                  return Script.Operator.GreaterThanOrEqual;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case Less:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.LessThan;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.BitShiftLeft;                              else if (op[1] == Equal)                                  return Script.Operator.LessThanOrEqual;                              else if (op[1] == Greater)                                  return Script.Operator.ValueInequality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitAND:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseAnd;                            case 2:                              if (op[0] == op[1])                                  return Script.Operator.BooleanAnd;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitOR:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseOr;                            case 2:                              if (op[0] == op[1])                                  return Script.Operator.BooleanOr;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitXOR:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseXor;                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitNOT:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseNot;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Equal:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.ValueEquality;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.IdentityEquality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case Not:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.LogicalNot;                            case 2:                              if (op[1] == Equal)                                  return Script.Operator.ValueInequality;                              else                                  throw new ParseException(ExUnexpected);                            case 3:                              if (op[1] == Equal && op[2] == Equal)                                  return Script.Operator.IdentityInequality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case AssignPre:                      if (op.Length > 1 && op[1] == Equal)                          return Script.Operator.Assign;                      else                          return Script.Operator.TernaryB;                    case Concatenate:                      return Script.Operator.Concat;                    case TernaryA:                      if (op.Length > 1 && op[1] == TernaryA)                          return Script.Operator.NullAssign;                      else                          return Script.Operator.TernaryA;                    default:                      switch (code.ToLowerInvariant())                      {                          case NotTxt:                              return Script.Operator.LogicalNotEx;                            case AndTxt:                              return Script.Operator.BooleanAnd;                            case OrTxt:                              return Script.Operator.BooleanOr;                            case IsTxt:                              return Script.Operator.Is;                      }                      throw new ArgumentOutOfRangeException();              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorFromString,The following statement contains a magic number: switch (op[0])              {                  case Add:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Add;                            case 2:                              return Script.Operator.Increment;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Minus:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Subtract;                            case 2:                              return Script.Operator.Decrement;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Multiply:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Multiply;                            case 2:                              return Script.Operator.Power;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Divide:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Divide;                            case 2:                              return Script.Operator.FloorDivide;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Greater:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.GreaterThan;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.BitShiftRight;                              else if (op[1] == Equal)                                  return Script.Operator.GreaterThanOrEqual;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case Less:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.LessThan;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.BitShiftLeft;                              else if (op[1] == Equal)                                  return Script.Operator.LessThanOrEqual;                              else if (op[1] == Greater)                                  return Script.Operator.ValueInequality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitAND:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseAnd;                            case 2:                              if (op[0] == op[1])                                  return Script.Operator.BooleanAnd;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitOR:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseOr;                            case 2:                              if (op[0] == op[1])                                  return Script.Operator.BooleanOr;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitXOR:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseXor;                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitNOT:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseNot;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Equal:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.ValueEquality;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.IdentityEquality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case Not:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.LogicalNot;                            case 2:                              if (op[1] == Equal)                                  return Script.Operator.ValueInequality;                              else                                  throw new ParseException(ExUnexpected);                            case 3:                              if (op[1] == Equal && op[2] == Equal)                                  return Script.Operator.IdentityInequality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case AssignPre:                      if (op.Length > 1 && op[1] == Equal)                          return Script.Operator.Assign;                      else                          return Script.Operator.TernaryB;                    case Concatenate:                      return Script.Operator.Concat;                    case TernaryA:                      if (op.Length > 1 && op[1] == TernaryA)                          return Script.Operator.NullAssign;                      else                          return Script.Operator.TernaryA;                    default:                      switch (code.ToLowerInvariant())                      {                          case NotTxt:                              return Script.Operator.LogicalNotEx;                            case AndTxt:                              return Script.Operator.BooleanAnd;                            case OrTxt:                              return Script.Operator.BooleanOr;                            case IsTxt:                              return Script.Operator.Is;                      }                      throw new ArgumentOutOfRangeException();              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorFromString,The following statement contains a magic number: switch (op[0])              {                  case Add:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Add;                            case 2:                              return Script.Operator.Increment;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Minus:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Subtract;                            case 2:                              return Script.Operator.Decrement;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Multiply:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Multiply;                            case 2:                              return Script.Operator.Power;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Divide:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Divide;                            case 2:                              return Script.Operator.FloorDivide;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Greater:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.GreaterThan;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.BitShiftRight;                              else if (op[1] == Equal)                                  return Script.Operator.GreaterThanOrEqual;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case Less:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.LessThan;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.BitShiftLeft;                              else if (op[1] == Equal)                                  return Script.Operator.LessThanOrEqual;                              else if (op[1] == Greater)                                  return Script.Operator.ValueInequality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitAND:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseAnd;                            case 2:                              if (op[0] == op[1])                                  return Script.Operator.BooleanAnd;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitOR:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseOr;                            case 2:                              if (op[0] == op[1])                                  return Script.Operator.BooleanOr;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitXOR:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseXor;                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitNOT:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseNot;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Equal:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.ValueEquality;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.IdentityEquality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case Not:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.LogicalNot;                            case 2:                              if (op[1] == Equal)                                  return Script.Operator.ValueInequality;                              else                                  throw new ParseException(ExUnexpected);                            case 3:                              if (op[1] == Equal && op[2] == Equal)                                  return Script.Operator.IdentityInequality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case AssignPre:                      if (op.Length > 1 && op[1] == Equal)                          return Script.Operator.Assign;                      else                          return Script.Operator.TernaryB;                    case Concatenate:                      return Script.Operator.Concat;                    case TernaryA:                      if (op.Length > 1 && op[1] == TernaryA)                          return Script.Operator.NullAssign;                      else                          return Script.Operator.TernaryA;                    default:                      switch (code.ToLowerInvariant())                      {                          case NotTxt:                              return Script.Operator.LogicalNotEx;                            case AndTxt:                              return Script.Operator.BooleanAnd;                            case OrTxt:                              return Script.Operator.BooleanOr;                            case IsTxt:                              return Script.Operator.Is;                      }                      throw new ArgumentOutOfRangeException();              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorFromString,The following statement contains a magic number: switch (op[0])              {                  case Add:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Add;                            case 2:                              return Script.Operator.Increment;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Minus:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Subtract;                            case 2:                              return Script.Operator.Decrement;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Multiply:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Multiply;                            case 2:                              return Script.Operator.Power;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Divide:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Divide;                            case 2:                              return Script.Operator.FloorDivide;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Greater:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.GreaterThan;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.BitShiftRight;                              else if (op[1] == Equal)                                  return Script.Operator.GreaterThanOrEqual;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case Less:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.LessThan;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.BitShiftLeft;                              else if (op[1] == Equal)                                  return Script.Operator.LessThanOrEqual;                              else if (op[1] == Greater)                                  return Script.Operator.ValueInequality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitAND:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseAnd;                            case 2:                              if (op[0] == op[1])                                  return Script.Operator.BooleanAnd;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitOR:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseOr;                            case 2:                              if (op[0] == op[1])                                  return Script.Operator.BooleanOr;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitXOR:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseXor;                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitNOT:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseNot;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Equal:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.ValueEquality;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.IdentityEquality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case Not:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.LogicalNot;                            case 2:                              if (op[1] == Equal)                                  return Script.Operator.ValueInequality;                              else                                  throw new ParseException(ExUnexpected);                            case 3:                              if (op[1] == Equal && op[2] == Equal)                                  return Script.Operator.IdentityInequality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case AssignPre:                      if (op.Length > 1 && op[1] == Equal)                          return Script.Operator.Assign;                      else                          return Script.Operator.TernaryB;                    case Concatenate:                      return Script.Operator.Concat;                    case TernaryA:                      if (op.Length > 1 && op[1] == TernaryA)                          return Script.Operator.NullAssign;                      else                          return Script.Operator.TernaryA;                    default:                      switch (code.ToLowerInvariant())                      {                          case NotTxt:                              return Script.Operator.LogicalNotEx;                            case AndTxt:                              return Script.Operator.BooleanAnd;                            case OrTxt:                              return Script.Operator.BooleanOr;                            case IsTxt:                              return Script.Operator.Is;                      }                      throw new ArgumentOutOfRangeException();              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorFromString,The following statement contains a magic number: switch (op[0])              {                  case Add:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Add;                            case 2:                              return Script.Operator.Increment;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Minus:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Subtract;                            case 2:                              return Script.Operator.Decrement;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Multiply:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Multiply;                            case 2:                              return Script.Operator.Power;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Divide:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Divide;                            case 2:                              return Script.Operator.FloorDivide;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Greater:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.GreaterThan;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.BitShiftRight;                              else if (op[1] == Equal)                                  return Script.Operator.GreaterThanOrEqual;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case Less:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.LessThan;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.BitShiftLeft;                              else if (op[1] == Equal)                                  return Script.Operator.LessThanOrEqual;                              else if (op[1] == Greater)                                  return Script.Operator.ValueInequality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitAND:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseAnd;                            case 2:                              if (op[0] == op[1])                                  return Script.Operator.BooleanAnd;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitOR:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseOr;                            case 2:                              if (op[0] == op[1])                                  return Script.Operator.BooleanOr;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitXOR:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseXor;                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitNOT:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseNot;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Equal:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.ValueEquality;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.IdentityEquality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case Not:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.LogicalNot;                            case 2:                              if (op[1] == Equal)                                  return Script.Operator.ValueInequality;                              else                                  throw new ParseException(ExUnexpected);                            case 3:                              if (op[1] == Equal && op[2] == Equal)                                  return Script.Operator.IdentityInequality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case AssignPre:                      if (op.Length > 1 && op[1] == Equal)                          return Script.Operator.Assign;                      else                          return Script.Operator.TernaryB;                    case Concatenate:                      return Script.Operator.Concat;                    case TernaryA:                      if (op.Length > 1 && op[1] == TernaryA)                          return Script.Operator.NullAssign;                      else                          return Script.Operator.TernaryA;                    default:                      switch (code.ToLowerInvariant())                      {                          case NotTxt:                              return Script.Operator.LogicalNotEx;                            case AndTxt:                              return Script.Operator.BooleanAnd;                            case OrTxt:                              return Script.Operator.BooleanOr;                            case IsTxt:                              return Script.Operator.Is;                      }                      throw new ArgumentOutOfRangeException();              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorFromString,The following statement contains a magic number: switch (op[0])              {                  case Add:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Add;                            case 2:                              return Script.Operator.Increment;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Minus:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Subtract;                            case 2:                              return Script.Operator.Decrement;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Multiply:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Multiply;                            case 2:                              return Script.Operator.Power;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Divide:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.Divide;                            case 2:                              return Script.Operator.FloorDivide;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Greater:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.GreaterThan;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.BitShiftRight;                              else if (op[1] == Equal)                                  return Script.Operator.GreaterThanOrEqual;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case Less:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.LessThan;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.BitShiftLeft;                              else if (op[1] == Equal)                                  return Script.Operator.LessThanOrEqual;                              else if (op[1] == Greater)                                  return Script.Operator.ValueInequality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitAND:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseAnd;                            case 2:                              if (op[0] == op[1])                                  return Script.Operator.BooleanAnd;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitOR:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseOr;                            case 2:                              if (op[0] == op[1])                                  return Script.Operator.BooleanOr;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitXOR:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseXor;                            default:                              throw new ParseException(ExUnexpected);                      }                    case BitNOT:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.BitwiseNot;                            default:                              throw new ParseException(ExUnexpected);                      }                    case Equal:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.ValueEquality;                            case 2:                              if (op[1] == op[0])                                  return Script.Operator.IdentityEquality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case Not:                      switch (op.Length)                      {                          case 1:                              return Script.Operator.LogicalNot;                            case 2:                              if (op[1] == Equal)                                  return Script.Operator.ValueInequality;                              else                                  throw new ParseException(ExUnexpected);                            case 3:                              if (op[1] == Equal && op[2] == Equal)                                  return Script.Operator.IdentityInequality;                              else                                  throw new ParseException(ExUnexpected);                            default:                              throw new ParseException(ExUnexpected);                      }                    case AssignPre:                      if (op.Length > 1 && op[1] == Equal)                          return Script.Operator.Assign;                      else                          return Script.Operator.TernaryB;                    case Concatenate:                      return Script.Operator.Concat;                    case TernaryA:                      if (op.Length > 1 && op[1] == TernaryA)                          return Script.Operator.NullAssign;                      else                          return Script.Operator.TernaryA;                    default:                      switch (code.ToLowerInvariant())                      {                          case NotTxt:                              return Script.Operator.LogicalNotEx;                            case AndTxt:                              return Script.Operator.BooleanAnd;                            case OrTxt:                              return Script.Operator.BooleanOr;                            case IsTxt:                              return Script.Operator.Is;                      }                      throw new ArgumentOutOfRangeException();              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorPrecedence,The following statement contains a magic number: switch (op)              {                  case Script.Operator.Power:                      return -1;                    case Script.Operator.Minus:                  case Script.Operator.LogicalNot:                  case Script.Operator.BitwiseNot:                  case Script.Operator.Address:                  case Script.Operator.Dereference:                      return -2;                    case Script.Operator.Multiply:                  case Script.Operator.Divide:                  case Script.Operator.FloorDivide:                      return -3;                    case Script.Operator.Add:                  case Script.Operator.Subtract:                      return -4;                    case Script.Operator.BitShiftLeft:                  case Script.Operator.BitShiftRight:                      return -5;                    case Script.Operator.BitwiseAnd:                  case Script.Operator.BitwiseXor:                  case Script.Operator.BitwiseOr:                      return -6;                    case Script.Operator.Concat:                      return -7;                    case Script.Operator.GreaterThan:                  case Script.Operator.LessThan:                  case Script.Operator.GreaterThanOrEqual:                  case Script.Operator.LessThanOrEqual:                  case Script.Operator.Is:                      return -8;                    case Script.Operator.ValueEquality:                  case Script.Operator.IdentityEquality:                  case Script.Operator.ValueInequality:                  case Script.Operator.IdentityInequality:                      return -9;                    case Script.Operator.LogicalNotEx:                      return -10;                    case Script.Operator.BooleanAnd:                  case Script.Operator.BooleanOr:                      return -11;                    case Script.Operator.TernaryA:                  case Script.Operator.TernaryB:                  case Script.Operator.NullAssign:                      return -12;                    case Script.Operator.Assign:                      return -13;                    default:                      throw new ArgumentOutOfRangeException();              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorPrecedence,The following statement contains a magic number: switch (op)              {                  case Script.Operator.Power:                      return -1;                    case Script.Operator.Minus:                  case Script.Operator.LogicalNot:                  case Script.Operator.BitwiseNot:                  case Script.Operator.Address:                  case Script.Operator.Dereference:                      return -2;                    case Script.Operator.Multiply:                  case Script.Operator.Divide:                  case Script.Operator.FloorDivide:                      return -3;                    case Script.Operator.Add:                  case Script.Operator.Subtract:                      return -4;                    case Script.Operator.BitShiftLeft:                  case Script.Operator.BitShiftRight:                      return -5;                    case Script.Operator.BitwiseAnd:                  case Script.Operator.BitwiseXor:                  case Script.Operator.BitwiseOr:                      return -6;                    case Script.Operator.Concat:                      return -7;                    case Script.Operator.GreaterThan:                  case Script.Operator.LessThan:                  case Script.Operator.GreaterThanOrEqual:                  case Script.Operator.LessThanOrEqual:                  case Script.Operator.Is:                      return -8;                    case Script.Operator.ValueEquality:                  case Script.Operator.IdentityEquality:                  case Script.Operator.ValueInequality:                  case Script.Operator.IdentityInequality:                      return -9;                    case Script.Operator.LogicalNotEx:                      return -10;                    case Script.Operator.BooleanAnd:                  case Script.Operator.BooleanOr:                      return -11;                    case Script.Operator.TernaryA:                  case Script.Operator.TernaryB:                  case Script.Operator.NullAssign:                      return -12;                    case Script.Operator.Assign:                      return -13;                    default:                      throw new ArgumentOutOfRangeException();              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorPrecedence,The following statement contains a magic number: switch (op)              {                  case Script.Operator.Power:                      return -1;                    case Script.Operator.Minus:                  case Script.Operator.LogicalNot:                  case Script.Operator.BitwiseNot:                  case Script.Operator.Address:                  case Script.Operator.Dereference:                      return -2;                    case Script.Operator.Multiply:                  case Script.Operator.Divide:                  case Script.Operator.FloorDivide:                      return -3;                    case Script.Operator.Add:                  case Script.Operator.Subtract:                      return -4;                    case Script.Operator.BitShiftLeft:                  case Script.Operator.BitShiftRight:                      return -5;                    case Script.Operator.BitwiseAnd:                  case Script.Operator.BitwiseXor:                  case Script.Operator.BitwiseOr:                      return -6;                    case Script.Operator.Concat:                      return -7;                    case Script.Operator.GreaterThan:                  case Script.Operator.LessThan:                  case Script.Operator.GreaterThanOrEqual:                  case Script.Operator.LessThanOrEqual:                  case Script.Operator.Is:                      return -8;                    case Script.Operator.ValueEquality:                  case Script.Operator.IdentityEquality:                  case Script.Operator.ValueInequality:                  case Script.Operator.IdentityInequality:                      return -9;                    case Script.Operator.LogicalNotEx:                      return -10;                    case Script.Operator.BooleanAnd:                  case Script.Operator.BooleanOr:                      return -11;                    case Script.Operator.TernaryA:                  case Script.Operator.TernaryB:                  case Script.Operator.NullAssign:                      return -12;                    case Script.Operator.Assign:                      return -13;                    default:                      throw new ArgumentOutOfRangeException();              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorPrecedence,The following statement contains a magic number: switch (op)              {                  case Script.Operator.Power:                      return -1;                    case Script.Operator.Minus:                  case Script.Operator.LogicalNot:                  case Script.Operator.BitwiseNot:                  case Script.Operator.Address:                  case Script.Operator.Dereference:                      return -2;                    case Script.Operator.Multiply:                  case Script.Operator.Divide:                  case Script.Operator.FloorDivide:                      return -3;                    case Script.Operator.Add:                  case Script.Operator.Subtract:                      return -4;                    case Script.Operator.BitShiftLeft:                  case Script.Operator.BitShiftRight:                      return -5;                    case Script.Operator.BitwiseAnd:                  case Script.Operator.BitwiseXor:                  case Script.Operator.BitwiseOr:                      return -6;                    case Script.Operator.Concat:                      return -7;                    case Script.Operator.GreaterThan:                  case Script.Operator.LessThan:                  case Script.Operator.GreaterThanOrEqual:                  case Script.Operator.LessThanOrEqual:                  case Script.Operator.Is:                      return -8;                    case Script.Operator.ValueEquality:                  case Script.Operator.IdentityEquality:                  case Script.Operator.ValueInequality:                  case Script.Operator.IdentityInequality:                      return -9;                    case Script.Operator.LogicalNotEx:                      return -10;                    case Script.Operator.BooleanAnd:                  case Script.Operator.BooleanOr:                      return -11;                    case Script.Operator.TernaryA:                  case Script.Operator.TernaryB:                  case Script.Operator.NullAssign:                      return -12;                    case Script.Operator.Assign:                      return -13;                    default:                      throw new ArgumentOutOfRangeException();              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorPrecedence,The following statement contains a magic number: switch (op)              {                  case Script.Operator.Power:                      return -1;                    case Script.Operator.Minus:                  case Script.Operator.LogicalNot:                  case Script.Operator.BitwiseNot:                  case Script.Operator.Address:                  case Script.Operator.Dereference:                      return -2;                    case Script.Operator.Multiply:                  case Script.Operator.Divide:                  case Script.Operator.FloorDivide:                      return -3;                    case Script.Operator.Add:                  case Script.Operator.Subtract:                      return -4;                    case Script.Operator.BitShiftLeft:                  case Script.Operator.BitShiftRight:                      return -5;                    case Script.Operator.BitwiseAnd:                  case Script.Operator.BitwiseXor:                  case Script.Operator.BitwiseOr:                      return -6;                    case Script.Operator.Concat:                      return -7;                    case Script.Operator.GreaterThan:                  case Script.Operator.LessThan:                  case Script.Operator.GreaterThanOrEqual:                  case Script.Operator.LessThanOrEqual:                  case Script.Operator.Is:                      return -8;                    case Script.Operator.ValueEquality:                  case Script.Operator.IdentityEquality:                  case Script.Operator.ValueInequality:                  case Script.Operator.IdentityInequality:                      return -9;                    case Script.Operator.LogicalNotEx:                      return -10;                    case Script.Operator.BooleanAnd:                  case Script.Operator.BooleanOr:                      return -11;                    case Script.Operator.TernaryA:                  case Script.Operator.TernaryB:                  case Script.Operator.NullAssign:                      return -12;                    case Script.Operator.Assign:                      return -13;                    default:                      throw new ArgumentOutOfRangeException();              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorPrecedence,The following statement contains a magic number: switch (op)              {                  case Script.Operator.Power:                      return -1;                    case Script.Operator.Minus:                  case Script.Operator.LogicalNot:                  case Script.Operator.BitwiseNot:                  case Script.Operator.Address:                  case Script.Operator.Dereference:                      return -2;                    case Script.Operator.Multiply:                  case Script.Operator.Divide:                  case Script.Operator.FloorDivide:                      return -3;                    case Script.Operator.Add:                  case Script.Operator.Subtract:                      return -4;                    case Script.Operator.BitShiftLeft:                  case Script.Operator.BitShiftRight:                      return -5;                    case Script.Operator.BitwiseAnd:                  case Script.Operator.BitwiseXor:                  case Script.Operator.BitwiseOr:                      return -6;                    case Script.Operator.Concat:                      return -7;                    case Script.Operator.GreaterThan:                  case Script.Operator.LessThan:                  case Script.Operator.GreaterThanOrEqual:                  case Script.Operator.LessThanOrEqual:                  case Script.Operator.Is:                      return -8;                    case Script.Operator.ValueEquality:                  case Script.Operator.IdentityEquality:                  case Script.Operator.ValueInequality:                  case Script.Operator.IdentityInequality:                      return -9;                    case Script.Operator.LogicalNotEx:                      return -10;                    case Script.Operator.BooleanAnd:                  case Script.Operator.BooleanOr:                      return -11;                    case Script.Operator.TernaryA:                  case Script.Operator.TernaryB:                  case Script.Operator.NullAssign:                      return -12;                    case Script.Operator.Assign:                      return -13;                    default:                      throw new ArgumentOutOfRangeException();              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorPrecedence,The following statement contains a magic number: switch (op)              {                  case Script.Operator.Power:                      return -1;                    case Script.Operator.Minus:                  case Script.Operator.LogicalNot:                  case Script.Operator.BitwiseNot:                  case Script.Operator.Address:                  case Script.Operator.Dereference:                      return -2;                    case Script.Operator.Multiply:                  case Script.Operator.Divide:                  case Script.Operator.FloorDivide:                      return -3;                    case Script.Operator.Add:                  case Script.Operator.Subtract:                      return -4;                    case Script.Operator.BitShiftLeft:                  case Script.Operator.BitShiftRight:                      return -5;                    case Script.Operator.BitwiseAnd:                  case Script.Operator.BitwiseXor:                  case Script.Operator.BitwiseOr:                      return -6;                    case Script.Operator.Concat:                      return -7;                    case Script.Operator.GreaterThan:                  case Script.Operator.LessThan:                  case Script.Operator.GreaterThanOrEqual:                  case Script.Operator.LessThanOrEqual:                  case Script.Operator.Is:                      return -8;                    case Script.Operator.ValueEquality:                  case Script.Operator.IdentityEquality:                  case Script.Operator.ValueInequality:                  case Script.Operator.IdentityInequality:                      return -9;                    case Script.Operator.LogicalNotEx:                      return -10;                    case Script.Operator.BooleanAnd:                  case Script.Operator.BooleanOr:                      return -11;                    case Script.Operator.TernaryA:                  case Script.Operator.TernaryB:                  case Script.Operator.NullAssign:                      return -12;                    case Script.Operator.Assign:                      return -13;                    default:                      throw new ArgumentOutOfRangeException();              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorPrecedence,The following statement contains a magic number: switch (op)              {                  case Script.Operator.Power:                      return -1;                    case Script.Operator.Minus:                  case Script.Operator.LogicalNot:                  case Script.Operator.BitwiseNot:                  case Script.Operator.Address:                  case Script.Operator.Dereference:                      return -2;                    case Script.Operator.Multiply:                  case Script.Operator.Divide:                  case Script.Operator.FloorDivide:                      return -3;                    case Script.Operator.Add:                  case Script.Operator.Subtract:                      return -4;                    case Script.Operator.BitShiftLeft:                  case Script.Operator.BitShiftRight:                      return -5;                    case Script.Operator.BitwiseAnd:                  case Script.Operator.BitwiseXor:                  case Script.Operator.BitwiseOr:                      return -6;                    case Script.Operator.Concat:                      return -7;                    case Script.Operator.GreaterThan:                  case Script.Operator.LessThan:                  case Script.Operator.GreaterThanOrEqual:                  case Script.Operator.LessThanOrEqual:                  case Script.Operator.Is:                      return -8;                    case Script.Operator.ValueEquality:                  case Script.Operator.IdentityEquality:                  case Script.Operator.ValueInequality:                  case Script.Operator.IdentityInequality:                      return -9;                    case Script.Operator.LogicalNotEx:                      return -10;                    case Script.Operator.BooleanAnd:                  case Script.Operator.BooleanOr:                      return -11;                    case Script.Operator.TernaryA:                  case Script.Operator.TernaryB:                  case Script.Operator.NullAssign:                      return -12;                    case Script.Operator.Assign:                      return -13;                    default:                      throw new ArgumentOutOfRangeException();              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorPrecedence,The following statement contains a magic number: switch (op)              {                  case Script.Operator.Power:                      return -1;                    case Script.Operator.Minus:                  case Script.Operator.LogicalNot:                  case Script.Operator.BitwiseNot:                  case Script.Operator.Address:                  case Script.Operator.Dereference:                      return -2;                    case Script.Operator.Multiply:                  case Script.Operator.Divide:                  case Script.Operator.FloorDivide:                      return -3;                    case Script.Operator.Add:                  case Script.Operator.Subtract:                      return -4;                    case Script.Operator.BitShiftLeft:                  case Script.Operator.BitShiftRight:                      return -5;                    case Script.Operator.BitwiseAnd:                  case Script.Operator.BitwiseXor:                  case Script.Operator.BitwiseOr:                      return -6;                    case Script.Operator.Concat:                      return -7;                    case Script.Operator.GreaterThan:                  case Script.Operator.LessThan:                  case Script.Operator.GreaterThanOrEqual:                  case Script.Operator.LessThanOrEqual:                  case Script.Operator.Is:                      return -8;                    case Script.Operator.ValueEquality:                  case Script.Operator.IdentityEquality:                  case Script.Operator.ValueInequality:                  case Script.Operator.IdentityInequality:                      return -9;                    case Script.Operator.LogicalNotEx:                      return -10;                    case Script.Operator.BooleanAnd:                  case Script.Operator.BooleanOr:                      return -11;                    case Script.Operator.TernaryA:                  case Script.Operator.TernaryB:                  case Script.Operator.NullAssign:                      return -12;                    case Script.Operator.Assign:                      return -13;                    default:                      throw new ArgumentOutOfRangeException();              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorPrecedence,The following statement contains a magic number: switch (op)              {                  case Script.Operator.Power:                      return -1;                    case Script.Operator.Minus:                  case Script.Operator.LogicalNot:                  case Script.Operator.BitwiseNot:                  case Script.Operator.Address:                  case Script.Operator.Dereference:                      return -2;                    case Script.Operator.Multiply:                  case Script.Operator.Divide:                  case Script.Operator.FloorDivide:                      return -3;                    case Script.Operator.Add:                  case Script.Operator.Subtract:                      return -4;                    case Script.Operator.BitShiftLeft:                  case Script.Operator.BitShiftRight:                      return -5;                    case Script.Operator.BitwiseAnd:                  case Script.Operator.BitwiseXor:                  case Script.Operator.BitwiseOr:                      return -6;                    case Script.Operator.Concat:                      return -7;                    case Script.Operator.GreaterThan:                  case Script.Operator.LessThan:                  case Script.Operator.GreaterThanOrEqual:                  case Script.Operator.LessThanOrEqual:                  case Script.Operator.Is:                      return -8;                    case Script.Operator.ValueEquality:                  case Script.Operator.IdentityEquality:                  case Script.Operator.ValueInequality:                  case Script.Operator.IdentityInequality:                      return -9;                    case Script.Operator.LogicalNotEx:                      return -10;                    case Script.Operator.BooleanAnd:                  case Script.Operator.BooleanOr:                      return -11;                    case Script.Operator.TernaryA:                  case Script.Operator.TernaryB:                  case Script.Operator.NullAssign:                      return -12;                    case Script.Operator.Assign:                      return -13;                    default:                      throw new ArgumentOutOfRangeException();              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorPrecedence,The following statement contains a magic number: switch (op)              {                  case Script.Operator.Power:                      return -1;                    case Script.Operator.Minus:                  case Script.Operator.LogicalNot:                  case Script.Operator.BitwiseNot:                  case Script.Operator.Address:                  case Script.Operator.Dereference:                      return -2;                    case Script.Operator.Multiply:                  case Script.Operator.Divide:                  case Script.Operator.FloorDivide:                      return -3;                    case Script.Operator.Add:                  case Script.Operator.Subtract:                      return -4;                    case Script.Operator.BitShiftLeft:                  case Script.Operator.BitShiftRight:                      return -5;                    case Script.Operator.BitwiseAnd:                  case Script.Operator.BitwiseXor:                  case Script.Operator.BitwiseOr:                      return -6;                    case Script.Operator.Concat:                      return -7;                    case Script.Operator.GreaterThan:                  case Script.Operator.LessThan:                  case Script.Operator.GreaterThanOrEqual:                  case Script.Operator.LessThanOrEqual:                  case Script.Operator.Is:                      return -8;                    case Script.Operator.ValueEquality:                  case Script.Operator.IdentityEquality:                  case Script.Operator.ValueInequality:                  case Script.Operator.IdentityInequality:                      return -9;                    case Script.Operator.LogicalNotEx:                      return -10;                    case Script.Operator.BooleanAnd:                  case Script.Operator.BooleanOr:                      return -11;                    case Script.Operator.TernaryA:                  case Script.Operator.TernaryB:                  case Script.Operator.NullAssign:                      return -12;                    case Script.Operator.Assign:                      return -13;                    default:                      throw new ArgumentOutOfRangeException();              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorPrecedence,The following statement contains a magic number: switch (op)              {                  case Script.Operator.Power:                      return -1;                    case Script.Operator.Minus:                  case Script.Operator.LogicalNot:                  case Script.Operator.BitwiseNot:                  case Script.Operator.Address:                  case Script.Operator.Dereference:                      return -2;                    case Script.Operator.Multiply:                  case Script.Operator.Divide:                  case Script.Operator.FloorDivide:                      return -3;                    case Script.Operator.Add:                  case Script.Operator.Subtract:                      return -4;                    case Script.Operator.BitShiftLeft:                  case Script.Operator.BitShiftRight:                      return -5;                    case Script.Operator.BitwiseAnd:                  case Script.Operator.BitwiseXor:                  case Script.Operator.BitwiseOr:                      return -6;                    case Script.Operator.Concat:                      return -7;                    case Script.Operator.GreaterThan:                  case Script.Operator.LessThan:                  case Script.Operator.GreaterThanOrEqual:                  case Script.Operator.LessThanOrEqual:                  case Script.Operator.Is:                      return -8;                    case Script.Operator.ValueEquality:                  case Script.Operator.IdentityEquality:                  case Script.Operator.ValueInequality:                  case Script.Operator.IdentityInequality:                      return -9;                    case Script.Operator.LogicalNotEx:                      return -10;                    case Script.Operator.BooleanAnd:                  case Script.Operator.BooleanOr:                      return -11;                    case Script.Operator.TernaryA:                  case Script.Operator.TernaryB:                  case Script.Operator.NullAssign:                      return -12;                    case Script.Operator.Assign:                      return -13;                    default:                      throw new ArgumentOutOfRangeException();              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsAssignOp,The following statement contains a magic number: if (!(code.Length == 2 || code.Length == 3))                  return false;
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsAssignOp,The following statement contains a magic number: if (!(code.Length == 2 || code.Length == 3))                  return false;
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsAssignOp,The following statement contains a magic number: if (code.Length == 3)              {                  if (code[0] == code[1])                  {                      switch (code[0])                      {                          case Greater:                          case Less:                          case Divide:                              return true;                            default:                              return false;                      }                  }                  else                      return false;              }              else              {                  switch (code[0])                  {                      case Greater:                      case Less:                      case Not:                          return false;                        default:                          return true;                  }              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitTokens,The following statement contains a magic number: for (int i = 0; i < code.Length; i++)              {                  char sym = code[i];                    #region Spaces                  if (IsSpace(sym))                      continue;                  #endregion                  #region Comments                  else if (IsCommentAt(code' i))                      MoveToEOL(code' ref i);                  #endregion                  #region Identifiers                  else if (IsIdentifier(sym) || sym == Resolve || (sym == Concatenate && i + 1 < code.Length && IsIdentifier(code[i + 1])))                  {                      var id = new StringBuilder(code.Length);                      id.Append(sym);                      i++;                                            // UNDONE: optimise split tokens                        for (; i < code.Length; i++)                      {                          sym = code[i];                          if ((sym == 'e' || sym == 'E') && IsPrimativeObject(id.ToString()) && id.ToString().IndexOf("0x") != 0 && i + 1 < code.Length)                          {                              id.Append(sym);                              sym = code[++i];                              if (!(sym == '+' || sym == '-' || char.IsDigit(sym)))                                  throw new ParseException(ExInvalidExponent);                              id.Append(sym);                          }                          else if (IsIdentifier(sym) || sym == Resolve || (sym == Concatenate && (i + 1 < code.Length ? code[i + 1] != Equal : true)))                              id.Append(sym);                          else                          {                              if (sym == ParenOpen && !IsKeyword(id.ToString()) && !id.ToString().Contains(Concatenate.ToString()))                                  id.Append(ParenOpen);                              else                                  i--;                              break;                          }                      }                        string seq = id.ToString();                      var parts = IsPrimativeObject(seq) ? new[] { seq } : seq.Split(Concatenate);                        if (parts[0].Length != 0)                          list.Add(parts[0]);                        for (int n = 1; n < parts.Length; n++)                      {                          list.Add(ArrayOpen.ToString());                          string str = StringBound.ToString();                          list.Add(string.Concat(str' parts[n]' str));                          list.Add(ArrayClose.ToString());                      }                  }                  #endregion                  #region Strings                  else if (sym == StringBound)                  {                      var str = new StringBuilder(code.Length);                      str.Append(StringBound);                      i++;                        for (int max = code.Length + 1; i < max; i++)                      {                          if (i == code.Length)                              throw new ParseException(ExUntermStr);                            sym = code[i];                          str.Append(sym);                            if (sym == StringBound)                          {                              int n = i + 1;                              if (n < code.Length && code[n] == StringBound)                                  i = n;                              else                                  break;                          }                      }                        list.Add(str.ToString());                  }                  #endregion                  #region Operators                  else                  {                      var op = new StringBuilder(3);                      int n = i + 1;                      char symNext = n < code.Length ? code[n] : Reserved;                      bool tri = false;                        #region 3x                      if (sym == symNext)                      {                          bool peekAssign = false;                            switch (sym)                          {                              case Divide:                              case Greater:                              case Less:                                  peekAssign = true;                                  goto case Add;                                case Add:                              case Minus:                              case Multiply:                              case BitOR:                              case BitAND:                                  op.Append(sym);                                  op.Append(symNext);                                  i++;                                  tri = true;                                  if (peekAssign)                                  {                                      n = i + 1;                                      if (n < code.Length && code[n] == Equal)                                      {                                          op.Append(code[n]);                                          i = n;                                      }                                  }                                  break;                          }                      }                      #endregion                        if (!tri)                      {                          #region 2x                          if (symNext == Equal)                          {                              switch (sym)                              {                                  case AssignPre:                                  case Add:                                  case Minus:                                  case Multiply:                                  case Divide:                                  case Concatenate:                                  case BitAND:                                  case BitXOR:                                  case BitOR:                                  case Not:                                  case Equal:                                  case Greater:                                  case Less:                                      op.Append(sym);                                      op.Append(symNext);                                      i++;                                      break;                              }                          }                          else if ((sym == Less && symNext == Greater) || (sym == TernaryA && symNext == TernaryA))                          {                              op.Append(sym);                              op.Append(symNext);                              i++;                          }                          #endregion                          #region 1x                          else                          {                              switch (sym)                              {                                  case Add:                                  case Minus:                                  case Multiply:                                  case Not:                                  case BitNOT:                                  case BitAND:                                  case Greater:                                  case Less:                                  case BitXOR:                                  case BitOR:                                  case ParenOpen:                                  case ParenClose:                                  case Equal:                                  case Concatenate:                                  case TernaryB:                                  case Divide:                                  case ArrayOpen:                                  case ArrayClose:                                      op.Append(sym);                                      break;                                    case BlockOpen:                                      if (json)                                      {                                          op.Append(sym);                                          break;                                      }                                      blockOpen = true;                                      int j = i + 2;                                      if (j < code.Length && !IsCommentAt(code' j))                                      {                                          blockOpen = false;                                          json = true;                                          goto case BlockOpen;                                      }                                      j--;                                      if (j < code.Length)                                      {                                          if (code[j] == BlockClose)                                          {                                              json = true;                                              goto case BlockClose;                                          }                                          else if (!IsSpace(code[j]))                                              throw new ParseException(ExUnexpected);                                      }                                      return list;                                    case BlockClose:                                      if (!json)                                          goto default;                                      op.Append(sym);                                      break;                                    default:                                      if (sym == Resolve || sym == Multicast)                                          goto case Add;                                      throw new ParseException(ExUnexpected);                              }                          }                          #endregion                      }                        if (op.Length == 0)                          op.Append(sym);                      list.Add(op.ToString());                  }                  #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitTokens,The following statement contains a magic number: for (int i = 0; i < code.Length; i++)              {                  char sym = code[i];                    #region Spaces                  if (IsSpace(sym))                      continue;                  #endregion                  #region Comments                  else if (IsCommentAt(code' i))                      MoveToEOL(code' ref i);                  #endregion                  #region Identifiers                  else if (IsIdentifier(sym) || sym == Resolve || (sym == Concatenate && i + 1 < code.Length && IsIdentifier(code[i + 1])))                  {                      var id = new StringBuilder(code.Length);                      id.Append(sym);                      i++;                                            // UNDONE: optimise split tokens                        for (; i < code.Length; i++)                      {                          sym = code[i];                          if ((sym == 'e' || sym == 'E') && IsPrimativeObject(id.ToString()) && id.ToString().IndexOf("0x") != 0 && i + 1 < code.Length)                          {                              id.Append(sym);                              sym = code[++i];                              if (!(sym == '+' || sym == '-' || char.IsDigit(sym)))                                  throw new ParseException(ExInvalidExponent);                              id.Append(sym);                          }                          else if (IsIdentifier(sym) || sym == Resolve || (sym == Concatenate && (i + 1 < code.Length ? code[i + 1] != Equal : true)))                              id.Append(sym);                          else                          {                              if (sym == ParenOpen && !IsKeyword(id.ToString()) && !id.ToString().Contains(Concatenate.ToString()))                                  id.Append(ParenOpen);                              else                                  i--;                              break;                          }                      }                        string seq = id.ToString();                      var parts = IsPrimativeObject(seq) ? new[] { seq } : seq.Split(Concatenate);                        if (parts[0].Length != 0)                          list.Add(parts[0]);                        for (int n = 1; n < parts.Length; n++)                      {                          list.Add(ArrayOpen.ToString());                          string str = StringBound.ToString();                          list.Add(string.Concat(str' parts[n]' str));                          list.Add(ArrayClose.ToString());                      }                  }                  #endregion                  #region Strings                  else if (sym == StringBound)                  {                      var str = new StringBuilder(code.Length);                      str.Append(StringBound);                      i++;                        for (int max = code.Length + 1; i < max; i++)                      {                          if (i == code.Length)                              throw new ParseException(ExUntermStr);                            sym = code[i];                          str.Append(sym);                            if (sym == StringBound)                          {                              int n = i + 1;                              if (n < code.Length && code[n] == StringBound)                                  i = n;                              else                                  break;                          }                      }                        list.Add(str.ToString());                  }                  #endregion                  #region Operators                  else                  {                      var op = new StringBuilder(3);                      int n = i + 1;                      char symNext = n < code.Length ? code[n] : Reserved;                      bool tri = false;                        #region 3x                      if (sym == symNext)                      {                          bool peekAssign = false;                            switch (sym)                          {                              case Divide:                              case Greater:                              case Less:                                  peekAssign = true;                                  goto case Add;                                case Add:                              case Minus:                              case Multiply:                              case BitOR:                              case BitAND:                                  op.Append(sym);                                  op.Append(symNext);                                  i++;                                  tri = true;                                  if (peekAssign)                                  {                                      n = i + 1;                                      if (n < code.Length && code[n] == Equal)                                      {                                          op.Append(code[n]);                                          i = n;                                      }                                  }                                  break;                          }                      }                      #endregion                        if (!tri)                      {                          #region 2x                          if (symNext == Equal)                          {                              switch (sym)                              {                                  case AssignPre:                                  case Add:                                  case Minus:                                  case Multiply:                                  case Divide:                                  case Concatenate:                                  case BitAND:                                  case BitXOR:                                  case BitOR:                                  case Not:                                  case Equal:                                  case Greater:                                  case Less:                                      op.Append(sym);                                      op.Append(symNext);                                      i++;                                      break;                              }                          }                          else if ((sym == Less && symNext == Greater) || (sym == TernaryA && symNext == TernaryA))                          {                              op.Append(sym);                              op.Append(symNext);                              i++;                          }                          #endregion                          #region 1x                          else                          {                              switch (sym)                              {                                  case Add:                                  case Minus:                                  case Multiply:                                  case Not:                                  case BitNOT:                                  case BitAND:                                  case Greater:                                  case Less:                                  case BitXOR:                                  case BitOR:                                  case ParenOpen:                                  case ParenClose:                                  case Equal:                                  case Concatenate:                                  case TernaryB:                                  case Divide:                                  case ArrayOpen:                                  case ArrayClose:                                      op.Append(sym);                                      break;                                    case BlockOpen:                                      if (json)                                      {                                          op.Append(sym);                                          break;                                      }                                      blockOpen = true;                                      int j = i + 2;                                      if (j < code.Length && !IsCommentAt(code' j))                                      {                                          blockOpen = false;                                          json = true;                                          goto case BlockOpen;                                      }                                      j--;                                      if (j < code.Length)                                      {                                          if (code[j] == BlockClose)                                          {                                              json = true;                                              goto case BlockClose;                                          }                                          else if (!IsSpace(code[j]))                                              throw new ParseException(ExUnexpected);                                      }                                      return list;                                    case BlockClose:                                      if (!json)                                          goto default;                                      op.Append(sym);                                      break;                                    default:                                      if (sym == Resolve || sym == Multicast)                                          goto case Add;                                      throw new ParseException(ExUnexpected);                              }                          }                          #endregion                      }                        if (op.Length == 0)                          op.Append(sym);                      list.Add(op.ToString());                  }                  #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: for (int i = 0; i < parts.Length; i++)              {                  if (IsExpressionParameter(parts[i]))                  {                      int e = parts[i].IndexOf(Resolve) + 1;                      if (e < parts[i].Length)                          parts[i] = parts[i].Substring(e);                      else                          parts[i] = new string(StringBound' 2);                  }                  else                  {                      parts[i] = parts[i].TrimStart(Spaces);                      int l = parts[i].Length;                      if (l > 1 && parts[i][0] == Resolve && parts[i][l - 1] == Resolve)                          parts[i] = parts[i].Substring(1' l - 2);                      else                      {                          string str = StringBound.ToString();                          parts[i] = string.Concat(str' parts[i]' str);                      }                  }              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: for (int i = 0; i < parts.Length; i++)              {                  if (IsExpressionParameter(parts[i]))                  {                      int e = parts[i].IndexOf(Resolve) + 1;                      if (e < parts[i].Length)                          parts[i] = parts[i].Substring(e);                      else                          parts[i] = new string(StringBound' 2);                  }                  else                  {                      parts[i] = parts[i].TrimStart(Spaces);                      int l = parts[i].Length;                      if (l > 1 && parts[i][0] == Resolve && parts[i][l - 1] == Resolve)                          parts[i] = parts[i].Substring(1' l - 2);                      else                      {                          string str = StringBound.ToString();                          parts[i] = string.Concat(str' parts[i]' str);                      }                  }              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following statement contains a magic number: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParameterPrepend,The following statement contains a magic number: if (IsExpressionParameter(param))              {                  var buffer = new StringBuilder(param.Length + insert.Length + 2);                  buffer.Append(Resolve);                  buffer.Append(SingleSpace);                  buffer.Append(StringBound);                  buffer.Append(insert);                  buffer.Append(StringBound);                  buffer.Append(SingleSpace);                  buffer.Append(Concatenate);                  buffer.Append(SingleSpace);                  buffer.Append(param' 2' param.Length - 2);                  param = buffer.ToString();              }              else                  param = string.Concat(insert' param);
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParameterPrepend,The following statement contains a magic number: if (IsExpressionParameter(param))              {                  var buffer = new StringBuilder(param.Length + insert.Length + 2);                  buffer.Append(Resolve);                  buffer.Append(SingleSpace);                  buffer.Append(StringBound);                  buffer.Append(insert);                  buffer.Append(StringBound);                  buffer.Append(SingleSpace);                  buffer.Append(Concatenate);                  buffer.Append(SingleSpace);                  buffer.Append(param' 2' param.Length - 2);                  param = buffer.ToString();              }              else                  param = string.Concat(insert' param);
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParameterPrepend,The following statement contains a magic number: if (IsExpressionParameter(param))              {                  var buffer = new StringBuilder(param.Length + insert.Length + 2);                  buffer.Append(Resolve);                  buffer.Append(SingleSpace);                  buffer.Append(StringBound);                  buffer.Append(insert);                  buffer.Append(StringBound);                  buffer.Append(SingleSpace);                  buffer.Append(Concatenate);                  buffer.Append(SingleSpace);                  buffer.Append(param' 2' param.Length - 2);                  param = buffer.ToString();              }              else                  param = string.Concat(insert' param);
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,CloseBlock,The following statement contains a magic number: if (blocks.Count < (skip ? 2 : 1))                  return;
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsIdentifier,The following statement contains a magic number: if (token[0] == TernaryA && (token.Length == 1 || token.Length == 2 && token[1] == TernaryA))                  return false;
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsPrimativeObject,The following statement contains a magic number: exp:              if (x != 0)              {                  if (!xf)                      throw new ParseException(ExInvalidExponent);                  result = (double)result * Math.Pow(10' x);              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsLegacyIf,The following statement contains a magic number: string[] part = code.TrimStart(Spaces).Split(Spaces' 3);
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsLegacyIf,The following statement contains a magic number: if (part.Length < 2 || !IsIdentifier(part[0]))                  return false;
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseHotkey,The following statement contains a magic number: string[] parts = code.Split(new[] { HotkeySignal }' 2' StringSplitOptions.None);
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseHotkey,The following statement contains a magic number: if (hotstring)              {                  invoke = (CodeMethodInvokeExpression)InternalMethods.Hotstring;                  invoke.Parameters.Add(new CodePrimitiveExpression(parts[0].Substring(mode.Length)));                  invoke.Parameters.Add(new CodePrimitiveExpression(name));                    string options = mode.Substring(1' mode.Length - 2);                  if (!string.IsNullOrEmpty(HotstringNewOptions))                      options = string.Concat(HotstringNewOptions' SingleSpace.ToString()' options);                  invoke.Parameters.Add(new CodePrimitiveExpression(options));              }              else              {                  invoke = (CodeMethodInvokeExpression)InternalMethods.Hotkey;                  invoke.Parameters.Add(new CodePrimitiveExpression(parts[0]));                  invoke.Parameters.Add(new CodePrimitiveExpression(name));                  invoke.Parameters.Add(new CodePrimitiveExpression(string.Empty));              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,MultilineString,The following statement contains a magic number: if (line.Length > 2)              {                  if (line.Contains("%"))                  {                      percentResolve = false;                      line = line.Replace("%"' string.Empty);                  }                  if (line.Contains("`"))                  {                      literalEscape = true;                      line = line.Replace("`"' string.Empty);                  }                  if (line.Contains("'"))                      line = line.Replace("'"' string.Empty);                    string[] options = line.Substring(1).Trim().Split(Spaces' StringSplitOptions.RemoveEmptyEntries);                  foreach (var option in options)                  {                      switch (option.ToUpperInvariant())                      {                          case "LTRIM":                              ltrim = true;                              break;                            case "RTRIM":                              break;                            case "RTRIM0":                              rtrim = false;                              break;                            case "COMMENTS":                          case "COMMENT":                          case "COM":                          case "C":                              stripComments = false;                              break;                            case "JOIN":                              join = string.Empty;                              break;                            default:                              const string joinOpt = "join";                              if (option.Length > joinOpt.Length && option.Substring(0' joinOpt.Length).Equals(joinOpt' StringComparison.OrdinalIgnoreCase))                                  join = option.Substring(joinOpt.Length).Replace("`s"' " ");                              else                                  throw new ParseException(ExMultiStr);                              break;                      }                  }              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,MultilineString,The following statement contains a magic number: var escapeEscaped = new string(Escape' 2);
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,EscapedString,The following statement contains a magic number: var buffer = new StringBuilder(code.Length + 32);
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseAssign,The following statement contains a magic number: CodeExpression result = value == null ? new CodePrimitiveExpression(null) :                  IsExpressionParameter(value) ? ParseSingleExpression(value.TrimStart(Spaces).Substring(2)) : VarIdExpand(value);
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitCommandParameters,The following statement contains a magic number: for (int i = 0; i < code.Length; i++)              {                  char sym = code[i];                    if (str)                  {                      if (sym == StringBound)                          str = !str;                      else if (sym == Multicast)                          goto delim;                      continue;                  }                  else if (IsCommentAt(code' i))                      break;                    if (start)                  {                      if (IsSpace(sym))                          continue;                      else                      {                          start = false;                          int n = i + 1;                          expr = sym == Resolve && (n < code.Length ? IsSpace(code[n]) : true);                          n = parts.Count;                          if (exp != null && exp.Length > n && exp[n])                              expr = true;                      }                  }                    if (expr)                  {                      switch (sym)                      {                          case StringBound: str = !str; break;                          case ParenOpen: levels[0]++; break;                          case ParenClose: levels[0]--; break;                          case BlockOpen: levels[1]++; break;                          case BlockClose: levels[1]--; break;                          case ArrayOpen: levels[2]++; break;                          case ArrayClose: levels[2]--; break;                      }                  }                                delim:                  if (sym == Multicast && (i == 0 || code[i - 1] != Escape) && !str && levels[0] == 0 && levels[1] == 0 && levels[2] == 0)                  {                      parts.Add(code.Substring(last' i - last));                      last = i + 1;                      start = true;                      expr = false;                  }              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitCommandParameters,The following statement contains a magic number: for (int i = 0; i < code.Length; i++)              {                  char sym = code[i];                    if (str)                  {                      if (sym == StringBound)                          str = !str;                      else if (sym == Multicast)                          goto delim;                      continue;                  }                  else if (IsCommentAt(code' i))                      break;                    if (start)                  {                      if (IsSpace(sym))                          continue;                      else                      {                          start = false;                          int n = i + 1;                          expr = sym == Resolve && (n < code.Length ? IsSpace(code[n]) : true);                          n = parts.Count;                          if (exp != null && exp.Length > n && exp[n])                              expr = true;                      }                  }                    if (expr)                  {                      switch (sym)                      {                          case StringBound: str = !str; break;                          case ParenOpen: levels[0]++; break;                          case ParenClose: levels[0]--; break;                          case BlockOpen: levels[1]++; break;                          case BlockClose: levels[1]--; break;                          case ArrayOpen: levels[2]++; break;                          case ArrayClose: levels[2]--; break;                      }                  }                                delim:                  if (sym == Multicast && (i == 0 || code[i - 1] != Escape) && !str && levels[0] == 0 && levels[1] == 0 && levels[2] == 0)                  {                      parts.Add(code.Substring(last' i - last));                      last = i + 1;                      start = true;                      expr = false;                  }              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitCommandParameters,The following statement contains a magic number: for (int i = 0; i < code.Length; i++)              {                  char sym = code[i];                    if (str)                  {                      if (sym == StringBound)                          str = !str;                      else if (sym == Multicast)                          goto delim;                      continue;                  }                  else if (IsCommentAt(code' i))                      break;                    if (start)                  {                      if (IsSpace(sym))                          continue;                      else                      {                          start = false;                          int n = i + 1;                          expr = sym == Resolve && (n < code.Length ? IsSpace(code[n]) : true);                          n = parts.Count;                          if (exp != null && exp.Length > n && exp[n])                              expr = true;                      }                  }                    if (expr)                  {                      switch (sym)                      {                          case StringBound: str = !str; break;                          case ParenOpen: levels[0]++; break;                          case ParenClose: levels[0]--; break;                          case BlockOpen: levels[1]++; break;                          case BlockClose: levels[1]--; break;                          case ArrayOpen: levels[2]++; break;                          case ArrayClose: levels[2]--; break;                      }                  }                                delim:                  if (sym == Multicast && (i == 0 || code[i - 1] != Escape) && !str && levels[0] == 0 && levels[1] == 0 && levels[2] == 0)                  {                      parts.Add(code.Substring(last' i - last));                      last = i + 1;                      start = true;                      expr = false;                  }              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseCommandParameter,The following statement contains a magic number: if (expr && code.Length > 2 && code[0] == Resolve && code[code.Length - 1] == Resolve)                  code = code.Substring(1' code.Length - 2);
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseCommandParameter,The following statement contains a magic number: if (expr && code.Length > 2 && code[0] == Resolve && code[code.Length - 1] == Resolve)                  code = code.Substring(1' code.Length - 2);
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseCommandParameter,The following statement contains a magic number: if (IsExpressionParameter(code))              {                  code = code.Substring(2);                  expr = true;                  explicitExpr = true;              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseDirective,The following statement contains a magic number: if (code.Length < 2)                  throw new ParseException(ExUnknownDirv);
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseDirective,The following statement contains a magic number: string[] parts = code.Split(delim' 2);
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseDirective,The following statement contains a magic number: if (parts.Length != 2)                  parts = new[] { parts[0]' string.Empty };
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseDirective,The following statement contains a magic number: if (parts[1].Length == 0)              {                  numeric = false;                  sub = new[] { string.Empty' string.Empty };              }              else              {                  numeric = int.TryParse(parts[1]' out value);                  string[] split = parts[1].Split(new[] { Multicast }' 2);                  sub = new[] { split[0].Trim(Spaces)' split.Length > 1 ? split[1].Trim(Spaces) : string.Empty };              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseDirective,The following statement contains a magic number: switch (cmd.ToUpperInvariant())              {                  #region Assembly manifest                    case "ASSEMBLYTITLE":                      if (!string.IsNullOrEmpty(parts[1]))                          AddAssemblyAttribute(typeof(AssemblyTitleAttribute)' parts[1]);                      break;                    case "ASSEMBLYDESCRIPTION":                      if (!string.IsNullOrEmpty(parts[1]))                          AddAssemblyAttribute(typeof(AssemblyDescriptionAttribute)' parts[1]);                      break;                    case "ASSEMBLYCONFIGURATION":                      if (!string.IsNullOrEmpty(parts[1]))                          AddAssemblyAttribute(typeof(AssemblyConfigurationAttribute)' parts[1]);                      break;                    case "ASSEMBLYCOMPANY":                      if (!string.IsNullOrEmpty(parts[1]))                          AddAssemblyAttribute(typeof(AssemblyCompanyAttribute)' parts[1]);                      break;                    case "ASSEMBLYPRODUCT":                      if (!string.IsNullOrEmpty(parts[1]))                          AddAssemblyAttribute(typeof(AssemblyProductAttribute)' parts[1]);                      break;                    case "ASSEMBLYCOPYRIGHT":                      if (!string.IsNullOrEmpty(parts[1]))                          AddAssemblyAttribute(typeof(AssemblyCopyrightAttribute)' parts[1]);                      break;                    case "ASSEMBLYTRADEMARK":                      if (!string.IsNullOrEmpty(parts[1]))                          AddAssemblyAttribute(typeof(AssemblyTrademarkAttribute)' parts[1]);                      break;                    case "ASSEMBLYCULTURE":                      if (!string.IsNullOrEmpty(parts[1]))                          AddAssemblyAttribute(typeof(AssemblyCultureAttribute)' parts[1]);                      break;                    case "ASSEMBLYVERSION":                      if (!string.IsNullOrEmpty(parts[1]))                          AddAssemblyAttribute(typeof(AssemblyVersionAttribute)' parts[1]);                      break;                    case "ASSEMBLYMERGE":                      if (CompilerParameters is IACompilerParameters)                      {                          var options = (IACompilerParameters)CompilerParameters;                          options.Merge = true;                            switch (parts[1].ToUpperInvariant())                          {                              case "FORCE":                                  options.MergeFallbackToLink = false;                                  break;                                case "OFF":                                  options.Merge = false;                                  break;                          }                      }                      break;                    #endregion                    case "CLIPBOARDTIMEOUT":                      ClipboardTimeout = numeric ? value : ClipboardTimeoutDefault;                         break;                    case "COMMENTFLAG":                      if (parts[1].Length == 2 && parts[1][0] == MultiComA && parts[1][1] == MultiComB)                          throw new ParseException(ExIllegalCommentFlag);                      Comment = parts[1];                      break;                    case "DEREFCHAR":                      Resolve = parts[1][0];                      break;                    case "ESCAPECHAR":                      Escape = parts[1][0];                      break;                    case "DELIMITER":                      Multicast = parts[1][0];                      break;                    case "HOTSTRING":                      HotstringNewOptions = parts[1];                      break;                    case "IFWINACTIVE":                      IfWinActive_WinTitle = sub[0];                      IfWinActive_WinText = sub[1];                      goto case res;                    case "IFWINEXIST":                      IfWinExist_WinTitle = sub[0];                      IfWinExist_WinText = sub[1];                      goto case res;                    case "IFWINNOTACTIVE":                      IfWinNotExist_WinTitle = sub[0];                      IfWinNotActive_WinText = sub[1];                      goto case res;                    case "IFWINNOTEXIST":                      IfWinNotExist_WinTitle = sub[0];                      IfWinNotExist_WinText = sub[1];                      goto case res;                    case res:                      var cond = (CodeMethodInvokeExpression)InternalMethods.Hotkey;                      cond.Parameters.Add(new CodePrimitiveExpression(cmd));                      cond.Parameters.Add(new CodePrimitiveExpression(sub[0]));                      cond.Parameters.Add(new CodePrimitiveExpression(sub[1]));                      prepend.Add(cond);                      break;                    case "LTRIM":                      switch (sub[0].ToUpperInvariant())                      {                          case "":                          case "ON":                              LTrimForced = true;                              break;                            case "OFF":                              LTrimForced = false;                              break;                            default:                              throw new ParseException("Directive parameter must be either \"on\" or \"off\"");                      }                      break;                    default:                      throw new ParseException(ExUnknownDirv);              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseMultiExpression,The following statement contains a magic number: int n = tokens.Count - 2;
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The following statement contains a magic number: for (int i = 0; i < parts.Count; i++)              {                  if (parts[i] is string)                  {                      var part = (string)parts[i];                      object result;                        #region Parentheses                      if (part[0] == ParenOpen)                      {                          int n = i + 1;                          var paren = Dissect(parts' n' Set(parts' i));                          parts.RemoveAt(n);                          n -= 2;                            bool call = n > -1 && parts[n] is CodeExpression && !(parts[n] is CodePrimitiveExpression);                            if (call && parts[n] is CodeMethodInvokeExpression && ((CodeMethodInvokeExpression)parts[n]).Parameters[0] is CodeFieldReferenceExpression)                              call = false;                            if (call)                          {                              var invoke = (CodeMethodInvokeExpression)InternalMethods.Invoke;                                invoke.Parameters.Add((CodeExpression)parts[n]);                                if (paren.Count != 0)                              {                                  var passed = ParseMultiExpression(paren.ToArray());                                  invoke.Parameters.AddRange(passed);                              }                                  parts[i] = invoke;                              parts.RemoveAt(n);                          }                          else                          {                              if (paren.Count == 0)                                  parts.RemoveAt(i);                              else                                  parts[i] = ParseExpression(paren);                          }                      }                      else if (part[0] == ParenClose)                          rescan = true;                      #endregion                      #region Strings                      else if (part.Length > 1 && part[0] == StringBound && part[part.Length - 1] == StringBound)                          parts[i] = new CodePrimitiveExpression(EscapedString(part.Substring(1' part.Length - 2)' false));                      #endregion                      #region Numerics                      else if (IsPrimativeObject(part' out result))                          parts[i] = new CodePrimitiveExpression(result);                      #endregion                      #region Variables                      else if (IsIdentifier(part' true) && !IsKeyword(part))                      {                          var low = part.ToLowerInvariant();                            if (libProperties.ContainsKey(low))                              parts[i] = new CodePropertyReferenceExpression(new CodeTypeReferenceExpression(bcl)' libProperties[low]);                          else                              parts[i] = VarIdOrConstant(part);                      }                      #endregion                      #region JSON                      else if (part.Length == 1 && part[0] == BlockOpen)                      {                          int n = i + 1;                          var paren = Dissect(parts' n' Set(parts' i));                            var invoke = (CodeMethodInvokeExpression)InternalMethods.Dictionary;                          CodePrimitiveExpression[] keys;                          CodeExpression[] values;                          ParseObject(paren' out keys' out values);                          invoke.Parameters.Add(new CodeArrayCreateExpression(typeof(string)' keys));                          invoke.Parameters.Add(new CodeArrayCreateExpression(typeof(object)' values));                            parts[i] = invoke;                          parts.RemoveAt(n);                          i--;                      }                      else if (part.Length == 1 && part[0] == ArrayOpen)                      {                          int n = i + 1;                          var paren = Dissect(parts' n' Set(parts' i));                          parts.RemoveAt(n);                            if (i > 0 && parts[i - 1] is CodeExpression)                          {                              var invoke = (CodeMethodInvokeExpression)InternalMethods.Index;                              n = i - 1;                              invoke.Parameters.Add((CodeExpression)parts[n]);                                var index = ParseMultiExpression(paren.ToArray());                              if (index.Length > 1)                                  throw new ParseException("Cannot have multipart expression in index.");                              else if (index.Length == 0)                              {                                  var extend = (CodeMethodInvokeExpression)InternalMethods.ExtendArray;                                  var sub = new List<object>(1);                                  sub.Add(parts[n]);                                  extend.Parameters.Add(ParseExpression(sub));                                  invoke = extend;                              }                              else                                  invoke.Parameters.Add(index[0]);                                parts[i] = invoke;                              parts.RemoveAt(n);                              i--;                          }                          else                          {                              var array = new CodeArrayCreateExpression(typeof(object[])' ParseMultiExpression(paren.ToArray()));                              parts[i] = array;                          }                      }                      #endregion                      #region Invokes                      else if (part.Length > 1 && part[part.Length - 1] == ParenOpen)                      {                          string name = part.Substring(0' part.Length - 1);                          bool dynamic = false;                            if (!IsIdentifier(name))                          {                              if (IsDynamicReference(name))                                  dynamic = true;                              else                                  throw new ParseException("Invalid function name");                          }                          else                              CheckPersistent(name);                            int n = i + 1;                          var paren = Dissect(parts' n' Set(parts' i));                          parts.RemoveAt(n);                            CodeMethodInvokeExpression invoke;                            if (dynamic)                          {                              invoke = (CodeMethodInvokeExpression)InternalMethods.FunctionCall;                              invoke.Parameters.Add(VarIdExpand(name));                          }                          else                              invoke = LocalMethodInvoke(name);                            if (paren.Count != 0)                          {                              var passed = ParseMultiExpression(paren.ToArray());                              invoke.Parameters.AddRange(passed);                          }                            parts[i] = invoke;                          invokes.Add(invoke);                      }                      #endregion                      #region Assignments                      else if (IsAssignOp(part) || IsImplicitAssignment(parts' i))                      {                          int n = i - 1;                            if (i > 0 && IsJsonObject(parts[n])) { }                          else if (n < 0 || !IsVarReference(parts[n]))                          {                              if (LaxExpressions)                              {                                  if (parts[n] is CodePrimitiveExpression && ((CodePrimitiveExpression)parts[n]).Value is decimal)                                      parts[n] = VarId(((decimal)((CodePrimitiveExpression)parts[n]).Value).ToString());                              }                              else                                  throw new ParseException("Can only assign to a variable");                          }                                                    // (x += y) => (x = x + y)                          parts[i] = CodeBinaryOperatorType.Assign;                          if (part[0] != AssignPre && part.Length != 1)                          {                              parts.Insert(++i' ParenOpen.ToString());                              parts.Insert(++i' parts[i - 3]);                              if (part.Length > 1)                              {                                  parts.Insert(++i' OperatorFromString(part.Substring(0' part.Length - 1)));                                  parts.Insert(++i' ParenOpen.ToString());                                  parts.Add(ParenClose.ToString());                              }                              parts.Add(ParenClose.ToString());                          }                      }                      #endregion                      #region Multiple statements                      else if (part.Length == 1 && part[0] == Multicast)                      {                          if (!LaxExpressions)                              throw new ParseException("Nested multipart expression not allowed.");                            // implement as: + Dummy(expr..)                            int z = i + 1' l = parts.Count - z;                          var sub = new List<object>(l);                            for (; z < parts.Count; z++)                              sub.Add(parts[z]);                            parts.RemoveRange(i' parts.Count - i);                            var invoke = (CodeMethodInvokeExpression)InternalMethods.OperateZero;                          invoke.Parameters.Add(ParseExpression(sub));                            parts.Add(Script.Operator.Add);                          parts.Add(invoke);                      }                      #endregion                      #region Binary operators                      else                      {                          var ops = OperatorFromString(part);                            #region Increment/decrement                          if (ops == Script.Operator.Increment || ops == Script.Operator.Decrement)                          {                              int z = -1' x = i - 1' y = i + 1;                              int d = ops == Script.Operator.Increment ? 1 : -1;                              CodeMethodInvokeExpression shadow = null;                                // UNDONE: use generic approach to ++/-- for all types of operands?                               if (x > -1 && parts[x] is CodeMethodInvokeExpression)                              {                                  var sub = new List<object>(5);                                  sub.Add(parts[x]);                                  sub.Add(CodeBinaryOperatorType.Assign);                                  sub.Add(parts[x]);                                  sub.Add(Script.Operator.Add);                                  sub.Add(d);                                    parts.RemoveAt(i);                                  parts[x] = ParseExpression(sub);                                  i = x;                                  continue;                              }                                #region Compounding increment/decrement operators                                if (LaxExpressions)                              {                                  while (y < parts.Count)                                  {                                      Script.Operator nextOps = Script.Operator.ValueEquality;                                        if (parts[y] is Script.Operator)                                          nextOps = (Script.Operator)parts[y];                                      else if (parts[y] is string)                                      {                                          try { nextOps = OperatorFromString((string)parts[y]); }                                          catch { break; }                                      }                                      else                                          break;                                        if (nextOps == Script.Operator.Increment)                                          d++;                                      else if (nextOps == Script.Operator.Decrement)                                          d--;                                      else                                          break;                                        parts.RemoveAt(y);                                  }                              }                                #endregion                                if (x > -1 && (IsVarReference(parts[x]) || parts[x] is CodePropertyReferenceExpression))                                  z = x;                                if (y < parts.Count && parts[y] is string && !IsOperator((string)parts[y]))                              {                                  if (z != -1)                                  {                                      if (LaxExpressions)                                      {                                          parts.Insert(y' Script.Operator.Concat);                                          z = x;                                      }                                      else                                          throw new ParseException("Cannot use both prefix and postfix operators on the same variable");                                  }                                    if (z == -1)                                      z = y;                                    if (LaxExpressions)                                  {                                      if (parts[z] is string && ((string)parts[z]).Length == 1 && ((string)parts[z])[0] == ParenOpen)                                      {                                          var zx = new[] { z + 1' z + 2 };                                          if (zx[1] < parts.Count &&                                              parts[zx[1]] is string && ((string)parts[zx[1]]).Length == 1 && ((string)parts[zx[1]])[0] == ParenClose &&                                              (parts[zx[0]] is string && IsDynamicReference((string)parts[zx[0]]) || IsVarReference(parts[zx[0]])))                                          {                                              parts.RemoveAt(zx[1]);                                              parts.RemoveAt(z);                                          }                                          else                                          {                                              parts.RemoveAt(i);                                              i--;                                              continue;                                          }                                      }                                  }                              }                                if (z == -1)                              {                                  if (LaxExpressions)                                  {                                      if ((x > 0 && (parts[x] is CodeBinaryOperatorExpression || parts[x] is CodeMethodInvokeExpression || parts[x] is CodePrimitiveExpression)) ||                                          (y < parts.Count && (parts[y] is string && !IsOperator(parts[y] as string) || parts[y] is Script.Operator)))                                      {                                          parts.RemoveAt(i);                                          i--;                                          continue;                                      }                                  }                                  else                                      throw new ParseException("Neither left or right hand side of operator is a variable");                              }                                if (parts[z] is string && ((string)parts[z]).Length > 0 && ((string)parts[z])[0] == StringBound)                              {                                  parts.RemoveAt(Math.Max(i' z));                                  parts.RemoveAt(Math.Min(i' z));                                  continue;                              }                                if (LaxExpressions)                              {                                  int w = z + (z == x ? 2 : 1);                                  if (w < parts.Count && (parts[w] is string && IsAssignOp((string)parts[w]) || IsVarAssignment(parts[w])))                                  {                                      int l = parts.Count - w;                                      var sub = new List<object>(l + 1);                                        sub.Add(parts[z]);                                      for (int wx = w; wx < parts.Count; wx++)                                          sub.Add(parts[wx]);                                        shadow = (CodeMethodInvokeExpression)InternalMethods.OperateZero;                                      shadow.Parameters.Add(ParseExpression(sub));                                        parts.RemoveRange(w' l);                                  }                              }                                var list = new List<object>(9);                              list.Add(parts[z]);                              list.Add(new string(new[] { Add' Equal }));                              list.Add(new CodePrimitiveExpression(d));                              if (shadow != null)                              {                                  list.Add(Script.Operator.Add);                                  list.Add(shadow);                              }                              if (z < i) // postfix' so adjust                              {                                  list.Insert(0' ParenOpen.ToString());                                  list.Add(ParenClose.ToString());                                  list.Add(d > 0 ? Script.Operator.Minus : Script.Operator.Add);                                  list.Add(new CodePrimitiveExpression(d));                              }                                x = Math.Min(i' z);                              y = Math.Max(i' z);                              parts[x] = ParseExpression(list);                              parts.RemoveAt(y);                              i = x;                          }                          #endregion                          else                          {                              #region Dereference                              if (part.Length == 1 && part[0] == Dereference)                              {                                  bool deref = false;                                    if (i == 0)                                      deref = true;                                  else                                  {                                      int x = i - 1;                                      deref = parts[x] is Script.Operator || IsVarAssignment(parts[x]) ||                                          (parts[x] is string && ((string)parts[x]).Length == 1 && ((string)parts[x])[0] == '(');                                  }                                    if (deref)                                  {                                      int y = i + 1;                                      if (y < parts.Count && (IsVarReference(parts[y]) ||                                          (parts[y] is string && IsIdentifier((string)parts[y]) && !IsKeyword((string)parts[y]))))                                          ops = Script.Operator.Dereference;                                  }                              }                              #endregion                                parts[i] = ops;                          }                      }                      #endregion                  }              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The following statement contains a magic number: for (int i = 0; i < parts.Count; i++)              {                  if (parts[i] is string)                  {                      var part = (string)parts[i];                      object result;                        #region Parentheses                      if (part[0] == ParenOpen)                      {                          int n = i + 1;                          var paren = Dissect(parts' n' Set(parts' i));                          parts.RemoveAt(n);                          n -= 2;                            bool call = n > -1 && parts[n] is CodeExpression && !(parts[n] is CodePrimitiveExpression);                            if (call && parts[n] is CodeMethodInvokeExpression && ((CodeMethodInvokeExpression)parts[n]).Parameters[0] is CodeFieldReferenceExpression)                              call = false;                            if (call)                          {                              var invoke = (CodeMethodInvokeExpression)InternalMethods.Invoke;                                invoke.Parameters.Add((CodeExpression)parts[n]);                                if (paren.Count != 0)                              {                                  var passed = ParseMultiExpression(paren.ToArray());                                  invoke.Parameters.AddRange(passed);                              }                                  parts[i] = invoke;                              parts.RemoveAt(n);                          }                          else                          {                              if (paren.Count == 0)                                  parts.RemoveAt(i);                              else                                  parts[i] = ParseExpression(paren);                          }                      }                      else if (part[0] == ParenClose)                          rescan = true;                      #endregion                      #region Strings                      else if (part.Length > 1 && part[0] == StringBound && part[part.Length - 1] == StringBound)                          parts[i] = new CodePrimitiveExpression(EscapedString(part.Substring(1' part.Length - 2)' false));                      #endregion                      #region Numerics                      else if (IsPrimativeObject(part' out result))                          parts[i] = new CodePrimitiveExpression(result);                      #endregion                      #region Variables                      else if (IsIdentifier(part' true) && !IsKeyword(part))                      {                          var low = part.ToLowerInvariant();                            if (libProperties.ContainsKey(low))                              parts[i] = new CodePropertyReferenceExpression(new CodeTypeReferenceExpression(bcl)' libProperties[low]);                          else                              parts[i] = VarIdOrConstant(part);                      }                      #endregion                      #region JSON                      else if (part.Length == 1 && part[0] == BlockOpen)                      {                          int n = i + 1;                          var paren = Dissect(parts' n' Set(parts' i));                            var invoke = (CodeMethodInvokeExpression)InternalMethods.Dictionary;                          CodePrimitiveExpression[] keys;                          CodeExpression[] values;                          ParseObject(paren' out keys' out values);                          invoke.Parameters.Add(new CodeArrayCreateExpression(typeof(string)' keys));                          invoke.Parameters.Add(new CodeArrayCreateExpression(typeof(object)' values));                            parts[i] = invoke;                          parts.RemoveAt(n);                          i--;                      }                      else if (part.Length == 1 && part[0] == ArrayOpen)                      {                          int n = i + 1;                          var paren = Dissect(parts' n' Set(parts' i));                          parts.RemoveAt(n);                            if (i > 0 && parts[i - 1] is CodeExpression)                          {                              var invoke = (CodeMethodInvokeExpression)InternalMethods.Index;                              n = i - 1;                              invoke.Parameters.Add((CodeExpression)parts[n]);                                var index = ParseMultiExpression(paren.ToArray());                              if (index.Length > 1)                                  throw new ParseException("Cannot have multipart expression in index.");                              else if (index.Length == 0)                              {                                  var extend = (CodeMethodInvokeExpression)InternalMethods.ExtendArray;                                  var sub = new List<object>(1);                                  sub.Add(parts[n]);                                  extend.Parameters.Add(ParseExpression(sub));                                  invoke = extend;                              }                              else                                  invoke.Parameters.Add(index[0]);                                parts[i] = invoke;                              parts.RemoveAt(n);                              i--;                          }                          else                          {                              var array = new CodeArrayCreateExpression(typeof(object[])' ParseMultiExpression(paren.ToArray()));                              parts[i] = array;                          }                      }                      #endregion                      #region Invokes                      else if (part.Length > 1 && part[part.Length - 1] == ParenOpen)                      {                          string name = part.Substring(0' part.Length - 1);                          bool dynamic = false;                            if (!IsIdentifier(name))                          {                              if (IsDynamicReference(name))                                  dynamic = true;                              else                                  throw new ParseException("Invalid function name");                          }                          else                              CheckPersistent(name);                            int n = i + 1;                          var paren = Dissect(parts' n' Set(parts' i));                          parts.RemoveAt(n);                            CodeMethodInvokeExpression invoke;                            if (dynamic)                          {                              invoke = (CodeMethodInvokeExpression)InternalMethods.FunctionCall;                              invoke.Parameters.Add(VarIdExpand(name));                          }                          else                              invoke = LocalMethodInvoke(name);                            if (paren.Count != 0)                          {                              var passed = ParseMultiExpression(paren.ToArray());                              invoke.Parameters.AddRange(passed);                          }                            parts[i] = invoke;                          invokes.Add(invoke);                      }                      #endregion                      #region Assignments                      else if (IsAssignOp(part) || IsImplicitAssignment(parts' i))                      {                          int n = i - 1;                            if (i > 0 && IsJsonObject(parts[n])) { }                          else if (n < 0 || !IsVarReference(parts[n]))                          {                              if (LaxExpressions)                              {                                  if (parts[n] is CodePrimitiveExpression && ((CodePrimitiveExpression)parts[n]).Value is decimal)                                      parts[n] = VarId(((decimal)((CodePrimitiveExpression)parts[n]).Value).ToString());                              }                              else                                  throw new ParseException("Can only assign to a variable");                          }                                                    // (x += y) => (x = x + y)                          parts[i] = CodeBinaryOperatorType.Assign;                          if (part[0] != AssignPre && part.Length != 1)                          {                              parts.Insert(++i' ParenOpen.ToString());                              parts.Insert(++i' parts[i - 3]);                              if (part.Length > 1)                              {                                  parts.Insert(++i' OperatorFromString(part.Substring(0' part.Length - 1)));                                  parts.Insert(++i' ParenOpen.ToString());                                  parts.Add(ParenClose.ToString());                              }                              parts.Add(ParenClose.ToString());                          }                      }                      #endregion                      #region Multiple statements                      else if (part.Length == 1 && part[0] == Multicast)                      {                          if (!LaxExpressions)                              throw new ParseException("Nested multipart expression not allowed.");                            // implement as: + Dummy(expr..)                            int z = i + 1' l = parts.Count - z;                          var sub = new List<object>(l);                            for (; z < parts.Count; z++)                              sub.Add(parts[z]);                            parts.RemoveRange(i' parts.Count - i);                            var invoke = (CodeMethodInvokeExpression)InternalMethods.OperateZero;                          invoke.Parameters.Add(ParseExpression(sub));                            parts.Add(Script.Operator.Add);                          parts.Add(invoke);                      }                      #endregion                      #region Binary operators                      else                      {                          var ops = OperatorFromString(part);                            #region Increment/decrement                          if (ops == Script.Operator.Increment || ops == Script.Operator.Decrement)                          {                              int z = -1' x = i - 1' y = i + 1;                              int d = ops == Script.Operator.Increment ? 1 : -1;                              CodeMethodInvokeExpression shadow = null;                                // UNDONE: use generic approach to ++/-- for all types of operands?                               if (x > -1 && parts[x] is CodeMethodInvokeExpression)                              {                                  var sub = new List<object>(5);                                  sub.Add(parts[x]);                                  sub.Add(CodeBinaryOperatorType.Assign);                                  sub.Add(parts[x]);                                  sub.Add(Script.Operator.Add);                                  sub.Add(d);                                    parts.RemoveAt(i);                                  parts[x] = ParseExpression(sub);                                  i = x;                                  continue;                              }                                #region Compounding increment/decrement operators                                if (LaxExpressions)                              {                                  while (y < parts.Count)                                  {                                      Script.Operator nextOps = Script.Operator.ValueEquality;                                        if (parts[y] is Script.Operator)                                          nextOps = (Script.Operator)parts[y];                                      else if (parts[y] is string)                                      {                                          try { nextOps = OperatorFromString((string)parts[y]); }                                          catch { break; }                                      }                                      else                                          break;                                        if (nextOps == Script.Operator.Increment)                                          d++;                                      else if (nextOps == Script.Operator.Decrement)                                          d--;                                      else                                          break;                                        parts.RemoveAt(y);                                  }                              }                                #endregion                                if (x > -1 && (IsVarReference(parts[x]) || parts[x] is CodePropertyReferenceExpression))                                  z = x;                                if (y < parts.Count && parts[y] is string && !IsOperator((string)parts[y]))                              {                                  if (z != -1)                                  {                                      if (LaxExpressions)                                      {                                          parts.Insert(y' Script.Operator.Concat);                                          z = x;                                      }                                      else                                          throw new ParseException("Cannot use both prefix and postfix operators on the same variable");                                  }                                    if (z == -1)                                      z = y;                                    if (LaxExpressions)                                  {                                      if (parts[z] is string && ((string)parts[z]).Length == 1 && ((string)parts[z])[0] == ParenOpen)                                      {                                          var zx = new[] { z + 1' z + 2 };                                          if (zx[1] < parts.Count &&                                              parts[zx[1]] is string && ((string)parts[zx[1]]).Length == 1 && ((string)parts[zx[1]])[0] == ParenClose &&                                              (parts[zx[0]] is string && IsDynamicReference((string)parts[zx[0]]) || IsVarReference(parts[zx[0]])))                                          {                                              parts.RemoveAt(zx[1]);                                              parts.RemoveAt(z);                                          }                                          else                                          {                                              parts.RemoveAt(i);                                              i--;                                              continue;                                          }                                      }                                  }                              }                                if (z == -1)                              {                                  if (LaxExpressions)                                  {                                      if ((x > 0 && (parts[x] is CodeBinaryOperatorExpression || parts[x] is CodeMethodInvokeExpression || parts[x] is CodePrimitiveExpression)) ||                                          (y < parts.Count && (parts[y] is string && !IsOperator(parts[y] as string) || parts[y] is Script.Operator)))                                      {                                          parts.RemoveAt(i);                                          i--;                                          continue;                                      }                                  }                                  else                                      throw new ParseException("Neither left or right hand side of operator is a variable");                              }                                if (parts[z] is string && ((string)parts[z]).Length > 0 && ((string)parts[z])[0] == StringBound)                              {                                  parts.RemoveAt(Math.Max(i' z));                                  parts.RemoveAt(Math.Min(i' z));                                  continue;                              }                                if (LaxExpressions)                              {                                  int w = z + (z == x ? 2 : 1);                                  if (w < parts.Count && (parts[w] is string && IsAssignOp((string)parts[w]) || IsVarAssignment(parts[w])))                                  {                                      int l = parts.Count - w;                                      var sub = new List<object>(l + 1);                                        sub.Add(parts[z]);                                      for (int wx = w; wx < parts.Count; wx++)                                          sub.Add(parts[wx]);                                        shadow = (CodeMethodInvokeExpression)InternalMethods.OperateZero;                                      shadow.Parameters.Add(ParseExpression(sub));                                        parts.RemoveRange(w' l);                                  }                              }                                var list = new List<object>(9);                              list.Add(parts[z]);                              list.Add(new string(new[] { Add' Equal }));                              list.Add(new CodePrimitiveExpression(d));                              if (shadow != null)                              {                                  list.Add(Script.Operator.Add);                                  list.Add(shadow);                              }                              if (z < i) // postfix' so adjust                              {                                  list.Insert(0' ParenOpen.ToString());                                  list.Add(ParenClose.ToString());                                  list.Add(d > 0 ? Script.Operator.Minus : Script.Operator.Add);                                  list.Add(new CodePrimitiveExpression(d));                              }                                x = Math.Min(i' z);                              y = Math.Max(i' z);                              parts[x] = ParseExpression(list);                              parts.RemoveAt(y);                              i = x;                          }                          #endregion                          else                          {                              #region Dereference                              if (part.Length == 1 && part[0] == Dereference)                              {                                  bool deref = false;                                    if (i == 0)                                      deref = true;                                  else                                  {                                      int x = i - 1;                                      deref = parts[x] is Script.Operator || IsVarAssignment(parts[x]) ||                                          (parts[x] is string && ((string)parts[x]).Length == 1 && ((string)parts[x])[0] == '(');                                  }                                    if (deref)                                  {                                      int y = i + 1;                                      if (y < parts.Count && (IsVarReference(parts[y]) ||                                          (parts[y] is string && IsIdentifier((string)parts[y]) && !IsKeyword((string)parts[y]))))                                          ops = Script.Operator.Dereference;                                  }                              }                              #endregion                                parts[i] = ops;                          }                      }                      #endregion                  }              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The following statement contains a magic number: for (int i = 0; i < parts.Count; i++)              {                  if (parts[i] is string)                  {                      var part = (string)parts[i];                      object result;                        #region Parentheses                      if (part[0] == ParenOpen)                      {                          int n = i + 1;                          var paren = Dissect(parts' n' Set(parts' i));                          parts.RemoveAt(n);                          n -= 2;                            bool call = n > -1 && parts[n] is CodeExpression && !(parts[n] is CodePrimitiveExpression);                            if (call && parts[n] is CodeMethodInvokeExpression && ((CodeMethodInvokeExpression)parts[n]).Parameters[0] is CodeFieldReferenceExpression)                              call = false;                            if (call)                          {                              var invoke = (CodeMethodInvokeExpression)InternalMethods.Invoke;                                invoke.Parameters.Add((CodeExpression)parts[n]);                                if (paren.Count != 0)                              {                                  var passed = ParseMultiExpression(paren.ToArray());                                  invoke.Parameters.AddRange(passed);                              }                                  parts[i] = invoke;                              parts.RemoveAt(n);                          }                          else                          {                              if (paren.Count == 0)                                  parts.RemoveAt(i);                              else                                  parts[i] = ParseExpression(paren);                          }                      }                      else if (part[0] == ParenClose)                          rescan = true;                      #endregion                      #region Strings                      else if (part.Length > 1 && part[0] == StringBound && part[part.Length - 1] == StringBound)                          parts[i] = new CodePrimitiveExpression(EscapedString(part.Substring(1' part.Length - 2)' false));                      #endregion                      #region Numerics                      else if (IsPrimativeObject(part' out result))                          parts[i] = new CodePrimitiveExpression(result);                      #endregion                      #region Variables                      else if (IsIdentifier(part' true) && !IsKeyword(part))                      {                          var low = part.ToLowerInvariant();                            if (libProperties.ContainsKey(low))                              parts[i] = new CodePropertyReferenceExpression(new CodeTypeReferenceExpression(bcl)' libProperties[low]);                          else                              parts[i] = VarIdOrConstant(part);                      }                      #endregion                      #region JSON                      else if (part.Length == 1 && part[0] == BlockOpen)                      {                          int n = i + 1;                          var paren = Dissect(parts' n' Set(parts' i));                            var invoke = (CodeMethodInvokeExpression)InternalMethods.Dictionary;                          CodePrimitiveExpression[] keys;                          CodeExpression[] values;                          ParseObject(paren' out keys' out values);                          invoke.Parameters.Add(new CodeArrayCreateExpression(typeof(string)' keys));                          invoke.Parameters.Add(new CodeArrayCreateExpression(typeof(object)' values));                            parts[i] = invoke;                          parts.RemoveAt(n);                          i--;                      }                      else if (part.Length == 1 && part[0] == ArrayOpen)                      {                          int n = i + 1;                          var paren = Dissect(parts' n' Set(parts' i));                          parts.RemoveAt(n);                            if (i > 0 && parts[i - 1] is CodeExpression)                          {                              var invoke = (CodeMethodInvokeExpression)InternalMethods.Index;                              n = i - 1;                              invoke.Parameters.Add((CodeExpression)parts[n]);                                var index = ParseMultiExpression(paren.ToArray());                              if (index.Length > 1)                                  throw new ParseException("Cannot have multipart expression in index.");                              else if (index.Length == 0)                              {                                  var extend = (CodeMethodInvokeExpression)InternalMethods.ExtendArray;                                  var sub = new List<object>(1);                                  sub.Add(parts[n]);                                  extend.Parameters.Add(ParseExpression(sub));                                  invoke = extend;                              }                              else                                  invoke.Parameters.Add(index[0]);                                parts[i] = invoke;                              parts.RemoveAt(n);                              i--;                          }                          else                          {                              var array = new CodeArrayCreateExpression(typeof(object[])' ParseMultiExpression(paren.ToArray()));                              parts[i] = array;                          }                      }                      #endregion                      #region Invokes                      else if (part.Length > 1 && part[part.Length - 1] == ParenOpen)                      {                          string name = part.Substring(0' part.Length - 1);                          bool dynamic = false;                            if (!IsIdentifier(name))                          {                              if (IsDynamicReference(name))                                  dynamic = true;                              else                                  throw new ParseException("Invalid function name");                          }                          else                              CheckPersistent(name);                            int n = i + 1;                          var paren = Dissect(parts' n' Set(parts' i));                          parts.RemoveAt(n);                            CodeMethodInvokeExpression invoke;                            if (dynamic)                          {                              invoke = (CodeMethodInvokeExpression)InternalMethods.FunctionCall;                              invoke.Parameters.Add(VarIdExpand(name));                          }                          else                              invoke = LocalMethodInvoke(name);                            if (paren.Count != 0)                          {                              var passed = ParseMultiExpression(paren.ToArray());                              invoke.Parameters.AddRange(passed);                          }                            parts[i] = invoke;                          invokes.Add(invoke);                      }                      #endregion                      #region Assignments                      else if (IsAssignOp(part) || IsImplicitAssignment(parts' i))                      {                          int n = i - 1;                            if (i > 0 && IsJsonObject(parts[n])) { }                          else if (n < 0 || !IsVarReference(parts[n]))                          {                              if (LaxExpressions)                              {                                  if (parts[n] is CodePrimitiveExpression && ((CodePrimitiveExpression)parts[n]).Value is decimal)                                      parts[n] = VarId(((decimal)((CodePrimitiveExpression)parts[n]).Value).ToString());                              }                              else                                  throw new ParseException("Can only assign to a variable");                          }                                                    // (x += y) => (x = x + y)                          parts[i] = CodeBinaryOperatorType.Assign;                          if (part[0] != AssignPre && part.Length != 1)                          {                              parts.Insert(++i' ParenOpen.ToString());                              parts.Insert(++i' parts[i - 3]);                              if (part.Length > 1)                              {                                  parts.Insert(++i' OperatorFromString(part.Substring(0' part.Length - 1)));                                  parts.Insert(++i' ParenOpen.ToString());                                  parts.Add(ParenClose.ToString());                              }                              parts.Add(ParenClose.ToString());                          }                      }                      #endregion                      #region Multiple statements                      else if (part.Length == 1 && part[0] == Multicast)                      {                          if (!LaxExpressions)                              throw new ParseException("Nested multipart expression not allowed.");                            // implement as: + Dummy(expr..)                            int z = i + 1' l = parts.Count - z;                          var sub = new List<object>(l);                            for (; z < parts.Count; z++)                              sub.Add(parts[z]);                            parts.RemoveRange(i' parts.Count - i);                            var invoke = (CodeMethodInvokeExpression)InternalMethods.OperateZero;                          invoke.Parameters.Add(ParseExpression(sub));                            parts.Add(Script.Operator.Add);                          parts.Add(invoke);                      }                      #endregion                      #region Binary operators                      else                      {                          var ops = OperatorFromString(part);                            #region Increment/decrement                          if (ops == Script.Operator.Increment || ops == Script.Operator.Decrement)                          {                              int z = -1' x = i - 1' y = i + 1;                              int d = ops == Script.Operator.Increment ? 1 : -1;                              CodeMethodInvokeExpression shadow = null;                                // UNDONE: use generic approach to ++/-- for all types of operands?                               if (x > -1 && parts[x] is CodeMethodInvokeExpression)                              {                                  var sub = new List<object>(5);                                  sub.Add(parts[x]);                                  sub.Add(CodeBinaryOperatorType.Assign);                                  sub.Add(parts[x]);                                  sub.Add(Script.Operator.Add);                                  sub.Add(d);                                    parts.RemoveAt(i);                                  parts[x] = ParseExpression(sub);                                  i = x;                                  continue;                              }                                #region Compounding increment/decrement operators                                if (LaxExpressions)                              {                                  while (y < parts.Count)                                  {                                      Script.Operator nextOps = Script.Operator.ValueEquality;                                        if (parts[y] is Script.Operator)                                          nextOps = (Script.Operator)parts[y];                                      else if (parts[y] is string)                                      {                                          try { nextOps = OperatorFromString((string)parts[y]); }                                          catch { break; }                                      }                                      else                                          break;                                        if (nextOps == Script.Operator.Increment)                                          d++;                                      else if (nextOps == Script.Operator.Decrement)                                          d--;                                      else                                          break;                                        parts.RemoveAt(y);                                  }                              }                                #endregion                                if (x > -1 && (IsVarReference(parts[x]) || parts[x] is CodePropertyReferenceExpression))                                  z = x;                                if (y < parts.Count && parts[y] is string && !IsOperator((string)parts[y]))                              {                                  if (z != -1)                                  {                                      if (LaxExpressions)                                      {                                          parts.Insert(y' Script.Operator.Concat);                                          z = x;                                      }                                      else                                          throw new ParseException("Cannot use both prefix and postfix operators on the same variable");                                  }                                    if (z == -1)                                      z = y;                                    if (LaxExpressions)                                  {                                      if (parts[z] is string && ((string)parts[z]).Length == 1 && ((string)parts[z])[0] == ParenOpen)                                      {                                          var zx = new[] { z + 1' z + 2 };                                          if (zx[1] < parts.Count &&                                              parts[zx[1]] is string && ((string)parts[zx[1]]).Length == 1 && ((string)parts[zx[1]])[0] == ParenClose &&                                              (parts[zx[0]] is string && IsDynamicReference((string)parts[zx[0]]) || IsVarReference(parts[zx[0]])))                                          {                                              parts.RemoveAt(zx[1]);                                              parts.RemoveAt(z);                                          }                                          else                                          {                                              parts.RemoveAt(i);                                              i--;                                              continue;                                          }                                      }                                  }                              }                                if (z == -1)                              {                                  if (LaxExpressions)                                  {                                      if ((x > 0 && (parts[x] is CodeBinaryOperatorExpression || parts[x] is CodeMethodInvokeExpression || parts[x] is CodePrimitiveExpression)) ||                                          (y < parts.Count && (parts[y] is string && !IsOperator(parts[y] as string) || parts[y] is Script.Operator)))                                      {                                          parts.RemoveAt(i);                                          i--;                                          continue;                                      }                                  }                                  else                                      throw new ParseException("Neither left or right hand side of operator is a variable");                              }                                if (parts[z] is string && ((string)parts[z]).Length > 0 && ((string)parts[z])[0] == StringBound)                              {                                  parts.RemoveAt(Math.Max(i' z));                                  parts.RemoveAt(Math.Min(i' z));                                  continue;                              }                                if (LaxExpressions)                              {                                  int w = z + (z == x ? 2 : 1);                                  if (w < parts.Count && (parts[w] is string && IsAssignOp((string)parts[w]) || IsVarAssignment(parts[w])))                                  {                                      int l = parts.Count - w;                                      var sub = new List<object>(l + 1);                                        sub.Add(parts[z]);                                      for (int wx = w; wx < parts.Count; wx++)                                          sub.Add(parts[wx]);                                        shadow = (CodeMethodInvokeExpression)InternalMethods.OperateZero;                                      shadow.Parameters.Add(ParseExpression(sub));                                        parts.RemoveRange(w' l);                                  }                              }                                var list = new List<object>(9);                              list.Add(parts[z]);                              list.Add(new string(new[] { Add' Equal }));                              list.Add(new CodePrimitiveExpression(d));                              if (shadow != null)                              {                                  list.Add(Script.Operator.Add);                                  list.Add(shadow);                              }                              if (z < i) // postfix' so adjust                              {                                  list.Insert(0' ParenOpen.ToString());                                  list.Add(ParenClose.ToString());                                  list.Add(d > 0 ? Script.Operator.Minus : Script.Operator.Add);                                  list.Add(new CodePrimitiveExpression(d));                              }                                x = Math.Min(i' z);                              y = Math.Max(i' z);                              parts[x] = ParseExpression(list);                              parts.RemoveAt(y);                              i = x;                          }                          #endregion                          else                          {                              #region Dereference                              if (part.Length == 1 && part[0] == Dereference)                              {                                  bool deref = false;                                    if (i == 0)                                      deref = true;                                  else                                  {                                      int x = i - 1;                                      deref = parts[x] is Script.Operator || IsVarAssignment(parts[x]) ||                                          (parts[x] is string && ((string)parts[x]).Length == 1 && ((string)parts[x])[0] == '(');                                  }                                    if (deref)                                  {                                      int y = i + 1;                                      if (y < parts.Count && (IsVarReference(parts[y]) ||                                          (parts[y] is string && IsIdentifier((string)parts[y]) && !IsKeyword((string)parts[y]))))                                          ops = Script.Operator.Dereference;                                  }                              }                              #endregion                                parts[i] = ops;                          }                      }                      #endregion                  }              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The following statement contains a magic number: for (int i = 0; i < parts.Count; i++)              {                  if (parts[i] is string)                  {                      var part = (string)parts[i];                      object result;                        #region Parentheses                      if (part[0] == ParenOpen)                      {                          int n = i + 1;                          var paren = Dissect(parts' n' Set(parts' i));                          parts.RemoveAt(n);                          n -= 2;                            bool call = n > -1 && parts[n] is CodeExpression && !(parts[n] is CodePrimitiveExpression);                            if (call && parts[n] is CodeMethodInvokeExpression && ((CodeMethodInvokeExpression)parts[n]).Parameters[0] is CodeFieldReferenceExpression)                              call = false;                            if (call)                          {                              var invoke = (CodeMethodInvokeExpression)InternalMethods.Invoke;                                invoke.Parameters.Add((CodeExpression)parts[n]);                                if (paren.Count != 0)                              {                                  var passed = ParseMultiExpression(paren.ToArray());                                  invoke.Parameters.AddRange(passed);                              }                                  parts[i] = invoke;                              parts.RemoveAt(n);                          }                          else                          {                              if (paren.Count == 0)                                  parts.RemoveAt(i);                              else                                  parts[i] = ParseExpression(paren);                          }                      }                      else if (part[0] == ParenClose)                          rescan = true;                      #endregion                      #region Strings                      else if (part.Length > 1 && part[0] == StringBound && part[part.Length - 1] == StringBound)                          parts[i] = new CodePrimitiveExpression(EscapedString(part.Substring(1' part.Length - 2)' false));                      #endregion                      #region Numerics                      else if (IsPrimativeObject(part' out result))                          parts[i] = new CodePrimitiveExpression(result);                      #endregion                      #region Variables                      else if (IsIdentifier(part' true) && !IsKeyword(part))                      {                          var low = part.ToLowerInvariant();                            if (libProperties.ContainsKey(low))                              parts[i] = new CodePropertyReferenceExpression(new CodeTypeReferenceExpression(bcl)' libProperties[low]);                          else                              parts[i] = VarIdOrConstant(part);                      }                      #endregion                      #region JSON                      else if (part.Length == 1 && part[0] == BlockOpen)                      {                          int n = i + 1;                          var paren = Dissect(parts' n' Set(parts' i));                            var invoke = (CodeMethodInvokeExpression)InternalMethods.Dictionary;                          CodePrimitiveExpression[] keys;                          CodeExpression[] values;                          ParseObject(paren' out keys' out values);                          invoke.Parameters.Add(new CodeArrayCreateExpression(typeof(string)' keys));                          invoke.Parameters.Add(new CodeArrayCreateExpression(typeof(object)' values));                            parts[i] = invoke;                          parts.RemoveAt(n);                          i--;                      }                      else if (part.Length == 1 && part[0] == ArrayOpen)                      {                          int n = i + 1;                          var paren = Dissect(parts' n' Set(parts' i));                          parts.RemoveAt(n);                            if (i > 0 && parts[i - 1] is CodeExpression)                          {                              var invoke = (CodeMethodInvokeExpression)InternalMethods.Index;                              n = i - 1;                              invoke.Parameters.Add((CodeExpression)parts[n]);                                var index = ParseMultiExpression(paren.ToArray());                              if (index.Length > 1)                                  throw new ParseException("Cannot have multipart expression in index.");                              else if (index.Length == 0)                              {                                  var extend = (CodeMethodInvokeExpression)InternalMethods.ExtendArray;                                  var sub = new List<object>(1);                                  sub.Add(parts[n]);                                  extend.Parameters.Add(ParseExpression(sub));                                  invoke = extend;                              }                              else                                  invoke.Parameters.Add(index[0]);                                parts[i] = invoke;                              parts.RemoveAt(n);                              i--;                          }                          else                          {                              var array = new CodeArrayCreateExpression(typeof(object[])' ParseMultiExpression(paren.ToArray()));                              parts[i] = array;                          }                      }                      #endregion                      #region Invokes                      else if (part.Length > 1 && part[part.Length - 1] == ParenOpen)                      {                          string name = part.Substring(0' part.Length - 1);                          bool dynamic = false;                            if (!IsIdentifier(name))                          {                              if (IsDynamicReference(name))                                  dynamic = true;                              else                                  throw new ParseException("Invalid function name");                          }                          else                              CheckPersistent(name);                            int n = i + 1;                          var paren = Dissect(parts' n' Set(parts' i));                          parts.RemoveAt(n);                            CodeMethodInvokeExpression invoke;                            if (dynamic)                          {                              invoke = (CodeMethodInvokeExpression)InternalMethods.FunctionCall;                              invoke.Parameters.Add(VarIdExpand(name));                          }                          else                              invoke = LocalMethodInvoke(name);                            if (paren.Count != 0)                          {                              var passed = ParseMultiExpression(paren.ToArray());                              invoke.Parameters.AddRange(passed);                          }                            parts[i] = invoke;                          invokes.Add(invoke);                      }                      #endregion                      #region Assignments                      else if (IsAssignOp(part) || IsImplicitAssignment(parts' i))                      {                          int n = i - 1;                            if (i > 0 && IsJsonObject(parts[n])) { }                          else if (n < 0 || !IsVarReference(parts[n]))                          {                              if (LaxExpressions)                              {                                  if (parts[n] is CodePrimitiveExpression && ((CodePrimitiveExpression)parts[n]).Value is decimal)                                      parts[n] = VarId(((decimal)((CodePrimitiveExpression)parts[n]).Value).ToString());                              }                              else                                  throw new ParseException("Can only assign to a variable");                          }                                                    // (x += y) => (x = x + y)                          parts[i] = CodeBinaryOperatorType.Assign;                          if (part[0] != AssignPre && part.Length != 1)                          {                              parts.Insert(++i' ParenOpen.ToString());                              parts.Insert(++i' parts[i - 3]);                              if (part.Length > 1)                              {                                  parts.Insert(++i' OperatorFromString(part.Substring(0' part.Length - 1)));                                  parts.Insert(++i' ParenOpen.ToString());                                  parts.Add(ParenClose.ToString());                              }                              parts.Add(ParenClose.ToString());                          }                      }                      #endregion                      #region Multiple statements                      else if (part.Length == 1 && part[0] == Multicast)                      {                          if (!LaxExpressions)                              throw new ParseException("Nested multipart expression not allowed.");                            // implement as: + Dummy(expr..)                            int z = i + 1' l = parts.Count - z;                          var sub = new List<object>(l);                            for (; z < parts.Count; z++)                              sub.Add(parts[z]);                            parts.RemoveRange(i' parts.Count - i);                            var invoke = (CodeMethodInvokeExpression)InternalMethods.OperateZero;                          invoke.Parameters.Add(ParseExpression(sub));                            parts.Add(Script.Operator.Add);                          parts.Add(invoke);                      }                      #endregion                      #region Binary operators                      else                      {                          var ops = OperatorFromString(part);                            #region Increment/decrement                          if (ops == Script.Operator.Increment || ops == Script.Operator.Decrement)                          {                              int z = -1' x = i - 1' y = i + 1;                              int d = ops == Script.Operator.Increment ? 1 : -1;                              CodeMethodInvokeExpression shadow = null;                                // UNDONE: use generic approach to ++/-- for all types of operands?                               if (x > -1 && parts[x] is CodeMethodInvokeExpression)                              {                                  var sub = new List<object>(5);                                  sub.Add(parts[x]);                                  sub.Add(CodeBinaryOperatorType.Assign);                                  sub.Add(parts[x]);                                  sub.Add(Script.Operator.Add);                                  sub.Add(d);                                    parts.RemoveAt(i);                                  parts[x] = ParseExpression(sub);                                  i = x;                                  continue;                              }                                #region Compounding increment/decrement operators                                if (LaxExpressions)                              {                                  while (y < parts.Count)                                  {                                      Script.Operator nextOps = Script.Operator.ValueEquality;                                        if (parts[y] is Script.Operator)                                          nextOps = (Script.Operator)parts[y];                                      else if (parts[y] is string)                                      {                                          try { nextOps = OperatorFromString((string)parts[y]); }                                          catch { break; }                                      }                                      else                                          break;                                        if (nextOps == Script.Operator.Increment)                                          d++;                                      else if (nextOps == Script.Operator.Decrement)                                          d--;                                      else                                          break;                                        parts.RemoveAt(y);                                  }                              }                                #endregion                                if (x > -1 && (IsVarReference(parts[x]) || parts[x] is CodePropertyReferenceExpression))                                  z = x;                                if (y < parts.Count && parts[y] is string && !IsOperator((string)parts[y]))                              {                                  if (z != -1)                                  {                                      if (LaxExpressions)                                      {                                          parts.Insert(y' Script.Operator.Concat);                                          z = x;                                      }                                      else                                          throw new ParseException("Cannot use both prefix and postfix operators on the same variable");                                  }                                    if (z == -1)                                      z = y;                                    if (LaxExpressions)                                  {                                      if (parts[z] is string && ((string)parts[z]).Length == 1 && ((string)parts[z])[0] == ParenOpen)                                      {                                          var zx = new[] { z + 1' z + 2 };                                          if (zx[1] < parts.Count &&                                              parts[zx[1]] is string && ((string)parts[zx[1]]).Length == 1 && ((string)parts[zx[1]])[0] == ParenClose &&                                              (parts[zx[0]] is string && IsDynamicReference((string)parts[zx[0]]) || IsVarReference(parts[zx[0]])))                                          {                                              parts.RemoveAt(zx[1]);                                              parts.RemoveAt(z);                                          }                                          else                                          {                                              parts.RemoveAt(i);                                              i--;                                              continue;                                          }                                      }                                  }                              }                                if (z == -1)                              {                                  if (LaxExpressions)                                  {                                      if ((x > 0 && (parts[x] is CodeBinaryOperatorExpression || parts[x] is CodeMethodInvokeExpression || parts[x] is CodePrimitiveExpression)) ||                                          (y < parts.Count && (parts[y] is string && !IsOperator(parts[y] as string) || parts[y] is Script.Operator)))                                      {                                          parts.RemoveAt(i);                                          i--;                                          continue;                                      }                                  }                                  else                                      throw new ParseException("Neither left or right hand side of operator is a variable");                              }                                if (parts[z] is string && ((string)parts[z]).Length > 0 && ((string)parts[z])[0] == StringBound)                              {                                  parts.RemoveAt(Math.Max(i' z));                                  parts.RemoveAt(Math.Min(i' z));                                  continue;                              }                                if (LaxExpressions)                              {                                  int w = z + (z == x ? 2 : 1);                                  if (w < parts.Count && (parts[w] is string && IsAssignOp((string)parts[w]) || IsVarAssignment(parts[w])))                                  {                                      int l = parts.Count - w;                                      var sub = new List<object>(l + 1);                                        sub.Add(parts[z]);                                      for (int wx = w; wx < parts.Count; wx++)                                          sub.Add(parts[wx]);                                        shadow = (CodeMethodInvokeExpression)InternalMethods.OperateZero;                                      shadow.Parameters.Add(ParseExpression(sub));                                        parts.RemoveRange(w' l);                                  }                              }                                var list = new List<object>(9);                              list.Add(parts[z]);                              list.Add(new string(new[] { Add' Equal }));                              list.Add(new CodePrimitiveExpression(d));                              if (shadow != null)                              {                                  list.Add(Script.Operator.Add);                                  list.Add(shadow);                              }                              if (z < i) // postfix' so adjust                              {                                  list.Insert(0' ParenOpen.ToString());                                  list.Add(ParenClose.ToString());                                  list.Add(d > 0 ? Script.Operator.Minus : Script.Operator.Add);                                  list.Add(new CodePrimitiveExpression(d));                              }                                x = Math.Min(i' z);                              y = Math.Max(i' z);                              parts[x] = ParseExpression(list);                              parts.RemoveAt(y);                              i = x;                          }                          #endregion                          else                          {                              #region Dereference                              if (part.Length == 1 && part[0] == Dereference)                              {                                  bool deref = false;                                    if (i == 0)                                      deref = true;                                  else                                  {                                      int x = i - 1;                                      deref = parts[x] is Script.Operator || IsVarAssignment(parts[x]) ||                                          (parts[x] is string && ((string)parts[x]).Length == 1 && ((string)parts[x])[0] == '(');                                  }                                    if (deref)                                  {                                      int y = i + 1;                                      if (y < parts.Count && (IsVarReference(parts[y]) ||                                          (parts[y] is string && IsIdentifier((string)parts[y]) && !IsKeyword((string)parts[y]))))                                          ops = Script.Operator.Dereference;                                  }                              }                              #endregion                                parts[i] = ops;                          }                      }                      #endregion                  }              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The following statement contains a magic number: for (int i = 0; i < parts.Count; i++)              {                  if (parts[i] is string)                  {                      var part = (string)parts[i];                      object result;                        #region Parentheses                      if (part[0] == ParenOpen)                      {                          int n = i + 1;                          var paren = Dissect(parts' n' Set(parts' i));                          parts.RemoveAt(n);                          n -= 2;                            bool call = n > -1 && parts[n] is CodeExpression && !(parts[n] is CodePrimitiveExpression);                            if (call && parts[n] is CodeMethodInvokeExpression && ((CodeMethodInvokeExpression)parts[n]).Parameters[0] is CodeFieldReferenceExpression)                              call = false;                            if (call)                          {                              var invoke = (CodeMethodInvokeExpression)InternalMethods.Invoke;                                invoke.Parameters.Add((CodeExpression)parts[n]);                                if (paren.Count != 0)                              {                                  var passed = ParseMultiExpression(paren.ToArray());                                  invoke.Parameters.AddRange(passed);                              }                                  parts[i] = invoke;                              parts.RemoveAt(n);                          }                          else                          {                              if (paren.Count == 0)                                  parts.RemoveAt(i);                              else                                  parts[i] = ParseExpression(paren);                          }                      }                      else if (part[0] == ParenClose)                          rescan = true;                      #endregion                      #region Strings                      else if (part.Length > 1 && part[0] == StringBound && part[part.Length - 1] == StringBound)                          parts[i] = new CodePrimitiveExpression(EscapedString(part.Substring(1' part.Length - 2)' false));                      #endregion                      #region Numerics                      else if (IsPrimativeObject(part' out result))                          parts[i] = new CodePrimitiveExpression(result);                      #endregion                      #region Variables                      else if (IsIdentifier(part' true) && !IsKeyword(part))                      {                          var low = part.ToLowerInvariant();                            if (libProperties.ContainsKey(low))                              parts[i] = new CodePropertyReferenceExpression(new CodeTypeReferenceExpression(bcl)' libProperties[low]);                          else                              parts[i] = VarIdOrConstant(part);                      }                      #endregion                      #region JSON                      else if (part.Length == 1 && part[0] == BlockOpen)                      {                          int n = i + 1;                          var paren = Dissect(parts' n' Set(parts' i));                            var invoke = (CodeMethodInvokeExpression)InternalMethods.Dictionary;                          CodePrimitiveExpression[] keys;                          CodeExpression[] values;                          ParseObject(paren' out keys' out values);                          invoke.Parameters.Add(new CodeArrayCreateExpression(typeof(string)' keys));                          invoke.Parameters.Add(new CodeArrayCreateExpression(typeof(object)' values));                            parts[i] = invoke;                          parts.RemoveAt(n);                          i--;                      }                      else if (part.Length == 1 && part[0] == ArrayOpen)                      {                          int n = i + 1;                          var paren = Dissect(parts' n' Set(parts' i));                          parts.RemoveAt(n);                            if (i > 0 && parts[i - 1] is CodeExpression)                          {                              var invoke = (CodeMethodInvokeExpression)InternalMethods.Index;                              n = i - 1;                              invoke.Parameters.Add((CodeExpression)parts[n]);                                var index = ParseMultiExpression(paren.ToArray());                              if (index.Length > 1)                                  throw new ParseException("Cannot have multipart expression in index.");                              else if (index.Length == 0)                              {                                  var extend = (CodeMethodInvokeExpression)InternalMethods.ExtendArray;                                  var sub = new List<object>(1);                                  sub.Add(parts[n]);                                  extend.Parameters.Add(ParseExpression(sub));                                  invoke = extend;                              }                              else                                  invoke.Parameters.Add(index[0]);                                parts[i] = invoke;                              parts.RemoveAt(n);                              i--;                          }                          else                          {                              var array = new CodeArrayCreateExpression(typeof(object[])' ParseMultiExpression(paren.ToArray()));                              parts[i] = array;                          }                      }                      #endregion                      #region Invokes                      else if (part.Length > 1 && part[part.Length - 1] == ParenOpen)                      {                          string name = part.Substring(0' part.Length - 1);                          bool dynamic = false;                            if (!IsIdentifier(name))                          {                              if (IsDynamicReference(name))                                  dynamic = true;                              else                                  throw new ParseException("Invalid function name");                          }                          else                              CheckPersistent(name);                            int n = i + 1;                          var paren = Dissect(parts' n' Set(parts' i));                          parts.RemoveAt(n);                            CodeMethodInvokeExpression invoke;                            if (dynamic)                          {                              invoke = (CodeMethodInvokeExpression)InternalMethods.FunctionCall;                              invoke.Parameters.Add(VarIdExpand(name));                          }                          else                              invoke = LocalMethodInvoke(name);                            if (paren.Count != 0)                          {                              var passed = ParseMultiExpression(paren.ToArray());                              invoke.Parameters.AddRange(passed);                          }                            parts[i] = invoke;                          invokes.Add(invoke);                      }                      #endregion                      #region Assignments                      else if (IsAssignOp(part) || IsImplicitAssignment(parts' i))                      {                          int n = i - 1;                            if (i > 0 && IsJsonObject(parts[n])) { }                          else if (n < 0 || !IsVarReference(parts[n]))                          {                              if (LaxExpressions)                              {                                  if (parts[n] is CodePrimitiveExpression && ((CodePrimitiveExpression)parts[n]).Value is decimal)                                      parts[n] = VarId(((decimal)((CodePrimitiveExpression)parts[n]).Value).ToString());                              }                              else                                  throw new ParseException("Can only assign to a variable");                          }                                                    // (x += y) => (x = x + y)                          parts[i] = CodeBinaryOperatorType.Assign;                          if (part[0] != AssignPre && part.Length != 1)                          {                              parts.Insert(++i' ParenOpen.ToString());                              parts.Insert(++i' parts[i - 3]);                              if (part.Length > 1)                              {                                  parts.Insert(++i' OperatorFromString(part.Substring(0' part.Length - 1)));                                  parts.Insert(++i' ParenOpen.ToString());                                  parts.Add(ParenClose.ToString());                              }                              parts.Add(ParenClose.ToString());                          }                      }                      #endregion                      #region Multiple statements                      else if (part.Length == 1 && part[0] == Multicast)                      {                          if (!LaxExpressions)                              throw new ParseException("Nested multipart expression not allowed.");                            // implement as: + Dummy(expr..)                            int z = i + 1' l = parts.Count - z;                          var sub = new List<object>(l);                            for (; z < parts.Count; z++)                              sub.Add(parts[z]);                            parts.RemoveRange(i' parts.Count - i);                            var invoke = (CodeMethodInvokeExpression)InternalMethods.OperateZero;                          invoke.Parameters.Add(ParseExpression(sub));                            parts.Add(Script.Operator.Add);                          parts.Add(invoke);                      }                      #endregion                      #region Binary operators                      else                      {                          var ops = OperatorFromString(part);                            #region Increment/decrement                          if (ops == Script.Operator.Increment || ops == Script.Operator.Decrement)                          {                              int z = -1' x = i - 1' y = i + 1;                              int d = ops == Script.Operator.Increment ? 1 : -1;                              CodeMethodInvokeExpression shadow = null;                                // UNDONE: use generic approach to ++/-- for all types of operands?                               if (x > -1 && parts[x] is CodeMethodInvokeExpression)                              {                                  var sub = new List<object>(5);                                  sub.Add(parts[x]);                                  sub.Add(CodeBinaryOperatorType.Assign);                                  sub.Add(parts[x]);                                  sub.Add(Script.Operator.Add);                                  sub.Add(d);                                    parts.RemoveAt(i);                                  parts[x] = ParseExpression(sub);                                  i = x;                                  continue;                              }                                #region Compounding increment/decrement operators                                if (LaxExpressions)                              {                                  while (y < parts.Count)                                  {                                      Script.Operator nextOps = Script.Operator.ValueEquality;                                        if (parts[y] is Script.Operator)                                          nextOps = (Script.Operator)parts[y];                                      else if (parts[y] is string)                                      {                                          try { nextOps = OperatorFromString((string)parts[y]); }                                          catch { break; }                                      }                                      else                                          break;                                        if (nextOps == Script.Operator.Increment)                                          d++;                                      else if (nextOps == Script.Operator.Decrement)                                          d--;                                      else                                          break;                                        parts.RemoveAt(y);                                  }                              }                                #endregion                                if (x > -1 && (IsVarReference(parts[x]) || parts[x] is CodePropertyReferenceExpression))                                  z = x;                                if (y < parts.Count && parts[y] is string && !IsOperator((string)parts[y]))                              {                                  if (z != -1)                                  {                                      if (LaxExpressions)                                      {                                          parts.Insert(y' Script.Operator.Concat);                                          z = x;                                      }                                      else                                          throw new ParseException("Cannot use both prefix and postfix operators on the same variable");                                  }                                    if (z == -1)                                      z = y;                                    if (LaxExpressions)                                  {                                      if (parts[z] is string && ((string)parts[z]).Length == 1 && ((string)parts[z])[0] == ParenOpen)                                      {                                          var zx = new[] { z + 1' z + 2 };                                          if (zx[1] < parts.Count &&                                              parts[zx[1]] is string && ((string)parts[zx[1]]).Length == 1 && ((string)parts[zx[1]])[0] == ParenClose &&                                              (parts[zx[0]] is string && IsDynamicReference((string)parts[zx[0]]) || IsVarReference(parts[zx[0]])))                                          {                                              parts.RemoveAt(zx[1]);                                              parts.RemoveAt(z);                                          }                                          else                                          {                                              parts.RemoveAt(i);                                              i--;                                              continue;                                          }                                      }                                  }                              }                                if (z == -1)                              {                                  if (LaxExpressions)                                  {                                      if ((x > 0 && (parts[x] is CodeBinaryOperatorExpression || parts[x] is CodeMethodInvokeExpression || parts[x] is CodePrimitiveExpression)) ||                                          (y < parts.Count && (parts[y] is string && !IsOperator(parts[y] as string) || parts[y] is Script.Operator)))                                      {                                          parts.RemoveAt(i);                                          i--;                                          continue;                                      }                                  }                                  else                                      throw new ParseException("Neither left or right hand side of operator is a variable");                              }                                if (parts[z] is string && ((string)parts[z]).Length > 0 && ((string)parts[z])[0] == StringBound)                              {                                  parts.RemoveAt(Math.Max(i' z));                                  parts.RemoveAt(Math.Min(i' z));                                  continue;                              }                                if (LaxExpressions)                              {                                  int w = z + (z == x ? 2 : 1);                                  if (w < parts.Count && (parts[w] is string && IsAssignOp((string)parts[w]) || IsVarAssignment(parts[w])))                                  {                                      int l = parts.Count - w;                                      var sub = new List<object>(l + 1);                                        sub.Add(parts[z]);                                      for (int wx = w; wx < parts.Count; wx++)                                          sub.Add(parts[wx]);                                        shadow = (CodeMethodInvokeExpression)InternalMethods.OperateZero;                                      shadow.Parameters.Add(ParseExpression(sub));                                        parts.RemoveRange(w' l);                                  }                              }                                var list = new List<object>(9);                              list.Add(parts[z]);                              list.Add(new string(new[] { Add' Equal }));                              list.Add(new CodePrimitiveExpression(d));                              if (shadow != null)                              {                                  list.Add(Script.Operator.Add);                                  list.Add(shadow);                              }                              if (z < i) // postfix' so adjust                              {                                  list.Insert(0' ParenOpen.ToString());                                  list.Add(ParenClose.ToString());                                  list.Add(d > 0 ? Script.Operator.Minus : Script.Operator.Add);                                  list.Add(new CodePrimitiveExpression(d));                              }                                x = Math.Min(i' z);                              y = Math.Max(i' z);                              parts[x] = ParseExpression(list);                              parts.RemoveAt(y);                              i = x;                          }                          #endregion                          else                          {                              #region Dereference                              if (part.Length == 1 && part[0] == Dereference)                              {                                  bool deref = false;                                    if (i == 0)                                      deref = true;                                  else                                  {                                      int x = i - 1;                                      deref = parts[x] is Script.Operator || IsVarAssignment(parts[x]) ||                                          (parts[x] is string && ((string)parts[x]).Length == 1 && ((string)parts[x])[0] == '(');                                  }                                    if (deref)                                  {                                      int y = i + 1;                                      if (y < parts.Count && (IsVarReference(parts[y]) ||                                          (parts[y] is string && IsIdentifier((string)parts[y]) && !IsKeyword((string)parts[y]))))                                          ops = Script.Operator.Dereference;                                  }                              }                              #endregion                                parts[i] = ops;                          }                      }                      #endregion                  }              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The following statement contains a magic number: for (int i = 0; i < parts.Count; i++)              {                  if (parts[i] is string)                  {                      var part = (string)parts[i];                      object result;                        #region Parentheses                      if (part[0] == ParenOpen)                      {                          int n = i + 1;                          var paren = Dissect(parts' n' Set(parts' i));                          parts.RemoveAt(n);                          n -= 2;                            bool call = n > -1 && parts[n] is CodeExpression && !(parts[n] is CodePrimitiveExpression);                            if (call && parts[n] is CodeMethodInvokeExpression && ((CodeMethodInvokeExpression)parts[n]).Parameters[0] is CodeFieldReferenceExpression)                              call = false;                            if (call)                          {                              var invoke = (CodeMethodInvokeExpression)InternalMethods.Invoke;                                invoke.Parameters.Add((CodeExpression)parts[n]);                                if (paren.Count != 0)                              {                                  var passed = ParseMultiExpression(paren.ToArray());                                  invoke.Parameters.AddRange(passed);                              }                                  parts[i] = invoke;                              parts.RemoveAt(n);                          }                          else                          {                              if (paren.Count == 0)                                  parts.RemoveAt(i);                              else                                  parts[i] = ParseExpression(paren);                          }                      }                      else if (part[0] == ParenClose)                          rescan = true;                      #endregion                      #region Strings                      else if (part.Length > 1 && part[0] == StringBound && part[part.Length - 1] == StringBound)                          parts[i] = new CodePrimitiveExpression(EscapedString(part.Substring(1' part.Length - 2)' false));                      #endregion                      #region Numerics                      else if (IsPrimativeObject(part' out result))                          parts[i] = new CodePrimitiveExpression(result);                      #endregion                      #region Variables                      else if (IsIdentifier(part' true) && !IsKeyword(part))                      {                          var low = part.ToLowerInvariant();                            if (libProperties.ContainsKey(low))                              parts[i] = new CodePropertyReferenceExpression(new CodeTypeReferenceExpression(bcl)' libProperties[low]);                          else                              parts[i] = VarIdOrConstant(part);                      }                      #endregion                      #region JSON                      else if (part.Length == 1 && part[0] == BlockOpen)                      {                          int n = i + 1;                          var paren = Dissect(parts' n' Set(parts' i));                            var invoke = (CodeMethodInvokeExpression)InternalMethods.Dictionary;                          CodePrimitiveExpression[] keys;                          CodeExpression[] values;                          ParseObject(paren' out keys' out values);                          invoke.Parameters.Add(new CodeArrayCreateExpression(typeof(string)' keys));                          invoke.Parameters.Add(new CodeArrayCreateExpression(typeof(object)' values));                            parts[i] = invoke;                          parts.RemoveAt(n);                          i--;                      }                      else if (part.Length == 1 && part[0] == ArrayOpen)                      {                          int n = i + 1;                          var paren = Dissect(parts' n' Set(parts' i));                          parts.RemoveAt(n);                            if (i > 0 && parts[i - 1] is CodeExpression)                          {                              var invoke = (CodeMethodInvokeExpression)InternalMethods.Index;                              n = i - 1;                              invoke.Parameters.Add((CodeExpression)parts[n]);                                var index = ParseMultiExpression(paren.ToArray());                              if (index.Length > 1)                                  throw new ParseException("Cannot have multipart expression in index.");                              else if (index.Length == 0)                              {                                  var extend = (CodeMethodInvokeExpression)InternalMethods.ExtendArray;                                  var sub = new List<object>(1);                                  sub.Add(parts[n]);                                  extend.Parameters.Add(ParseExpression(sub));                                  invoke = extend;                              }                              else                                  invoke.Parameters.Add(index[0]);                                parts[i] = invoke;                              parts.RemoveAt(n);                              i--;                          }                          else                          {                              var array = new CodeArrayCreateExpression(typeof(object[])' ParseMultiExpression(paren.ToArray()));                              parts[i] = array;                          }                      }                      #endregion                      #region Invokes                      else if (part.Length > 1 && part[part.Length - 1] == ParenOpen)                      {                          string name = part.Substring(0' part.Length - 1);                          bool dynamic = false;                            if (!IsIdentifier(name))                          {                              if (IsDynamicReference(name))                                  dynamic = true;                              else                                  throw new ParseException("Invalid function name");                          }                          else                              CheckPersistent(name);                            int n = i + 1;                          var paren = Dissect(parts' n' Set(parts' i));                          parts.RemoveAt(n);                            CodeMethodInvokeExpression invoke;                            if (dynamic)                          {                              invoke = (CodeMethodInvokeExpression)InternalMethods.FunctionCall;                              invoke.Parameters.Add(VarIdExpand(name));                          }                          else                              invoke = LocalMethodInvoke(name);                            if (paren.Count != 0)                          {                              var passed = ParseMultiExpression(paren.ToArray());                              invoke.Parameters.AddRange(passed);                          }                            parts[i] = invoke;                          invokes.Add(invoke);                      }                      #endregion                      #region Assignments                      else if (IsAssignOp(part) || IsImplicitAssignment(parts' i))                      {                          int n = i - 1;                            if (i > 0 && IsJsonObject(parts[n])) { }                          else if (n < 0 || !IsVarReference(parts[n]))                          {                              if (LaxExpressions)                              {                                  if (parts[n] is CodePrimitiveExpression && ((CodePrimitiveExpression)parts[n]).Value is decimal)                                      parts[n] = VarId(((decimal)((CodePrimitiveExpression)parts[n]).Value).ToString());                              }                              else                                  throw new ParseException("Can only assign to a variable");                          }                                                    // (x += y) => (x = x + y)                          parts[i] = CodeBinaryOperatorType.Assign;                          if (part[0] != AssignPre && part.Length != 1)                          {                              parts.Insert(++i' ParenOpen.ToString());                              parts.Insert(++i' parts[i - 3]);                              if (part.Length > 1)                              {                                  parts.Insert(++i' OperatorFromString(part.Substring(0' part.Length - 1)));                                  parts.Insert(++i' ParenOpen.ToString());                                  parts.Add(ParenClose.ToString());                              }                              parts.Add(ParenClose.ToString());                          }                      }                      #endregion                      #region Multiple statements                      else if (part.Length == 1 && part[0] == Multicast)                      {                          if (!LaxExpressions)                              throw new ParseException("Nested multipart expression not allowed.");                            // implement as: + Dummy(expr..)                            int z = i + 1' l = parts.Count - z;                          var sub = new List<object>(l);                            for (; z < parts.Count; z++)                              sub.Add(parts[z]);                            parts.RemoveRange(i' parts.Count - i);                            var invoke = (CodeMethodInvokeExpression)InternalMethods.OperateZero;                          invoke.Parameters.Add(ParseExpression(sub));                            parts.Add(Script.Operator.Add);                          parts.Add(invoke);                      }                      #endregion                      #region Binary operators                      else                      {                          var ops = OperatorFromString(part);                            #region Increment/decrement                          if (ops == Script.Operator.Increment || ops == Script.Operator.Decrement)                          {                              int z = -1' x = i - 1' y = i + 1;                              int d = ops == Script.Operator.Increment ? 1 : -1;                              CodeMethodInvokeExpression shadow = null;                                // UNDONE: use generic approach to ++/-- for all types of operands?                               if (x > -1 && parts[x] is CodeMethodInvokeExpression)                              {                                  var sub = new List<object>(5);                                  sub.Add(parts[x]);                                  sub.Add(CodeBinaryOperatorType.Assign);                                  sub.Add(parts[x]);                                  sub.Add(Script.Operator.Add);                                  sub.Add(d);                                    parts.RemoveAt(i);                                  parts[x] = ParseExpression(sub);                                  i = x;                                  continue;                              }                                #region Compounding increment/decrement operators                                if (LaxExpressions)                              {                                  while (y < parts.Count)                                  {                                      Script.Operator nextOps = Script.Operator.ValueEquality;                                        if (parts[y] is Script.Operator)                                          nextOps = (Script.Operator)parts[y];                                      else if (parts[y] is string)                                      {                                          try { nextOps = OperatorFromString((string)parts[y]); }                                          catch { break; }                                      }                                      else                                          break;                                        if (nextOps == Script.Operator.Increment)                                          d++;                                      else if (nextOps == Script.Operator.Decrement)                                          d--;                                      else                                          break;                                        parts.RemoveAt(y);                                  }                              }                                #endregion                                if (x > -1 && (IsVarReference(parts[x]) || parts[x] is CodePropertyReferenceExpression))                                  z = x;                                if (y < parts.Count && parts[y] is string && !IsOperator((string)parts[y]))                              {                                  if (z != -1)                                  {                                      if (LaxExpressions)                                      {                                          parts.Insert(y' Script.Operator.Concat);                                          z = x;                                      }                                      else                                          throw new ParseException("Cannot use both prefix and postfix operators on the same variable");                                  }                                    if (z == -1)                                      z = y;                                    if (LaxExpressions)                                  {                                      if (parts[z] is string && ((string)parts[z]).Length == 1 && ((string)parts[z])[0] == ParenOpen)                                      {                                          var zx = new[] { z + 1' z + 2 };                                          if (zx[1] < parts.Count &&                                              parts[zx[1]] is string && ((string)parts[zx[1]]).Length == 1 && ((string)parts[zx[1]])[0] == ParenClose &&                                              (parts[zx[0]] is string && IsDynamicReference((string)parts[zx[0]]) || IsVarReference(parts[zx[0]])))                                          {                                              parts.RemoveAt(zx[1]);                                              parts.RemoveAt(z);                                          }                                          else                                          {                                              parts.RemoveAt(i);                                              i--;                                              continue;                                          }                                      }                                  }                              }                                if (z == -1)                              {                                  if (LaxExpressions)                                  {                                      if ((x > 0 && (parts[x] is CodeBinaryOperatorExpression || parts[x] is CodeMethodInvokeExpression || parts[x] is CodePrimitiveExpression)) ||                                          (y < parts.Count && (parts[y] is string && !IsOperator(parts[y] as string) || parts[y] is Script.Operator)))                                      {                                          parts.RemoveAt(i);                                          i--;                                          continue;                                      }                                  }                                  else                                      throw new ParseException("Neither left or right hand side of operator is a variable");                              }                                if (parts[z] is string && ((string)parts[z]).Length > 0 && ((string)parts[z])[0] == StringBound)                              {                                  parts.RemoveAt(Math.Max(i' z));                                  parts.RemoveAt(Math.Min(i' z));                                  continue;                              }                                if (LaxExpressions)                              {                                  int w = z + (z == x ? 2 : 1);                                  if (w < parts.Count && (parts[w] is string && IsAssignOp((string)parts[w]) || IsVarAssignment(parts[w])))                                  {                                      int l = parts.Count - w;                                      var sub = new List<object>(l + 1);                                        sub.Add(parts[z]);                                      for (int wx = w; wx < parts.Count; wx++)                                          sub.Add(parts[wx]);                                        shadow = (CodeMethodInvokeExpression)InternalMethods.OperateZero;                                      shadow.Parameters.Add(ParseExpression(sub));                                        parts.RemoveRange(w' l);                                  }                              }                                var list = new List<object>(9);                              list.Add(parts[z]);                              list.Add(new string(new[] { Add' Equal }));                              list.Add(new CodePrimitiveExpression(d));                              if (shadow != null)                              {                                  list.Add(Script.Operator.Add);                                  list.Add(shadow);                              }                              if (z < i) // postfix' so adjust                              {                                  list.Insert(0' ParenOpen.ToString());                                  list.Add(ParenClose.ToString());                                  list.Add(d > 0 ? Script.Operator.Minus : Script.Operator.Add);                                  list.Add(new CodePrimitiveExpression(d));                              }                                x = Math.Min(i' z);                              y = Math.Max(i' z);                              parts[x] = ParseExpression(list);                              parts.RemoveAt(y);                              i = x;                          }                          #endregion                          else                          {                              #region Dereference                              if (part.Length == 1 && part[0] == Dereference)                              {                                  bool deref = false;                                    if (i == 0)                                      deref = true;                                  else                                  {                                      int x = i - 1;                                      deref = parts[x] is Script.Operator || IsVarAssignment(parts[x]) ||                                          (parts[x] is string && ((string)parts[x]).Length == 1 && ((string)parts[x])[0] == '(');                                  }                                    if (deref)                                  {                                      int y = i + 1;                                      if (y < parts.Count && (IsVarReference(parts[y]) ||                                          (parts[y] is string && IsIdentifier((string)parts[y]) && !IsKeyword((string)parts[y]))))                                          ops = Script.Operator.Dereference;                                  }                              }                              #endregion                                parts[i] = ops;                          }                      }                      #endregion                  }              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The following statement contains a magic number: for (int i = 0; i < parts.Count; i++)              {                  if (parts[i] is string)                  {                      var part = (string)parts[i];                      object result;                        #region Parentheses                      if (part[0] == ParenOpen)                      {                          int n = i + 1;                          var paren = Dissect(parts' n' Set(parts' i));                          parts.RemoveAt(n);                          n -= 2;                            bool call = n > -1 && parts[n] is CodeExpression && !(parts[n] is CodePrimitiveExpression);                            if (call && parts[n] is CodeMethodInvokeExpression && ((CodeMethodInvokeExpression)parts[n]).Parameters[0] is CodeFieldReferenceExpression)                              call = false;                            if (call)                          {                              var invoke = (CodeMethodInvokeExpression)InternalMethods.Invoke;                                invoke.Parameters.Add((CodeExpression)parts[n]);                                if (paren.Count != 0)                              {                                  var passed = ParseMultiExpression(paren.ToArray());                                  invoke.Parameters.AddRange(passed);                              }                                  parts[i] = invoke;                              parts.RemoveAt(n);                          }                          else                          {                              if (paren.Count == 0)                                  parts.RemoveAt(i);                              else                                  parts[i] = ParseExpression(paren);                          }                      }                      else if (part[0] == ParenClose)                          rescan = true;                      #endregion                      #region Strings                      else if (part.Length > 1 && part[0] == StringBound && part[part.Length - 1] == StringBound)                          parts[i] = new CodePrimitiveExpression(EscapedString(part.Substring(1' part.Length - 2)' false));                      #endregion                      #region Numerics                      else if (IsPrimativeObject(part' out result))                          parts[i] = new CodePrimitiveExpression(result);                      #endregion                      #region Variables                      else if (IsIdentifier(part' true) && !IsKeyword(part))                      {                          var low = part.ToLowerInvariant();                            if (libProperties.ContainsKey(low))                              parts[i] = new CodePropertyReferenceExpression(new CodeTypeReferenceExpression(bcl)' libProperties[low]);                          else                              parts[i] = VarIdOrConstant(part);                      }                      #endregion                      #region JSON                      else if (part.Length == 1 && part[0] == BlockOpen)                      {                          int n = i + 1;                          var paren = Dissect(parts' n' Set(parts' i));                            var invoke = (CodeMethodInvokeExpression)InternalMethods.Dictionary;                          CodePrimitiveExpression[] keys;                          CodeExpression[] values;                          ParseObject(paren' out keys' out values);                          invoke.Parameters.Add(new CodeArrayCreateExpression(typeof(string)' keys));                          invoke.Parameters.Add(new CodeArrayCreateExpression(typeof(object)' values));                            parts[i] = invoke;                          parts.RemoveAt(n);                          i--;                      }                      else if (part.Length == 1 && part[0] == ArrayOpen)                      {                          int n = i + 1;                          var paren = Dissect(parts' n' Set(parts' i));                          parts.RemoveAt(n);                            if (i > 0 && parts[i - 1] is CodeExpression)                          {                              var invoke = (CodeMethodInvokeExpression)InternalMethods.Index;                              n = i - 1;                              invoke.Parameters.Add((CodeExpression)parts[n]);                                var index = ParseMultiExpression(paren.ToArray());                              if (index.Length > 1)                                  throw new ParseException("Cannot have multipart expression in index.");                              else if (index.Length == 0)                              {                                  var extend = (CodeMethodInvokeExpression)InternalMethods.ExtendArray;                                  var sub = new List<object>(1);                                  sub.Add(parts[n]);                                  extend.Parameters.Add(ParseExpression(sub));                                  invoke = extend;                              }                              else                                  invoke.Parameters.Add(index[0]);                                parts[i] = invoke;                              parts.RemoveAt(n);                              i--;                          }                          else                          {                              var array = new CodeArrayCreateExpression(typeof(object[])' ParseMultiExpression(paren.ToArray()));                              parts[i] = array;                          }                      }                      #endregion                      #region Invokes                      else if (part.Length > 1 && part[part.Length - 1] == ParenOpen)                      {                          string name = part.Substring(0' part.Length - 1);                          bool dynamic = false;                            if (!IsIdentifier(name))                          {                              if (IsDynamicReference(name))                                  dynamic = true;                              else                                  throw new ParseException("Invalid function name");                          }                          else                              CheckPersistent(name);                            int n = i + 1;                          var paren = Dissect(parts' n' Set(parts' i));                          parts.RemoveAt(n);                            CodeMethodInvokeExpression invoke;                            if (dynamic)                          {                              invoke = (CodeMethodInvokeExpression)InternalMethods.FunctionCall;                              invoke.Parameters.Add(VarIdExpand(name));                          }                          else                              invoke = LocalMethodInvoke(name);                            if (paren.Count != 0)                          {                              var passed = ParseMultiExpression(paren.ToArray());                              invoke.Parameters.AddRange(passed);                          }                            parts[i] = invoke;                          invokes.Add(invoke);                      }                      #endregion                      #region Assignments                      else if (IsAssignOp(part) || IsImplicitAssignment(parts' i))                      {                          int n = i - 1;                            if (i > 0 && IsJsonObject(parts[n])) { }                          else if (n < 0 || !IsVarReference(parts[n]))                          {                              if (LaxExpressions)                              {                                  if (parts[n] is CodePrimitiveExpression && ((CodePrimitiveExpression)parts[n]).Value is decimal)                                      parts[n] = VarId(((decimal)((CodePrimitiveExpression)parts[n]).Value).ToString());                              }                              else                                  throw new ParseException("Can only assign to a variable");                          }                                                    // (x += y) => (x = x + y)                          parts[i] = CodeBinaryOperatorType.Assign;                          if (part[0] != AssignPre && part.Length != 1)                          {                              parts.Insert(++i' ParenOpen.ToString());                              parts.Insert(++i' parts[i - 3]);                              if (part.Length > 1)                              {                                  parts.Insert(++i' OperatorFromString(part.Substring(0' part.Length - 1)));                                  parts.Insert(++i' ParenOpen.ToString());                                  parts.Add(ParenClose.ToString());                              }                              parts.Add(ParenClose.ToString());                          }                      }                      #endregion                      #region Multiple statements                      else if (part.Length == 1 && part[0] == Multicast)                      {                          if (!LaxExpressions)                              throw new ParseException("Nested multipart expression not allowed.");                            // implement as: + Dummy(expr..)                            int z = i + 1' l = parts.Count - z;                          var sub = new List<object>(l);                            for (; z < parts.Count; z++)                              sub.Add(parts[z]);                            parts.RemoveRange(i' parts.Count - i);                            var invoke = (CodeMethodInvokeExpression)InternalMethods.OperateZero;                          invoke.Parameters.Add(ParseExpression(sub));                            parts.Add(Script.Operator.Add);                          parts.Add(invoke);                      }                      #endregion                      #region Binary operators                      else                      {                          var ops = OperatorFromString(part);                            #region Increment/decrement                          if (ops == Script.Operator.Increment || ops == Script.Operator.Decrement)                          {                              int z = -1' x = i - 1' y = i + 1;                              int d = ops == Script.Operator.Increment ? 1 : -1;                              CodeMethodInvokeExpression shadow = null;                                // UNDONE: use generic approach to ++/-- for all types of operands?                               if (x > -1 && parts[x] is CodeMethodInvokeExpression)                              {                                  var sub = new List<object>(5);                                  sub.Add(parts[x]);                                  sub.Add(CodeBinaryOperatorType.Assign);                                  sub.Add(parts[x]);                                  sub.Add(Script.Operator.Add);                                  sub.Add(d);                                    parts.RemoveAt(i);                                  parts[x] = ParseExpression(sub);                                  i = x;                                  continue;                              }                                #region Compounding increment/decrement operators                                if (LaxExpressions)                              {                                  while (y < parts.Count)                                  {                                      Script.Operator nextOps = Script.Operator.ValueEquality;                                        if (parts[y] is Script.Operator)                                          nextOps = (Script.Operator)parts[y];                                      else if (parts[y] is string)                                      {                                          try { nextOps = OperatorFromString((string)parts[y]); }                                          catch { break; }                                      }                                      else                                          break;                                        if (nextOps == Script.Operator.Increment)                                          d++;                                      else if (nextOps == Script.Operator.Decrement)                                          d--;                                      else                                          break;                                        parts.RemoveAt(y);                                  }                              }                                #endregion                                if (x > -1 && (IsVarReference(parts[x]) || parts[x] is CodePropertyReferenceExpression))                                  z = x;                                if (y < parts.Count && parts[y] is string && !IsOperator((string)parts[y]))                              {                                  if (z != -1)                                  {                                      if (LaxExpressions)                                      {                                          parts.Insert(y' Script.Operator.Concat);                                          z = x;                                      }                                      else                                          throw new ParseException("Cannot use both prefix and postfix operators on the same variable");                                  }                                    if (z == -1)                                      z = y;                                    if (LaxExpressions)                                  {                                      if (parts[z] is string && ((string)parts[z]).Length == 1 && ((string)parts[z])[0] == ParenOpen)                                      {                                          var zx = new[] { z + 1' z + 2 };                                          if (zx[1] < parts.Count &&                                              parts[zx[1]] is string && ((string)parts[zx[1]]).Length == 1 && ((string)parts[zx[1]])[0] == ParenClose &&                                              (parts[zx[0]] is string && IsDynamicReference((string)parts[zx[0]]) || IsVarReference(parts[zx[0]])))                                          {                                              parts.RemoveAt(zx[1]);                                              parts.RemoveAt(z);                                          }                                          else                                          {                                              parts.RemoveAt(i);                                              i--;                                              continue;                                          }                                      }                                  }                              }                                if (z == -1)                              {                                  if (LaxExpressions)                                  {                                      if ((x > 0 && (parts[x] is CodeBinaryOperatorExpression || parts[x] is CodeMethodInvokeExpression || parts[x] is CodePrimitiveExpression)) ||                                          (y < parts.Count && (parts[y] is string && !IsOperator(parts[y] as string) || parts[y] is Script.Operator)))                                      {                                          parts.RemoveAt(i);                                          i--;                                          continue;                                      }                                  }                                  else                                      throw new ParseException("Neither left or right hand side of operator is a variable");                              }                                if (parts[z] is string && ((string)parts[z]).Length > 0 && ((string)parts[z])[0] == StringBound)                              {                                  parts.RemoveAt(Math.Max(i' z));                                  parts.RemoveAt(Math.Min(i' z));                                  continue;                              }                                if (LaxExpressions)                              {                                  int w = z + (z == x ? 2 : 1);                                  if (w < parts.Count && (parts[w] is string && IsAssignOp((string)parts[w]) || IsVarAssignment(parts[w])))                                  {                                      int l = parts.Count - w;                                      var sub = new List<object>(l + 1);                                        sub.Add(parts[z]);                                      for (int wx = w; wx < parts.Count; wx++)                                          sub.Add(parts[wx]);                                        shadow = (CodeMethodInvokeExpression)InternalMethods.OperateZero;                                      shadow.Parameters.Add(ParseExpression(sub));                                        parts.RemoveRange(w' l);                                  }                              }                                var list = new List<object>(9);                              list.Add(parts[z]);                              list.Add(new string(new[] { Add' Equal }));                              list.Add(new CodePrimitiveExpression(d));                              if (shadow != null)                              {                                  list.Add(Script.Operator.Add);                                  list.Add(shadow);                              }                              if (z < i) // postfix' so adjust                              {                                  list.Insert(0' ParenOpen.ToString());                                  list.Add(ParenClose.ToString());                                  list.Add(d > 0 ? Script.Operator.Minus : Script.Operator.Add);                                  list.Add(new CodePrimitiveExpression(d));                              }                                x = Math.Min(i' z);                              y = Math.Max(i' z);                              parts[x] = ParseExpression(list);                              parts.RemoveAt(y);                              i = x;                          }                          #endregion                          else                          {                              #region Dereference                              if (part.Length == 1 && part[0] == Dereference)                              {                                  bool deref = false;                                    if (i == 0)                                      deref = true;                                  else                                  {                                      int x = i - 1;                                      deref = parts[x] is Script.Operator || IsVarAssignment(parts[x]) ||                                          (parts[x] is string && ((string)parts[x]).Length == 1 && ((string)parts[x])[0] == '(');                                  }                                    if (deref)                                  {                                      int y = i + 1;                                      if (y < parts.Count && (IsVarReference(parts[y]) ||                                          (parts[y] is string && IsIdentifier((string)parts[y]) && !IsKeyword((string)parts[y]))))                                          ops = Script.Operator.Dereference;                                  }                              }                              #endregion                                parts[i] = ops;                          }                      }                      #endregion                  }              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The following statement contains a magic number: for (int i = 1; i < parts.Count; i++)              {                  if (parts[i] is Script.Operator &&                      (parts[i - 1] is Script.Operator || parts[i - 1] as CodeBinaryOperatorType? == CodeBinaryOperatorType.Assign || IsVarAssignment(parts[i - 1])) &&                      IsUnaryOperator((Script.Operator)parts[i]))                  {                      int n = i + 1' m = n + 1;                        int u = n;                      while (u < parts.Count && parts[u] is Script.Operator && IsUnaryOperator((Script.Operator)parts[u])) u++;                      if (u == parts.Count)                      {                          if (LaxExpressions)                          {                              u--;                              while (parts[u] is Script.Operator && ((Script.Operator)parts[u] == Script.Operator.Add || (Script.Operator)parts[u] == Script.Operator.Subtract))                                  parts.RemoveAt(u--);                                if (u + 1 < n)                              {                                  i = u;                                  continue;                              }                          }                            throw new ParseException("Compounding unary operator with no operand");                      }                        if (u > n)                      {                          var sub = new List<object>(++u - n);                          for (int x = n; x < u; x++)                              sub.Add(parts[x]);                          parts.RemoveRange(n' u - n);                          parts.Insert(n' ParseExpression(sub));                      }                        if (m + 1 < parts.Count && IsVarReference(parts[n]) && IsVarAssignment(parts[m]))                          MergeAssignmentAt(parts' i + 2);                        if (m > parts.Count)                          throw new ParseException("Unary operator without operand");                        var op = (Script.Operator)parts[i];                        if (parts[n] is CodePrimitiveExpression && op == Script.Operator.Subtract)                      {                          var parent = ((CodePrimitiveExpression)parts[n]);                            if (parent.Value is int)                              parent.Value = -(int)parent.Value;                          else if (parent.Value is decimal)                              parent.Value = -(decimal)parent.Value;                          else if (parent.Value is double)                              parent.Value = -(double)parent.Value;                          else if (parent.Value is string)                              parent.Value = string.Concat(Minus.ToString()' (string)parent.Value);                          else                              throw new ArgumentOutOfRangeException();                            parts.RemoveAt(i);                      }                      else if (op == Script.Operator.Add)                      {                          parts.RemoveAt(i);                      }                      else                      {                          var invoke = (CodeMethodInvokeExpression)InternalMethods.OperateUnary;                          invoke.Parameters.Add(OperatorAsFieldReference(op));                            if (LaxExpressions)                          {                              if (!(IsVarReference(parts[n]) || IsVarAssignment(parts[n])))                              {                                  invoke.Parameters.Add(new CodePrimitiveExpression(null));                                  goto next;                              }                          }                          invoke.Parameters.Add(VarMixedExpr(parts[n]));                        next:                          parts[i] = invoke;                          parts.RemoveAt(n);                      }                  }              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The following statement contains a magic number: while (scan)              {                  scan = false;                  for (int i = 0; i < parts.Count; i++)                  {                      if (parts[i] is Script.Operator && (Script.Operator)parts[i] != Script.Operator.Assign)                      {                          scan = true;                          var op = (Script.Operator)parts[i];                            if (OperatorPrecedence(op) < level)                              continue;                            int x = i - 1' y = i + 1;                          var invoke = new CodeMethodInvokeExpression();                            if (i + 3 < parts.Count && IsVarReference(parts[i + 1]) && parts[i + 2] as CodeBinaryOperatorType? == CodeBinaryOperatorType.Assign)                              MergeAssignmentAt(parts' i + 2);                            #region Ternary                          if (op == Script.Operator.TernaryA)                          {                              if (x < 0)                              {                                  if (LaxExpressions)                                      return new CodePrimitiveExpression(null);                                  else                                      throw new ParseException("Ternary with no condition.");                              }                                var eval = (CodeMethodInvokeExpression)InternalMethods.IfElse;                              eval.Parameters.Add(VarMixedExpr(parts[x]));                              var ternary = new CodeTernaryOperatorExpression { Condition = eval };                                int depth = 1' max = parts.Count - i' start = i;                              var branch = new[] { new List<object>(max)' new List<object>(max) };                                for (i++; i < parts.Count; i++)                              {                                  switch (parts[i] as Script.Operator?)                                  {                                      case Script.Operator.TernaryA:                                          depth++;                                          break;                                        case Script.Operator.TernaryB:                                          depth--;                                          break;                                  }                                    if (depth == 0)                                  {                                      for (int n = i + 1; n < parts.Count; n++)                                          branch[1].Add(parts[n]);                                      break;                                  }                                  else                                      branch[0].Add(parts[i]);                              }                                if (branch[0].Count == 0)                                  throw new ParseException("Ternary operator must have at least one branch");                                if (branch[1].Count == 0)                                  branch[1].Add(new CodePrimitiveExpression(null));                                ternary.TrueBranch = ParseExpression(branch[0]);                              ternary.FalseBranch = ParseExpression(branch[1]);                              parts[x] = ternary;                                parts.Remove(y);                              parts.RemoveRange(start' parts.Count - start);                          }                          else if (op == Script.Operator.NullAssign)                          {                              if (x < 0)                                  throw new ParseException("Nullable assignment with no condition.");                                int n = i + 1;                                if (n >= parts.Count)                                  throw new ParseException("Nullable assignment with no right-hand operator");                                var result = InternalVariable;                              var left = new CodeBinaryOperatorExpression(result' CodeBinaryOperatorType.Assign' VarMixedExpr(parts[x]));                                var eval = (CodeMethodInvokeExpression)InternalMethods.IfElse;                              eval.Parameters.Add(left);                              var ternary = new CodeTernaryOperatorExpression { Condition = eval' TrueBranch = result };                                var right = new List<object>();                                while (n < parts.Count)                                  right.Add(parts[n++]);                                ternary.FalseBranch = ParseExpression(right);                                parts[x] = ternary;                              parts.RemoveRange(i' parts.Count - i);                          }                          #endregion                          #region Unary                          else if (x == -1)                          {                              int z = y + 1;                              if (op == Script.Operator.LogicalNotEx && IsVarReference(parts[y]) && z < parts.Count)                                  MergeAssignmentAt(parts' z);                                if (LaxExpressions)                              {                                  if (y > parts.Count - 1)                                      return new CodePrimitiveExpression(null);                              }                                invoke.Method = (CodeMethodReferenceExpression)InternalMethods.OperateUnary;                              invoke.Parameters.Add(OperatorAsFieldReference(op));                              invoke.Parameters.Add(VarMixedExpr(parts[y]));                              parts[i] = invoke;                              parts.RemoveAt(y);                          }                          #endregion                          #region Binary                          else                          {                              if (op == Script.Operator.BooleanAnd || op == Script.Operator.BooleanOr)                              {                                  var boolean = new CodeBinaryOperatorExpression();                                  boolean.Operator = op == Script.Operator.BooleanAnd ? CodeBinaryOperatorType.BooleanAnd : CodeBinaryOperatorType.BooleanOr;                                    var iftest = (CodeMethodInvokeExpression)InternalMethods.IfElse;                                  iftest.Parameters.Add(VarMixedExpr(parts[x]));                                  boolean.Left = iftest;                                    iftest = (CodeMethodInvokeExpression)InternalMethods.IfElse;                                  var next = parts[y] as Script.Operator?;                                  if (next == Script.Operator.BooleanAnd || next == Script.Operator.BooleanOr)                                  {                                      if (LaxExpressions)                                          iftest.Parameters.Add(new CodePrimitiveExpression(false));                                      else                                          throw new ParseException(ExInvalidExpression);                                  }                                  else                                  {                                      iftest.Parameters.Add(VarMixedExpr(parts[y]));                                      parts.RemoveAt(y);                                  }                                  boolean.Right = iftest;                                    parts[x] = boolean;                              }                              else                              {                                  if (LaxExpressions)                                  {                                      if (parts[x] is Script.Operator && (Script.Operator)parts[x] == Script.Operator.TernaryA)                                      {                                          parts[x] = new CodePrimitiveExpression(null);                                          goto next;                                      }                                        if (y > parts.Count - 1)                                          return new CodePrimitiveExpression(null);                                  }                                  else                                      throw new ParseException(ExInvalidExpression);                                    invoke.Method = (CodeMethodReferenceExpression)InternalMethods.Operate;                                  invoke.Parameters.Add(OperatorAsFieldReference(op));                                    if (LaxExpressions && parts[i] is Script.Operator && (Script.Operator)parts[i] == Script.Operator.Concat && parts[x] as CodeBinaryOperatorType? == CodeBinaryOperatorType.Assign)                                      invoke.Parameters.Add(new CodePrimitiveExpression(string.Empty));                                  else                                      invoke.Parameters.Add(VarMixedExpr(parts[x]));                                    invoke.Parameters.Add(VarMixedExpr(parts[y]));                                  parts[x] = invoke;                                next:                                  parts.RemoveAt(y);                              }                                parts.RemoveAt(i);                          }                          #endregion                            i--;                      }                      else if (parts[i] as CodeBinaryOperatorType? != CodeBinaryOperatorType.Assign)                      {                          var x = i - 1;                            if (x > 0 && !(parts[x] is Script.Operator || parts[x] is CodeBinaryOperatorType))                          {                              parts.Insert(i' Script.Operator.Concat);                              i--;                              continue;                          }                      }                  }                  level--;              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The following statement contains a magic number: while (scan)              {                  scan = false;                  for (int i = 0; i < parts.Count; i++)                  {                      if (parts[i] is Script.Operator && (Script.Operator)parts[i] != Script.Operator.Assign)                      {                          scan = true;                          var op = (Script.Operator)parts[i];                            if (OperatorPrecedence(op) < level)                              continue;                            int x = i - 1' y = i + 1;                          var invoke = new CodeMethodInvokeExpression();                            if (i + 3 < parts.Count && IsVarReference(parts[i + 1]) && parts[i + 2] as CodeBinaryOperatorType? == CodeBinaryOperatorType.Assign)                              MergeAssignmentAt(parts' i + 2);                            #region Ternary                          if (op == Script.Operator.TernaryA)                          {                              if (x < 0)                              {                                  if (LaxExpressions)                                      return new CodePrimitiveExpression(null);                                  else                                      throw new ParseException("Ternary with no condition.");                              }                                var eval = (CodeMethodInvokeExpression)InternalMethods.IfElse;                              eval.Parameters.Add(VarMixedExpr(parts[x]));                              var ternary = new CodeTernaryOperatorExpression { Condition = eval };                                int depth = 1' max = parts.Count - i' start = i;                              var branch = new[] { new List<object>(max)' new List<object>(max) };                                for (i++; i < parts.Count; i++)                              {                                  switch (parts[i] as Script.Operator?)                                  {                                      case Script.Operator.TernaryA:                                          depth++;                                          break;                                        case Script.Operator.TernaryB:                                          depth--;                                          break;                                  }                                    if (depth == 0)                                  {                                      for (int n = i + 1; n < parts.Count; n++)                                          branch[1].Add(parts[n]);                                      break;                                  }                                  else                                      branch[0].Add(parts[i]);                              }                                if (branch[0].Count == 0)                                  throw new ParseException("Ternary operator must have at least one branch");                                if (branch[1].Count == 0)                                  branch[1].Add(new CodePrimitiveExpression(null));                                ternary.TrueBranch = ParseExpression(branch[0]);                              ternary.FalseBranch = ParseExpression(branch[1]);                              parts[x] = ternary;                                parts.Remove(y);                              parts.RemoveRange(start' parts.Count - start);                          }                          else if (op == Script.Operator.NullAssign)                          {                              if (x < 0)                                  throw new ParseException("Nullable assignment with no condition.");                                int n = i + 1;                                if (n >= parts.Count)                                  throw new ParseException("Nullable assignment with no right-hand operator");                                var result = InternalVariable;                              var left = new CodeBinaryOperatorExpression(result' CodeBinaryOperatorType.Assign' VarMixedExpr(parts[x]));                                var eval = (CodeMethodInvokeExpression)InternalMethods.IfElse;                              eval.Parameters.Add(left);                              var ternary = new CodeTernaryOperatorExpression { Condition = eval' TrueBranch = result };                                var right = new List<object>();                                while (n < parts.Count)                                  right.Add(parts[n++]);                                ternary.FalseBranch = ParseExpression(right);                                parts[x] = ternary;                              parts.RemoveRange(i' parts.Count - i);                          }                          #endregion                          #region Unary                          else if (x == -1)                          {                              int z = y + 1;                              if (op == Script.Operator.LogicalNotEx && IsVarReference(parts[y]) && z < parts.Count)                                  MergeAssignmentAt(parts' z);                                if (LaxExpressions)                              {                                  if (y > parts.Count - 1)                                      return new CodePrimitiveExpression(null);                              }                                invoke.Method = (CodeMethodReferenceExpression)InternalMethods.OperateUnary;                              invoke.Parameters.Add(OperatorAsFieldReference(op));                              invoke.Parameters.Add(VarMixedExpr(parts[y]));                              parts[i] = invoke;                              parts.RemoveAt(y);                          }                          #endregion                          #region Binary                          else                          {                              if (op == Script.Operator.BooleanAnd || op == Script.Operator.BooleanOr)                              {                                  var boolean = new CodeBinaryOperatorExpression();                                  boolean.Operator = op == Script.Operator.BooleanAnd ? CodeBinaryOperatorType.BooleanAnd : CodeBinaryOperatorType.BooleanOr;                                    var iftest = (CodeMethodInvokeExpression)InternalMethods.IfElse;                                  iftest.Parameters.Add(VarMixedExpr(parts[x]));                                  boolean.Left = iftest;                                    iftest = (CodeMethodInvokeExpression)InternalMethods.IfElse;                                  var next = parts[y] as Script.Operator?;                                  if (next == Script.Operator.BooleanAnd || next == Script.Operator.BooleanOr)                                  {                                      if (LaxExpressions)                                          iftest.Parameters.Add(new CodePrimitiveExpression(false));                                      else                                          throw new ParseException(ExInvalidExpression);                                  }                                  else                                  {                                      iftest.Parameters.Add(VarMixedExpr(parts[y]));                                      parts.RemoveAt(y);                                  }                                  boolean.Right = iftest;                                    parts[x] = boolean;                              }                              else                              {                                  if (LaxExpressions)                                  {                                      if (parts[x] is Script.Operator && (Script.Operator)parts[x] == Script.Operator.TernaryA)                                      {                                          parts[x] = new CodePrimitiveExpression(null);                                          goto next;                                      }                                        if (y > parts.Count - 1)                                          return new CodePrimitiveExpression(null);                                  }                                  else                                      throw new ParseException(ExInvalidExpression);                                    invoke.Method = (CodeMethodReferenceExpression)InternalMethods.Operate;                                  invoke.Parameters.Add(OperatorAsFieldReference(op));                                    if (LaxExpressions && parts[i] is Script.Operator && (Script.Operator)parts[i] == Script.Operator.Concat && parts[x] as CodeBinaryOperatorType? == CodeBinaryOperatorType.Assign)                                      invoke.Parameters.Add(new CodePrimitiveExpression(string.Empty));                                  else                                      invoke.Parameters.Add(VarMixedExpr(parts[x]));                                    invoke.Parameters.Add(VarMixedExpr(parts[y]));                                  parts[x] = invoke;                                next:                                  parts.RemoveAt(y);                              }                                parts.RemoveAt(i);                          }                          #endregion                            i--;                      }                      else if (parts[i] as CodeBinaryOperatorType? != CodeBinaryOperatorType.Assign)                      {                          var x = i - 1;                            if (x > 0 && !(parts[x] is Script.Operator || parts[x] is CodeBinaryOperatorType))                          {                              parts.Insert(i' Script.Operator.Concat);                              i--;                              continue;                          }                      }                  }                  level--;              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The following statement contains a magic number: while (scan)              {                  scan = false;                  for (int i = 0; i < parts.Count; i++)                  {                      if (parts[i] is Script.Operator && (Script.Operator)parts[i] != Script.Operator.Assign)                      {                          scan = true;                          var op = (Script.Operator)parts[i];                            if (OperatorPrecedence(op) < level)                              continue;                            int x = i - 1' y = i + 1;                          var invoke = new CodeMethodInvokeExpression();                            if (i + 3 < parts.Count && IsVarReference(parts[i + 1]) && parts[i + 2] as CodeBinaryOperatorType? == CodeBinaryOperatorType.Assign)                              MergeAssignmentAt(parts' i + 2);                            #region Ternary                          if (op == Script.Operator.TernaryA)                          {                              if (x < 0)                              {                                  if (LaxExpressions)                                      return new CodePrimitiveExpression(null);                                  else                                      throw new ParseException("Ternary with no condition.");                              }                                var eval = (CodeMethodInvokeExpression)InternalMethods.IfElse;                              eval.Parameters.Add(VarMixedExpr(parts[x]));                              var ternary = new CodeTernaryOperatorExpression { Condition = eval };                                int depth = 1' max = parts.Count - i' start = i;                              var branch = new[] { new List<object>(max)' new List<object>(max) };                                for (i++; i < parts.Count; i++)                              {                                  switch (parts[i] as Script.Operator?)                                  {                                      case Script.Operator.TernaryA:                                          depth++;                                          break;                                        case Script.Operator.TernaryB:                                          depth--;                                          break;                                  }                                    if (depth == 0)                                  {                                      for (int n = i + 1; n < parts.Count; n++)                                          branch[1].Add(parts[n]);                                      break;                                  }                                  else                                      branch[0].Add(parts[i]);                              }                                if (branch[0].Count == 0)                                  throw new ParseException("Ternary operator must have at least one branch");                                if (branch[1].Count == 0)                                  branch[1].Add(new CodePrimitiveExpression(null));                                ternary.TrueBranch = ParseExpression(branch[0]);                              ternary.FalseBranch = ParseExpression(branch[1]);                              parts[x] = ternary;                                parts.Remove(y);                              parts.RemoveRange(start' parts.Count - start);                          }                          else if (op == Script.Operator.NullAssign)                          {                              if (x < 0)                                  throw new ParseException("Nullable assignment with no condition.");                                int n = i + 1;                                if (n >= parts.Count)                                  throw new ParseException("Nullable assignment with no right-hand operator");                                var result = InternalVariable;                              var left = new CodeBinaryOperatorExpression(result' CodeBinaryOperatorType.Assign' VarMixedExpr(parts[x]));                                var eval = (CodeMethodInvokeExpression)InternalMethods.IfElse;                              eval.Parameters.Add(left);                              var ternary = new CodeTernaryOperatorExpression { Condition = eval' TrueBranch = result };                                var right = new List<object>();                                while (n < parts.Count)                                  right.Add(parts[n++]);                                ternary.FalseBranch = ParseExpression(right);                                parts[x] = ternary;                              parts.RemoveRange(i' parts.Count - i);                          }                          #endregion                          #region Unary                          else if (x == -1)                          {                              int z = y + 1;                              if (op == Script.Operator.LogicalNotEx && IsVarReference(parts[y]) && z < parts.Count)                                  MergeAssignmentAt(parts' z);                                if (LaxExpressions)                              {                                  if (y > parts.Count - 1)                                      return new CodePrimitiveExpression(null);                              }                                invoke.Method = (CodeMethodReferenceExpression)InternalMethods.OperateUnary;                              invoke.Parameters.Add(OperatorAsFieldReference(op));                              invoke.Parameters.Add(VarMixedExpr(parts[y]));                              parts[i] = invoke;                              parts.RemoveAt(y);                          }                          #endregion                          #region Binary                          else                          {                              if (op == Script.Operator.BooleanAnd || op == Script.Operator.BooleanOr)                              {                                  var boolean = new CodeBinaryOperatorExpression();                                  boolean.Operator = op == Script.Operator.BooleanAnd ? CodeBinaryOperatorType.BooleanAnd : CodeBinaryOperatorType.BooleanOr;                                    var iftest = (CodeMethodInvokeExpression)InternalMethods.IfElse;                                  iftest.Parameters.Add(VarMixedExpr(parts[x]));                                  boolean.Left = iftest;                                    iftest = (CodeMethodInvokeExpression)InternalMethods.IfElse;                                  var next = parts[y] as Script.Operator?;                                  if (next == Script.Operator.BooleanAnd || next == Script.Operator.BooleanOr)                                  {                                      if (LaxExpressions)                                          iftest.Parameters.Add(new CodePrimitiveExpression(false));                                      else                                          throw new ParseException(ExInvalidExpression);                                  }                                  else                                  {                                      iftest.Parameters.Add(VarMixedExpr(parts[y]));                                      parts.RemoveAt(y);                                  }                                  boolean.Right = iftest;                                    parts[x] = boolean;                              }                              else                              {                                  if (LaxExpressions)                                  {                                      if (parts[x] is Script.Operator && (Script.Operator)parts[x] == Script.Operator.TernaryA)                                      {                                          parts[x] = new CodePrimitiveExpression(null);                                          goto next;                                      }                                        if (y > parts.Count - 1)                                          return new CodePrimitiveExpression(null);                                  }                                  else                                      throw new ParseException(ExInvalidExpression);                                    invoke.Method = (CodeMethodReferenceExpression)InternalMethods.Operate;                                  invoke.Parameters.Add(OperatorAsFieldReference(op));                                    if (LaxExpressions && parts[i] is Script.Operator && (Script.Operator)parts[i] == Script.Operator.Concat && parts[x] as CodeBinaryOperatorType? == CodeBinaryOperatorType.Assign)                                      invoke.Parameters.Add(new CodePrimitiveExpression(string.Empty));                                  else                                      invoke.Parameters.Add(VarMixedExpr(parts[x]));                                    invoke.Parameters.Add(VarMixedExpr(parts[y]));                                  parts[x] = invoke;                                next:                                  parts.RemoveAt(y);                              }                                parts.RemoveAt(i);                          }                          #endregion                            i--;                      }                      else if (parts[i] as CodeBinaryOperatorType? != CodeBinaryOperatorType.Assign)                      {                          var x = i - 1;                            if (x > 0 && !(parts[x] is Script.Operator || parts[x] is CodeBinaryOperatorType))                          {                              parts.Insert(i' Script.Operator.Concat);                              i--;                              continue;                          }                      }                  }                  level--;              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The following statement contains a magic number: if (parts.Count > 1)              {                  for (int i = 0; i < parts.Count; i++)                  {                      bool typed = false;                        if (LaxExpressions)                          typed = IsVarAssignment(parts[i]) || IsVarReference(parts[i]);                        if (!(typed || parts[i] is CodeMethodInvokeExpression || parts[i] is CodePrimitiveExpression || parts[i] is CodeTernaryOperatorExpression || parts[i] is CodeBinaryOperatorExpression || parts[i] is CodePropertyReferenceExpression))                          throw new ArgumentOutOfRangeException();                        if (i % 2 == 1)                          parts.Insert(i' Script.Operator.Concat);                  }                  var concat = ParseExpression(parts);                  parts.Clear();                  parts.Add(concat);              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseFlow,The following statement contains a magic number: switch (parts[0].ToLowerInvariant())              {                  #region If/Else                    case FlowIf:                      {                          if (parts.Length < 1)                              throw new ParseException("If requires a parameter");                            bool blockOpen = false;                          CodeExpression condition = ParseFlowParameter(parts[1]' true' out blockOpen' false);                          var ifelse = new CodeConditionStatement { Condition = condition };                            var block = new CodeBlock(line' Scope' ifelse.TrueStatements' CodeBlock.BlockKind.IfElse' blocks.Count == 0 ? null : blocks.Peek());                          block.Type = blockOpen ? CodeBlock.BlockType.Within : CodeBlock.BlockType.Expect;                          CloseTopSingleBlock();                          blocks.Push(block);                            elses.Push(ifelse.FalseStatements);                          return new CodeStatement[] { ifelse };                      }                    case FlowElse:                      {                          if (elses.Count == 0)                              throw new ParseException("Else with no preceeding if block");                            string next = line.Code.TrimStart(Spaces).Substring(FlowElse.Length).TrimStart(Spaces);                            if (!IsEmptyStatement(next))                              lines.Insert(index + 1' new CodeLine(lines[index].FileName' lines[index].LineNumber' next));                            var type = parts.Length > 1 && parts[1][0] == BlockOpen ? CodeBlock.BlockType.Within : CodeBlock.BlockType.Expect;                          var block = new CodeBlock(lines[index]' Scope' elses.Pop()' CodeBlock.BlockKind.IfElse' blocks.Count == 0 ? null : blocks.Peek()) { Type = type };                          CloseTopSingleBlock();                          blocks.Push(block);                      }                      break;                    #endregion                    #region Goto                    case FlowGosub:                      {                          if (parts.Length < 1)                              throw new ParseException("No label specified");                          return new CodeStatement[] { new CodeExpressionStatement(LocalLabelInvoke(parts[1])) };                      }                    case FlowGoto:                      {                          if (parts.Length < 1)                              throw new ParseException("No label specified");                          return new CodeStatement[] { new CodeExpressionStatement(LocalLabelInvoke(parts[1]))' new CodeMethodReturnStatement() };                      }                    #endregion                    #region Loops                    case FlowLoop:                      {                          bool blockOpen = false;                          CodeMethodInvokeExpression iterator;                          bool skip = true;                          bool checkBrace = true;                          bool byref = false;                            #region Loop types                          if (parts.Length > 1)                          {                              string[] sub = parts[1].Split(new[] { Multicast }' 2);                              sub = new[] { sub[0].Trim()' sub.Length > 1 ? sub[1].Trim() : string.Empty };                                switch (sub[0].ToUpperInvariant())                              {                                  case "READ":                                      byref = true;                                      iterator = (CodeMethodInvokeExpression)InternalMethods.LoopRead;                                      break;                                    case "PARSE":                                      checkBrace = false;                                      byref = true;                                      iterator = (CodeMethodInvokeExpression)InternalMethods.LoopParse;                                      break;                                    case "HKEY_LOCAL_MACHINE":                                  case "HKLM":                                  case "HKEY_USERS":                                  case "HKU":                                  case "HKEY_CURRENT_USER":                                  case "HKCU":                                  case "HKEY_CLASSES_ROOT":                                  case "HKCR":                                  case "HKEY_CURRENT_CONFIG":                                  case "HKCC":                                      iterator = (CodeMethodInvokeExpression)InternalMethods.LoopRegistry;                                      break;                                    case "EACH":                                      byref = true;                                      iterator = (CodeMethodInvokeExpression)InternalMethods.LoopEach;                                      break;                                    default:                                      {                                          var file = false;                                            if (parts[1].IndexOf(Multicast) != -1)                                              file = true;                                            // TODO: check file/iteration loop types                                            skip = false;                                          iterator = (CodeMethodInvokeExpression)(file ? InternalMethods.LoopFile : InternalMethods.Loop);                                      }                                      break;                              }                                if (skip)                                  parts[1] = sub[1];                                if (checkBrace)                              {                                  // TODO: check expression parameters before stripping comments                                  int x = parts.Length == 1 ? 0 : 1;                                  string part = StripComment(parts[x]).TrimEnd(Spaces);                                  int l = part.Length - 1;                                  if (part.Length > 0 && part[l] == BlockOpen)                                  {                                      blockOpen = true;                                      parts[x] = part.Substring(0' l);                                  }                              }                                if (skip && parts[1].Length == 0)                                  throw new ParseException("Loop type must have an argument");                                foreach (var arg in SplitCommandParameters(parts[1]))                                  iterator.Parameters.Add(ParseCommandParameter(arg));                                if (LegacyLoop && byref)                                  iterator.Parameters[0] = VarId(iterator.Parameters[0]);                          }                          else                          {                              iterator = (CodeMethodInvokeExpression)InternalMethods.Loop;                              iterator.Parameters.Add(new CodePrimitiveExpression(int.MaxValue));                          }                          #endregion                            string id = InternalID;                            var init = new CodeVariableDeclarationStatement();                          init.Name = id;                          init.Type = new CodeTypeReference(typeof(IEnumerable));                          init.InitExpression = new CodeMethodInvokeExpression(iterator' "GetEnumerator"' new CodeExpression[] { });                            var condition = new CodeMethodInvokeExpression();                          condition.Method.TargetObject = new CodeVariableReferenceExpression(id);                          condition.Method.MethodName = "MoveNext";                            var loop = new CodeIterationStatement();                          loop.InitStatement = init;                          loop.IncrementStatement = new CodeCommentStatement(string.Empty); // for C# display                          loop.TestExpression = condition;                            var block = new CodeBlock(line' Scope' loop.Statements' CodeBlock.BlockKind.Loop' blocks.Count == 0 ? null : blocks.Peek()' InternalID' InternalID);                          block.Type = blockOpen ? CodeBlock.BlockType.Within : CodeBlock.BlockType.Expect;                          CloseTopSingleBlock();                          blocks.Push(block);                            return new CodeStatement[] { loop' new CodeLabeledStatement(block.ExitLabel) };                      }                    case FlowWhile:                      {                          bool blockOpen = false;                          CodeExpression condition = parts.Length > 1 ? ParseFlowParameter(parts[1]' true' out blockOpen' true) : new CodePrimitiveExpression(true);                          var loop = new CodeIterationStatement();                          loop.TestExpression = condition;                          loop.InitStatement = new CodeCommentStatement(string.Empty);                            var block = new CodeBlock(line' Scope' loop.Statements' CodeBlock.BlockKind.Loop' blocks.Count == 0 ? null : blocks.Peek()' InternalID' InternalID);                          block.Type = blockOpen ? CodeBlock.BlockType.Within : CodeBlock.BlockType.Expect;                          CloseTopSingleBlock();                          blocks.Push(block);                            return new CodeStatement[] { loop' new CodeLabeledStatement(block.ExitLabel) };                      }                    case FlowBreak:                      int b = 1;                      if (parts.Length > 1)                      {                          parts[1] = StripCommentSingle(parts[1]);                          if (!int.TryParse(parts[1]' out b) || b < 1)                              throw new ParseException("Break parameter must be a static integer greater than zero.");                      }                      string exit = PeekLoopLabel(true' b);                      if (exit == null)                          throw new ParseException("Cannot break outside a loop");                      return new CodeStatement[] { new CodeGotoStatement(exit) };                    case FlowContinue:                      int c = 1;                      if (parts.Length > 1)                      {                          parts[1] = StripCommentSingle(parts[1]);                          if (!int.TryParse(parts[1]' out c) || c < 1)                              throw new ParseException("Continue parameter must be a static integer greater than zero.");                      }                      string cont = PeekLoopLabel(false' c);                      if (cont == null)                          throw new ParseException("Cannot continue outside a loop");                      return new CodeStatement[] { new CodeGotoStatement(cont) };                    #endregion                    #region Return                    case FlowReturn:                      if (Scope == mainScope)                      {                          if (parts.Length > 1)                              throw new ParseException("Cannot have return parameter for entry point method");                          return new CodeStatement[] { new CodeMethodReturnStatement() };                      }                      else                      {                          var result = parts.Length > 1 ? ParseSingleExpression(parts[1]) : new CodePrimitiveExpression(null);                          return new CodeStatement[] { new CodeMethodReturnStatement(result) };                      }                    #endregion                    #region Function                    case FunctionLocal:                  case FunctionGlobal:                  case FunctionStatic:                      // TODO: function local/global/static scoping modifiers                      break;                    #endregion                    default:                      throw new ParseException(ExUnexpected);              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseInequality,The following statement contains a magic number: if (i != code.Length) // if test argument is not a lone identifier then it is an expression              {                  var op = new[] { Equal' Not' Greater' Less };                                    if (Array.IndexOf(op' code[i]) == -1)                      throw new ParseException(ExUnexpected);                    buf.Append(code[i++]);                    if (i < code.Length && Array.IndexOf(op' code[i]) != -1)                      buf.Append(code[i++]);                    buf.Append(StringBound);                    while (i < code.Length && IsSpace(code[i])) i++;                    if (i < code.Length)                  {                      string str = code.Substring(i);                      str = str.Replace(StringBound.ToString()' new string(StringBound' 2));                      buf.Append(str);                  }                    while (i < code.Length && IsSpace(code[i])) i++;                    buf.Append(StringBound);              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseLegacyIf,The following statement contains a magic number: string[] parts = code.TrimStart(Spaces).Split(Spaces' 3);
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseLegacyIf,The following statement contains a magic number: if (parts.Length != 3)                  throw new ArgumentOutOfRangeException();
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseLegacyIf,The following statement contains a magic number: if (parts[1].Equals(NotTxt' StringComparison.OrdinalIgnoreCase))              {                  not = false;                  string[] sub = parts[2].Split(Spaces' 2);                  parts[1] = sub[0];                  parts[2] = sub[1];              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseLegacyIf,The following statement contains a magic number: if (parts[1].Equals(NotTxt' StringComparison.OrdinalIgnoreCase))              {                  not = false;                  string[] sub = parts[2].Split(Spaces' 2);                  parts[1] = sub[0];                  parts[2] = sub[1];              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseLegacyIf,The following statement contains a magic number: if (parts[1].Equals(NotTxt' StringComparison.OrdinalIgnoreCase))              {                  not = false;                  string[] sub = parts[2].Split(Spaces' 2);                  parts[1] = sub[0];                  parts[2] = sub[1];              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseLegacyIf,The following statement contains a magic number: invoke.Parameters.Add(ParseCommandParameter(parts[2]));
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ValidateParameterLiteral,The following statement contains a magic number: if (code[0] == StringBound)              {                  bool str = true;                  for (int i = 1; i < code.Length; i++)                  {                      if (code[i] == StringBound)                      {                          str = !str;                          int n = i + 1;                          if (n < code.Length && code[n] == code[i])                          {                              i = n;                          }                          else if (n != code.Length)                              throw new ParseException(err);                      }                  }                  if (str)                      throw new ParseException(err);                    code = code.Substring(1' code.Length - 2);                  code.Replace(new string(StringBound' 2)' string.Empty);              }              else if (!IsPrimativeObject(code))                  throw new ParseException(err);
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ValidateParameterLiteral,The following statement contains a magic number: if (code[0] == StringBound)              {                  bool str = true;                  for (int i = 1; i < code.Length; i++)                  {                      if (code[i] == StringBound)                      {                          str = !str;                          int n = i + 1;                          if (n < code.Length && code[n] == code[i])                          {                              i = n;                          }                          else if (n != code.Length)                              throw new ParseException(err);                      }                  }                  if (str)                      throw new ParseException(err);                    code = code.Substring(1' code.Length - 2);                  code.Replace(new string(StringBound' 2)' string.Empty);              }              else if (!IsPrimativeObject(code))                  throw new ParseException(err);
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseLabel,The following statement contains a magic number: if (code.Length < 2 || code[z] != HotkeyBound)                  throw new ParseException("Invalid label name");
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Read,The following statement contains a magic number: while ((code = source.ReadLine()) != null)              {                  #region Line                    line++;                    if (line == 1 && code.Length > 2 && code[0] == '#' && code[1] == '!')                      continue;                    string codeTrim = code.TrimStart(Spaces);                    #endregion                    #region Multiline comments                    if (codeTrim.Length > 1 && codeTrim[0] == MultiComA && codeTrim[1] == MultiComB)                  {                      while ((code = source.ReadLine()) != null)                      {                          line++;                          codeTrim = code.TrimStart(Spaces);                          if (codeTrim.Length > 1 && codeTrim[0] == MultiComB && codeTrim[1] == MultiComA)                          {                              code = codeTrim = codeTrim.Substring(2);                              break;                          }                      }                      if (code == null)                          continue;                  }                    #endregion                    #region Directives                    if(codeTrim.Length > 1 && codeTrim[0] == Directive)                  {                      if(codeTrim.Length < 2)                          throw new ParseException(ExUnknownDirv' line);                                            var delim = new char[Spaces.Length + 1];                      delim[0] = Multicast;                      Spaces.CopyTo(delim' 1);                      string[] sub = codeTrim.Split(delim' 2);                      var parts = new[] { sub[0]' sub.Length > 1 ? sub[1] : string.Empty };                        parts[1] = StripComment(parts[1]).Trim(Spaces);                        int value;                      int.TryParse(parts[1]' out value);                        bool next = true;                      bool includeOnce = false;                        switch (parts[0].Substring(1).ToUpperInvariant())                      {                          case "INCLUDE":                              includeOnce = true;                              goto case "INCLUDEAGAIN";                            case "INCLUDEAGAIN":                              {                                  var replace = new[']                                  {                                      { "A_ScriptDir"' Path.GetDirectoryName(name) }'                                      { "A_AppData"' Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) }'                                      { "A_AppDataCommon"' Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData) }'                                      { "ProgramFiles"' Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles) }'                                  };                                    for (int i = 0; i < replace.Length / 2; i++)                                      parts[1] = Replace(parts[1]' string.Format("{0}{1}{0}"' Resolve' replace[i' 0])' replace[i' 1]);                                    bool silent = false;                                    if (parts[1].Length > 3 && parts[1][0] == '*' && (parts[1][1] == 'i' || parts[1][1] == 'I') && IsSpace(parts[1][2]))                                  {                                      parts[1] = parts[1].Substring(3);                                      silent = true;                                  }                                    string path = parts[1];                                    if (!Path.IsPathRooted(path) && Directory.Exists(includePath))                                      path = Path.Combine(includePath' path);                                  else if(!Path.IsPathRooted(path))                                      path = Path.Combine(Path.GetDirectoryName(name)' path);                                    path = Path.GetFullPath(path);                                    if (!File.Exists(path))                                  {                                      if (!silent)                                          throw new ParseException(ExIncludeNotFound' line);                                      break;                                  }                                    if (includeOnce && includes.Contains(path))                                      break;                                    var newlist = Read(new StreamReader(path)' path);                                  list.AddRange(newlist);                                    if (!includes.Contains(path))                                      includes.Add(path);                              }                              break;                            case "NODYNAMICVARS":                              DynamicVars = false;                              break;                            case "NOENV":                              NoEnv = true;                              break;                            case "NOTRAYICON":                              NoTrayIcon = true;                              break;                            case "PERSISTENT":                              Persistent = true;                              break;                            case "SINGLEINSTANCE":                              switch (parts[1].ToUpperInvariant())                              {                                  case "FORCE":                                      SingleInstance = true;                                      break;                                  case "IGNORE":                                      SingleInstance = null;                                      break;                                  case "OFF":                                      SingleInstance = false;                                      break;                                  default:                                      break;                              }                              break;                            case "WINACTIVATEFORCE":                              WinActivateForce = true;                              break;                            case "HOTSTRING":                              switch (parts[1].ToUpperInvariant())                              {                                  case "NOMOUSE":                                      HotstringNoMouse = true;                                      break;                                  case "ENDCHARS":                                      HotstringEndChars = parts[1];                                      break;                                  default:                                      next = false;                                      break;                              }                              break;                            case "ALLOWSAMELINECOMMENTS":                          case "ERRORSTDOUT":                          case "HOTKEYINTERVAL":                          case "HOTKEYMODIFIERTIMEOUT":                          case "INSTALLKEYBDHOOK":                          case "INSTALLMOUSEHOOK":                          case "KEYHISTORY":                          case "MAXHOTKEYSPERINTERVAL":                          case "MAXMEM":                          case "MAXTHREADS":                          case "MAXTHREADSBUFFER":                          case "MAXTHREADSPERHOTKEY":                          case "USEHOOK":                              // deprecated directives                              break;                            default:                              next = false;                              break;                      }                        if (next)                          continue;                  }                    #endregion                    #region Mulitline strings                    if (codeTrim.Length > 0 && codeTrim[0] == ParenOpen)                  {                      if (list.Count == 0)                          throw new ParseException(ExUnexpected' line);                        var buf = new StringBuilder(code.Length);                      buf.Append(code);                      buf.Append(Environment.NewLine);                        while ((code = source.ReadLine()) != null)                      {                          codeTrim = code.TrimStart(Spaces);                            if (codeTrim.Length > 0 && codeTrim[0] == ParenClose)                          {                              code = codeTrim = codeTrim.Substring(1);                              buf.Append(ParenClose);                              break;                          }                          else                          {                              buf.Append(code);                              buf.Append(Environment.NewLine);                          }                      }                        string str = buf.ToString();                      string result = MultilineString(str);                      list[list.Count - 1].Code += result + code;                      continue;                  }                    #endregion                    #region Statement                    code = code.Trim(Spaces);                    if (code.StartsWith(new string(new[] { MultiComB' MultiComA })))                      code = code.Substring(2);                    if (code.Length == 0 || IsCommentLine(code))                      continue;                    if (IsContinuationLine(code))                  {                      if (list.Count == 0)                          throw new ParseException(ExUnexpected' line);                        int i = list.Count - 1;                      var buf = new StringBuilder(list[i].Code' list[i].Code.Length + Environment.NewLine.Length + code.Length);                      buf.Append(Environment.NewLine);                      buf.Append(code);                      list[i].Code = buf.ToString();                  }                  else                  {                      Translate(ref code);                        if (code.Length != 0)                          list.Add(new CodeLine(name' line' code));                  }                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Read,The following statement contains a magic number: while ((code = source.ReadLine()) != null)              {                  #region Line                    line++;                    if (line == 1 && code.Length > 2 && code[0] == '#' && code[1] == '!')                      continue;                    string codeTrim = code.TrimStart(Spaces);                    #endregion                    #region Multiline comments                    if (codeTrim.Length > 1 && codeTrim[0] == MultiComA && codeTrim[1] == MultiComB)                  {                      while ((code = source.ReadLine()) != null)                      {                          line++;                          codeTrim = code.TrimStart(Spaces);                          if (codeTrim.Length > 1 && codeTrim[0] == MultiComB && codeTrim[1] == MultiComA)                          {                              code = codeTrim = codeTrim.Substring(2);                              break;                          }                      }                      if (code == null)                          continue;                  }                    #endregion                    #region Directives                    if(codeTrim.Length > 1 && codeTrim[0] == Directive)                  {                      if(codeTrim.Length < 2)                          throw new ParseException(ExUnknownDirv' line);                                            var delim = new char[Spaces.Length + 1];                      delim[0] = Multicast;                      Spaces.CopyTo(delim' 1);                      string[] sub = codeTrim.Split(delim' 2);                      var parts = new[] { sub[0]' sub.Length > 1 ? sub[1] : string.Empty };                        parts[1] = StripComment(parts[1]).Trim(Spaces);                        int value;                      int.TryParse(parts[1]' out value);                        bool next = true;                      bool includeOnce = false;                        switch (parts[0].Substring(1).ToUpperInvariant())                      {                          case "INCLUDE":                              includeOnce = true;                              goto case "INCLUDEAGAIN";                            case "INCLUDEAGAIN":                              {                                  var replace = new[']                                  {                                      { "A_ScriptDir"' Path.GetDirectoryName(name) }'                                      { "A_AppData"' Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) }'                                      { "A_AppDataCommon"' Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData) }'                                      { "ProgramFiles"' Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles) }'                                  };                                    for (int i = 0; i < replace.Length / 2; i++)                                      parts[1] = Replace(parts[1]' string.Format("{0}{1}{0}"' Resolve' replace[i' 0])' replace[i' 1]);                                    bool silent = false;                                    if (parts[1].Length > 3 && parts[1][0] == '*' && (parts[1][1] == 'i' || parts[1][1] == 'I') && IsSpace(parts[1][2]))                                  {                                      parts[1] = parts[1].Substring(3);                                      silent = true;                                  }                                    string path = parts[1];                                    if (!Path.IsPathRooted(path) && Directory.Exists(includePath))                                      path = Path.Combine(includePath' path);                                  else if(!Path.IsPathRooted(path))                                      path = Path.Combine(Path.GetDirectoryName(name)' path);                                    path = Path.GetFullPath(path);                                    if (!File.Exists(path))                                  {                                      if (!silent)                                          throw new ParseException(ExIncludeNotFound' line);                                      break;                                  }                                    if (includeOnce && includes.Contains(path))                                      break;                                    var newlist = Read(new StreamReader(path)' path);                                  list.AddRange(newlist);                                    if (!includes.Contains(path))                                      includes.Add(path);                              }                              break;                            case "NODYNAMICVARS":                              DynamicVars = false;                              break;                            case "NOENV":                              NoEnv = true;                              break;                            case "NOTRAYICON":                              NoTrayIcon = true;                              break;                            case "PERSISTENT":                              Persistent = true;                              break;                            case "SINGLEINSTANCE":                              switch (parts[1].ToUpperInvariant())                              {                                  case "FORCE":                                      SingleInstance = true;                                      break;                                  case "IGNORE":                                      SingleInstance = null;                                      break;                                  case "OFF":                                      SingleInstance = false;                                      break;                                  default:                                      break;                              }                              break;                            case "WINACTIVATEFORCE":                              WinActivateForce = true;                              break;                            case "HOTSTRING":                              switch (parts[1].ToUpperInvariant())                              {                                  case "NOMOUSE":                                      HotstringNoMouse = true;                                      break;                                  case "ENDCHARS":                                      HotstringEndChars = parts[1];                                      break;                                  default:                                      next = false;                                      break;                              }                              break;                            case "ALLOWSAMELINECOMMENTS":                          case "ERRORSTDOUT":                          case "HOTKEYINTERVAL":                          case "HOTKEYMODIFIERTIMEOUT":                          case "INSTALLKEYBDHOOK":                          case "INSTALLMOUSEHOOK":                          case "KEYHISTORY":                          case "MAXHOTKEYSPERINTERVAL":                          case "MAXMEM":                          case "MAXTHREADS":                          case "MAXTHREADSBUFFER":                          case "MAXTHREADSPERHOTKEY":                          case "USEHOOK":                              // deprecated directives                              break;                            default:                              next = false;                              break;                      }                        if (next)                          continue;                  }                    #endregion                    #region Mulitline strings                    if (codeTrim.Length > 0 && codeTrim[0] == ParenOpen)                  {                      if (list.Count == 0)                          throw new ParseException(ExUnexpected' line);                        var buf = new StringBuilder(code.Length);                      buf.Append(code);                      buf.Append(Environment.NewLine);                        while ((code = source.ReadLine()) != null)                      {                          codeTrim = code.TrimStart(Spaces);                            if (codeTrim.Length > 0 && codeTrim[0] == ParenClose)                          {                              code = codeTrim = codeTrim.Substring(1);                              buf.Append(ParenClose);                              break;                          }                          else                          {                              buf.Append(code);                              buf.Append(Environment.NewLine);                          }                      }                        string str = buf.ToString();                      string result = MultilineString(str);                      list[list.Count - 1].Code += result + code;                      continue;                  }                    #endregion                    #region Statement                    code = code.Trim(Spaces);                    if (code.StartsWith(new string(new[] { MultiComB' MultiComA })))                      code = code.Substring(2);                    if (code.Length == 0 || IsCommentLine(code))                      continue;                    if (IsContinuationLine(code))                  {                      if (list.Count == 0)                          throw new ParseException(ExUnexpected' line);                        int i = list.Count - 1;                      var buf = new StringBuilder(list[i].Code' list[i].Code.Length + Environment.NewLine.Length + code.Length);                      buf.Append(Environment.NewLine);                      buf.Append(code);                      list[i].Code = buf.ToString();                  }                  else                  {                      Translate(ref code);                        if (code.Length != 0)                          list.Add(new CodeLine(name' line' code));                  }                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Read,The following statement contains a magic number: while ((code = source.ReadLine()) != null)              {                  #region Line                    line++;                    if (line == 1 && code.Length > 2 && code[0] == '#' && code[1] == '!')                      continue;                    string codeTrim = code.TrimStart(Spaces);                    #endregion                    #region Multiline comments                    if (codeTrim.Length > 1 && codeTrim[0] == MultiComA && codeTrim[1] == MultiComB)                  {                      while ((code = source.ReadLine()) != null)                      {                          line++;                          codeTrim = code.TrimStart(Spaces);                          if (codeTrim.Length > 1 && codeTrim[0] == MultiComB && codeTrim[1] == MultiComA)                          {                              code = codeTrim = codeTrim.Substring(2);                              break;                          }                      }                      if (code == null)                          continue;                  }                    #endregion                    #region Directives                    if(codeTrim.Length > 1 && codeTrim[0] == Directive)                  {                      if(codeTrim.Length < 2)                          throw new ParseException(ExUnknownDirv' line);                                            var delim = new char[Spaces.Length + 1];                      delim[0] = Multicast;                      Spaces.CopyTo(delim' 1);                      string[] sub = codeTrim.Split(delim' 2);                      var parts = new[] { sub[0]' sub.Length > 1 ? sub[1] : string.Empty };                        parts[1] = StripComment(parts[1]).Trim(Spaces);                        int value;                      int.TryParse(parts[1]' out value);                        bool next = true;                      bool includeOnce = false;                        switch (parts[0].Substring(1).ToUpperInvariant())                      {                          case "INCLUDE":                              includeOnce = true;                              goto case "INCLUDEAGAIN";                            case "INCLUDEAGAIN":                              {                                  var replace = new[']                                  {                                      { "A_ScriptDir"' Path.GetDirectoryName(name) }'                                      { "A_AppData"' Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) }'                                      { "A_AppDataCommon"' Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData) }'                                      { "ProgramFiles"' Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles) }'                                  };                                    for (int i = 0; i < replace.Length / 2; i++)                                      parts[1] = Replace(parts[1]' string.Format("{0}{1}{0}"' Resolve' replace[i' 0])' replace[i' 1]);                                    bool silent = false;                                    if (parts[1].Length > 3 && parts[1][0] == '*' && (parts[1][1] == 'i' || parts[1][1] == 'I') && IsSpace(parts[1][2]))                                  {                                      parts[1] = parts[1].Substring(3);                                      silent = true;                                  }                                    string path = parts[1];                                    if (!Path.IsPathRooted(path) && Directory.Exists(includePath))                                      path = Path.Combine(includePath' path);                                  else if(!Path.IsPathRooted(path))                                      path = Path.Combine(Path.GetDirectoryName(name)' path);                                    path = Path.GetFullPath(path);                                    if (!File.Exists(path))                                  {                                      if (!silent)                                          throw new ParseException(ExIncludeNotFound' line);                                      break;                                  }                                    if (includeOnce && includes.Contains(path))                                      break;                                    var newlist = Read(new StreamReader(path)' path);                                  list.AddRange(newlist);                                    if (!includes.Contains(path))                                      includes.Add(path);                              }                              break;                            case "NODYNAMICVARS":                              DynamicVars = false;                              break;                            case "NOENV":                              NoEnv = true;                              break;                            case "NOTRAYICON":                              NoTrayIcon = true;                              break;                            case "PERSISTENT":                              Persistent = true;                              break;                            case "SINGLEINSTANCE":                              switch (parts[1].ToUpperInvariant())                              {                                  case "FORCE":                                      SingleInstance = true;                                      break;                                  case "IGNORE":                                      SingleInstance = null;                                      break;                                  case "OFF":                                      SingleInstance = false;                                      break;                                  default:                                      break;                              }                              break;                            case "WINACTIVATEFORCE":                              WinActivateForce = true;                              break;                            case "HOTSTRING":                              switch (parts[1].ToUpperInvariant())                              {                                  case "NOMOUSE":                                      HotstringNoMouse = true;                                      break;                                  case "ENDCHARS":                                      HotstringEndChars = parts[1];                                      break;                                  default:                                      next = false;                                      break;                              }                              break;                            case "ALLOWSAMELINECOMMENTS":                          case "ERRORSTDOUT":                          case "HOTKEYINTERVAL":                          case "HOTKEYMODIFIERTIMEOUT":                          case "INSTALLKEYBDHOOK":                          case "INSTALLMOUSEHOOK":                          case "KEYHISTORY":                          case "MAXHOTKEYSPERINTERVAL":                          case "MAXMEM":                          case "MAXTHREADS":                          case "MAXTHREADSBUFFER":                          case "MAXTHREADSPERHOTKEY":                          case "USEHOOK":                              // deprecated directives                              break;                            default:                              next = false;                              break;                      }                        if (next)                          continue;                  }                    #endregion                    #region Mulitline strings                    if (codeTrim.Length > 0 && codeTrim[0] == ParenOpen)                  {                      if (list.Count == 0)                          throw new ParseException(ExUnexpected' line);                        var buf = new StringBuilder(code.Length);                      buf.Append(code);                      buf.Append(Environment.NewLine);                        while ((code = source.ReadLine()) != null)                      {                          codeTrim = code.TrimStart(Spaces);                            if (codeTrim.Length > 0 && codeTrim[0] == ParenClose)                          {                              code = codeTrim = codeTrim.Substring(1);                              buf.Append(ParenClose);                              break;                          }                          else                          {                              buf.Append(code);                              buf.Append(Environment.NewLine);                          }                      }                        string str = buf.ToString();                      string result = MultilineString(str);                      list[list.Count - 1].Code += result + code;                      continue;                  }                    #endregion                    #region Statement                    code = code.Trim(Spaces);                    if (code.StartsWith(new string(new[] { MultiComB' MultiComA })))                      code = code.Substring(2);                    if (code.Length == 0 || IsCommentLine(code))                      continue;                    if (IsContinuationLine(code))                  {                      if (list.Count == 0)                          throw new ParseException(ExUnexpected' line);                        int i = list.Count - 1;                      var buf = new StringBuilder(list[i].Code' list[i].Code.Length + Environment.NewLine.Length + code.Length);                      buf.Append(Environment.NewLine);                      buf.Append(code);                      list[i].Code = buf.ToString();                  }                  else                  {                      Translate(ref code);                        if (code.Length != 0)                          list.Add(new CodeLine(name' line' code));                  }                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Read,The following statement contains a magic number: while ((code = source.ReadLine()) != null)              {                  #region Line                    line++;                    if (line == 1 && code.Length > 2 && code[0] == '#' && code[1] == '!')                      continue;                    string codeTrim = code.TrimStart(Spaces);                    #endregion                    #region Multiline comments                    if (codeTrim.Length > 1 && codeTrim[0] == MultiComA && codeTrim[1] == MultiComB)                  {                      while ((code = source.ReadLine()) != null)                      {                          line++;                          codeTrim = code.TrimStart(Spaces);                          if (codeTrim.Length > 1 && codeTrim[0] == MultiComB && codeTrim[1] == MultiComA)                          {                              code = codeTrim = codeTrim.Substring(2);                              break;                          }                      }                      if (code == null)                          continue;                  }                    #endregion                    #region Directives                    if(codeTrim.Length > 1 && codeTrim[0] == Directive)                  {                      if(codeTrim.Length < 2)                          throw new ParseException(ExUnknownDirv' line);                                            var delim = new char[Spaces.Length + 1];                      delim[0] = Multicast;                      Spaces.CopyTo(delim' 1);                      string[] sub = codeTrim.Split(delim' 2);                      var parts = new[] { sub[0]' sub.Length > 1 ? sub[1] : string.Empty };                        parts[1] = StripComment(parts[1]).Trim(Spaces);                        int value;                      int.TryParse(parts[1]' out value);                        bool next = true;                      bool includeOnce = false;                        switch (parts[0].Substring(1).ToUpperInvariant())                      {                          case "INCLUDE":                              includeOnce = true;                              goto case "INCLUDEAGAIN";                            case "INCLUDEAGAIN":                              {                                  var replace = new[']                                  {                                      { "A_ScriptDir"' Path.GetDirectoryName(name) }'                                      { "A_AppData"' Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) }'                                      { "A_AppDataCommon"' Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData) }'                                      { "ProgramFiles"' Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles) }'                                  };                                    for (int i = 0; i < replace.Length / 2; i++)                                      parts[1] = Replace(parts[1]' string.Format("{0}{1}{0}"' Resolve' replace[i' 0])' replace[i' 1]);                                    bool silent = false;                                    if (parts[1].Length > 3 && parts[1][0] == '*' && (parts[1][1] == 'i' || parts[1][1] == 'I') && IsSpace(parts[1][2]))                                  {                                      parts[1] = parts[1].Substring(3);                                      silent = true;                                  }                                    string path = parts[1];                                    if (!Path.IsPathRooted(path) && Directory.Exists(includePath))                                      path = Path.Combine(includePath' path);                                  else if(!Path.IsPathRooted(path))                                      path = Path.Combine(Path.GetDirectoryName(name)' path);                                    path = Path.GetFullPath(path);                                    if (!File.Exists(path))                                  {                                      if (!silent)                                          throw new ParseException(ExIncludeNotFound' line);                                      break;                                  }                                    if (includeOnce && includes.Contains(path))                                      break;                                    var newlist = Read(new StreamReader(path)' path);                                  list.AddRange(newlist);                                    if (!includes.Contains(path))                                      includes.Add(path);                              }                              break;                            case "NODYNAMICVARS":                              DynamicVars = false;                              break;                            case "NOENV":                              NoEnv = true;                              break;                            case "NOTRAYICON":                              NoTrayIcon = true;                              break;                            case "PERSISTENT":                              Persistent = true;                              break;                            case "SINGLEINSTANCE":                              switch (parts[1].ToUpperInvariant())                              {                                  case "FORCE":                                      SingleInstance = true;                                      break;                                  case "IGNORE":                                      SingleInstance = null;                                      break;                                  case "OFF":                                      SingleInstance = false;                                      break;                                  default:                                      break;                              }                              break;                            case "WINACTIVATEFORCE":                              WinActivateForce = true;                              break;                            case "HOTSTRING":                              switch (parts[1].ToUpperInvariant())                              {                                  case "NOMOUSE":                                      HotstringNoMouse = true;                                      break;                                  case "ENDCHARS":                                      HotstringEndChars = parts[1];                                      break;                                  default:                                      next = false;                                      break;                              }                              break;                            case "ALLOWSAMELINECOMMENTS":                          case "ERRORSTDOUT":                          case "HOTKEYINTERVAL":                          case "HOTKEYMODIFIERTIMEOUT":                          case "INSTALLKEYBDHOOK":                          case "INSTALLMOUSEHOOK":                          case "KEYHISTORY":                          case "MAXHOTKEYSPERINTERVAL":                          case "MAXMEM":                          case "MAXTHREADS":                          case "MAXTHREADSBUFFER":                          case "MAXTHREADSPERHOTKEY":                          case "USEHOOK":                              // deprecated directives                              break;                            default:                              next = false;                              break;                      }                        if (next)                          continue;                  }                    #endregion                    #region Mulitline strings                    if (codeTrim.Length > 0 && codeTrim[0] == ParenOpen)                  {                      if (list.Count == 0)                          throw new ParseException(ExUnexpected' line);                        var buf = new StringBuilder(code.Length);                      buf.Append(code);                      buf.Append(Environment.NewLine);                        while ((code = source.ReadLine()) != null)                      {                          codeTrim = code.TrimStart(Spaces);                            if (codeTrim.Length > 0 && codeTrim[0] == ParenClose)                          {                              code = codeTrim = codeTrim.Substring(1);                              buf.Append(ParenClose);                              break;                          }                          else                          {                              buf.Append(code);                              buf.Append(Environment.NewLine);                          }                      }                        string str = buf.ToString();                      string result = MultilineString(str);                      list[list.Count - 1].Code += result + code;                      continue;                  }                    #endregion                    #region Statement                    code = code.Trim(Spaces);                    if (code.StartsWith(new string(new[] { MultiComB' MultiComA })))                      code = code.Substring(2);                    if (code.Length == 0 || IsCommentLine(code))                      continue;                    if (IsContinuationLine(code))                  {                      if (list.Count == 0)                          throw new ParseException(ExUnexpected' line);                        int i = list.Count - 1;                      var buf = new StringBuilder(list[i].Code' list[i].Code.Length + Environment.NewLine.Length + code.Length);                      buf.Append(Environment.NewLine);                      buf.Append(code);                      list[i].Code = buf.ToString();                  }                  else                  {                      Translate(ref code);                        if (code.Length != 0)                          list.Add(new CodeLine(name' line' code));                  }                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Read,The following statement contains a magic number: while ((code = source.ReadLine()) != null)              {                  #region Line                    line++;                    if (line == 1 && code.Length > 2 && code[0] == '#' && code[1] == '!')                      continue;                    string codeTrim = code.TrimStart(Spaces);                    #endregion                    #region Multiline comments                    if (codeTrim.Length > 1 && codeTrim[0] == MultiComA && codeTrim[1] == MultiComB)                  {                      while ((code = source.ReadLine()) != null)                      {                          line++;                          codeTrim = code.TrimStart(Spaces);                          if (codeTrim.Length > 1 && codeTrim[0] == MultiComB && codeTrim[1] == MultiComA)                          {                              code = codeTrim = codeTrim.Substring(2);                              break;                          }                      }                      if (code == null)                          continue;                  }                    #endregion                    #region Directives                    if(codeTrim.Length > 1 && codeTrim[0] == Directive)                  {                      if(codeTrim.Length < 2)                          throw new ParseException(ExUnknownDirv' line);                                            var delim = new char[Spaces.Length + 1];                      delim[0] = Multicast;                      Spaces.CopyTo(delim' 1);                      string[] sub = codeTrim.Split(delim' 2);                      var parts = new[] { sub[0]' sub.Length > 1 ? sub[1] : string.Empty };                        parts[1] = StripComment(parts[1]).Trim(Spaces);                        int value;                      int.TryParse(parts[1]' out value);                        bool next = true;                      bool includeOnce = false;                        switch (parts[0].Substring(1).ToUpperInvariant())                      {                          case "INCLUDE":                              includeOnce = true;                              goto case "INCLUDEAGAIN";                            case "INCLUDEAGAIN":                              {                                  var replace = new[']                                  {                                      { "A_ScriptDir"' Path.GetDirectoryName(name) }'                                      { "A_AppData"' Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) }'                                      { "A_AppDataCommon"' Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData) }'                                      { "ProgramFiles"' Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles) }'                                  };                                    for (int i = 0; i < replace.Length / 2; i++)                                      parts[1] = Replace(parts[1]' string.Format("{0}{1}{0}"' Resolve' replace[i' 0])' replace[i' 1]);                                    bool silent = false;                                    if (parts[1].Length > 3 && parts[1][0] == '*' && (parts[1][1] == 'i' || parts[1][1] == 'I') && IsSpace(parts[1][2]))                                  {                                      parts[1] = parts[1].Substring(3);                                      silent = true;                                  }                                    string path = parts[1];                                    if (!Path.IsPathRooted(path) && Directory.Exists(includePath))                                      path = Path.Combine(includePath' path);                                  else if(!Path.IsPathRooted(path))                                      path = Path.Combine(Path.GetDirectoryName(name)' path);                                    path = Path.GetFullPath(path);                                    if (!File.Exists(path))                                  {                                      if (!silent)                                          throw new ParseException(ExIncludeNotFound' line);                                      break;                                  }                                    if (includeOnce && includes.Contains(path))                                      break;                                    var newlist = Read(new StreamReader(path)' path);                                  list.AddRange(newlist);                                    if (!includes.Contains(path))                                      includes.Add(path);                              }                              break;                            case "NODYNAMICVARS":                              DynamicVars = false;                              break;                            case "NOENV":                              NoEnv = true;                              break;                            case "NOTRAYICON":                              NoTrayIcon = true;                              break;                            case "PERSISTENT":                              Persistent = true;                              break;                            case "SINGLEINSTANCE":                              switch (parts[1].ToUpperInvariant())                              {                                  case "FORCE":                                      SingleInstance = true;                                      break;                                  case "IGNORE":                                      SingleInstance = null;                                      break;                                  case "OFF":                                      SingleInstance = false;                                      break;                                  default:                                      break;                              }                              break;                            case "WINACTIVATEFORCE":                              WinActivateForce = true;                              break;                            case "HOTSTRING":                              switch (parts[1].ToUpperInvariant())                              {                                  case "NOMOUSE":                                      HotstringNoMouse = true;                                      break;                                  case "ENDCHARS":                                      HotstringEndChars = parts[1];                                      break;                                  default:                                      next = false;                                      break;                              }                              break;                            case "ALLOWSAMELINECOMMENTS":                          case "ERRORSTDOUT":                          case "HOTKEYINTERVAL":                          case "HOTKEYMODIFIERTIMEOUT":                          case "INSTALLKEYBDHOOK":                          case "INSTALLMOUSEHOOK":                          case "KEYHISTORY":                          case "MAXHOTKEYSPERINTERVAL":                          case "MAXMEM":                          case "MAXTHREADS":                          case "MAXTHREADSBUFFER":                          case "MAXTHREADSPERHOTKEY":                          case "USEHOOK":                              // deprecated directives                              break;                            default:                              next = false;                              break;                      }                        if (next)                          continue;                  }                    #endregion                    #region Mulitline strings                    if (codeTrim.Length > 0 && codeTrim[0] == ParenOpen)                  {                      if (list.Count == 0)                          throw new ParseException(ExUnexpected' line);                        var buf = new StringBuilder(code.Length);                      buf.Append(code);                      buf.Append(Environment.NewLine);                        while ((code = source.ReadLine()) != null)                      {                          codeTrim = code.TrimStart(Spaces);                            if (codeTrim.Length > 0 && codeTrim[0] == ParenClose)                          {                              code = codeTrim = codeTrim.Substring(1);                              buf.Append(ParenClose);                              break;                          }                          else                          {                              buf.Append(code);                              buf.Append(Environment.NewLine);                          }                      }                        string str = buf.ToString();                      string result = MultilineString(str);                      list[list.Count - 1].Code += result + code;                      continue;                  }                    #endregion                    #region Statement                    code = code.Trim(Spaces);                    if (code.StartsWith(new string(new[] { MultiComB' MultiComA })))                      code = code.Substring(2);                    if (code.Length == 0 || IsCommentLine(code))                      continue;                    if (IsContinuationLine(code))                  {                      if (list.Count == 0)                          throw new ParseException(ExUnexpected' line);                        int i = list.Count - 1;                      var buf = new StringBuilder(list[i].Code' list[i].Code.Length + Environment.NewLine.Length + code.Length);                      buf.Append(Environment.NewLine);                      buf.Append(code);                      list[i].Code = buf.ToString();                  }                  else                  {                      Translate(ref code);                        if (code.Length != 0)                          list.Add(new CodeLine(name' line' code));                  }                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Read,The following statement contains a magic number: while ((code = source.ReadLine()) != null)              {                  #region Line                    line++;                    if (line == 1 && code.Length > 2 && code[0] == '#' && code[1] == '!')                      continue;                    string codeTrim = code.TrimStart(Spaces);                    #endregion                    #region Multiline comments                    if (codeTrim.Length > 1 && codeTrim[0] == MultiComA && codeTrim[1] == MultiComB)                  {                      while ((code = source.ReadLine()) != null)                      {                          line++;                          codeTrim = code.TrimStart(Spaces);                          if (codeTrim.Length > 1 && codeTrim[0] == MultiComB && codeTrim[1] == MultiComA)                          {                              code = codeTrim = codeTrim.Substring(2);                              break;                          }                      }                      if (code == null)                          continue;                  }                    #endregion                    #region Directives                    if(codeTrim.Length > 1 && codeTrim[0] == Directive)                  {                      if(codeTrim.Length < 2)                          throw new ParseException(ExUnknownDirv' line);                                            var delim = new char[Spaces.Length + 1];                      delim[0] = Multicast;                      Spaces.CopyTo(delim' 1);                      string[] sub = codeTrim.Split(delim' 2);                      var parts = new[] { sub[0]' sub.Length > 1 ? sub[1] : string.Empty };                        parts[1] = StripComment(parts[1]).Trim(Spaces);                        int value;                      int.TryParse(parts[1]' out value);                        bool next = true;                      bool includeOnce = false;                        switch (parts[0].Substring(1).ToUpperInvariant())                      {                          case "INCLUDE":                              includeOnce = true;                              goto case "INCLUDEAGAIN";                            case "INCLUDEAGAIN":                              {                                  var replace = new[']                                  {                                      { "A_ScriptDir"' Path.GetDirectoryName(name) }'                                      { "A_AppData"' Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) }'                                      { "A_AppDataCommon"' Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData) }'                                      { "ProgramFiles"' Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles) }'                                  };                                    for (int i = 0; i < replace.Length / 2; i++)                                      parts[1] = Replace(parts[1]' string.Format("{0}{1}{0}"' Resolve' replace[i' 0])' replace[i' 1]);                                    bool silent = false;                                    if (parts[1].Length > 3 && parts[1][0] == '*' && (parts[1][1] == 'i' || parts[1][1] == 'I') && IsSpace(parts[1][2]))                                  {                                      parts[1] = parts[1].Substring(3);                                      silent = true;                                  }                                    string path = parts[1];                                    if (!Path.IsPathRooted(path) && Directory.Exists(includePath))                                      path = Path.Combine(includePath' path);                                  else if(!Path.IsPathRooted(path))                                      path = Path.Combine(Path.GetDirectoryName(name)' path);                                    path = Path.GetFullPath(path);                                    if (!File.Exists(path))                                  {                                      if (!silent)                                          throw new ParseException(ExIncludeNotFound' line);                                      break;                                  }                                    if (includeOnce && includes.Contains(path))                                      break;                                    var newlist = Read(new StreamReader(path)' path);                                  list.AddRange(newlist);                                    if (!includes.Contains(path))                                      includes.Add(path);                              }                              break;                            case "NODYNAMICVARS":                              DynamicVars = false;                              break;                            case "NOENV":                              NoEnv = true;                              break;                            case "NOTRAYICON":                              NoTrayIcon = true;                              break;                            case "PERSISTENT":                              Persistent = true;                              break;                            case "SINGLEINSTANCE":                              switch (parts[1].ToUpperInvariant())                              {                                  case "FORCE":                                      SingleInstance = true;                                      break;                                  case "IGNORE":                                      SingleInstance = null;                                      break;                                  case "OFF":                                      SingleInstance = false;                                      break;                                  default:                                      break;                              }                              break;                            case "WINACTIVATEFORCE":                              WinActivateForce = true;                              break;                            case "HOTSTRING":                              switch (parts[1].ToUpperInvariant())                              {                                  case "NOMOUSE":                                      HotstringNoMouse = true;                                      break;                                  case "ENDCHARS":                                      HotstringEndChars = parts[1];                                      break;                                  default:                                      next = false;                                      break;                              }                              break;                            case "ALLOWSAMELINECOMMENTS":                          case "ERRORSTDOUT":                          case "HOTKEYINTERVAL":                          case "HOTKEYMODIFIERTIMEOUT":                          case "INSTALLKEYBDHOOK":                          case "INSTALLMOUSEHOOK":                          case "KEYHISTORY":                          case "MAXHOTKEYSPERINTERVAL":                          case "MAXMEM":                          case "MAXTHREADS":                          case "MAXTHREADSBUFFER":                          case "MAXTHREADSPERHOTKEY":                          case "USEHOOK":                              // deprecated directives                              break;                            default:                              next = false;                              break;                      }                        if (next)                          continue;                  }                    #endregion                    #region Mulitline strings                    if (codeTrim.Length > 0 && codeTrim[0] == ParenOpen)                  {                      if (list.Count == 0)                          throw new ParseException(ExUnexpected' line);                        var buf = new StringBuilder(code.Length);                      buf.Append(code);                      buf.Append(Environment.NewLine);                        while ((code = source.ReadLine()) != null)                      {                          codeTrim = code.TrimStart(Spaces);                            if (codeTrim.Length > 0 && codeTrim[0] == ParenClose)                          {                              code = codeTrim = codeTrim.Substring(1);                              buf.Append(ParenClose);                              break;                          }                          else                          {                              buf.Append(code);                              buf.Append(Environment.NewLine);                          }                      }                        string str = buf.ToString();                      string result = MultilineString(str);                      list[list.Count - 1].Code += result + code;                      continue;                  }                    #endregion                    #region Statement                    code = code.Trim(Spaces);                    if (code.StartsWith(new string(new[] { MultiComB' MultiComA })))                      code = code.Substring(2);                    if (code.Length == 0 || IsCommentLine(code))                      continue;                    if (IsContinuationLine(code))                  {                      if (list.Count == 0)                          throw new ParseException(ExUnexpected' line);                        int i = list.Count - 1;                      var buf = new StringBuilder(list[i].Code' list[i].Code.Length + Environment.NewLine.Length + code.Length);                      buf.Append(Environment.NewLine);                      buf.Append(code);                      list[i].Code = buf.ToString();                  }                  else                  {                      Translate(ref code);                        if (code.Length != 0)                          list.Add(new CodeLine(name' line' code));                  }                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Read,The following statement contains a magic number: while ((code = source.ReadLine()) != null)              {                  #region Line                    line++;                    if (line == 1 && code.Length > 2 && code[0] == '#' && code[1] == '!')                      continue;                    string codeTrim = code.TrimStart(Spaces);                    #endregion                    #region Multiline comments                    if (codeTrim.Length > 1 && codeTrim[0] == MultiComA && codeTrim[1] == MultiComB)                  {                      while ((code = source.ReadLine()) != null)                      {                          line++;                          codeTrim = code.TrimStart(Spaces);                          if (codeTrim.Length > 1 && codeTrim[0] == MultiComB && codeTrim[1] == MultiComA)                          {                              code = codeTrim = codeTrim.Substring(2);                              break;                          }                      }                      if (code == null)                          continue;                  }                    #endregion                    #region Directives                    if(codeTrim.Length > 1 && codeTrim[0] == Directive)                  {                      if(codeTrim.Length < 2)                          throw new ParseException(ExUnknownDirv' line);                                            var delim = new char[Spaces.Length + 1];                      delim[0] = Multicast;                      Spaces.CopyTo(delim' 1);                      string[] sub = codeTrim.Split(delim' 2);                      var parts = new[] { sub[0]' sub.Length > 1 ? sub[1] : string.Empty };                        parts[1] = StripComment(parts[1]).Trim(Spaces);                        int value;                      int.TryParse(parts[1]' out value);                        bool next = true;                      bool includeOnce = false;                        switch (parts[0].Substring(1).ToUpperInvariant())                      {                          case "INCLUDE":                              includeOnce = true;                              goto case "INCLUDEAGAIN";                            case "INCLUDEAGAIN":                              {                                  var replace = new[']                                  {                                      { "A_ScriptDir"' Path.GetDirectoryName(name) }'                                      { "A_AppData"' Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) }'                                      { "A_AppDataCommon"' Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData) }'                                      { "ProgramFiles"' Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles) }'                                  };                                    for (int i = 0; i < replace.Length / 2; i++)                                      parts[1] = Replace(parts[1]' string.Format("{0}{1}{0}"' Resolve' replace[i' 0])' replace[i' 1]);                                    bool silent = false;                                    if (parts[1].Length > 3 && parts[1][0] == '*' && (parts[1][1] == 'i' || parts[1][1] == 'I') && IsSpace(parts[1][2]))                                  {                                      parts[1] = parts[1].Substring(3);                                      silent = true;                                  }                                    string path = parts[1];                                    if (!Path.IsPathRooted(path) && Directory.Exists(includePath))                                      path = Path.Combine(includePath' path);                                  else if(!Path.IsPathRooted(path))                                      path = Path.Combine(Path.GetDirectoryName(name)' path);                                    path = Path.GetFullPath(path);                                    if (!File.Exists(path))                                  {                                      if (!silent)                                          throw new ParseException(ExIncludeNotFound' line);                                      break;                                  }                                    if (includeOnce && includes.Contains(path))                                      break;                                    var newlist = Read(new StreamReader(path)' path);                                  list.AddRange(newlist);                                    if (!includes.Contains(path))                                      includes.Add(path);                              }                              break;                            case "NODYNAMICVARS":                              DynamicVars = false;                              break;                            case "NOENV":                              NoEnv = true;                              break;                            case "NOTRAYICON":                              NoTrayIcon = true;                              break;                            case "PERSISTENT":                              Persistent = true;                              break;                            case "SINGLEINSTANCE":                              switch (parts[1].ToUpperInvariant())                              {                                  case "FORCE":                                      SingleInstance = true;                                      break;                                  case "IGNORE":                                      SingleInstance = null;                                      break;                                  case "OFF":                                      SingleInstance = false;                                      break;                                  default:                                      break;                              }                              break;                            case "WINACTIVATEFORCE":                              WinActivateForce = true;                              break;                            case "HOTSTRING":                              switch (parts[1].ToUpperInvariant())                              {                                  case "NOMOUSE":                                      HotstringNoMouse = true;                                      break;                                  case "ENDCHARS":                                      HotstringEndChars = parts[1];                                      break;                                  default:                                      next = false;                                      break;                              }                              break;                            case "ALLOWSAMELINECOMMENTS":                          case "ERRORSTDOUT":                          case "HOTKEYINTERVAL":                          case "HOTKEYMODIFIERTIMEOUT":                          case "INSTALLKEYBDHOOK":                          case "INSTALLMOUSEHOOK":                          case "KEYHISTORY":                          case "MAXHOTKEYSPERINTERVAL":                          case "MAXMEM":                          case "MAXTHREADS":                          case "MAXTHREADSBUFFER":                          case "MAXTHREADSPERHOTKEY":                          case "USEHOOK":                              // deprecated directives                              break;                            default:                              next = false;                              break;                      }                        if (next)                          continue;                  }                    #endregion                    #region Mulitline strings                    if (codeTrim.Length > 0 && codeTrim[0] == ParenOpen)                  {                      if (list.Count == 0)                          throw new ParseException(ExUnexpected' line);                        var buf = new StringBuilder(code.Length);                      buf.Append(code);                      buf.Append(Environment.NewLine);                        while ((code = source.ReadLine()) != null)                      {                          codeTrim = code.TrimStart(Spaces);                            if (codeTrim.Length > 0 && codeTrim[0] == ParenClose)                          {                              code = codeTrim = codeTrim.Substring(1);                              buf.Append(ParenClose);                              break;                          }                          else                          {                              buf.Append(code);                              buf.Append(Environment.NewLine);                          }                      }                        string str = buf.ToString();                      string result = MultilineString(str);                      list[list.Count - 1].Code += result + code;                      continue;                  }                    #endregion                    #region Statement                    code = code.Trim(Spaces);                    if (code.StartsWith(new string(new[] { MultiComB' MultiComA })))                      code = code.Substring(2);                    if (code.Length == 0 || IsCommentLine(code))                      continue;                    if (IsContinuationLine(code))                  {                      if (list.Count == 0)                          throw new ParseException(ExUnexpected' line);                        int i = list.Count - 1;                      var buf = new StringBuilder(list[i].Code' list[i].Code.Length + Environment.NewLine.Length + code.Length);                      buf.Append(Environment.NewLine);                      buf.Append(code);                      list[i].Code = buf.ToString();                  }                  else                  {                      Translate(ref code);                        if (code.Length != 0)                          list.Add(new CodeLine(name' line' code));                  }                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Read,The following statement contains a magic number: while ((code = source.ReadLine()) != null)              {                  #region Line                    line++;                    if (line == 1 && code.Length > 2 && code[0] == '#' && code[1] == '!')                      continue;                    string codeTrim = code.TrimStart(Spaces);                    #endregion                    #region Multiline comments                    if (codeTrim.Length > 1 && codeTrim[0] == MultiComA && codeTrim[1] == MultiComB)                  {                      while ((code = source.ReadLine()) != null)                      {                          line++;                          codeTrim = code.TrimStart(Spaces);                          if (codeTrim.Length > 1 && codeTrim[0] == MultiComB && codeTrim[1] == MultiComA)                          {                              code = codeTrim = codeTrim.Substring(2);                              break;                          }                      }                      if (code == null)                          continue;                  }                    #endregion                    #region Directives                    if(codeTrim.Length > 1 && codeTrim[0] == Directive)                  {                      if(codeTrim.Length < 2)                          throw new ParseException(ExUnknownDirv' line);                                            var delim = new char[Spaces.Length + 1];                      delim[0] = Multicast;                      Spaces.CopyTo(delim' 1);                      string[] sub = codeTrim.Split(delim' 2);                      var parts = new[] { sub[0]' sub.Length > 1 ? sub[1] : string.Empty };                        parts[1] = StripComment(parts[1]).Trim(Spaces);                        int value;                      int.TryParse(parts[1]' out value);                        bool next = true;                      bool includeOnce = false;                        switch (parts[0].Substring(1).ToUpperInvariant())                      {                          case "INCLUDE":                              includeOnce = true;                              goto case "INCLUDEAGAIN";                            case "INCLUDEAGAIN":                              {                                  var replace = new[']                                  {                                      { "A_ScriptDir"' Path.GetDirectoryName(name) }'                                      { "A_AppData"' Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) }'                                      { "A_AppDataCommon"' Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData) }'                                      { "ProgramFiles"' Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles) }'                                  };                                    for (int i = 0; i < replace.Length / 2; i++)                                      parts[1] = Replace(parts[1]' string.Format("{0}{1}{0}"' Resolve' replace[i' 0])' replace[i' 1]);                                    bool silent = false;                                    if (parts[1].Length > 3 && parts[1][0] == '*' && (parts[1][1] == 'i' || parts[1][1] == 'I') && IsSpace(parts[1][2]))                                  {                                      parts[1] = parts[1].Substring(3);                                      silent = true;                                  }                                    string path = parts[1];                                    if (!Path.IsPathRooted(path) && Directory.Exists(includePath))                                      path = Path.Combine(includePath' path);                                  else if(!Path.IsPathRooted(path))                                      path = Path.Combine(Path.GetDirectoryName(name)' path);                                    path = Path.GetFullPath(path);                                    if (!File.Exists(path))                                  {                                      if (!silent)                                          throw new ParseException(ExIncludeNotFound' line);                                      break;                                  }                                    if (includeOnce && includes.Contains(path))                                      break;                                    var newlist = Read(new StreamReader(path)' path);                                  list.AddRange(newlist);                                    if (!includes.Contains(path))                                      includes.Add(path);                              }                              break;                            case "NODYNAMICVARS":                              DynamicVars = false;                              break;                            case "NOENV":                              NoEnv = true;                              break;                            case "NOTRAYICON":                              NoTrayIcon = true;                              break;                            case "PERSISTENT":                              Persistent = true;                              break;                            case "SINGLEINSTANCE":                              switch (parts[1].ToUpperInvariant())                              {                                  case "FORCE":                                      SingleInstance = true;                                      break;                                  case "IGNORE":                                      SingleInstance = null;                                      break;                                  case "OFF":                                      SingleInstance = false;                                      break;                                  default:                                      break;                              }                              break;                            case "WINACTIVATEFORCE":                              WinActivateForce = true;                              break;                            case "HOTSTRING":                              switch (parts[1].ToUpperInvariant())                              {                                  case "NOMOUSE":                                      HotstringNoMouse = true;                                      break;                                  case "ENDCHARS":                                      HotstringEndChars = parts[1];                                      break;                                  default:                                      next = false;                                      break;                              }                              break;                            case "ALLOWSAMELINECOMMENTS":                          case "ERRORSTDOUT":                          case "HOTKEYINTERVAL":                          case "HOTKEYMODIFIERTIMEOUT":                          case "INSTALLKEYBDHOOK":                          case "INSTALLMOUSEHOOK":                          case "KEYHISTORY":                          case "MAXHOTKEYSPERINTERVAL":                          case "MAXMEM":                          case "MAXTHREADS":                          case "MAXTHREADSBUFFER":                          case "MAXTHREADSPERHOTKEY":                          case "USEHOOK":                              // deprecated directives                              break;                            default:                              next = false;                              break;                      }                        if (next)                          continue;                  }                    #endregion                    #region Mulitline strings                    if (codeTrim.Length > 0 && codeTrim[0] == ParenOpen)                  {                      if (list.Count == 0)                          throw new ParseException(ExUnexpected' line);                        var buf = new StringBuilder(code.Length);                      buf.Append(code);                      buf.Append(Environment.NewLine);                        while ((code = source.ReadLine()) != null)                      {                          codeTrim = code.TrimStart(Spaces);                            if (codeTrim.Length > 0 && codeTrim[0] == ParenClose)                          {                              code = codeTrim = codeTrim.Substring(1);                              buf.Append(ParenClose);                              break;                          }                          else                          {                              buf.Append(code);                              buf.Append(Environment.NewLine);                          }                      }                        string str = buf.ToString();                      string result = MultilineString(str);                      list[list.Count - 1].Code += result + code;                      continue;                  }                    #endregion                    #region Statement                    code = code.Trim(Spaces);                    if (code.StartsWith(new string(new[] { MultiComB' MultiComA })))                      code = code.Substring(2);                    if (code.Length == 0 || IsCommentLine(code))                      continue;                    if (IsContinuationLine(code))                  {                      if (list.Count == 0)                          throw new ParseException(ExUnexpected' line);                        int i = list.Count - 1;                      var buf = new StringBuilder(list[i].Code' list[i].Code.Length + Environment.NewLine.Length + code.Length);                      buf.Append(Environment.NewLine);                      buf.Append(code);                      list[i].Code = buf.ToString();                  }                  else                  {                      Translate(ref code);                        if (code.Length != 0)                          list.Add(new CodeLine(name' line' code));                  }                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Read,The following statement contains a magic number: while ((code = source.ReadLine()) != null)              {                  #region Line                    line++;                    if (line == 1 && code.Length > 2 && code[0] == '#' && code[1] == '!')                      continue;                    string codeTrim = code.TrimStart(Spaces);                    #endregion                    #region Multiline comments                    if (codeTrim.Length > 1 && codeTrim[0] == MultiComA && codeTrim[1] == MultiComB)                  {                      while ((code = source.ReadLine()) != null)                      {                          line++;                          codeTrim = code.TrimStart(Spaces);                          if (codeTrim.Length > 1 && codeTrim[0] == MultiComB && codeTrim[1] == MultiComA)                          {                              code = codeTrim = codeTrim.Substring(2);                              break;                          }                      }                      if (code == null)                          continue;                  }                    #endregion                    #region Directives                    if(codeTrim.Length > 1 && codeTrim[0] == Directive)                  {                      if(codeTrim.Length < 2)                          throw new ParseException(ExUnknownDirv' line);                                            var delim = new char[Spaces.Length + 1];                      delim[0] = Multicast;                      Spaces.CopyTo(delim' 1);                      string[] sub = codeTrim.Split(delim' 2);                      var parts = new[] { sub[0]' sub.Length > 1 ? sub[1] : string.Empty };                        parts[1] = StripComment(parts[1]).Trim(Spaces);                        int value;                      int.TryParse(parts[1]' out value);                        bool next = true;                      bool includeOnce = false;                        switch (parts[0].Substring(1).ToUpperInvariant())                      {                          case "INCLUDE":                              includeOnce = true;                              goto case "INCLUDEAGAIN";                            case "INCLUDEAGAIN":                              {                                  var replace = new[']                                  {                                      { "A_ScriptDir"' Path.GetDirectoryName(name) }'                                      { "A_AppData"' Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) }'                                      { "A_AppDataCommon"' Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData) }'                                      { "ProgramFiles"' Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles) }'                                  };                                    for (int i = 0; i < replace.Length / 2; i++)                                      parts[1] = Replace(parts[1]' string.Format("{0}{1}{0}"' Resolve' replace[i' 0])' replace[i' 1]);                                    bool silent = false;                                    if (parts[1].Length > 3 && parts[1][0] == '*' && (parts[1][1] == 'i' || parts[1][1] == 'I') && IsSpace(parts[1][2]))                                  {                                      parts[1] = parts[1].Substring(3);                                      silent = true;                                  }                                    string path = parts[1];                                    if (!Path.IsPathRooted(path) && Directory.Exists(includePath))                                      path = Path.Combine(includePath' path);                                  else if(!Path.IsPathRooted(path))                                      path = Path.Combine(Path.GetDirectoryName(name)' path);                                    path = Path.GetFullPath(path);                                    if (!File.Exists(path))                                  {                                      if (!silent)                                          throw new ParseException(ExIncludeNotFound' line);                                      break;                                  }                                    if (includeOnce && includes.Contains(path))                                      break;                                    var newlist = Read(new StreamReader(path)' path);                                  list.AddRange(newlist);                                    if (!includes.Contains(path))                                      includes.Add(path);                              }                              break;                            case "NODYNAMICVARS":                              DynamicVars = false;                              break;                            case "NOENV":                              NoEnv = true;                              break;                            case "NOTRAYICON":                              NoTrayIcon = true;                              break;                            case "PERSISTENT":                              Persistent = true;                              break;                            case "SINGLEINSTANCE":                              switch (parts[1].ToUpperInvariant())                              {                                  case "FORCE":                                      SingleInstance = true;                                      break;                                  case "IGNORE":                                      SingleInstance = null;                                      break;                                  case "OFF":                                      SingleInstance = false;                                      break;                                  default:                                      break;                              }                              break;                            case "WINACTIVATEFORCE":                              WinActivateForce = true;                              break;                            case "HOTSTRING":                              switch (parts[1].ToUpperInvariant())                              {                                  case "NOMOUSE":                                      HotstringNoMouse = true;                                      break;                                  case "ENDCHARS":                                      HotstringEndChars = parts[1];                                      break;                                  default:                                      next = false;                                      break;                              }                              break;                            case "ALLOWSAMELINECOMMENTS":                          case "ERRORSTDOUT":                          case "HOTKEYINTERVAL":                          case "HOTKEYMODIFIERTIMEOUT":                          case "INSTALLKEYBDHOOK":                          case "INSTALLMOUSEHOOK":                          case "KEYHISTORY":                          case "MAXHOTKEYSPERINTERVAL":                          case "MAXMEM":                          case "MAXTHREADS":                          case "MAXTHREADSBUFFER":                          case "MAXTHREADSPERHOTKEY":                          case "USEHOOK":                              // deprecated directives                              break;                            default:                              next = false;                              break;                      }                        if (next)                          continue;                  }                    #endregion                    #region Mulitline strings                    if (codeTrim.Length > 0 && codeTrim[0] == ParenOpen)                  {                      if (list.Count == 0)                          throw new ParseException(ExUnexpected' line);                        var buf = new StringBuilder(code.Length);                      buf.Append(code);                      buf.Append(Environment.NewLine);                        while ((code = source.ReadLine()) != null)                      {                          codeTrim = code.TrimStart(Spaces);                            if (codeTrim.Length > 0 && codeTrim[0] == ParenClose)                          {                              code = codeTrim = codeTrim.Substring(1);                              buf.Append(ParenClose);                              break;                          }                          else                          {                              buf.Append(code);                              buf.Append(Environment.NewLine);                          }                      }                        string str = buf.ToString();                      string result = MultilineString(str);                      list[list.Count - 1].Code += result + code;                      continue;                  }                    #endregion                    #region Statement                    code = code.Trim(Spaces);                    if (code.StartsWith(new string(new[] { MultiComB' MultiComA })))                      code = code.Substring(2);                    if (code.Length == 0 || IsCommentLine(code))                      continue;                    if (IsContinuationLine(code))                  {                      if (list.Count == 0)                          throw new ParseException(ExUnexpected' line);                        int i = list.Count - 1;                      var buf = new StringBuilder(list[i].Code' list[i].Code.Length + Environment.NewLine.Length + code.Length);                      buf.Append(Environment.NewLine);                      buf.Append(code);                      list[i].Code = buf.ToString();                  }                  else                  {                      Translate(ref code);                        if (code.Length != 0)                          list.Add(new CodeLine(name' line' code));                  }                    #endregion              }
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsFlowOperator,The following statement contains a magic number: const int offset = 3;
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsFlowOperator,The following statement contains a magic number: delimiters[2] = ParenOpen;
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsFlowOperator,The following statement contains a magic number: string word = code.Split(delimiters' 2)[0].ToLowerInvariant();
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsCommand,The following statement contains a magic number: if (i == 0)                  return false;              else if (i == code.Length)                  return true;              else if (code[i] == Multicast)                  return true;              else if (IsSpace(code[i]))              {                  i++;                  while (i < code.Length && IsSpace(code[i])) i++;                    if (i < code.Length && code[i] == Equal)                      return false;                  else if (IsCommentAt(code' i))                      return true;                    if (IsIdentifier(code[i]))                      return !IsKeyword(code[i]);                    int y = i + 1' z = i + 2;                    if (y < code.Length)                  {                      if (code[y] == Equal)                          return false;                      else if (z < code.Length && code[i] == code[y] && code[z] == Equal)                          return false;                      else if (LaxExpressions)                      {                          if (IsOperator(code.Substring(i' 1)) && code.Contains(" ? "))                              return false;                      }                  }                    string pre = code.Substring(0' i).TrimEnd(Spaces);                  return !IsPrimativeObject(pre);              }              else                  return false;
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsDirective,The following statement contains a magic number: return code.Length > 2 && code[0] == Directive;
Magic Number,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsFunction,The following statement contains a magic number: for (int i = 0; i < code.Length; i++)              {                  char sym = code[i];                    switch (stage)                  {                      case 0:                          if (sym == ParenOpen)                              stage++;                          else if (!IsIdentifier(sym))                              return false;                          break;                        case 1:                          if (sym == StringBound)                              str = !str;                          else if (!str && sym == ParenClose)                              stage++;                          break;                        case 2:                          if (sym == BlockOpen)                              return true;                          else if (IsCommentAt(code' i))                              goto next;                          else if (!IsSpace(sym))                              return false;                          break;                  }              }
Magic Number,IronAHK.Scripting,Script,C:\repos\polyethene_IronAHK\Scripting\Script\Call.cs,FunctionCall,The following statement contains a magic number: for (int i = 0; i < 3; i++)              {                  var type = stack[i].GetMethod().DeclaringType;                  method = FindMethod(name' type.GetMethods()' parameters);                  if (method != null)                      break;              }
Magic Number,IronAHK.Scripting,Script,C:\repos\polyethene_IronAHK\Scripting\Script\Call.cs,IfLegacy,The following statement contains a magic number: switch (op)              {                  case Between:                      {                          int z = var.IndexOf(And' StringComparison.OrdinalIgnoreCase);                            if (z == -1)                              z = var.Length;                            double low = double.MinValue' high = double.MaxValue;                            if (double.TryParse(var.Substring(0' z)' out low) && double.TryParse(var.Substring(z + And.Length)' out high))                          {                              var d = ForceDouble(subject);                              return d >= low && d <= high;                          }                      }                      return false;                    case In:                      foreach (var sub in test.Split(Delimiter))                          if (var.Equals(sub' StringComparison.OrdinalIgnoreCase))                              return true;                      return false;                    case Contains:                      foreach (var sub in test.Split(Delimiter))                          if (var.IndexOf(sub' StringComparison.OrdinalIgnoreCase) != -1)                              return true;                      return false;                    case Is:                      test = test.ToLowerInvariant();                      if (subject != null)                      {                          var type = subject.GetType();                          switch (test)                          {                              case Object:                                  return typeof(IDictionary).IsAssignableFrom(type);                                case Array:                                  return type.IsArray;                          }                      }                      switch (test)                      {                          case Integer:                          case Number:                              var = var.Trim().TrimStart(new[] { '+'' '-' });                              goto case Xdigit;                            case Xdigit:                              if (var.Length > 3 && var[0] == '0' && (var[1] == 'x' || var[1] == 'X'))                                  var = var.Substring(2);                              break;                      }                      switch (test)                      {                          case Float:                              if (!var.Contains("."))                                  return false;                              goto case Number;                            case Number:                              {                                  bool dot = false;                                    foreach (var sym in var)                                  {                                      if (sym == '.')                                      {                                          if (dot)                                              return false;                                          dot = true;                                      }                                      else if (!char.IsDigit(sym))                                          return false;                                  }                                    return true;                              }                            case Digit:                              foreach (var sym in var)                                  if (!char.IsDigit(sym))                                      return false;                              return true;                            case Integer:                          case Xdigit:                              {                                  foreach (var sym in var)                                      if (!(char.IsDigit(sym) || (sym > 'a' - 1 && sym < 'f' + 1) || (sym > 'A' - 1 && sym < 'F' + 1)))                                          return false;                                  return true;                              }                            case Alpha:                              foreach (var sym in var)                                  if (!char.IsLetter(sym))                                      return false;                              return true;                            case Upper:                              foreach (var sym in var)                                  if (!char.IsUpper(sym))                                      return false;                              return true;                            case Lower:                              foreach (var sym in var)                                  if (!char.IsLower(sym))                                      return false;                              return true;                            case Alnum:                              foreach (var sym in var)                                  if (!char.IsLetterOrDigit(sym))                                      return false;                              return true;                            case Space:                              foreach (var sym in var)                                  if (!char.IsWhiteSpace(sym))                                      return false;                              return true;                            case Time:                              if (!IsNumeric(var))                                  return false;                              return ForceLong(var) < 99991231125959;                            default:                              return false;                      }              }
Magic Number,IronAHK.Scripting,Script,C:\repos\polyethene_IronAHK\Scripting\Script\Call.cs,IfLegacy,The following statement contains a magic number: switch (op)              {                  case Between:                      {                          int z = var.IndexOf(And' StringComparison.OrdinalIgnoreCase);                            if (z == -1)                              z = var.Length;                            double low = double.MinValue' high = double.MaxValue;                            if (double.TryParse(var.Substring(0' z)' out low) && double.TryParse(var.Substring(z + And.Length)' out high))                          {                              var d = ForceDouble(subject);                              return d >= low && d <= high;                          }                      }                      return false;                    case In:                      foreach (var sub in test.Split(Delimiter))                          if (var.Equals(sub' StringComparison.OrdinalIgnoreCase))                              return true;                      return false;                    case Contains:                      foreach (var sub in test.Split(Delimiter))                          if (var.IndexOf(sub' StringComparison.OrdinalIgnoreCase) != -1)                              return true;                      return false;                    case Is:                      test = test.ToLowerInvariant();                      if (subject != null)                      {                          var type = subject.GetType();                          switch (test)                          {                              case Object:                                  return typeof(IDictionary).IsAssignableFrom(type);                                case Array:                                  return type.IsArray;                          }                      }                      switch (test)                      {                          case Integer:                          case Number:                              var = var.Trim().TrimStart(new[] { '+'' '-' });                              goto case Xdigit;                            case Xdigit:                              if (var.Length > 3 && var[0] == '0' && (var[1] == 'x' || var[1] == 'X'))                                  var = var.Substring(2);                              break;                      }                      switch (test)                      {                          case Float:                              if (!var.Contains("."))                                  return false;                              goto case Number;                            case Number:                              {                                  bool dot = false;                                    foreach (var sym in var)                                  {                                      if (sym == '.')                                      {                                          if (dot)                                              return false;                                          dot = true;                                      }                                      else if (!char.IsDigit(sym))                                          return false;                                  }                                    return true;                              }                            case Digit:                              foreach (var sym in var)                                  if (!char.IsDigit(sym))                                      return false;                              return true;                            case Integer:                          case Xdigit:                              {                                  foreach (var sym in var)                                      if (!(char.IsDigit(sym) || (sym > 'a' - 1 && sym < 'f' + 1) || (sym > 'A' - 1 && sym < 'F' + 1)))                                          return false;                                  return true;                              }                            case Alpha:                              foreach (var sym in var)                                  if (!char.IsLetter(sym))                                      return false;                              return true;                            case Upper:                              foreach (var sym in var)                                  if (!char.IsUpper(sym))                                      return false;                              return true;                            case Lower:                              foreach (var sym in var)                                  if (!char.IsLower(sym))                                      return false;                              return true;                            case Alnum:                              foreach (var sym in var)                                  if (!char.IsLetterOrDigit(sym))                                      return false;                              return true;                            case Space:                              foreach (var sym in var)                                  if (!char.IsWhiteSpace(sym))                                      return false;                              return true;                            case Time:                              if (!IsNumeric(var))                                  return false;                              return ForceLong(var) < 99991231125959;                            default:                              return false;                      }              }
Magic Number,IronAHK.Scripting,Script,C:\repos\polyethene_IronAHK\Scripting\Script\Call.cs,IfLegacy,The following statement contains a magic number: switch (op)              {                  case Between:                      {                          int z = var.IndexOf(And' StringComparison.OrdinalIgnoreCase);                            if (z == -1)                              z = var.Length;                            double low = double.MinValue' high = double.MaxValue;                            if (double.TryParse(var.Substring(0' z)' out low) && double.TryParse(var.Substring(z + And.Length)' out high))                          {                              var d = ForceDouble(subject);                              return d >= low && d <= high;                          }                      }                      return false;                    case In:                      foreach (var sub in test.Split(Delimiter))                          if (var.Equals(sub' StringComparison.OrdinalIgnoreCase))                              return true;                      return false;                    case Contains:                      foreach (var sub in test.Split(Delimiter))                          if (var.IndexOf(sub' StringComparison.OrdinalIgnoreCase) != -1)                              return true;                      return false;                    case Is:                      test = test.ToLowerInvariant();                      if (subject != null)                      {                          var type = subject.GetType();                          switch (test)                          {                              case Object:                                  return typeof(IDictionary).IsAssignableFrom(type);                                case Array:                                  return type.IsArray;                          }                      }                      switch (test)                      {                          case Integer:                          case Number:                              var = var.Trim().TrimStart(new[] { '+'' '-' });                              goto case Xdigit;                            case Xdigit:                              if (var.Length > 3 && var[0] == '0' && (var[1] == 'x' || var[1] == 'X'))                                  var = var.Substring(2);                              break;                      }                      switch (test)                      {                          case Float:                              if (!var.Contains("."))                                  return false;                              goto case Number;                            case Number:                              {                                  bool dot = false;                                    foreach (var sym in var)                                  {                                      if (sym == '.')                                      {                                          if (dot)                                              return false;                                          dot = true;                                      }                                      else if (!char.IsDigit(sym))                                          return false;                                  }                                    return true;                              }                            case Digit:                              foreach (var sym in var)                                  if (!char.IsDigit(sym))                                      return false;                              return true;                            case Integer:                          case Xdigit:                              {                                  foreach (var sym in var)                                      if (!(char.IsDigit(sym) || (sym > 'a' - 1 && sym < 'f' + 1) || (sym > 'A' - 1 && sym < 'F' + 1)))                                          return false;                                  return true;                              }                            case Alpha:                              foreach (var sym in var)                                  if (!char.IsLetter(sym))                                      return false;                              return true;                            case Upper:                              foreach (var sym in var)                                  if (!char.IsUpper(sym))                                      return false;                              return true;                            case Lower:                              foreach (var sym in var)                                  if (!char.IsLower(sym))                                      return false;                              return true;                            case Alnum:                              foreach (var sym in var)                                  if (!char.IsLetterOrDigit(sym))                                      return false;                              return true;                            case Space:                              foreach (var sym in var)                                  if (!char.IsWhiteSpace(sym))                                      return false;                              return true;                            case Time:                              if (!IsNumeric(var))                                  return false;                              return ForceLong(var) < 99991231125959;                            default:                              return false;                      }              }
Magic Number,IronAHK.Scripting,Generator,C:\repos\polyethene_IronAHK\Scripting\Generator\Generator.cs,GetTypeOutput,The following statement contains a magic number: var name = new StringBuilder(type.BaseType.Length + type.ArrayRank * 2);
Magic Number,IronAHK.Scripting,Generator,C:\repos\polyethene_IronAHK\Scripting\Generator\Generator.cs,CreateEscapedIdentifier,The following statement contains a magic number: var result = new StringBuilder(value.Length * 5);
Magic Number,IronAHK.Scripting,MethodWriter,C:\repos\polyethene_IronAHK\Scripting\Compiler\Emission\MethodWriter.cs,EmitLiteral,The following statement contains a magic number: if (Value == null)              {                  Debug("Pushing null");                  Generator.Emit(OpCodes.Ldnull);                  Generated = typeof(Nullable);              }              else if(T == typeof(string))              {                  Debug("Pushing primitive string : \""+(Value as string)+"\"");                    if (((string)Value).Length == 0)                      Generator.Emit(OpCodes.Ldsfld' typeof(string).GetField("Empty"));                  else                      Generator.Emit(OpCodes.Ldstr' Value as string);              }              else if(T == typeof(int))              {                  var val = (int)Value;                  Debug("Pushing primitive integer : " + val);                    switch (val)                  {                      case -1: Generator.Emit(OpCodes.Ldc_I4_M1); break;                      case 0: Generator.Emit(OpCodes.Ldc_I4_0); break;                      case 1: Generator.Emit(OpCodes.Ldc_I4_1); break;                      case 2: Generator.Emit(OpCodes.Ldc_I4_2); break;                      case 3: Generator.Emit(OpCodes.Ldc_I4_3); break;                      case 4: Generator.Emit(OpCodes.Ldc_I4_4); break;                      case 5: Generator.Emit(OpCodes.Ldc_I4_5); break;                      case 6: Generator.Emit(OpCodes.Ldc_I4_6); break;                      case 7: Generator.Emit(OpCodes.Ldc_I4_7); break;                      case 8: Generator.Emit(OpCodes.Ldc_I4_8); break;                      default: Generator.Emit(OpCodes.Ldc_I4' val); break;                  }              }              else if(T == typeof(decimal))              {                  Debug("Pushing decimal : "+((decimal) Value));                                    // HACK:  push real decimals without downcasting                  // i.e. new decimal(decimal.GetBits((decimal)Value));                                    Generator.Emit(OpCodes.Ldc_R8' ((double)((decimal)Value)));                  Generated = typeof(double);              }              else if (T == typeof(object[]))              {                  Debug("Pushing object[" + ((object[])Value).Length + "]");                  var array = new CodeArrayCreateExpression();                  array.CreateType = new CodeTypeReference(typeof(object));                    foreach (var sub in (object[])Value)                      array.Initializers.Add(new CodePrimitiveExpression(sub));                    EmitDynamicName(array);              }              else if(T == typeof(bool))              {                  var val = (bool) Value;                  Debug("Pushing bool: "+Value);                                    Generator.Emit(val ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);              }              else if(T == typeof(double))              {                  Debug("Pushing double: "+((double) Value));                  Generator.Emit(OpCodes.Ldc_R8' ((double)Value));              }              else if (T == typeof(long))              {                  Debug("Pushing long: " + (long)Value);                  Generator.Emit(OpCodes.Ldc_I8' (long)Value);              }              else if (T.IsGenericType && T.GetGenericTypeDefinition() == typeof(Nullable<>))              {                  Debug("Pushing nullable: " + Value);                  EmitLiteral(Value == null ? typeof(Nullable) : T.GetGenericArguments()[0]' Value);              }              else              {                  Debug("Unhandled primitive: " + T);                  Generated = null;              }
Magic Number,IronAHK.Scripting,MethodWriter,C:\repos\polyethene_IronAHK\Scripting\Compiler\Emission\MethodWriter.cs,EmitLiteral,The following statement contains a magic number: if (Value == null)              {                  Debug("Pushing null");                  Generator.Emit(OpCodes.Ldnull);                  Generated = typeof(Nullable);              }              else if(T == typeof(string))              {                  Debug("Pushing primitive string : \""+(Value as string)+"\"");                    if (((string)Value).Length == 0)                      Generator.Emit(OpCodes.Ldsfld' typeof(string).GetField("Empty"));                  else                      Generator.Emit(OpCodes.Ldstr' Value as string);              }              else if(T == typeof(int))              {                  var val = (int)Value;                  Debug("Pushing primitive integer : " + val);                    switch (val)                  {                      case -1: Generator.Emit(OpCodes.Ldc_I4_M1); break;                      case 0: Generator.Emit(OpCodes.Ldc_I4_0); break;                      case 1: Generator.Emit(OpCodes.Ldc_I4_1); break;                      case 2: Generator.Emit(OpCodes.Ldc_I4_2); break;                      case 3: Generator.Emit(OpCodes.Ldc_I4_3); break;                      case 4: Generator.Emit(OpCodes.Ldc_I4_4); break;                      case 5: Generator.Emit(OpCodes.Ldc_I4_5); break;                      case 6: Generator.Emit(OpCodes.Ldc_I4_6); break;                      case 7: Generator.Emit(OpCodes.Ldc_I4_7); break;                      case 8: Generator.Emit(OpCodes.Ldc_I4_8); break;                      default: Generator.Emit(OpCodes.Ldc_I4' val); break;                  }              }              else if(T == typeof(decimal))              {                  Debug("Pushing decimal : "+((decimal) Value));                                    // HACK:  push real decimals without downcasting                  // i.e. new decimal(decimal.GetBits((decimal)Value));                                    Generator.Emit(OpCodes.Ldc_R8' ((double)((decimal)Value)));                  Generated = typeof(double);              }              else if (T == typeof(object[]))              {                  Debug("Pushing object[" + ((object[])Value).Length + "]");                  var array = new CodeArrayCreateExpression();                  array.CreateType = new CodeTypeReference(typeof(object));                    foreach (var sub in (object[])Value)                      array.Initializers.Add(new CodePrimitiveExpression(sub));                    EmitDynamicName(array);              }              else if(T == typeof(bool))              {                  var val = (bool) Value;                  Debug("Pushing bool: "+Value);                                    Generator.Emit(val ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);              }              else if(T == typeof(double))              {                  Debug("Pushing double: "+((double) Value));                  Generator.Emit(OpCodes.Ldc_R8' ((double)Value));              }              else if (T == typeof(long))              {                  Debug("Pushing long: " + (long)Value);                  Generator.Emit(OpCodes.Ldc_I8' (long)Value);              }              else if (T.IsGenericType && T.GetGenericTypeDefinition() == typeof(Nullable<>))              {                  Debug("Pushing nullable: " + Value);                  EmitLiteral(Value == null ? typeof(Nullable) : T.GetGenericArguments()[0]' Value);              }              else              {                  Debug("Unhandled primitive: " + T);                  Generated = null;              }
Magic Number,IronAHK.Scripting,MethodWriter,C:\repos\polyethene_IronAHK\Scripting\Compiler\Emission\MethodWriter.cs,EmitLiteral,The following statement contains a magic number: if (Value == null)              {                  Debug("Pushing null");                  Generator.Emit(OpCodes.Ldnull);                  Generated = typeof(Nullable);              }              else if(T == typeof(string))              {                  Debug("Pushing primitive string : \""+(Value as string)+"\"");                    if (((string)Value).Length == 0)                      Generator.Emit(OpCodes.Ldsfld' typeof(string).GetField("Empty"));                  else                      Generator.Emit(OpCodes.Ldstr' Value as string);              }              else if(T == typeof(int))              {                  var val = (int)Value;                  Debug("Pushing primitive integer : " + val);                    switch (val)                  {                      case -1: Generator.Emit(OpCodes.Ldc_I4_M1); break;                      case 0: Generator.Emit(OpCodes.Ldc_I4_0); break;                      case 1: Generator.Emit(OpCodes.Ldc_I4_1); break;                      case 2: Generator.Emit(OpCodes.Ldc_I4_2); break;                      case 3: Generator.Emit(OpCodes.Ldc_I4_3); break;                      case 4: Generator.Emit(OpCodes.Ldc_I4_4); break;                      case 5: Generator.Emit(OpCodes.Ldc_I4_5); break;                      case 6: Generator.Emit(OpCodes.Ldc_I4_6); break;                      case 7: Generator.Emit(OpCodes.Ldc_I4_7); break;                      case 8: Generator.Emit(OpCodes.Ldc_I4_8); break;                      default: Generator.Emit(OpCodes.Ldc_I4' val); break;                  }              }              else if(T == typeof(decimal))              {                  Debug("Pushing decimal : "+((decimal) Value));                                    // HACK:  push real decimals without downcasting                  // i.e. new decimal(decimal.GetBits((decimal)Value));                                    Generator.Emit(OpCodes.Ldc_R8' ((double)((decimal)Value)));                  Generated = typeof(double);              }              else if (T == typeof(object[]))              {                  Debug("Pushing object[" + ((object[])Value).Length + "]");                  var array = new CodeArrayCreateExpression();                  array.CreateType = new CodeTypeReference(typeof(object));                    foreach (var sub in (object[])Value)                      array.Initializers.Add(new CodePrimitiveExpression(sub));                    EmitDynamicName(array);              }              else if(T == typeof(bool))              {                  var val = (bool) Value;                  Debug("Pushing bool: "+Value);                                    Generator.Emit(val ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);              }              else if(T == typeof(double))              {                  Debug("Pushing double: "+((double) Value));                  Generator.Emit(OpCodes.Ldc_R8' ((double)Value));              }              else if (T == typeof(long))              {                  Debug("Pushing long: " + (long)Value);                  Generator.Emit(OpCodes.Ldc_I8' (long)Value);              }              else if (T.IsGenericType && T.GetGenericTypeDefinition() == typeof(Nullable<>))              {                  Debug("Pushing nullable: " + Value);                  EmitLiteral(Value == null ? typeof(Nullable) : T.GetGenericArguments()[0]' Value);              }              else              {                  Debug("Unhandled primitive: " + T);                  Generated = null;              }
Magic Number,IronAHK.Scripting,MethodWriter,C:\repos\polyethene_IronAHK\Scripting\Compiler\Emission\MethodWriter.cs,EmitLiteral,The following statement contains a magic number: if (Value == null)              {                  Debug("Pushing null");                  Generator.Emit(OpCodes.Ldnull);                  Generated = typeof(Nullable);              }              else if(T == typeof(string))              {                  Debug("Pushing primitive string : \""+(Value as string)+"\"");                    if (((string)Value).Length == 0)                      Generator.Emit(OpCodes.Ldsfld' typeof(string).GetField("Empty"));                  else                      Generator.Emit(OpCodes.Ldstr' Value as string);              }              else if(T == typeof(int))              {                  var val = (int)Value;                  Debug("Pushing primitive integer : " + val);                    switch (val)                  {                      case -1: Generator.Emit(OpCodes.Ldc_I4_M1); break;                      case 0: Generator.Emit(OpCodes.Ldc_I4_0); break;                      case 1: Generator.Emit(OpCodes.Ldc_I4_1); break;                      case 2: Generator.Emit(OpCodes.Ldc_I4_2); break;                      case 3: Generator.Emit(OpCodes.Ldc_I4_3); break;                      case 4: Generator.Emit(OpCodes.Ldc_I4_4); break;                      case 5: Generator.Emit(OpCodes.Ldc_I4_5); break;                      case 6: Generator.Emit(OpCodes.Ldc_I4_6); break;                      case 7: Generator.Emit(OpCodes.Ldc_I4_7); break;                      case 8: Generator.Emit(OpCodes.Ldc_I4_8); break;                      default: Generator.Emit(OpCodes.Ldc_I4' val); break;                  }              }              else if(T == typeof(decimal))              {                  Debug("Pushing decimal : "+((decimal) Value));                                    // HACK:  push real decimals without downcasting                  // i.e. new decimal(decimal.GetBits((decimal)Value));                                    Generator.Emit(OpCodes.Ldc_R8' ((double)((decimal)Value)));                  Generated = typeof(double);              }              else if (T == typeof(object[]))              {                  Debug("Pushing object[" + ((object[])Value).Length + "]");                  var array = new CodeArrayCreateExpression();                  array.CreateType = new CodeTypeReference(typeof(object));                    foreach (var sub in (object[])Value)                      array.Initializers.Add(new CodePrimitiveExpression(sub));                    EmitDynamicName(array);              }              else if(T == typeof(bool))              {                  var val = (bool) Value;                  Debug("Pushing bool: "+Value);                                    Generator.Emit(val ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);              }              else if(T == typeof(double))              {                  Debug("Pushing double: "+((double) Value));                  Generator.Emit(OpCodes.Ldc_R8' ((double)Value));              }              else if (T == typeof(long))              {                  Debug("Pushing long: " + (long)Value);                  Generator.Emit(OpCodes.Ldc_I8' (long)Value);              }              else if (T.IsGenericType && T.GetGenericTypeDefinition() == typeof(Nullable<>))              {                  Debug("Pushing nullable: " + Value);                  EmitLiteral(Value == null ? typeof(Nullable) : T.GetGenericArguments()[0]' Value);              }              else              {                  Debug("Unhandled primitive: " + T);                  Generated = null;              }
Magic Number,IronAHK.Scripting,MethodWriter,C:\repos\polyethene_IronAHK\Scripting\Compiler\Emission\MethodWriter.cs,EmitLiteral,The following statement contains a magic number: if (Value == null)              {                  Debug("Pushing null");                  Generator.Emit(OpCodes.Ldnull);                  Generated = typeof(Nullable);              }              else if(T == typeof(string))              {                  Debug("Pushing primitive string : \""+(Value as string)+"\"");                    if (((string)Value).Length == 0)                      Generator.Emit(OpCodes.Ldsfld' typeof(string).GetField("Empty"));                  else                      Generator.Emit(OpCodes.Ldstr' Value as string);              }              else if(T == typeof(int))              {                  var val = (int)Value;                  Debug("Pushing primitive integer : " + val);                    switch (val)                  {                      case -1: Generator.Emit(OpCodes.Ldc_I4_M1); break;                      case 0: Generator.Emit(OpCodes.Ldc_I4_0); break;                      case 1: Generator.Emit(OpCodes.Ldc_I4_1); break;                      case 2: Generator.Emit(OpCodes.Ldc_I4_2); break;                      case 3: Generator.Emit(OpCodes.Ldc_I4_3); break;                      case 4: Generator.Emit(OpCodes.Ldc_I4_4); break;                      case 5: Generator.Emit(OpCodes.Ldc_I4_5); break;                      case 6: Generator.Emit(OpCodes.Ldc_I4_6); break;                      case 7: Generator.Emit(OpCodes.Ldc_I4_7); break;                      case 8: Generator.Emit(OpCodes.Ldc_I4_8); break;                      default: Generator.Emit(OpCodes.Ldc_I4' val); break;                  }              }              else if(T == typeof(decimal))              {                  Debug("Pushing decimal : "+((decimal) Value));                                    // HACK:  push real decimals without downcasting                  // i.e. new decimal(decimal.GetBits((decimal)Value));                                    Generator.Emit(OpCodes.Ldc_R8' ((double)((decimal)Value)));                  Generated = typeof(double);              }              else if (T == typeof(object[]))              {                  Debug("Pushing object[" + ((object[])Value).Length + "]");                  var array = new CodeArrayCreateExpression();                  array.CreateType = new CodeTypeReference(typeof(object));                    foreach (var sub in (object[])Value)                      array.Initializers.Add(new CodePrimitiveExpression(sub));                    EmitDynamicName(array);              }              else if(T == typeof(bool))              {                  var val = (bool) Value;                  Debug("Pushing bool: "+Value);                                    Generator.Emit(val ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);              }              else if(T == typeof(double))              {                  Debug("Pushing double: "+((double) Value));                  Generator.Emit(OpCodes.Ldc_R8' ((double)Value));              }              else if (T == typeof(long))              {                  Debug("Pushing long: " + (long)Value);                  Generator.Emit(OpCodes.Ldc_I8' (long)Value);              }              else if (T.IsGenericType && T.GetGenericTypeDefinition() == typeof(Nullable<>))              {                  Debug("Pushing nullable: " + Value);                  EmitLiteral(Value == null ? typeof(Nullable) : T.GetGenericArguments()[0]' Value);              }              else              {                  Debug("Unhandled primitive: " + T);                  Generated = null;              }
Magic Number,IronAHK.Scripting,MethodWriter,C:\repos\polyethene_IronAHK\Scripting\Compiler\Emission\MethodWriter.cs,EmitLiteral,The following statement contains a magic number: if (Value == null)              {                  Debug("Pushing null");                  Generator.Emit(OpCodes.Ldnull);                  Generated = typeof(Nullable);              }              else if(T == typeof(string))              {                  Debug("Pushing primitive string : \""+(Value as string)+"\"");                    if (((string)Value).Length == 0)                      Generator.Emit(OpCodes.Ldsfld' typeof(string).GetField("Empty"));                  else                      Generator.Emit(OpCodes.Ldstr' Value as string);              }              else if(T == typeof(int))              {                  var val = (int)Value;                  Debug("Pushing primitive integer : " + val);                    switch (val)                  {                      case -1: Generator.Emit(OpCodes.Ldc_I4_M1); break;                      case 0: Generator.Emit(OpCodes.Ldc_I4_0); break;                      case 1: Generator.Emit(OpCodes.Ldc_I4_1); break;                      case 2: Generator.Emit(OpCodes.Ldc_I4_2); break;                      case 3: Generator.Emit(OpCodes.Ldc_I4_3); break;                      case 4: Generator.Emit(OpCodes.Ldc_I4_4); break;                      case 5: Generator.Emit(OpCodes.Ldc_I4_5); break;                      case 6: Generator.Emit(OpCodes.Ldc_I4_6); break;                      case 7: Generator.Emit(OpCodes.Ldc_I4_7); break;                      case 8: Generator.Emit(OpCodes.Ldc_I4_8); break;                      default: Generator.Emit(OpCodes.Ldc_I4' val); break;                  }              }              else if(T == typeof(decimal))              {                  Debug("Pushing decimal : "+((decimal) Value));                                    // HACK:  push real decimals without downcasting                  // i.e. new decimal(decimal.GetBits((decimal)Value));                                    Generator.Emit(OpCodes.Ldc_R8' ((double)((decimal)Value)));                  Generated = typeof(double);              }              else if (T == typeof(object[]))              {                  Debug("Pushing object[" + ((object[])Value).Length + "]");                  var array = new CodeArrayCreateExpression();                  array.CreateType = new CodeTypeReference(typeof(object));                    foreach (var sub in (object[])Value)                      array.Initializers.Add(new CodePrimitiveExpression(sub));                    EmitDynamicName(array);              }              else if(T == typeof(bool))              {                  var val = (bool) Value;                  Debug("Pushing bool: "+Value);                                    Generator.Emit(val ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);              }              else if(T == typeof(double))              {                  Debug("Pushing double: "+((double) Value));                  Generator.Emit(OpCodes.Ldc_R8' ((double)Value));              }              else if (T == typeof(long))              {                  Debug("Pushing long: " + (long)Value);                  Generator.Emit(OpCodes.Ldc_I8' (long)Value);              }              else if (T.IsGenericType && T.GetGenericTypeDefinition() == typeof(Nullable<>))              {                  Debug("Pushing nullable: " + Value);                  EmitLiteral(Value == null ? typeof(Nullable) : T.GetGenericArguments()[0]' Value);              }              else              {                  Debug("Unhandled primitive: " + T);                  Generated = null;              }
Magic Number,IronAHK.Scripting,MethodWriter,C:\repos\polyethene_IronAHK\Scripting\Compiler\Emission\MethodWriter.cs,EmitLiteral,The following statement contains a magic number: if (Value == null)              {                  Debug("Pushing null");                  Generator.Emit(OpCodes.Ldnull);                  Generated = typeof(Nullable);              }              else if(T == typeof(string))              {                  Debug("Pushing primitive string : \""+(Value as string)+"\"");                    if (((string)Value).Length == 0)                      Generator.Emit(OpCodes.Ldsfld' typeof(string).GetField("Empty"));                  else                      Generator.Emit(OpCodes.Ldstr' Value as string);              }              else if(T == typeof(int))              {                  var val = (int)Value;                  Debug("Pushing primitive integer : " + val);                    switch (val)                  {                      case -1: Generator.Emit(OpCodes.Ldc_I4_M1); break;                      case 0: Generator.Emit(OpCodes.Ldc_I4_0); break;                      case 1: Generator.Emit(OpCodes.Ldc_I4_1); break;                      case 2: Generator.Emit(OpCodes.Ldc_I4_2); break;                      case 3: Generator.Emit(OpCodes.Ldc_I4_3); break;                      case 4: Generator.Emit(OpCodes.Ldc_I4_4); break;                      case 5: Generator.Emit(OpCodes.Ldc_I4_5); break;                      case 6: Generator.Emit(OpCodes.Ldc_I4_6); break;                      case 7: Generator.Emit(OpCodes.Ldc_I4_7); break;                      case 8: Generator.Emit(OpCodes.Ldc_I4_8); break;                      default: Generator.Emit(OpCodes.Ldc_I4' val); break;                  }              }              else if(T == typeof(decimal))              {                  Debug("Pushing decimal : "+((decimal) Value));                                    // HACK:  push real decimals without downcasting                  // i.e. new decimal(decimal.GetBits((decimal)Value));                                    Generator.Emit(OpCodes.Ldc_R8' ((double)((decimal)Value)));                  Generated = typeof(double);              }              else if (T == typeof(object[]))              {                  Debug("Pushing object[" + ((object[])Value).Length + "]");                  var array = new CodeArrayCreateExpression();                  array.CreateType = new CodeTypeReference(typeof(object));                    foreach (var sub in (object[])Value)                      array.Initializers.Add(new CodePrimitiveExpression(sub));                    EmitDynamicName(array);              }              else if(T == typeof(bool))              {                  var val = (bool) Value;                  Debug("Pushing bool: "+Value);                                    Generator.Emit(val ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);              }              else if(T == typeof(double))              {                  Debug("Pushing double: "+((double) Value));                  Generator.Emit(OpCodes.Ldc_R8' ((double)Value));              }              else if (T == typeof(long))              {                  Debug("Pushing long: " + (long)Value);                  Generator.Emit(OpCodes.Ldc_I8' (long)Value);              }              else if (T.IsGenericType && T.GetGenericTypeDefinition() == typeof(Nullable<>))              {                  Debug("Pushing nullable: " + Value);                  EmitLiteral(Value == null ? typeof(Nullable) : T.GetGenericArguments()[0]' Value);              }              else              {                  Debug("Unhandled primitive: " + T);                  Generated = null;              }
Magic Number,IronAHK.Scripting,ILMirror,C:\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,CopyOpcode,The following statement contains a magic number: if(Code == OpCodes.Leave && ExceptionTrinkets.Contains(i + 5))               {                  i += 4;                  return;              }              else if(Code == OpCodes.Leave_S && ExceptionTrinkets.Contains(i + 2))              {                  // This is a rather tricky one. See the comment preceding the call to MineLabels above.                  i++;                  return;              }              else if(Code == OpCodes.Endfinally && ExceptionTrinkets.Contains(i+1)) return;
Magic Number,IronAHK.Scripting,ILMirror,C:\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,CopyOpcode,The following statement contains a magic number: if(Code == OpCodes.Leave && ExceptionTrinkets.Contains(i + 5))               {                  i += 4;                  return;              }              else if(Code == OpCodes.Leave_S && ExceptionTrinkets.Contains(i + 2))              {                  // This is a rather tricky one. See the comment preceding the call to MineLabels above.                  i++;                  return;              }              else if(Code == OpCodes.Endfinally && ExceptionTrinkets.Contains(i+1)) return;
Magic Number,IronAHK.Scripting,ILMirror,C:\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,CopyOpcode,The following statement contains a magic number: if(Code == OpCodes.Leave && ExceptionTrinkets.Contains(i + 5))               {                  i += 4;                  return;              }              else if(Code == OpCodes.Leave_S && ExceptionTrinkets.Contains(i + 2))              {                  // This is a rather tricky one. See the comment preceding the call to MineLabels above.                  i++;                  return;              }              else if(Code == OpCodes.Endfinally && ExceptionTrinkets.Contains(i+1)) return;
Magic Number,IronAHK.Scripting,ILMirror,C:\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,CopyOpcode,The following statement contains a magic number: switch(Code.OperandType)              {                  // If no argument' then re-emit the opcode                  case OperandType.InlineNone:                  {                      Gen.Emit(Code);                      break;                  }                                        // If argument is a method' re-emit the method reference                  case OperandType.InlineMethod:                  {                      int Token = BitHelper.ReadInteger(Bytes' ref i);                      MethodBase Base = Origin.ResolveMethod(Token);                                            if(Base is MethodInfo)                          Gen.Emit(Code' GrabMethod(Base as MethodInfo));                      else if(Base is ConstructorInfo)                          Gen.Emit(Code' GrabConstructor(Base as ConstructorInfo));                      else throw new InvalidOperationException("Inline method is neither method nor constructor.");                                            break;                  }                                        // Argument is a field reference                  case OperandType.InlineField:                  {                      int Token = BitHelper.ReadInteger(Bytes' ref i);                      FieldInfo Field = Origin.ResolveField(Token);                      Gen.Emit(Code' GrabField(Field));                      break;                  }                                        // Argument is a type reference                  case OperandType.InlineType:                  {                      int Token = BitHelper.ReadInteger(Bytes' ref i);                      Type Ref = Origin.ResolveType(Token);                      Gen.Emit(Code' GrabType(Ref));                      break;                  }                                        // Argument is an inline string                  case OperandType.InlineString:                  {                      int Token = BitHelper.ReadInteger(Bytes' ref i);                      string Copy = Origin.ResolveString(Token);                      Gen.Emit(Code' Copy);                      break;                  }                                     // Argument is a metadata token                  case OperandType.InlineTok:                  {                      int Token = BitHelper.ReadInteger(Bytes' ref i);                      MemberInfo Info = Origin.ResolveMember(Token);                                            if(Info.MemberType == MemberTypes.Field)                      {                          if(Code != OpCodes.Ldtoken || !TryReplaceBackingField(Bytes' i' Gen' Origin))                              Gen.Emit(Code' GrabField(Info as FieldInfo));                      }                      else if(Info.MemberType == MemberTypes.Method)                          Gen.Emit(Code' GrabMethod(Info as MethodInfo));                      else if(Info.MemberType == MemberTypes.TypeInfo || Info.MemberType == MemberTypes.NestedType)                          Gen.Emit(Code' GrabType(Info as Type));                      else throw new InvalidOperationException("Inline token is neither field' nor method' nor type");                                            break;                  }                                        // Argument is a switch map                  case OperandType.InlineSwitch:                  {                      if(!LabelOrigins.ContainsKey(i))                          throw new Exception("No switchmap found for RVA "+i.ToString("X"));                                                Label[] Labels = LabelOrigins[i];                      i += 4 + Labels.Length*4;                      Gen.Emit(Code' Labels);                                            break;                  }                                        // Argument is a single-byte branch target                  case OperandType.ShortInlineBrTarget:                  {                      if(!LabelOrigins.ContainsKey(i))                          throw new Exception("No label origin found for RVA "+i.ToString("X"));                        // messy fix to convert short branch targets to normal ones' since there's no easy way to calculate offsets via reflection                      const string s = ".s";                      string name = Code.Name;                      if (name.EndsWith(s))                      {                          name = name.Substring(0' name.Length - s.Length);                          foreach (var field in typeof(OpCodes).GetFields(BindingFlags.Public | BindingFlags.Static))                          {                              var opcode = (OpCode)field.GetValue(null);                              if (opcode.Name.Equals(name))                              {                                  Code = opcode;                                  break;                              }                          }                      }                        Gen.Emit(Code' LabelOrigins[i][0]);                      i++;                                            break;                  }                                        // Argument is a byte                  case OperandType.ShortInlineI:                  case OperandType.ShortInlineVar:                  {                      Gen.Emit(Code' Bytes[++i]);                      break;                  }                                    // Argument is a short                  case OperandType.InlineVar:                  {                      Gen.Emit(Code' BitHelper.ReadShort(Bytes' ref i));                      break;                  }                                        case OperandType.InlineBrTarget:                  {                      if(!LabelOrigins.ContainsKey(i))                          throw new Exception("No label origin found for RVA "+i.ToString("X"));                                            Gen.Emit(Code' LabelOrigins[i][0]);                      i += 4;                                            break;                  }                                        // Argument is a 32-bit integer                  case OperandType.InlineI:                  case OperandType.ShortInlineR: // This is actually a 32-bit float' but we don't care                  {                      Gen.Emit(Code' BitHelper.ReadInteger(Bytes' ref i));                      break;                  }                                        // Argument is a 64-bit integer                  case OperandType.InlineI8:                  {                      Gen.Emit(Code' BitHelper.ReadLong(Bytes' ref i));                      break;                  }                                        // Argument is a 64-bit float                  case OperandType.InlineR:                  {                      Gen.Emit(Code' BitHelper.ReadDouble(Bytes' ref i));                      break;                  }                                         // If ever we run across OpCodes.Calli this'll probably happen                  default:                      throw new InvalidOperationException("The method copier ran across an unknown opcode.");              }
Magic Number,IronAHK.Scripting,ILMirror,C:\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,CopyOpcode,The following statement contains a magic number: switch(Code.OperandType)              {                  // If no argument' then re-emit the opcode                  case OperandType.InlineNone:                  {                      Gen.Emit(Code);                      break;                  }                                        // If argument is a method' re-emit the method reference                  case OperandType.InlineMethod:                  {                      int Token = BitHelper.ReadInteger(Bytes' ref i);                      MethodBase Base = Origin.ResolveMethod(Token);                                            if(Base is MethodInfo)                          Gen.Emit(Code' GrabMethod(Base as MethodInfo));                      else if(Base is ConstructorInfo)                          Gen.Emit(Code' GrabConstructor(Base as ConstructorInfo));                      else throw new InvalidOperationException("Inline method is neither method nor constructor.");                                            break;                  }                                        // Argument is a field reference                  case OperandType.InlineField:                  {                      int Token = BitHelper.ReadInteger(Bytes' ref i);                      FieldInfo Field = Origin.ResolveField(Token);                      Gen.Emit(Code' GrabField(Field));                      break;                  }                                        // Argument is a type reference                  case OperandType.InlineType:                  {                      int Token = BitHelper.ReadInteger(Bytes' ref i);                      Type Ref = Origin.ResolveType(Token);                      Gen.Emit(Code' GrabType(Ref));                      break;                  }                                        // Argument is an inline string                  case OperandType.InlineString:                  {                      int Token = BitHelper.ReadInteger(Bytes' ref i);                      string Copy = Origin.ResolveString(Token);                      Gen.Emit(Code' Copy);                      break;                  }                                     // Argument is a metadata token                  case OperandType.InlineTok:                  {                      int Token = BitHelper.ReadInteger(Bytes' ref i);                      MemberInfo Info = Origin.ResolveMember(Token);                                            if(Info.MemberType == MemberTypes.Field)                      {                          if(Code != OpCodes.Ldtoken || !TryReplaceBackingField(Bytes' i' Gen' Origin))                              Gen.Emit(Code' GrabField(Info as FieldInfo));                      }                      else if(Info.MemberType == MemberTypes.Method)                          Gen.Emit(Code' GrabMethod(Info as MethodInfo));                      else if(Info.MemberType == MemberTypes.TypeInfo || Info.MemberType == MemberTypes.NestedType)                          Gen.Emit(Code' GrabType(Info as Type));                      else throw new InvalidOperationException("Inline token is neither field' nor method' nor type");                                            break;                  }                                        // Argument is a switch map                  case OperandType.InlineSwitch:                  {                      if(!LabelOrigins.ContainsKey(i))                          throw new Exception("No switchmap found for RVA "+i.ToString("X"));                                                Label[] Labels = LabelOrigins[i];                      i += 4 + Labels.Length*4;                      Gen.Emit(Code' Labels);                                            break;                  }                                        // Argument is a single-byte branch target                  case OperandType.ShortInlineBrTarget:                  {                      if(!LabelOrigins.ContainsKey(i))                          throw new Exception("No label origin found for RVA "+i.ToString("X"));                        // messy fix to convert short branch targets to normal ones' since there's no easy way to calculate offsets via reflection                      const string s = ".s";                      string name = Code.Name;                      if (name.EndsWith(s))                      {                          name = name.Substring(0' name.Length - s.Length);                          foreach (var field in typeof(OpCodes).GetFields(BindingFlags.Public | BindingFlags.Static))                          {                              var opcode = (OpCode)field.GetValue(null);                              if (opcode.Name.Equals(name))                              {                                  Code = opcode;                                  break;                              }                          }                      }                        Gen.Emit(Code' LabelOrigins[i][0]);                      i++;                                            break;                  }                                        // Argument is a byte                  case OperandType.ShortInlineI:                  case OperandType.ShortInlineVar:                  {                      Gen.Emit(Code' Bytes[++i]);                      break;                  }                                    // Argument is a short                  case OperandType.InlineVar:                  {                      Gen.Emit(Code' BitHelper.ReadShort(Bytes' ref i));                      break;                  }                                        case OperandType.InlineBrTarget:                  {                      if(!LabelOrigins.ContainsKey(i))                          throw new Exception("No label origin found for RVA "+i.ToString("X"));                                            Gen.Emit(Code' LabelOrigins[i][0]);                      i += 4;                                            break;                  }                                        // Argument is a 32-bit integer                  case OperandType.InlineI:                  case OperandType.ShortInlineR: // This is actually a 32-bit float' but we don't care                  {                      Gen.Emit(Code' BitHelper.ReadInteger(Bytes' ref i));                      break;                  }                                        // Argument is a 64-bit integer                  case OperandType.InlineI8:                  {                      Gen.Emit(Code' BitHelper.ReadLong(Bytes' ref i));                      break;                  }                                        // Argument is a 64-bit float                  case OperandType.InlineR:                  {                      Gen.Emit(Code' BitHelper.ReadDouble(Bytes' ref i));                      break;                  }                                         // If ever we run across OpCodes.Calli this'll probably happen                  default:                      throw new InvalidOperationException("The method copier ran across an unknown opcode.");              }
Magic Number,IronAHK.Scripting,ILMirror,C:\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,CopyOpcode,The following statement contains a magic number: switch(Code.OperandType)              {                  // If no argument' then re-emit the opcode                  case OperandType.InlineNone:                  {                      Gen.Emit(Code);                      break;                  }                                        // If argument is a method' re-emit the method reference                  case OperandType.InlineMethod:                  {                      int Token = BitHelper.ReadInteger(Bytes' ref i);                      MethodBase Base = Origin.ResolveMethod(Token);                                            if(Base is MethodInfo)                          Gen.Emit(Code' GrabMethod(Base as MethodInfo));                      else if(Base is ConstructorInfo)                          Gen.Emit(Code' GrabConstructor(Base as ConstructorInfo));                      else throw new InvalidOperationException("Inline method is neither method nor constructor.");                                            break;                  }                                        // Argument is a field reference                  case OperandType.InlineField:                  {                      int Token = BitHelper.ReadInteger(Bytes' ref i);                      FieldInfo Field = Origin.ResolveField(Token);                      Gen.Emit(Code' GrabField(Field));                      break;                  }                                        // Argument is a type reference                  case OperandType.InlineType:                  {                      int Token = BitHelper.ReadInteger(Bytes' ref i);                      Type Ref = Origin.ResolveType(Token);                      Gen.Emit(Code' GrabType(Ref));                      break;                  }                                        // Argument is an inline string                  case OperandType.InlineString:                  {                      int Token = BitHelper.ReadInteger(Bytes' ref i);                      string Copy = Origin.ResolveString(Token);                      Gen.Emit(Code' Copy);                      break;                  }                                     // Argument is a metadata token                  case OperandType.InlineTok:                  {                      int Token = BitHelper.ReadInteger(Bytes' ref i);                      MemberInfo Info = Origin.ResolveMember(Token);                                            if(Info.MemberType == MemberTypes.Field)                      {                          if(Code != OpCodes.Ldtoken || !TryReplaceBackingField(Bytes' i' Gen' Origin))                              Gen.Emit(Code' GrabField(Info as FieldInfo));                      }                      else if(Info.MemberType == MemberTypes.Method)                          Gen.Emit(Code' GrabMethod(Info as MethodInfo));                      else if(Info.MemberType == MemberTypes.TypeInfo || Info.MemberType == MemberTypes.NestedType)                          Gen.Emit(Code' GrabType(Info as Type));                      else throw new InvalidOperationException("Inline token is neither field' nor method' nor type");                                            break;                  }                                        // Argument is a switch map                  case OperandType.InlineSwitch:                  {                      if(!LabelOrigins.ContainsKey(i))                          throw new Exception("No switchmap found for RVA "+i.ToString("X"));                                                Label[] Labels = LabelOrigins[i];                      i += 4 + Labels.Length*4;                      Gen.Emit(Code' Labels);                                            break;                  }                                        // Argument is a single-byte branch target                  case OperandType.ShortInlineBrTarget:                  {                      if(!LabelOrigins.ContainsKey(i))                          throw new Exception("No label origin found for RVA "+i.ToString("X"));                        // messy fix to convert short branch targets to normal ones' since there's no easy way to calculate offsets via reflection                      const string s = ".s";                      string name = Code.Name;                      if (name.EndsWith(s))                      {                          name = name.Substring(0' name.Length - s.Length);                          foreach (var field in typeof(OpCodes).GetFields(BindingFlags.Public | BindingFlags.Static))                          {                              var opcode = (OpCode)field.GetValue(null);                              if (opcode.Name.Equals(name))                              {                                  Code = opcode;                                  break;                              }                          }                      }                        Gen.Emit(Code' LabelOrigins[i][0]);                      i++;                                            break;                  }                                        // Argument is a byte                  case OperandType.ShortInlineI:                  case OperandType.ShortInlineVar:                  {                      Gen.Emit(Code' Bytes[++i]);                      break;                  }                                    // Argument is a short                  case OperandType.InlineVar:                  {                      Gen.Emit(Code' BitHelper.ReadShort(Bytes' ref i));                      break;                  }                                        case OperandType.InlineBrTarget:                  {                      if(!LabelOrigins.ContainsKey(i))                          throw new Exception("No label origin found for RVA "+i.ToString("X"));                                            Gen.Emit(Code' LabelOrigins[i][0]);                      i += 4;                                            break;                  }                                        // Argument is a 32-bit integer                  case OperandType.InlineI:                  case OperandType.ShortInlineR: // This is actually a 32-bit float' but we don't care                  {                      Gen.Emit(Code' BitHelper.ReadInteger(Bytes' ref i));                      break;                  }                                        // Argument is a 64-bit integer                  case OperandType.InlineI8:                  {                      Gen.Emit(Code' BitHelper.ReadLong(Bytes' ref i));                      break;                  }                                        // Argument is a 64-bit float                  case OperandType.InlineR:                  {                      Gen.Emit(Code' BitHelper.ReadDouble(Bytes' ref i));                      break;                  }                                         // If ever we run across OpCodes.Calli this'll probably happen                  default:                      throw new InvalidOperationException("The method copier ran across an unknown opcode.");              }
Magic Number,IronAHK.Scripting,ILMirror,C:\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,TryReplaceBackingField,The following statement contains a magic number: if(Bytes[i+6] != (byte) OpCodes.Stsfld.Value)                  return false;
Magic Number,IronAHK.Scripting,ILMirror,C:\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,TryReplaceBackingField,The following statement contains a magic number: i += 6;
Magic Number,IronAHK.Scripting,ILMirror,C:\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,MineLabels,The following statement contains a magic number: for(int i = 0; i < Bytes.Length; i++)              {                  OpCode Code = GetOpcode(Bytes' ref i);                  int Start = i;                                    // Reference: http://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.switch(VS.80).aspx                  if(Code == OpCodes.Switch)                   {                      int Count = (int) BitHelper.ReadUnsignedInteger(Bytes' ref i);                                            // Jumps are relative to the first byte of the instruction following the switchmap                      int Zero = i+Count*4+1;                       List<Label> Labels = new List<Label>();                                            for(int j = 0; j < Count; j++)                      {                          int Absolute = Zero+BitHelper.ReadInteger(Bytes' ref i);                                                    if(!LabelTargets.ContainsKey(Absolute))                          {                              Label At = Gen.DefineLabel();                              LabelTargets.Add(Absolute' At);                              Labels.Add(At);                          }                          // If there is a label already defined for this position' reuse that for this switchmap too                          else Labels.Add(LabelTargets[Absolute]);                       }                                            LabelOrigins.Add(Start' Labels.ToArray());                  }                  else if(Code.OperandType == OperandType.InlineBrTarget ||                           Code.OperandType == OperandType.ShortInlineBrTarget)                  {                      int Zero' Target;                                            if(Code.OperandType == OperandType.InlineBrTarget)                      {                          Zero = i+5;                          Target = Zero+BitHelper.ReadInteger(Bytes' ref i);                      }                      else                       {                          Zero = i+2;                          Target = Zero+((sbyte)Bytes[++i]);                      }                                            if(!LabelTargets.ContainsKey(Target))                      {                          Label At = Gen.DefineLabel();                          LabelTargets.Add(Target' At);                          LabelOrigins.Add(Start' new Label[] { At });                      }                      else LabelOrigins.Add(Start' new Label[] { LabelTargets[Target] });                  }                  else i += CodeArgumentSize(Code);              }
Magic Number,IronAHK.Scripting,ILMirror,C:\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,MineLabels,The following statement contains a magic number: for(int i = 0; i < Bytes.Length; i++)              {                  OpCode Code = GetOpcode(Bytes' ref i);                  int Start = i;                                    // Reference: http://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.switch(VS.80).aspx                  if(Code == OpCodes.Switch)                   {                      int Count = (int) BitHelper.ReadUnsignedInteger(Bytes' ref i);                                            // Jumps are relative to the first byte of the instruction following the switchmap                      int Zero = i+Count*4+1;                       List<Label> Labels = new List<Label>();                                            for(int j = 0; j < Count; j++)                      {                          int Absolute = Zero+BitHelper.ReadInteger(Bytes' ref i);                                                    if(!LabelTargets.ContainsKey(Absolute))                          {                              Label At = Gen.DefineLabel();                              LabelTargets.Add(Absolute' At);                              Labels.Add(At);                          }                          // If there is a label already defined for this position' reuse that for this switchmap too                          else Labels.Add(LabelTargets[Absolute]);                       }                                            LabelOrigins.Add(Start' Labels.ToArray());                  }                  else if(Code.OperandType == OperandType.InlineBrTarget ||                           Code.OperandType == OperandType.ShortInlineBrTarget)                  {                      int Zero' Target;                                            if(Code.OperandType == OperandType.InlineBrTarget)                      {                          Zero = i+5;                          Target = Zero+BitHelper.ReadInteger(Bytes' ref i);                      }                      else                       {                          Zero = i+2;                          Target = Zero+((sbyte)Bytes[++i]);                      }                                            if(!LabelTargets.ContainsKey(Target))                      {                          Label At = Gen.DefineLabel();                          LabelTargets.Add(Target' At);                          LabelOrigins.Add(Start' new Label[] { At });                      }                      else LabelOrigins.Add(Start' new Label[] { LabelTargets[Target] });                  }                  else i += CodeArgumentSize(Code);              }
Magic Number,IronAHK.Scripting,ILMirror,C:\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,MineLabels,The following statement contains a magic number: for(int i = 0; i < Bytes.Length; i++)              {                  OpCode Code = GetOpcode(Bytes' ref i);                  int Start = i;                                    // Reference: http://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.switch(VS.80).aspx                  if(Code == OpCodes.Switch)                   {                      int Count = (int) BitHelper.ReadUnsignedInteger(Bytes' ref i);                                            // Jumps are relative to the first byte of the instruction following the switchmap                      int Zero = i+Count*4+1;                       List<Label> Labels = new List<Label>();                                            for(int j = 0; j < Count; j++)                      {                          int Absolute = Zero+BitHelper.ReadInteger(Bytes' ref i);                                                    if(!LabelTargets.ContainsKey(Absolute))                          {                              Label At = Gen.DefineLabel();                              LabelTargets.Add(Absolute' At);                              Labels.Add(At);                          }                          // If there is a label already defined for this position' reuse that for this switchmap too                          else Labels.Add(LabelTargets[Absolute]);                       }                                            LabelOrigins.Add(Start' Labels.ToArray());                  }                  else if(Code.OperandType == OperandType.InlineBrTarget ||                           Code.OperandType == OperandType.ShortInlineBrTarget)                  {                      int Zero' Target;                                            if(Code.OperandType == OperandType.InlineBrTarget)                      {                          Zero = i+5;                          Target = Zero+BitHelper.ReadInteger(Bytes' ref i);                      }                      else                       {                          Zero = i+2;                          Target = Zero+((sbyte)Bytes[++i]);                      }                                            if(!LabelTargets.ContainsKey(Target))                      {                          Label At = Gen.DefineLabel();                          LabelTargets.Add(Target' At);                          LabelOrigins.Add(Start' new Label[] { At });                      }                      else LabelOrigins.Add(Start' new Label[] { LabelTargets[Target] });                  }                  else i += CodeArgumentSize(Code);              }
Magic Number,IronAHK.Scripting,ILMirror,C:\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,CodeArgumentSize,The following statement contains a magic number: switch(Code.OperandType)              {                  case OperandType.InlineNone:                      return 0;                                        // All tokens are 32-bit integers                  case OperandType.InlineMethod:                  case OperandType.InlineField:                  case OperandType.InlineType:                  case OperandType.InlineString:                  case OperandType.InlineTok:                  case OperandType.InlineBrTarget:                  case OperandType.InlineI:                  case OperandType.ShortInlineR:                       return 4;                                        // Variable length                  case OperandType.InlineSwitch:                      throw new ArgumentException("InlineSwitch has variable argument length"' "Code");                                        // Argument is a byte                  case OperandType.ShortInlineBrTarget:                  case OperandType.ShortInlineI:                  case OperandType.ShortInlineVar:                      return 1;                                    // Argument is a short                  case OperandType.InlineVar:                      return 2;                                        // Argument is a 64-bit integer                  case OperandType.InlineI8:                  case OperandType.InlineR:                      return 8;                                    default:                      throw new InvalidOperationException("Could not determine argument size for opcode "+Code);              }
Magic Number,IronAHK.Scripting,ILMirror,C:\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,CodeArgumentSize,The following statement contains a magic number: switch(Code.OperandType)              {                  case OperandType.InlineNone:                      return 0;                                        // All tokens are 32-bit integers                  case OperandType.InlineMethod:                  case OperandType.InlineField:                  case OperandType.InlineType:                  case OperandType.InlineString:                  case OperandType.InlineTok:                  case OperandType.InlineBrTarget:                  case OperandType.InlineI:                  case OperandType.ShortInlineR:                       return 4;                                        // Variable length                  case OperandType.InlineSwitch:                      throw new ArgumentException("InlineSwitch has variable argument length"' "Code");                                        // Argument is a byte                  case OperandType.ShortInlineBrTarget:                  case OperandType.ShortInlineI:                  case OperandType.ShortInlineVar:                      return 1;                                    // Argument is a short                  case OperandType.InlineVar:                      return 2;                                        // Argument is a 64-bit integer                  case OperandType.InlineI8:                  case OperandType.InlineR:                      return 8;                                    default:                      throw new InvalidOperationException("Could not determine argument size for opcode "+Code);              }
Magic Number,IronAHK.Scripting,ILMirror,C:\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,CodeArgumentSize,The following statement contains a magic number: switch(Code.OperandType)              {                  case OperandType.InlineNone:                      return 0;                                        // All tokens are 32-bit integers                  case OperandType.InlineMethod:                  case OperandType.InlineField:                  case OperandType.InlineType:                  case OperandType.InlineString:                  case OperandType.InlineTok:                  case OperandType.InlineBrTarget:                  case OperandType.InlineI:                  case OperandType.ShortInlineR:                       return 4;                                        // Variable length                  case OperandType.InlineSwitch:                      throw new ArgumentException("InlineSwitch has variable argument length"' "Code");                                        // Argument is a byte                  case OperandType.ShortInlineBrTarget:                  case OperandType.ShortInlineI:                  case OperandType.ShortInlineVar:                      return 1;                                    // Argument is a short                  case OperandType.InlineVar:                      return 2;                                        // Argument is a 64-bit integer                  case OperandType.InlineI8:                  case OperandType.InlineR:                      return 8;                                    default:                      throw new InvalidOperationException("Could not determine argument size for opcode "+Code);              }
Magic Number,IronAHK.Scripting,BitHelper,C:\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,ReadUnsignedInteger,The following statement contains a magic number: i += 3;
Magic Number,IronAHK.Scripting,BitHelper,C:\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,ReadInteger,The following statement contains a magic number: i += 3;
Magic Number,IronAHK.Scripting,BitHelper,C:\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,ReadLong,The following statement contains a magic number: i += 7;
Magic Number,IronAHK.Scripting,BitHelper,C:\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,ReadFloat,The following statement contains a magic number: i += 3;
Magic Number,IronAHK.Scripting,BitHelper,C:\repos\polyethene_IronAHK\Scripting\Compiler\Bundling\BitHelper.cs,ReadDouble,The following statement contains a magic number: i += 7;
Missing Default,IronAHK.Scripting,Emit,C:\repos\polyethene_IronAHK\Scripting\Generator\Emission\Operators.cs,EmitMethod,The following switch statement is missing a default case: switch (param.Direction)                  {                      case FieldDirection.Out:                          throw new NotSupportedException();                        case FieldDirection.Ref:                          writer.Write(Parser.FunctionParamRef);                          writer.Write(Parser.SingleSpace);                          break;                  }
Missing Default,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Set,The following switch statement is missing a default case: switch (first[0])                  {                      case BlockOpen:                          expect = BlockClose;                          levels[1]++;                          break;                        case ArrayOpen:                          expect = ArrayClose;                          levels[2]++;                          break;                        case ParenOpen:                          expect = ParenClose;                          levels[0]++;                          break;                  }
Missing Default,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Set,The following switch statement is missing a default case: switch (current[0])                      {                          case BlockOpen:                              levels[1]++;                              break;                            case BlockClose:                              levels[1]--;                              if (levels[1] < 0)                                  throw new ParseException(ExUnbalancedParens);                              else if (expect == BlockClose && levels[0] == 0 && levels[1] == 0 && levels[2] == 0)                                  return position;                              break;                            case ArrayOpen:                              levels[2]++;                              break;                            case ArrayClose:                              levels[2]--;                              if (levels[2] < 0)                                  throw new ParseException(ExUnbalancedParens);                              else if (expect == ArrayClose && levels[0] == 0 && levels[1] == 0 && levels[2] == 0)                                  return position;                              break;                            case ParenOpen:                              levels[0]++;                              break;                            case ParenClose:                              levels[0]--;                              if (levels[0] < 0)                                  throw new ParseException(ExUnbalancedParens);                              else if (expect == ParenClose && levels[0] == 0 && levels[1] == 0 && levels[2] == 0)                                  return position;                              break;                      }
Missing Default,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,OperatorFromString,The following switch statement is missing a default case: switch (code.ToLowerInvariant())                      {                          case NotTxt:                              return Script.Operator.LogicalNotEx;                            case AndTxt:                              return Script.Operator.BooleanAnd;                            case OrTxt:                              return Script.Operator.BooleanOr;                            case IsTxt:                              return Script.Operator.Is;                      }
Missing Default,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitTokens,The following switch statement is missing a default case: switch (sym)                          {                              case Divide:                              case Greater:                              case Less:                                  peekAssign = true;                                  goto case Add;                                case Add:                              case Minus:                              case Multiply:                              case BitOR:                              case BitAND:                                  op.Append(sym);                                  op.Append(symNext);                                  i++;                                  tri = true;                                  if (peekAssign)                                  {                                      n = i + 1;                                      if (n < code.Length && code[n] == Equal)                                      {                                          op.Append(code[n]);                                          i = n;                                      }                                  }                                  break;                          }
Missing Default,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitTokens,The following switch statement is missing a default case: switch (sym)                              {                                  case AssignPre:                                  case Add:                                  case Minus:                                  case Multiply:                                  case Divide:                                  case Concatenate:                                  case BitAND:                                  case BitXOR:                                  case BitOR:                                  case Not:                                  case Equal:                                  case Greater:                                  case Less:                                      op.Append(sym);                                      op.Append(symNext);                                      i++;                                      break;                              }
Missing Default,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,RemoveExcessParentheses,The following switch statement is missing a default case: switch (check[check.Length - 1])                      {                          case ParenOpen:                              level++;                              break;                            case ParenClose:                              if (check.Length != 1)                                  break;                              else if (--level < 0)                                  throw new ParseException(ExUnbalancedParens);                              break;                      }
Missing Default,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,Translate,The following switch statement is missing a default case: switch (cmd.ToLowerInvariant())              {                  #region Repeat                    case "repeat":                      param = StripCommentSingle(param);                      if (param.Length > 0 && !IsPrimativeObject(param))                              param = string.Empty;                      replaced.Append("Loop ");                      replaced.Append(param);                      replaced.Append(SingleSpace);                      replaced.Append(BlockOpen);                      break;                    case "endrepeat":                      replaced.Append(BlockClose);                      replaced.Append(param);                      break;                    #endregion                    #region Setters                    case "setbatchlines":                  case "setcontroldelay":                  case "setdefaultmousespeed":                  case "setkeydelay":                  case "setmousedelay":                  case "setstorecapslockmode":                  case "settitlematchmode":                  case "setwindelay":                  case "setworkingdir":                      replaced.Append("A_");                      replaced.Append(cmd' 3' cmd.Length - 3);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    case "setenv":                      replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      else                          replaced.Append(NullTxt);                      break;                    case "setformat":                      if (parts.Length != 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append("A_Format");                      const string fast = "fast";                      parts[0] = parts[0].Substring(1' parts[0].Length - 2);                      if (parts[0].EndsWith(fast' System.StringComparison.OrdinalIgnoreCase))                          parts[0] = parts[0].Substring(0' parts[0].Length - fast.Length);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append(parts[1]);                      break;                    case "autotrim":                  case "detecthiddentext":                  case "detecthiddenwindows":                  case "stringcasesense":                      replaced.Append("A_");                      replaced.Append(cmd);                      replaced.Append(Equal);                      replaced.Append(param);                      break;                    #endregion                    #region If                    #region Equality                    // TODO: push single conditional command on same line as legacy converted equality-if statements                    case "ifequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifnotequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Not);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreater":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifgreaterorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Greater);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "ifless":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    case "iflessorequal":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(parts[0]);                      replaced.Append(Less);                      replaced.Append(Equal);                      if (parts.Length > 1)                          replaced.Append(parts[1]);                      break;                    #endregion                    case "ifexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotexist":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("FileExist");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifnotinstring":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[0]);                      replaced.Append(Multicast);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose' 2);                      break;                    case "ifmsgbox":                      if (parts.Length < 1)                          throw new ParseException(ExTooFewParams);                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("A_MsgBox");                      replaced.Append(Equal);                      replaced.Append(parts[0]);                      replaced.Append(ParenClose);                      break;                    case "ifwinactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotactive":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinActive");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    case "ifwinnotexist":                      replaced.Append(FlowIf);                      replaced.Append(SingleSpace);                      replaced.Append(ParenOpen);                      replaced.Append(Not);                      replaced.Append("WinExist");                      replaced.Append(ParenOpen);                      foreach (var part in parts)                      {                          replaced.Append(part);                          replaced.Append(Multicast);                      }                      if (parts.Length > 1)                          replaced.Remove(replaced.Length - 1' 1);                      replaced.Append(ParenClose' 2);                      break;                    #endregion                    #region Strings                    // HACK: convert L/R paramter for legacy StringGetPos command                  case "stringgetpos":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0].Trim(StringBound));                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("InStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(Multicast);                      replaced.Append(FalseTxt);                      replaced.Append(Multicast);                      replaced.Append(parts.Length > 4 ? parts[4] : "0");                      replaced.Append(ParenClose);                      break;                    case "stringleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringlen":                      if (parts.Length < 2)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("StrLen");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(ParenClose);                      break;                    case "stringmid":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append(parts[2]);                      if (parts.Length > 3)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[3]);                      }                      if (parts.Length > 4)                      {                          replaced.Append(Multicast);                          replaced.Append(parts[4]);                      }                      replaced.Append(ParenClose);                      break;                    case "stringright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    case "stringtrimleft":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Add);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      break;                    case "stringtrimright":                      if (parts.Length < 3)                          throw new ParseException(ExTooFewParams);                      replaced.Append(parts[0]);                      replaced.Append(AssignPre);                      replaced.Append(Equal);                      replaced.Append("SubStr");                      replaced.Append(ParenOpen);                      replaced.Append(parts[1]);                      replaced.Append(Multicast);                      replaced.Append("1");                      replaced.Append(Multicast);                      replaced.Append(Minus);                      replaced.Append(ParenOpen);                      replaced.Append(parts[2]);                      replaced.Append(ParenClose);                      replaced.Append(ParenClose);                      break;                    #endregion                    #region Arithmetic                    // TODO: translate legacy EnvMult' EnvDiv etc                    #endregion                    #region Send                    case "sendevent":                  case "sendinput":                  case "sendplay":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    case "sendraw":                      replaced.Append("Send");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "controlsendraw":                      replaced.Append("ControlSend");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      ParameterPrepend(ref param' "{Raw}");                      replaced.Append(param);                      break;                    case "sendmode":                      code = string.Empty;                      break;                    case "setcapslockstate":                  case "setnumlockstate":                  case "setscrolllockstate":                      replaced.Append("SetLockState");                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(cmd' 3' cmd.Length - 3 - 5);                      replaced.Append(Multicast);                      replaced.Append(SingleSpace);                      replaced.Append(param);                      break;                    #endregion                    #region Mouse                    case "leftclick":                  case "mouseclick":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "leftclickdrag":                      replaced.Append("MouseClickDrag");                      replaced.Append(Multicast);                      replaced.Append("Left");                      replaced.Append(Multicast);                      replaced.Append(param);                      break;                    case "mousemove":                      replaced.Append("Click");                      replaced.Append(Multicast);                      replaced.Append(param);                      replaced.Append(Multicast);                      replaced.Append("0");                      break;                    #endregion                    #region Debug                    case "edit":                  case "listlines":                  case "listvars":                      replaced = null;                      break;                    #endregion                    #region Other                    case "filegetattrib":                      if (parts.Length != 2)                          replaced = null;                      else                      {                          replaced.Append(parts[0].Substring(1' parts[0].Length - 2));                          replaced.Append(AssignPre);                          replaced.Append(Equal);                          replaced.Append("FileExist");                          replaced.Append(ParenOpen);                          replaced.Append(parts[1]);                          replaced.Append(ParenClose);                      }                      break;                    #endregion              }
Missing Default,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,CheckPersistent,The following switch statement is missing a default case: switch (name.ToLowerInvariant())              {                  case "settimer":                  case "menu":                  case "hotkey":                  case "hotstring":                  case "onmessage":                  case "gui":                      persistent = true;                      break;              }
Missing Default,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsPrimativeObject,The following switch statement is missing a default case: switch (code.ToLowerInvariant())              {                  case TrueTxt:                      result = true;                      return true;                    case FalseTxt:                      result = false;                      return true;                    case NullTxt:                      return true;              }
Missing Default,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsExpressionIf,The following switch statement is missing a default case: switch (code[i])              {                  case Equal:                  case Not:                  case Greater:                  case Less:                      return false;              }
Missing Default,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsLegacyIf,The following switch statement is missing a default case: switch (part[1].ToLowerInvariant())              {                  case NotTxt:                  case BetweenTxt:                  case InTxt:                  case ContainsTxt:                  case IsTxt:                      return true;              }
Missing Default,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,SplitCommandParameters,The following switch statement is missing a default case: switch (sym)                      {                          case StringBound: str = !str; break;                          case ParenOpen: levels[0]++; break;                          case ParenClose: levels[0]--; break;                          case BlockOpen: levels[1]++; break;                          case BlockClose: levels[1]--; break;                          case ArrayOpen: levels[2]++; break;                          case ArrayClose: levels[2]--; break;                      }
Missing Default,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseDirective,The following switch statement is missing a default case: switch (parts[1].ToUpperInvariant())                          {                              case "FORCE":                                  options.MergeFallbackToLink = false;                                  break;                                case "OFF":                                  options.Merge = false;                                  break;                          }
Missing Default,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseMultiExpression,The following switch statement is missing a default case: switch (arg)                  {                      case "S":                      case "SECOND":                      case "M":                      case "MINUTE":                      case "H":                      case "HOUR":                      case "D":                      case "DAY":                          return new[] { new CodeExpressionStatement(ParseDateExpression(code)) };                  }
Missing Default,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,ParseExpression,The following switch statement is missing a default case: switch (parts[i] as Script.Operator?)                                  {                                      case Script.Operator.TernaryA:                                          depth++;                                          break;                                        case Script.Operator.TernaryB:                                          depth--;                                          break;                                  }
Missing Default,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsFlowOperator,The following switch statement is missing a default case: switch (word)              {                  case FlowBreak:                  case FlowContinue:                  case FlowElse:                  case FlowGosub:                  case FlowGoto:                  case FlowIf:                  case FlowLoop:                  case FlowReturn:                  case FlowWhile:                  case FunctionLocal:                  case FunctionGlobal:                  case FunctionStatic:                      return true;              }
Missing Default,IronAHK.Scripting,Parser,C:\repos\polyethene_IronAHK\Scripting\Parser\Construct\Expressions\Assignments.cs,IsFunction,The following switch statement is missing a default case: switch (stage)                  {                      case 0:                          if (sym == ParenOpen)                              stage++;                          else if (!IsIdentifier(sym))                              return false;                          break;                        case 1:                          if (sym == StringBound)                              str = !str;                          else if (!str && sym == ParenClose)                              stage++;                          break;                        case 2:                          if (sym == BlockOpen)                              return true;                          else if (IsCommentAt(code' i))                              goto next;                          else if (!IsSpace(sym))                              return false;                          break;                  }
Missing Default,IronAHK.Scripting,Script,C:\repos\polyethene_IronAHK\Scripting\Script\Call.cs,IfLegacy,The following switch statement is missing a default case: switch (test)                          {                              case Object:                                  return typeof(IDictionary).IsAssignableFrom(type);                                case Array:                                  return type.IsArray;                          }
Missing Default,IronAHK.Scripting,Script,C:\repos\polyethene_IronAHK\Scripting\Script\Call.cs,IfLegacy,The following switch statement is missing a default case: switch (test)                      {                          case Integer:                          case Number:                              var = var.Trim().TrimStart(new[] { '+'' '-' });                              goto case Xdigit;                            case Xdigit:                              if (var.Length > 3 && var[0] == '0' && (var[1] == 'x' || var[1] == 'X'))                                  var = var.Substring(2);                              break;                      }
