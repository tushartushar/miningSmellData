Implementation smell,Namespace,Class,File,Method,Description
Long Method,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,pagein,The method has 147 lines of code.
Long Method,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,flush,The method has 128 lines of code.
Long Method,csogg,SyncState,C:\repos\mono_csvorbis\csogg\SyncState.cs,pageseek,The method has 125 lines of code.
Complex Method,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,pagein,Cyclomatic complexity of the method is 21
Complex Method,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,flush,Cyclomatic complexity of the method is 13
Complex Method,csogg,SyncState,C:\repos\mono_csvorbis\csogg\SyncState.cs,pageseek,Cyclomatic complexity of the method is 11
Complex Conditional,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,pageout,The conditional expression  "(e_o_s!=0&&lacing_fill!=0) ||  /* 'were done' now flush' case */ 				body_fill-body_returned> 4096 ||     /* 'page nominal size' case */ 				lacing_fill>=255 ||          /* 'segment table full' case */ 				(lacing_fill!=0&&b_o_s==0)"  is complex.
Complex Conditional,csogg,SyncState,C:\repos\mono_csvorbis\csogg\SyncState.cs,pageseek,The conditional expression  "data[page]!='O' || 					data[page+1]!='g' || 					data[page+2]!='g' || 					data[page+3]!='S'"  is complex.
Complex Conditional,csogg,SyncState,C:\repos\mono_csvorbis\csogg\SyncState.cs,pageseek,The conditional expression  "chksum[0]!=data[page+22] || 					chksum[1]!=data[page+23] || 					chksum[2]!=data[page+24] || 					chksum[3]!=data[page+25]"  is complex.
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,write,The following statement contains a magic number: for(int i = 0; i < s.Length; i++)   			{  				if(s[i] == 0) break;  				write(s[i]' 8);  			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,read,The following statement contains a magic number: while(bytes--!=0)   			{  				s[i++]=(byte)(read(8));  			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,write,The following statement contains a magic number: if(endbyte + 4 >= storage)   			{  				byte[] foo = new byte[storage + BUFFER_INCREMENT];  				Array.Copy(buffer' 0' foo' 0' storage);  				buffer = foo;  				storage += BUFFER_INCREMENT;  			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,write,The following statement contains a magic number: if(bits >= 8)  			{  				buffer[ptr+1] = (byte)((uint)vvalue >> (8-endbit));  				if(bits >= 16)  				{  					buffer[ptr+2] = (byte)((uint)vvalue >> (16-endbit));  					if (bits >= 24)  					{  						buffer[ptr+3] = (byte)((uint)vvalue >> (24-endbit));  						if(bits >= 32)  						{  							if(endbit > 0)  								buffer[ptr+4] = (byte)((uint)vvalue >> (32-endbit));  							else  								buffer[ptr+4]=0;  						}  					}  				}  			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,write,The following statement contains a magic number: if(bits >= 8)  			{  				buffer[ptr+1] = (byte)((uint)vvalue >> (8-endbit));  				if(bits >= 16)  				{  					buffer[ptr+2] = (byte)((uint)vvalue >> (16-endbit));  					if (bits >= 24)  					{  						buffer[ptr+3] = (byte)((uint)vvalue >> (24-endbit));  						if(bits >= 32)  						{  							if(endbit > 0)  								buffer[ptr+4] = (byte)((uint)vvalue >> (32-endbit));  							else  								buffer[ptr+4]=0;  						}  					}  				}  			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,write,The following statement contains a magic number: if(bits >= 8)  			{  				buffer[ptr+1] = (byte)((uint)vvalue >> (8-endbit));  				if(bits >= 16)  				{  					buffer[ptr+2] = (byte)((uint)vvalue >> (16-endbit));  					if (bits >= 24)  					{  						buffer[ptr+3] = (byte)((uint)vvalue >> (24-endbit));  						if(bits >= 32)  						{  							if(endbit > 0)  								buffer[ptr+4] = (byte)((uint)vvalue >> (32-endbit));  							else  								buffer[ptr+4]=0;  						}  					}  				}  			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,write,The following statement contains a magic number: if(bits >= 8)  			{  				buffer[ptr+1] = (byte)((uint)vvalue >> (8-endbit));  				if(bits >= 16)  				{  					buffer[ptr+2] = (byte)((uint)vvalue >> (16-endbit));  					if (bits >= 24)  					{  						buffer[ptr+3] = (byte)((uint)vvalue >> (24-endbit));  						if(bits >= 32)  						{  							if(endbit > 0)  								buffer[ptr+4] = (byte)((uint)vvalue >> (32-endbit));  							else  								buffer[ptr+4]=0;  						}  					}  				}  			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,write,The following statement contains a magic number: if(bits >= 8)  			{  				buffer[ptr+1] = (byte)((uint)vvalue >> (8-endbit));  				if(bits >= 16)  				{  					buffer[ptr+2] = (byte)((uint)vvalue >> (16-endbit));  					if (bits >= 24)  					{  						buffer[ptr+3] = (byte)((uint)vvalue >> (24-endbit));  						if(bits >= 32)  						{  							if(endbit > 0)  								buffer[ptr+4] = (byte)((uint)vvalue >> (32-endbit));  							else  								buffer[ptr+4]=0;  						}  					}  				}  			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,write,The following statement contains a magic number: if(bits >= 8)  			{  				buffer[ptr+1] = (byte)((uint)vvalue >> (8-endbit));  				if(bits >= 16)  				{  					buffer[ptr+2] = (byte)((uint)vvalue >> (16-endbit));  					if (bits >= 24)  					{  						buffer[ptr+3] = (byte)((uint)vvalue >> (24-endbit));  						if(bits >= 32)  						{  							if(endbit > 0)  								buffer[ptr+4] = (byte)((uint)vvalue >> (32-endbit));  							else  								buffer[ptr+4]=0;  						}  					}  				}  			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,write,The following statement contains a magic number: if(bits >= 8)  			{  				buffer[ptr+1] = (byte)((uint)vvalue >> (8-endbit));  				if(bits >= 16)  				{  					buffer[ptr+2] = (byte)((uint)vvalue >> (16-endbit));  					if (bits >= 24)  					{  						buffer[ptr+3] = (byte)((uint)vvalue >> (24-endbit));  						if(bits >= 32)  						{  							if(endbit > 0)  								buffer[ptr+4] = (byte)((uint)vvalue >> (32-endbit));  							else  								buffer[ptr+4]=0;  						}  					}  				}  			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,write,The following statement contains a magic number: if(bits >= 8)  			{  				buffer[ptr+1] = (byte)((uint)vvalue >> (8-endbit));  				if(bits >= 16)  				{  					buffer[ptr+2] = (byte)((uint)vvalue >> (16-endbit));  					if (bits >= 24)  					{  						buffer[ptr+3] = (byte)((uint)vvalue >> (24-endbit));  						if(bits >= 32)  						{  							if(endbit > 0)  								buffer[ptr+4] = (byte)((uint)vvalue >> (32-endbit));  							else  								buffer[ptr+4]=0;  						}  					}  				}  			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,write,The following statement contains a magic number: if(bits >= 8)  			{  				buffer[ptr+1] = (byte)((uint)vvalue >> (8-endbit));  				if(bits >= 16)  				{  					buffer[ptr+2] = (byte)((uint)vvalue >> (16-endbit));  					if (bits >= 24)  					{  						buffer[ptr+3] = (byte)((uint)vvalue >> (24-endbit));  						if(bits >= 32)  						{  							if(endbit > 0)  								buffer[ptr+4] = (byte)((uint)vvalue >> (32-endbit));  							else  								buffer[ptr+4]=0;  						}  					}  				}  			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,write,The following statement contains a magic number: if(bits >= 8)  			{  				buffer[ptr+1] = (byte)((uint)vvalue >> (8-endbit));  				if(bits >= 16)  				{  					buffer[ptr+2] = (byte)((uint)vvalue >> (16-endbit));  					if (bits >= 24)  					{  						buffer[ptr+3] = (byte)((uint)vvalue >> (24-endbit));  						if(bits >= 32)  						{  							if(endbit > 0)  								buffer[ptr+4] = (byte)((uint)vvalue >> (32-endbit));  							else  								buffer[ptr+4]=0;  						}  					}  				}  			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,write,The following statement contains a magic number: if(bits >= 8)  			{  				buffer[ptr+1] = (byte)((uint)vvalue >> (8-endbit));  				if(bits >= 16)  				{  					buffer[ptr+2] = (byte)((uint)vvalue >> (16-endbit));  					if (bits >= 24)  					{  						buffer[ptr+3] = (byte)((uint)vvalue >> (24-endbit));  						if(bits >= 32)  						{  							if(endbit > 0)  								buffer[ptr+4] = (byte)((uint)vvalue >> (32-endbit));  							else  								buffer[ptr+4]=0;  						}  					}  				}  			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,write,The following statement contains a magic number: if(bits >= 8)  			{  				buffer[ptr+1] = (byte)((uint)vvalue >> (8-endbit));  				if(bits >= 16)  				{  					buffer[ptr+2] = (byte)((uint)vvalue >> (16-endbit));  					if (bits >= 24)  					{  						buffer[ptr+3] = (byte)((uint)vvalue >> (24-endbit));  						if(bits >= 32)  						{  							if(endbit > 0)  								buffer[ptr+4] = (byte)((uint)vvalue >> (32-endbit));  							else  								buffer[ptr+4]=0;  						}  					}  				}  			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,write,The following statement contains a magic number: endbyte += bits / 8;
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,write,The following statement contains a magic number: ptr += bits/8;
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,write,The following statement contains a magic number: endbit = bits & 7;
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,look,The following statement contains a magic number: if(endbyte + 4 >= storage)  			{  				if(endbyte+(bits-1)/8 >= storage)  					return (-1);  			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,look,The following statement contains a magic number: if(endbyte + 4 >= storage)  			{  				if(endbyte+(bits-1)/8 >= storage)  					return (-1);  			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,look,The following statement contains a magic number: if(bits > 8)  			{  				ret |= ((buffer[ptr+1]) & 0xff) << (8 - endbit);  				if(bits > 16)  				{ 					ret |= ((buffer[ptr+2])&0xff) << (16-endbit); 					if(bits > 24)  					{ 						ret |= ((buffer[ptr+3])&0xff) << (24-endbit); 						if((bits > 32) && (endbit != 0))  						{ 							ret |= ((buffer[ptr+4])&0xff) << (32-endbit); 						} 					} 				} 			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,look,The following statement contains a magic number: if(bits > 8)  			{  				ret |= ((buffer[ptr+1]) & 0xff) << (8 - endbit);  				if(bits > 16)  				{ 					ret |= ((buffer[ptr+2])&0xff) << (16-endbit); 					if(bits > 24)  					{ 						ret |= ((buffer[ptr+3])&0xff) << (24-endbit); 						if((bits > 32) && (endbit != 0))  						{ 							ret |= ((buffer[ptr+4])&0xff) << (32-endbit); 						} 					} 				} 			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,look,The following statement contains a magic number: if(bits > 8)  			{  				ret |= ((buffer[ptr+1]) & 0xff) << (8 - endbit);  				if(bits > 16)  				{ 					ret |= ((buffer[ptr+2])&0xff) << (16-endbit); 					if(bits > 24)  					{ 						ret |= ((buffer[ptr+3])&0xff) << (24-endbit); 						if((bits > 32) && (endbit != 0))  						{ 							ret |= ((buffer[ptr+4])&0xff) << (32-endbit); 						} 					} 				} 			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,look,The following statement contains a magic number: if(bits > 8)  			{  				ret |= ((buffer[ptr+1]) & 0xff) << (8 - endbit);  				if(bits > 16)  				{ 					ret |= ((buffer[ptr+2])&0xff) << (16-endbit); 					if(bits > 24)  					{ 						ret |= ((buffer[ptr+3])&0xff) << (24-endbit); 						if((bits > 32) && (endbit != 0))  						{ 							ret |= ((buffer[ptr+4])&0xff) << (32-endbit); 						} 					} 				} 			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,look,The following statement contains a magic number: if(bits > 8)  			{  				ret |= ((buffer[ptr+1]) & 0xff) << (8 - endbit);  				if(bits > 16)  				{ 					ret |= ((buffer[ptr+2])&0xff) << (16-endbit); 					if(bits > 24)  					{ 						ret |= ((buffer[ptr+3])&0xff) << (24-endbit); 						if((bits > 32) && (endbit != 0))  						{ 							ret |= ((buffer[ptr+4])&0xff) << (32-endbit); 						} 					} 				} 			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,look,The following statement contains a magic number: if(bits > 8)  			{  				ret |= ((buffer[ptr+1]) & 0xff) << (8 - endbit);  				if(bits > 16)  				{ 					ret |= ((buffer[ptr+2])&0xff) << (16-endbit); 					if(bits > 24)  					{ 						ret |= ((buffer[ptr+3])&0xff) << (24-endbit); 						if((bits > 32) && (endbit != 0))  						{ 							ret |= ((buffer[ptr+4])&0xff) << (32-endbit); 						} 					} 				} 			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,look,The following statement contains a magic number: if(bits > 8)  			{  				ret |= ((buffer[ptr+1]) & 0xff) << (8 - endbit);  				if(bits > 16)  				{ 					ret |= ((buffer[ptr+2])&0xff) << (16-endbit); 					if(bits > 24)  					{ 						ret |= ((buffer[ptr+3])&0xff) << (24-endbit); 						if((bits > 32) && (endbit != 0))  						{ 							ret |= ((buffer[ptr+4])&0xff) << (32-endbit); 						} 					} 				} 			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,look,The following statement contains a magic number: if(bits > 8)  			{  				ret |= ((buffer[ptr+1]) & 0xff) << (8 - endbit);  				if(bits > 16)  				{ 					ret |= ((buffer[ptr+2])&0xff) << (16-endbit); 					if(bits > 24)  					{ 						ret |= ((buffer[ptr+3])&0xff) << (24-endbit); 						if((bits > 32) && (endbit != 0))  						{ 							ret |= ((buffer[ptr+4])&0xff) << (32-endbit); 						} 					} 				} 			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,look,The following statement contains a magic number: if(bits > 8)  			{  				ret |= ((buffer[ptr+1]) & 0xff) << (8 - endbit);  				if(bits > 16)  				{ 					ret |= ((buffer[ptr+2])&0xff) << (16-endbit); 					if(bits > 24)  					{ 						ret |= ((buffer[ptr+3])&0xff) << (24-endbit); 						if((bits > 32) && (endbit != 0))  						{ 							ret |= ((buffer[ptr+4])&0xff) << (32-endbit); 						} 					} 				} 			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,look,The following statement contains a magic number: if(bits > 8)  			{  				ret |= ((buffer[ptr+1]) & 0xff) << (8 - endbit);  				if(bits > 16)  				{ 					ret |= ((buffer[ptr+2])&0xff) << (16-endbit); 					if(bits > 24)  					{ 						ret |= ((buffer[ptr+3])&0xff) << (24-endbit); 						if((bits > 32) && (endbit != 0))  						{ 							ret |= ((buffer[ptr+4])&0xff) << (32-endbit); 						} 					} 				} 			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,look,The following statement contains a magic number: if(bits > 8)  			{  				ret |= ((buffer[ptr+1]) & 0xff) << (8 - endbit);  				if(bits > 16)  				{ 					ret |= ((buffer[ptr+2])&0xff) << (16-endbit); 					if(bits > 24)  					{ 						ret |= ((buffer[ptr+3])&0xff) << (24-endbit); 						if((bits > 32) && (endbit != 0))  						{ 							ret |= ((buffer[ptr+4])&0xff) << (32-endbit); 						} 					} 				} 			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,adv,The following statement contains a magic number: ptr += bits / 8;
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,adv,The following statement contains a magic number: endbyte += bits / 8;
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,adv,The following statement contains a magic number: endbit = bits & 7;
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,adv1,The following statement contains a magic number: if(endbit > 7)  			{ 				endbit = 0; 				ptr++; 				endbyte++; 			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,read,The following statement contains a magic number: if(endbyte+4 >= storage)  			{ 				ret = -1; 				if(endbyte + (bits-1)/8 >= storage)  				{ 					ptr += bits/8; 					endbyte += bits/8; 					endbit = bits&7; 					return(ret); 				} 			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,read,The following statement contains a magic number: if(endbyte+4 >= storage)  			{ 				ret = -1; 				if(endbyte + (bits-1)/8 >= storage)  				{ 					ptr += bits/8; 					endbyte += bits/8; 					endbit = bits&7; 					return(ret); 				} 			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,read,The following statement contains a magic number: if(endbyte+4 >= storage)  			{ 				ret = -1; 				if(endbyte + (bits-1)/8 >= storage)  				{ 					ptr += bits/8; 					endbyte += bits/8; 					endbit = bits&7; 					return(ret); 				} 			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,read,The following statement contains a magic number: if(endbyte+4 >= storage)  			{ 				ret = -1; 				if(endbyte + (bits-1)/8 >= storage)  				{ 					ptr += bits/8; 					endbyte += bits/8; 					endbit = bits&7; 					return(ret); 				} 			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,read,The following statement contains a magic number: if(endbyte+4 >= storage)  			{ 				ret = -1; 				if(endbyte + (bits-1)/8 >= storage)  				{ 					ptr += bits/8; 					endbyte += bits/8; 					endbit = bits&7; 					return(ret); 				} 			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,read,The following statement contains a magic number: if(bits > 8)  			{ 				ret|=((buffer[ptr+1])&0xff)<<(8-endbit); 				if(bits > 16)  				{ 					ret|=((buffer[ptr+2])&0xff)<<(16-endbit); 					if(bits > 24)  					{ 						ret|=((buffer[ptr+3])&0xff)<<(24-endbit);   						if((bits > 32) && (endbit != 0))  						{ 							ret|=((buffer[ptr+4])&0xff)<<(32-endbit); 						} 					} 				} 			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,read,The following statement contains a magic number: if(bits > 8)  			{ 				ret|=((buffer[ptr+1])&0xff)<<(8-endbit); 				if(bits > 16)  				{ 					ret|=((buffer[ptr+2])&0xff)<<(16-endbit); 					if(bits > 24)  					{ 						ret|=((buffer[ptr+3])&0xff)<<(24-endbit);   						if((bits > 32) && (endbit != 0))  						{ 							ret|=((buffer[ptr+4])&0xff)<<(32-endbit); 						} 					} 				} 			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,read,The following statement contains a magic number: if(bits > 8)  			{ 				ret|=((buffer[ptr+1])&0xff)<<(8-endbit); 				if(bits > 16)  				{ 					ret|=((buffer[ptr+2])&0xff)<<(16-endbit); 					if(bits > 24)  					{ 						ret|=((buffer[ptr+3])&0xff)<<(24-endbit);   						if((bits > 32) && (endbit != 0))  						{ 							ret|=((buffer[ptr+4])&0xff)<<(32-endbit); 						} 					} 				} 			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,read,The following statement contains a magic number: if(bits > 8)  			{ 				ret|=((buffer[ptr+1])&0xff)<<(8-endbit); 				if(bits > 16)  				{ 					ret|=((buffer[ptr+2])&0xff)<<(16-endbit); 					if(bits > 24)  					{ 						ret|=((buffer[ptr+3])&0xff)<<(24-endbit);   						if((bits > 32) && (endbit != 0))  						{ 							ret|=((buffer[ptr+4])&0xff)<<(32-endbit); 						} 					} 				} 			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,read,The following statement contains a magic number: if(bits > 8)  			{ 				ret|=((buffer[ptr+1])&0xff)<<(8-endbit); 				if(bits > 16)  				{ 					ret|=((buffer[ptr+2])&0xff)<<(16-endbit); 					if(bits > 24)  					{ 						ret|=((buffer[ptr+3])&0xff)<<(24-endbit);   						if((bits > 32) && (endbit != 0))  						{ 							ret|=((buffer[ptr+4])&0xff)<<(32-endbit); 						} 					} 				} 			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,read,The following statement contains a magic number: if(bits > 8)  			{ 				ret|=((buffer[ptr+1])&0xff)<<(8-endbit); 				if(bits > 16)  				{ 					ret|=((buffer[ptr+2])&0xff)<<(16-endbit); 					if(bits > 24)  					{ 						ret|=((buffer[ptr+3])&0xff)<<(24-endbit);   						if((bits > 32) && (endbit != 0))  						{ 							ret|=((buffer[ptr+4])&0xff)<<(32-endbit); 						} 					} 				} 			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,read,The following statement contains a magic number: if(bits > 8)  			{ 				ret|=((buffer[ptr+1])&0xff)<<(8-endbit); 				if(bits > 16)  				{ 					ret|=((buffer[ptr+2])&0xff)<<(16-endbit); 					if(bits > 24)  					{ 						ret|=((buffer[ptr+3])&0xff)<<(24-endbit);   						if((bits > 32) && (endbit != 0))  						{ 							ret|=((buffer[ptr+4])&0xff)<<(32-endbit); 						} 					} 				} 			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,read,The following statement contains a magic number: if(bits > 8)  			{ 				ret|=((buffer[ptr+1])&0xff)<<(8-endbit); 				if(bits > 16)  				{ 					ret|=((buffer[ptr+2])&0xff)<<(16-endbit); 					if(bits > 24)  					{ 						ret|=((buffer[ptr+3])&0xff)<<(24-endbit);   						if((bits > 32) && (endbit != 0))  						{ 							ret|=((buffer[ptr+4])&0xff)<<(32-endbit); 						} 					} 				} 			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,read,The following statement contains a magic number: if(bits > 8)  			{ 				ret|=((buffer[ptr+1])&0xff)<<(8-endbit); 				if(bits > 16)  				{ 					ret|=((buffer[ptr+2])&0xff)<<(16-endbit); 					if(bits > 24)  					{ 						ret|=((buffer[ptr+3])&0xff)<<(24-endbit);   						if((bits > 32) && (endbit != 0))  						{ 							ret|=((buffer[ptr+4])&0xff)<<(32-endbit); 						} 					} 				} 			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,read,The following statement contains a magic number: if(bits > 8)  			{ 				ret|=((buffer[ptr+1])&0xff)<<(8-endbit); 				if(bits > 16)  				{ 					ret|=((buffer[ptr+2])&0xff)<<(16-endbit); 					if(bits > 24)  					{ 						ret|=((buffer[ptr+3])&0xff)<<(24-endbit);   						if((bits > 32) && (endbit != 0))  						{ 							ret|=((buffer[ptr+4])&0xff)<<(32-endbit); 						} 					} 				} 			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,read,The following statement contains a magic number: if(bits > 8)  			{ 				ret|=((buffer[ptr+1])&0xff)<<(8-endbit); 				if(bits > 16)  				{ 					ret|=((buffer[ptr+2])&0xff)<<(16-endbit); 					if(bits > 24)  					{ 						ret|=((buffer[ptr+3])&0xff)<<(24-endbit);   						if((bits > 32) && (endbit != 0))  						{ 							ret|=((buffer[ptr+4])&0xff)<<(32-endbit); 						} 					} 				} 			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,read,The following statement contains a magic number: ptr += bits/8;
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,read,The following statement contains a magic number: endbyte += bits/8;
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,read,The following statement contains a magic number: endbit = bits&7;
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,read1,The following statement contains a magic number: if(endbyte>=storage)  			{ 				ret = -1; 				endbit++; 				if(endbit > 7)  				{ 					endbit = 0; 					ptr++; 					endbyte++; 				} 				return(ret); 			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,read1,The following statement contains a magic number: if(endbit > 7)  			{ 				endbit = 0; 				ptr++; 				endbyte++; 			}
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,bytes,The following statement contains a magic number: return(endbyte+(endbit+7)/8);
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,bytes,The following statement contains a magic number: return(endbyte+(endbit+7)/8);
Magic Number,csogg,csBuffer,C:\repos\mono_csvorbis\csogg\Buffer.cs,bits,The following statement contains a magic number: return(endbyte*8+endbit);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,crc_entry,The following statement contains a magic number: uint r = index << 24;
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,crc_entry,The following statement contains a magic number: for(int i=0; i<8; i++)  			{  				if((r& 0x80000000)!=0)  				{  					r=(r << 1)^0x04c11db7; /* The same as the ethernet generator  											polynomial' although we use an  											unreflected alg and an init/final  											of 0' not 0xffffffff */  				}  				else  				{  					r <<= 1;  				}  			}
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,version,The following statement contains a magic number: return header_base[header+4]&0xff;
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,continued,The following statement contains a magic number: return (header_base[header+5]&0x01);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,bos,The following statement contains a magic number: return (header_base[header+5]&0x02);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,eos,The following statement contains a magic number: return (header_base[header+5]&0x04);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,granulepos,The following statement contains a magic number: long foo = header_base[header+13]&0xff;
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,granulepos,The following statement contains a magic number: foo = (foo<<8) | (uint)(header_base[header+12]&0xff);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,granulepos,The following statement contains a magic number: foo = (foo<<8) | (uint)(header_base[header+12]&0xff);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,granulepos,The following statement contains a magic number: foo = (foo<<8) | (uint)(header_base[header+11]&0xff);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,granulepos,The following statement contains a magic number: foo = (foo<<8) | (uint)(header_base[header+11]&0xff);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,granulepos,The following statement contains a magic number: foo = (foo<<8) | (uint)(header_base[header+10]&0xff);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,granulepos,The following statement contains a magic number: foo = (foo<<8) | (uint)(header_base[header+10]&0xff);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,granulepos,The following statement contains a magic number: foo = (foo<<8) | (uint)(header_base[header+9]&0xff);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,granulepos,The following statement contains a magic number: foo = (foo<<8) | (uint)(header_base[header+9]&0xff);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,granulepos,The following statement contains a magic number: foo = (foo<<8) | (uint)(header_base[header+8]&0xff);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,granulepos,The following statement contains a magic number: foo = (foo<<8) | (uint)(header_base[header+8]&0xff);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,granulepos,The following statement contains a magic number: foo = (foo<<8) | (uint)(header_base[header+7]&0xff);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,granulepos,The following statement contains a magic number: foo = (foo<<8) | (uint)(header_base[header+7]&0xff);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,granulepos,The following statement contains a magic number: foo = (foo<<8) | (uint)(header_base[header+6]&0xff);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,granulepos,The following statement contains a magic number: foo = (foo<<8) | (uint)(header_base[header+6]&0xff);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,serialno,The following statement contains a magic number: return (header_base[header+14]&0xff)|  				((header_base[header+15]&0xff)<<8)|  				((header_base[header+16]&0xff)<<16)|  				((header_base[header+17]&0xff)<<24);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,serialno,The following statement contains a magic number: return (header_base[header+14]&0xff)|  				((header_base[header+15]&0xff)<<8)|  				((header_base[header+16]&0xff)<<16)|  				((header_base[header+17]&0xff)<<24);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,serialno,The following statement contains a magic number: return (header_base[header+14]&0xff)|  				((header_base[header+15]&0xff)<<8)|  				((header_base[header+16]&0xff)<<16)|  				((header_base[header+17]&0xff)<<24);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,serialno,The following statement contains a magic number: return (header_base[header+14]&0xff)|  				((header_base[header+15]&0xff)<<8)|  				((header_base[header+16]&0xff)<<16)|  				((header_base[header+17]&0xff)<<24);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,serialno,The following statement contains a magic number: return (header_base[header+14]&0xff)|  				((header_base[header+15]&0xff)<<8)|  				((header_base[header+16]&0xff)<<16)|  				((header_base[header+17]&0xff)<<24);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,serialno,The following statement contains a magic number: return (header_base[header+14]&0xff)|  				((header_base[header+15]&0xff)<<8)|  				((header_base[header+16]&0xff)<<16)|  				((header_base[header+17]&0xff)<<24);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,serialno,The following statement contains a magic number: return (header_base[header+14]&0xff)|  				((header_base[header+15]&0xff)<<8)|  				((header_base[header+16]&0xff)<<16)|  				((header_base[header+17]&0xff)<<24);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,pageno,The following statement contains a magic number: return (header_base[header+18]&0xff)|  				((header_base[header+19]&0xff)<<8)|  				((header_base[header+20]&0xff)<<16)|  				((header_base[header+21]&0xff)<<24);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,pageno,The following statement contains a magic number: return (header_base[header+18]&0xff)|  				((header_base[header+19]&0xff)<<8)|  				((header_base[header+20]&0xff)<<16)|  				((header_base[header+21]&0xff)<<24);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,pageno,The following statement contains a magic number: return (header_base[header+18]&0xff)|  				((header_base[header+19]&0xff)<<8)|  				((header_base[header+20]&0xff)<<16)|  				((header_base[header+21]&0xff)<<24);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,pageno,The following statement contains a magic number: return (header_base[header+18]&0xff)|  				((header_base[header+19]&0xff)<<8)|  				((header_base[header+20]&0xff)<<16)|  				((header_base[header+21]&0xff)<<24);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,pageno,The following statement contains a magic number: return (header_base[header+18]&0xff)|  				((header_base[header+19]&0xff)<<8)|  				((header_base[header+20]&0xff)<<16)|  				((header_base[header+21]&0xff)<<24);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,pageno,The following statement contains a magic number: return (header_base[header+18]&0xff)|  				((header_base[header+19]&0xff)<<8)|  				((header_base[header+20]&0xff)<<16)|  				((header_base[header+21]&0xff)<<24);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,pageno,The following statement contains a magic number: return (header_base[header+18]&0xff)|  				((header_base[header+19]&0xff)<<8)|  				((header_base[header+20]&0xff)<<16)|  				((header_base[header+21]&0xff)<<24);
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,checksum,The following statement contains a magic number: for(int i=0;i<header_len;i++)  			{  				a = header_base[header+i] & 0xffu;  				b = (crc_reg >> 24) & 0xff;  				crc_reg = (crc_reg<<8)^crc_lookup[a^b];  				//crc_reg = (crc_reg<<8)^(uint)(crc_lookup[((crc_reg >> 24)&0xff)^(header_base[header+i]&0xff)]);  			}
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,checksum,The following statement contains a magic number: for(int i=0;i<header_len;i++)  			{  				a = header_base[header+i] & 0xffu;  				b = (crc_reg >> 24) & 0xff;  				crc_reg = (crc_reg<<8)^crc_lookup[a^b];  				//crc_reg = (crc_reg<<8)^(uint)(crc_lookup[((crc_reg >> 24)&0xff)^(header_base[header+i]&0xff)]);  			}
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,checksum,The following statement contains a magic number: for(int i=0;i<body_len;i++)  			{  				a = body_base[body+i] & 0xffu;  				b = (crc_reg >> 24) & 0xff;  				crc_reg = (crc_reg<<8)^crc_lookup[a^b];    				//crc_reg = (crc_reg<<8)^(uint)(crc_lookup[((crc_reg >> 24)&0xff)^(body_base[body+i]&0xff)]);  			}
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,checksum,The following statement contains a magic number: for(int i=0;i<body_len;i++)  			{  				a = body_base[body+i] & 0xffu;  				b = (crc_reg >> 24) & 0xff;  				crc_reg = (crc_reg<<8)^crc_lookup[a^b];    				//crc_reg = (crc_reg<<8)^(uint)(crc_lookup[((crc_reg >> 24)&0xff)^(body_base[body+i]&0xff)]);  			}
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,checksum,The following statement contains a magic number: header_base[header+22]=(byte)crc_reg/*&0xff*/;
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,checksum,The following statement contains a magic number: header_base[header+23]=(byte)(crc_reg>>8)/*&0xff*/;
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,checksum,The following statement contains a magic number: header_base[header+23]=(byte)(crc_reg>>8)/*&0xff*/;
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,checksum,The following statement contains a magic number: header_base[header+24]=(byte)(crc_reg>>16)/*&0xff*/;
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,checksum,The following statement contains a magic number: header_base[header+24]=(byte)(crc_reg>>16)/*&0xff*/;
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,checksum,The following statement contains a magic number: header_base[header+25]=(byte)(crc_reg>>24)/*&0xff*/;
Magic Number,csogg,Page,C:\repos\mono_csvorbis\csogg\Page.cs,checksum,The following statement contains a magic number: header_base[header+25]=(byte)(crc_reg>>24)/*&0xff*/;
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,init,The following statement contains a magic number: body_storage=16*1024;
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,init,The following statement contains a magic number: body_storage=16*1024;
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,init,The following statement contains a magic number: lacing_storage=1024;
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,body_expand,The following statement contains a magic number: if(body_storage<=body_fill+needed)  			{ 				body_storage+=(needed+1024); 				byte[] foo=new byte[body_storage]; 				Array.Copy(body_data' 0' foo' 0' body_data.Length); 				body_data=foo; 			}
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,lacing_expand,The following statement contains a magic number: if(lacing_storage<=lacing_fill+needed)  			{ 				lacing_storage+=(needed+32); 				int[] foo=new int[lacing_storage]; 				Array.Copy(lacing_vals' 0' foo' 0' lacing_vals.Length); 				lacing_vals=foo;  				long[] bar=new long[lacing_storage]; 				Array.Copy(granule_vals' 0' bar' 0' granule_vals.Length); 				granule_vals=bar; 			}
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,packetin,The following statement contains a magic number: int lacing_val=op.bytes/255+1;
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,packetin,The following statement contains a magic number: for(j=0;j<lacing_val-1;j++)  			{ 				lacing_vals[lacing_fill+j]=255; 				granule_vals[lacing_fill+j]=granulepos; 			}
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,packetin,The following statement contains a magic number: lacing_vals[lacing_fill+j]=(op.bytes)%255;
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,packetout,The following statement contains a magic number: { 			int size=lacing_vals[ptr]&0xff; 			int bytes=0;  			op.packet_base=body_data; 			op.packet=body_returned; 			op.e_o_s=lacing_vals[ptr]&0x200; /* last packet of the stream? */ 			op.b_o_s=lacing_vals[ptr]&0x100; /* first packet of the stream? */ 			bytes+=size;  			while(size==255)  			{ 				int val=lacing_vals[++ptr]; 				size=val&0xff; 				if((val&0x200)!=0)op.e_o_s=0x200; 				bytes+=size; 			}  			op.packetno=packetno; 			op.granulepos=granule_vals[ptr]; 			op.bytes=bytes;  			//System.out.println(this+" # body_returned="+body_returned); 			body_returned+=bytes; 			//System.out.println(this+"## body_returned="+body_returned);  			lacing_returned=ptr+1; 		}
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,pagein,The following statement contains a magic number: int segments=header_base[header+26]&0xff;
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,pagein,The following statement contains a magic number: if(_pageno!=pageno)  			{ 				int i;  				// unroll previous partial packet (if any) 				for(i=lacing_packet;i<lacing_fill;i++)  				{ 					body_fill-=lacing_vals[i]&0xff; 					//System.out.println("??"); 				} 				lacing_fill=lacing_packet;  				// make a note of dropped data in segment table 				if(pageno!=-1)  				{ 					lacing_vals[lacing_fill++]=0x400; 					lacing_packet++; 				}  				// are we a 'continued packet' page?  If so' we'll need to skip 				// some segments 				if(continued!=0)  				{ 					bos=0; 					for(;segptr<segments;segptr++)  					{ 						int val=(header_base[header+27+segptr]&0xff); 						body+=val; 						bodysize-=val; 						if(val<255)  						{ 							segptr++; 							break; 						} 					} 				} 			}
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,pagein,The following statement contains a magic number: if(_pageno!=pageno)  			{ 				int i;  				// unroll previous partial packet (if any) 				for(i=lacing_packet;i<lacing_fill;i++)  				{ 					body_fill-=lacing_vals[i]&0xff; 					//System.out.println("??"); 				} 				lacing_fill=lacing_packet;  				// make a note of dropped data in segment table 				if(pageno!=-1)  				{ 					lacing_vals[lacing_fill++]=0x400; 					lacing_packet++; 				}  				// are we a 'continued packet' page?  If so' we'll need to skip 				// some segments 				if(continued!=0)  				{ 					bos=0; 					for(;segptr<segments;segptr++)  					{ 						int val=(header_base[header+27+segptr]&0xff); 						body+=val; 						bodysize-=val; 						if(val<255)  						{ 							segptr++; 							break; 						} 					} 				} 			}
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,pagein,The following statement contains a magic number: { 			int saved=-1; 			while(segptr<segments)  			{ 				int val=(header_base[header+27+segptr]&0xff); 				lacing_vals[lacing_fill]=val; 				granule_vals[lacing_fill]=-1;        				if(bos!=0)  				{ 					lacing_vals[lacing_fill]|=0x100; 					bos=0; 				}        				if(val<255)saved=lacing_fill;        				lacing_fill++; 				segptr++;        				if(val<255)lacing_packet=lacing_fill; 			}    			/* set the granulepos on the last pcmval of the last full packet */ 			if(saved!=-1)  			{ 				granule_vals[saved]=granulepos; 			} 		}
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,pagein,The following statement contains a magic number: { 			int saved=-1; 			while(segptr<segments)  			{ 				int val=(header_base[header+27+segptr]&0xff); 				lacing_vals[lacing_fill]=val; 				granule_vals[lacing_fill]=-1;        				if(bos!=0)  				{ 					lacing_vals[lacing_fill]|=0x100; 					bos=0; 				}        				if(val<255)saved=lacing_fill;        				lacing_fill++; 				segptr++;        				if(val<255)lacing_packet=lacing_fill; 			}    			/* set the granulepos on the last pcmval of the last full packet */ 			if(saved!=-1)  			{ 				granule_vals[saved]=granulepos; 			} 		}
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,pagein,The following statement contains a magic number: { 			int saved=-1; 			while(segptr<segments)  			{ 				int val=(header_base[header+27+segptr]&0xff); 				lacing_vals[lacing_fill]=val; 				granule_vals[lacing_fill]=-1;        				if(bos!=0)  				{ 					lacing_vals[lacing_fill]|=0x100; 					bos=0; 				}        				if(val<255)saved=lacing_fill;        				lacing_fill++; 				segptr++;        				if(val<255)lacing_packet=lacing_fill; 			}    			/* set the granulepos on the last pcmval of the last full packet */ 			if(saved!=-1)  			{ 				granule_vals[saved]=granulepos; 			} 		}
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,flush,The following statement contains a magic number: int maxvals=(lacing_fill>255?255:lacing_fill);
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,flush,The following statement contains a magic number: int maxvals=(lacing_fill>255?255:lacing_fill);
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,flush,The following statement contains a magic number: if(b_o_s==0)  			{  /* 'initial header page' case */ 				granule_pos=0; 				for(vals=0;vals<maxvals;vals++)  				{ 					if((lacing_vals[vals]&0x0ff)<255)  					{ 						vals++; 						break; 					} 				} 			} 			else  			{ 				for(vals=0;vals<maxvals;vals++)  				{ 					if(acc>4096)break; 					acc+=(lacing_vals[vals]&0x0ff); 					granule_pos=granule_vals[vals]; 				} 			}
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,flush,The following statement contains a magic number: if(b_o_s==0)  			{  /* 'initial header page' case */ 				granule_pos=0; 				for(vals=0;vals<maxvals;vals++)  				{ 					if((lacing_vals[vals]&0x0ff)<255)  					{ 						vals++; 						break; 					} 				} 			} 			else  			{ 				for(vals=0;vals<maxvals;vals++)  				{ 					if(acc>4096)break; 					acc+=(lacing_vals[vals]&0x0ff); 					granule_pos=granule_vals[vals]; 				} 			}
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,flush,The following statement contains a magic number: header[4]=0x00;
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,flush,The following statement contains a magic number: header[5]=0x00;
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,flush,The following statement contains a magic number: if((lacing_vals[0]&0x100)==0)header[5]|=0x01;
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,flush,The following statement contains a magic number: if(b_o_s==0) header[5]|=0x02;
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,flush,The following statement contains a magic number: if(e_o_s!=0 && lacing_fill==vals) header[5]|=0x04;
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,flush,The following statement contains a magic number: for(i=6;i<14;i++)  			{ 				header[i]=(byte)granule_pos; 				granule_pos>>=8; 			}
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,flush,The following statement contains a magic number: for(i=6;i<14;i++)  			{ 				header[i]=(byte)granule_pos; 				granule_pos>>=8; 			}
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,flush,The following statement contains a magic number: for(i=6;i<14;i++)  			{ 				header[i]=(byte)granule_pos; 				granule_pos>>=8; 			}
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,flush,The following statement contains a magic number: { 			int _serialno=serialno; 			for(i=14;i<18;i++)  			{ 				header[i]=(byte)_serialno; 				_serialno>>=8; 			} 		}
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,flush,The following statement contains a magic number: { 			int _serialno=serialno; 			for(i=14;i<18;i++)  			{ 				header[i]=(byte)_serialno; 				_serialno>>=8; 			} 		}
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,flush,The following statement contains a magic number: { 			int _serialno=serialno; 			for(i=14;i<18;i++)  			{ 				header[i]=(byte)_serialno; 				_serialno>>=8; 			} 		}
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,flush,The following statement contains a magic number: { 			int _pageno=pageno++; 			for(i=18;i<22;i++)  			{ 				header[i]=(byte)_pageno; 				_pageno>>=8; 			} 		}
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,flush,The following statement contains a magic number: { 			int _pageno=pageno++; 			for(i=18;i<22;i++)  			{ 				header[i]=(byte)_pageno; 				_pageno>>=8; 			} 		}
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,flush,The following statement contains a magic number: { 			int _pageno=pageno++; 			for(i=18;i<22;i++)  			{ 				header[i]=(byte)_pageno; 				_pageno>>=8; 			} 		}
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,flush,The following statement contains a magic number: header[22]=0;
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,flush,The following statement contains a magic number: header[23]=0;
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,flush,The following statement contains a magic number: header[24]=0;
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,flush,The following statement contains a magic number: header[25]=0;
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,flush,The following statement contains a magic number: header[26]=(byte)vals;
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,flush,The following statement contains a magic number: for(i=0;i<vals;i++)  			{ 				header[i+27]=(byte)lacing_vals[i]; 				bytes+=(header[i+27]&0xff); 			}
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,flush,The following statement contains a magic number: for(i=0;i<vals;i++)  			{ 				header[i+27]=(byte)lacing_vals[i]; 				bytes+=(header[i+27]&0xff); 			}
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,flush,The following statement contains a magic number: og.header_len=header_fill=vals+27;
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,flush,The following statement contains a magic number: Array.Copy(lacing_vals' vals' lacing_vals' 0' lacing_fill*4);
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,flush,The following statement contains a magic number: Array.Copy(granule_vals' vals' granule_vals' 0' lacing_fill*8);
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,pageout,The following statement contains a magic number: if((e_o_s!=0&&lacing_fill!=0) ||  /* 'were done' now flush' case */ 				body_fill-body_returned> 4096 ||     /* 'page nominal size' case */ 				lacing_fill>=255 ||          /* 'segment table full' case */ 				(lacing_fill!=0&&b_o_s==0))  			{  /* 'initial header page' case */ 				return flush(og); 			}
Magic Number,csogg,StreamState,C:\repos\mono_csvorbis\csogg\StreamState.cs,pageout,The following statement contains a magic number: if((e_o_s!=0&&lacing_fill!=0) ||  /* 'were done' now flush' case */ 				body_fill-body_returned> 4096 ||     /* 'page nominal size' case */ 				lacing_fill>=255 ||          /* 'segment table full' case */ 				(lacing_fill!=0&&b_o_s==0))  			{  /* 'initial header page' case */ 				return flush(og); 			}
Magic Number,csogg,SyncState,C:\repos\mono_csvorbis\csogg\SyncState.cs,buffer,The following statement contains a magic number: if(size>storage-fill)  			{ 				// We need to extend the internal buffer 				int newsize=size+fill+4096; // an extra page to be nice 				if(data!=null)  				{ 					byte[] foo=new byte[newsize]; 					Array.Copy(data' 0' foo' 0' data.Length); 					data=foo; 				} 				else  				{ 					data=new byte[newsize]; 				} 				storage=newsize; 			}
Magic Number,csogg,SyncState,C:\repos\mono_csvorbis\csogg\SyncState.cs,pageseek,The following statement contains a magic number: if(headerbytes==0)  			{ 				int _headerbytes'i; 				if(bytes<27)return(0); // not enough for a header      				/* verify capture pattern */ 				//!!!!!!!!!!! 				if(data[page]!='O' || 					data[page+1]!='g' || 					data[page+2]!='g' || 					data[page+3]!='S')  				{ 					headerbytes=0; 					bodybytes=0;    					// search for possible capture 					next=0; 					for(int ii=0; ii<bytes-1; ii++)  					{ 						if(data[page+1+ii]=='O'){next=page+1+ii; break;} 					} 					//next=memchr(page+1''O''bytes-1); 					if(next==0) next=fill;  					returned=next; 					return(-(next-page)); 				} 				_headerbytes=(data[page+26]&0xff)+27; 				if(bytes<_headerbytes)return(0); // not enough for header + seg table      				// count up body length in the segment table      				for(i=0;i<(data[page+26]&0xff);i++)  				{ 					bodybytes+=(data[page+27+i]&0xff); 				} 				headerbytes=_headerbytes; 			}
Magic Number,csogg,SyncState,C:\repos\mono_csvorbis\csogg\SyncState.cs,pageseek,The following statement contains a magic number: if(headerbytes==0)  			{ 				int _headerbytes'i; 				if(bytes<27)return(0); // not enough for a header      				/* verify capture pattern */ 				//!!!!!!!!!!! 				if(data[page]!='O' || 					data[page+1]!='g' || 					data[page+2]!='g' || 					data[page+3]!='S')  				{ 					headerbytes=0; 					bodybytes=0;    					// search for possible capture 					next=0; 					for(int ii=0; ii<bytes-1; ii++)  					{ 						if(data[page+1+ii]=='O'){next=page+1+ii; break;} 					} 					//next=memchr(page+1''O''bytes-1); 					if(next==0) next=fill;  					returned=next; 					return(-(next-page)); 				} 				_headerbytes=(data[page+26]&0xff)+27; 				if(bytes<_headerbytes)return(0); // not enough for header + seg table      				// count up body length in the segment table      				for(i=0;i<(data[page+26]&0xff);i++)  				{ 					bodybytes+=(data[page+27+i]&0xff); 				} 				headerbytes=_headerbytes; 			}
Magic Number,csogg,SyncState,C:\repos\mono_csvorbis\csogg\SyncState.cs,pageseek,The following statement contains a magic number: if(headerbytes==0)  			{ 				int _headerbytes'i; 				if(bytes<27)return(0); // not enough for a header      				/* verify capture pattern */ 				//!!!!!!!!!!! 				if(data[page]!='O' || 					data[page+1]!='g' || 					data[page+2]!='g' || 					data[page+3]!='S')  				{ 					headerbytes=0; 					bodybytes=0;    					// search for possible capture 					next=0; 					for(int ii=0; ii<bytes-1; ii++)  					{ 						if(data[page+1+ii]=='O'){next=page+1+ii; break;} 					} 					//next=memchr(page+1''O''bytes-1); 					if(next==0) next=fill;  					returned=next; 					return(-(next-page)); 				} 				_headerbytes=(data[page+26]&0xff)+27; 				if(bytes<_headerbytes)return(0); // not enough for header + seg table      				// count up body length in the segment table      				for(i=0;i<(data[page+26]&0xff);i++)  				{ 					bodybytes+=(data[page+27+i]&0xff); 				} 				headerbytes=_headerbytes; 			}
Magic Number,csogg,SyncState,C:\repos\mono_csvorbis\csogg\SyncState.cs,pageseek,The following statement contains a magic number: if(headerbytes==0)  			{ 				int _headerbytes'i; 				if(bytes<27)return(0); // not enough for a header      				/* verify capture pattern */ 				//!!!!!!!!!!! 				if(data[page]!='O' || 					data[page+1]!='g' || 					data[page+2]!='g' || 					data[page+3]!='S')  				{ 					headerbytes=0; 					bodybytes=0;    					// search for possible capture 					next=0; 					for(int ii=0; ii<bytes-1; ii++)  					{ 						if(data[page+1+ii]=='O'){next=page+1+ii; break;} 					} 					//next=memchr(page+1''O''bytes-1); 					if(next==0) next=fill;  					returned=next; 					return(-(next-page)); 				} 				_headerbytes=(data[page+26]&0xff)+27; 				if(bytes<_headerbytes)return(0); // not enough for header + seg table      				// count up body length in the segment table      				for(i=0;i<(data[page+26]&0xff);i++)  				{ 					bodybytes+=(data[page+27+i]&0xff); 				} 				headerbytes=_headerbytes; 			}
Magic Number,csogg,SyncState,C:\repos\mono_csvorbis\csogg\SyncState.cs,pageseek,The following statement contains a magic number: if(headerbytes==0)  			{ 				int _headerbytes'i; 				if(bytes<27)return(0); // not enough for a header      				/* verify capture pattern */ 				//!!!!!!!!!!! 				if(data[page]!='O' || 					data[page+1]!='g' || 					data[page+2]!='g' || 					data[page+3]!='S')  				{ 					headerbytes=0; 					bodybytes=0;    					// search for possible capture 					next=0; 					for(int ii=0; ii<bytes-1; ii++)  					{ 						if(data[page+1+ii]=='O'){next=page+1+ii; break;} 					} 					//next=memchr(page+1''O''bytes-1); 					if(next==0) next=fill;  					returned=next; 					return(-(next-page)); 				} 				_headerbytes=(data[page+26]&0xff)+27; 				if(bytes<_headerbytes)return(0); // not enough for header + seg table      				// count up body length in the segment table      				for(i=0;i<(data[page+26]&0xff);i++)  				{ 					bodybytes+=(data[page+27+i]&0xff); 				} 				headerbytes=_headerbytes; 			}
Magic Number,csogg,SyncState,C:\repos\mono_csvorbis\csogg\SyncState.cs,pageseek,The following statement contains a magic number: if(headerbytes==0)  			{ 				int _headerbytes'i; 				if(bytes<27)return(0); // not enough for a header      				/* verify capture pattern */ 				//!!!!!!!!!!! 				if(data[page]!='O' || 					data[page+1]!='g' || 					data[page+2]!='g' || 					data[page+3]!='S')  				{ 					headerbytes=0; 					bodybytes=0;    					// search for possible capture 					next=0; 					for(int ii=0; ii<bytes-1; ii++)  					{ 						if(data[page+1+ii]=='O'){next=page+1+ii; break;} 					} 					//next=memchr(page+1''O''bytes-1); 					if(next==0) next=fill;  					returned=next; 					return(-(next-page)); 				} 				_headerbytes=(data[page+26]&0xff)+27; 				if(bytes<_headerbytes)return(0); // not enough for header + seg table      				// count up body length in the segment table      				for(i=0;i<(data[page+26]&0xff);i++)  				{ 					bodybytes+=(data[page+27+i]&0xff); 				} 				headerbytes=_headerbytes; 			}
Magic Number,csogg,SyncState,C:\repos\mono_csvorbis\csogg\SyncState.cs,pageseek,The following statement contains a magic number: if(headerbytes==0)  			{ 				int _headerbytes'i; 				if(bytes<27)return(0); // not enough for a header      				/* verify capture pattern */ 				//!!!!!!!!!!! 				if(data[page]!='O' || 					data[page+1]!='g' || 					data[page+2]!='g' || 					data[page+3]!='S')  				{ 					headerbytes=0; 					bodybytes=0;    					// search for possible capture 					next=0; 					for(int ii=0; ii<bytes-1; ii++)  					{ 						if(data[page+1+ii]=='O'){next=page+1+ii; break;} 					} 					//next=memchr(page+1''O''bytes-1); 					if(next==0) next=fill;  					returned=next; 					return(-(next-page)); 				} 				_headerbytes=(data[page+26]&0xff)+27; 				if(bytes<_headerbytes)return(0); // not enough for header + seg table      				// count up body length in the segment table      				for(i=0;i<(data[page+26]&0xff);i++)  				{ 					bodybytes+=(data[page+27+i]&0xff); 				} 				headerbytes=_headerbytes; 			}
Magic Number,csogg,SyncState,C:\repos\mono_csvorbis\csogg\SyncState.cs,pageseek,The following statement contains a magic number: lock(chksum)  			{ 				// Grab the checksum bytes' set the header field to zero      				Array.Copy(data' page+22' chksum' 0' 4); 				data[page+22]=0; 				data[page+23]=0; 				data[page+24]=0; 				data[page+25]=0;      				// set up a temp page struct and recompute the checksum 				Page log=pageseek_p; 				log.header_base=data; 				log.header=page; 				log.header_len=headerbytes;  				log.body_base=data; 				log.body=page+headerbytes; 				log.body_len=bodybytes; 				log.checksum();  				// Compare 				if(chksum[0]!=data[page+22] || 					chksum[1]!=data[page+23] || 					chksum[2]!=data[page+24] || 					chksum[3]!=data[page+25])  				{ 					// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all) 					// replace the computed checksum with the one actually read in 					Array.Copy(chksum' 0' data' page+22' 4); 					// Bad checksum. Lose sync */  					headerbytes=0; 					bodybytes=0; 					// search for possible capture 					next=0; 					for(int ii=0; ii<bytes-1; ii++)  					{ 						if(data[page+1+ii]=='O'){next=page+1+ii; break;} 					} 					//next=memchr(page+1''O''bytes-1); 					if(next==0) next=fill; 					returned=next; 					return(-(next-page)); 				} 			}
Magic Number,csogg,SyncState,C:\repos\mono_csvorbis\csogg\SyncState.cs,pageseek,The following statement contains a magic number: lock(chksum)  			{ 				// Grab the checksum bytes' set the header field to zero      				Array.Copy(data' page+22' chksum' 0' 4); 				data[page+22]=0; 				data[page+23]=0; 				data[page+24]=0; 				data[page+25]=0;      				// set up a temp page struct and recompute the checksum 				Page log=pageseek_p; 				log.header_base=data; 				log.header=page; 				log.header_len=headerbytes;  				log.body_base=data; 				log.body=page+headerbytes; 				log.body_len=bodybytes; 				log.checksum();  				// Compare 				if(chksum[0]!=data[page+22] || 					chksum[1]!=data[page+23] || 					chksum[2]!=data[page+24] || 					chksum[3]!=data[page+25])  				{ 					// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all) 					// replace the computed checksum with the one actually read in 					Array.Copy(chksum' 0' data' page+22' 4); 					// Bad checksum. Lose sync */  					headerbytes=0; 					bodybytes=0; 					// search for possible capture 					next=0; 					for(int ii=0; ii<bytes-1; ii++)  					{ 						if(data[page+1+ii]=='O'){next=page+1+ii; break;} 					} 					//next=memchr(page+1''O''bytes-1); 					if(next==0) next=fill; 					returned=next; 					return(-(next-page)); 				} 			}
Magic Number,csogg,SyncState,C:\repos\mono_csvorbis\csogg\SyncState.cs,pageseek,The following statement contains a magic number: lock(chksum)  			{ 				// Grab the checksum bytes' set the header field to zero      				Array.Copy(data' page+22' chksum' 0' 4); 				data[page+22]=0; 				data[page+23]=0; 				data[page+24]=0; 				data[page+25]=0;      				// set up a temp page struct and recompute the checksum 				Page log=pageseek_p; 				log.header_base=data; 				log.header=page; 				log.header_len=headerbytes;  				log.body_base=data; 				log.body=page+headerbytes; 				log.body_len=bodybytes; 				log.checksum();  				// Compare 				if(chksum[0]!=data[page+22] || 					chksum[1]!=data[page+23] || 					chksum[2]!=data[page+24] || 					chksum[3]!=data[page+25])  				{ 					// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all) 					// replace the computed checksum with the one actually read in 					Array.Copy(chksum' 0' data' page+22' 4); 					// Bad checksum. Lose sync */  					headerbytes=0; 					bodybytes=0; 					// search for possible capture 					next=0; 					for(int ii=0; ii<bytes-1; ii++)  					{ 						if(data[page+1+ii]=='O'){next=page+1+ii; break;} 					} 					//next=memchr(page+1''O''bytes-1); 					if(next==0) next=fill; 					returned=next; 					return(-(next-page)); 				} 			}
Magic Number,csogg,SyncState,C:\repos\mono_csvorbis\csogg\SyncState.cs,pageseek,The following statement contains a magic number: lock(chksum)  			{ 				// Grab the checksum bytes' set the header field to zero      				Array.Copy(data' page+22' chksum' 0' 4); 				data[page+22]=0; 				data[page+23]=0; 				data[page+24]=0; 				data[page+25]=0;      				// set up a temp page struct and recompute the checksum 				Page log=pageseek_p; 				log.header_base=data; 				log.header=page; 				log.header_len=headerbytes;  				log.body_base=data; 				log.body=page+headerbytes; 				log.body_len=bodybytes; 				log.checksum();  				// Compare 				if(chksum[0]!=data[page+22] || 					chksum[1]!=data[page+23] || 					chksum[2]!=data[page+24] || 					chksum[3]!=data[page+25])  				{ 					// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all) 					// replace the computed checksum with the one actually read in 					Array.Copy(chksum' 0' data' page+22' 4); 					// Bad checksum. Lose sync */  					headerbytes=0; 					bodybytes=0; 					// search for possible capture 					next=0; 					for(int ii=0; ii<bytes-1; ii++)  					{ 						if(data[page+1+ii]=='O'){next=page+1+ii; break;} 					} 					//next=memchr(page+1''O''bytes-1); 					if(next==0) next=fill; 					returned=next; 					return(-(next-page)); 				} 			}
Magic Number,csogg,SyncState,C:\repos\mono_csvorbis\csogg\SyncState.cs,pageseek,The following statement contains a magic number: lock(chksum)  			{ 				// Grab the checksum bytes' set the header field to zero      				Array.Copy(data' page+22' chksum' 0' 4); 				data[page+22]=0; 				data[page+23]=0; 				data[page+24]=0; 				data[page+25]=0;      				// set up a temp page struct and recompute the checksum 				Page log=pageseek_p; 				log.header_base=data; 				log.header=page; 				log.header_len=headerbytes;  				log.body_base=data; 				log.body=page+headerbytes; 				log.body_len=bodybytes; 				log.checksum();  				// Compare 				if(chksum[0]!=data[page+22] || 					chksum[1]!=data[page+23] || 					chksum[2]!=data[page+24] || 					chksum[3]!=data[page+25])  				{ 					// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all) 					// replace the computed checksum with the one actually read in 					Array.Copy(chksum' 0' data' page+22' 4); 					// Bad checksum. Lose sync */  					headerbytes=0; 					bodybytes=0; 					// search for possible capture 					next=0; 					for(int ii=0; ii<bytes-1; ii++)  					{ 						if(data[page+1+ii]=='O'){next=page+1+ii; break;} 					} 					//next=memchr(page+1''O''bytes-1); 					if(next==0) next=fill; 					returned=next; 					return(-(next-page)); 				} 			}
Magic Number,csogg,SyncState,C:\repos\mono_csvorbis\csogg\SyncState.cs,pageseek,The following statement contains a magic number: lock(chksum)  			{ 				// Grab the checksum bytes' set the header field to zero      				Array.Copy(data' page+22' chksum' 0' 4); 				data[page+22]=0; 				data[page+23]=0; 				data[page+24]=0; 				data[page+25]=0;      				// set up a temp page struct and recompute the checksum 				Page log=pageseek_p; 				log.header_base=data; 				log.header=page; 				log.header_len=headerbytes;  				log.body_base=data; 				log.body=page+headerbytes; 				log.body_len=bodybytes; 				log.checksum();  				// Compare 				if(chksum[0]!=data[page+22] || 					chksum[1]!=data[page+23] || 					chksum[2]!=data[page+24] || 					chksum[3]!=data[page+25])  				{ 					// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all) 					// replace the computed checksum with the one actually read in 					Array.Copy(chksum' 0' data' page+22' 4); 					// Bad checksum. Lose sync */  					headerbytes=0; 					bodybytes=0; 					// search for possible capture 					next=0; 					for(int ii=0; ii<bytes-1; ii++)  					{ 						if(data[page+1+ii]=='O'){next=page+1+ii; break;} 					} 					//next=memchr(page+1''O''bytes-1); 					if(next==0) next=fill; 					returned=next; 					return(-(next-page)); 				} 			}
Magic Number,csogg,SyncState,C:\repos\mono_csvorbis\csogg\SyncState.cs,pageseek,The following statement contains a magic number: lock(chksum)  			{ 				// Grab the checksum bytes' set the header field to zero      				Array.Copy(data' page+22' chksum' 0' 4); 				data[page+22]=0; 				data[page+23]=0; 				data[page+24]=0; 				data[page+25]=0;      				// set up a temp page struct and recompute the checksum 				Page log=pageseek_p; 				log.header_base=data; 				log.header=page; 				log.header_len=headerbytes;  				log.body_base=data; 				log.body=page+headerbytes; 				log.body_len=bodybytes; 				log.checksum();  				// Compare 				if(chksum[0]!=data[page+22] || 					chksum[1]!=data[page+23] || 					chksum[2]!=data[page+24] || 					chksum[3]!=data[page+25])  				{ 					// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all) 					// replace the computed checksum with the one actually read in 					Array.Copy(chksum' 0' data' page+22' 4); 					// Bad checksum. Lose sync */  					headerbytes=0; 					bodybytes=0; 					// search for possible capture 					next=0; 					for(int ii=0; ii<bytes-1; ii++)  					{ 						if(data[page+1+ii]=='O'){next=page+1+ii; break;} 					} 					//next=memchr(page+1''O''bytes-1); 					if(next==0) next=fill; 					returned=next; 					return(-(next-page)); 				} 			}
Magic Number,csogg,SyncState,C:\repos\mono_csvorbis\csogg\SyncState.cs,pageseek,The following statement contains a magic number: lock(chksum)  			{ 				// Grab the checksum bytes' set the header field to zero      				Array.Copy(data' page+22' chksum' 0' 4); 				data[page+22]=0; 				data[page+23]=0; 				data[page+24]=0; 				data[page+25]=0;      				// set up a temp page struct and recompute the checksum 				Page log=pageseek_p; 				log.header_base=data; 				log.header=page; 				log.header_len=headerbytes;  				log.body_base=data; 				log.body=page+headerbytes; 				log.body_len=bodybytes; 				log.checksum();  				// Compare 				if(chksum[0]!=data[page+22] || 					chksum[1]!=data[page+23] || 					chksum[2]!=data[page+24] || 					chksum[3]!=data[page+25])  				{ 					// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all) 					// replace the computed checksum with the one actually read in 					Array.Copy(chksum' 0' data' page+22' 4); 					// Bad checksum. Lose sync */  					headerbytes=0; 					bodybytes=0; 					// search for possible capture 					next=0; 					for(int ii=0; ii<bytes-1; ii++)  					{ 						if(data[page+1+ii]=='O'){next=page+1+ii; break;} 					} 					//next=memchr(page+1''O''bytes-1); 					if(next==0) next=fill; 					returned=next; 					return(-(next-page)); 				} 			}
Magic Number,csogg,SyncState,C:\repos\mono_csvorbis\csogg\SyncState.cs,pageseek,The following statement contains a magic number: lock(chksum)  			{ 				// Grab the checksum bytes' set the header field to zero      				Array.Copy(data' page+22' chksum' 0' 4); 				data[page+22]=0; 				data[page+23]=0; 				data[page+24]=0; 				data[page+25]=0;      				// set up a temp page struct and recompute the checksum 				Page log=pageseek_p; 				log.header_base=data; 				log.header=page; 				log.header_len=headerbytes;  				log.body_base=data; 				log.body=page+headerbytes; 				log.body_len=bodybytes; 				log.checksum();  				// Compare 				if(chksum[0]!=data[page+22] || 					chksum[1]!=data[page+23] || 					chksum[2]!=data[page+24] || 					chksum[3]!=data[page+25])  				{ 					// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all) 					// replace the computed checksum with the one actually read in 					Array.Copy(chksum' 0' data' page+22' 4); 					// Bad checksum. Lose sync */  					headerbytes=0; 					bodybytes=0; 					// search for possible capture 					next=0; 					for(int ii=0; ii<bytes-1; ii++)  					{ 						if(data[page+1+ii]=='O'){next=page+1+ii; break;} 					} 					//next=memchr(page+1''O''bytes-1); 					if(next==0) next=fill; 					returned=next; 					return(-(next-page)); 				} 			}
Magic Number,csogg,SyncState,C:\repos\mono_csvorbis\csogg\SyncState.cs,pageseek,The following statement contains a magic number: lock(chksum)  			{ 				// Grab the checksum bytes' set the header field to zero      				Array.Copy(data' page+22' chksum' 0' 4); 				data[page+22]=0; 				data[page+23]=0; 				data[page+24]=0; 				data[page+25]=0;      				// set up a temp page struct and recompute the checksum 				Page log=pageseek_p; 				log.header_base=data; 				log.header=page; 				log.header_len=headerbytes;  				log.body_base=data; 				log.body=page+headerbytes; 				log.body_len=bodybytes; 				log.checksum();  				// Compare 				if(chksum[0]!=data[page+22] || 					chksum[1]!=data[page+23] || 					chksum[2]!=data[page+24] || 					chksum[3]!=data[page+25])  				{ 					// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all) 					// replace the computed checksum with the one actually read in 					Array.Copy(chksum' 0' data' page+22' 4); 					// Bad checksum. Lose sync */  					headerbytes=0; 					bodybytes=0; 					// search for possible capture 					next=0; 					for(int ii=0; ii<bytes-1; ii++)  					{ 						if(data[page+1+ii]=='O'){next=page+1+ii; break;} 					} 					//next=memchr(page+1''O''bytes-1); 					if(next==0) next=fill; 					returned=next; 					return(-(next-page)); 				} 			}
Magic Number,csogg,SyncState,C:\repos\mono_csvorbis\csogg\SyncState.cs,pageseek,The following statement contains a magic number: lock(chksum)  			{ 				// Grab the checksum bytes' set the header field to zero      				Array.Copy(data' page+22' chksum' 0' 4); 				data[page+22]=0; 				data[page+23]=0; 				data[page+24]=0; 				data[page+25]=0;      				// set up a temp page struct and recompute the checksum 				Page log=pageseek_p; 				log.header_base=data; 				log.header=page; 				log.header_len=headerbytes;  				log.body_base=data; 				log.body=page+headerbytes; 				log.body_len=bodybytes; 				log.checksum();  				// Compare 				if(chksum[0]!=data[page+22] || 					chksum[1]!=data[page+23] || 					chksum[2]!=data[page+24] || 					chksum[3]!=data[page+25])  				{ 					// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all) 					// replace the computed checksum with the one actually read in 					Array.Copy(chksum' 0' data' page+22' 4); 					// Bad checksum. Lose sync */  					headerbytes=0; 					bodybytes=0; 					// search for possible capture 					next=0; 					for(int ii=0; ii<bytes-1; ii++)  					{ 						if(data[page+1+ii]=='O'){next=page+1+ii; break;} 					} 					//next=memchr(page+1''O''bytes-1); 					if(next==0) next=fill; 					returned=next; 					return(-(next-page)); 				} 			}
Magic Number,csogg,SyncState,C:\repos\mono_csvorbis\csogg\SyncState.cs,pageseek,The following statement contains a magic number: lock(chksum)  			{ 				// Grab the checksum bytes' set the header field to zero      				Array.Copy(data' page+22' chksum' 0' 4); 				data[page+22]=0; 				data[page+23]=0; 				data[page+24]=0; 				data[page+25]=0;      				// set up a temp page struct and recompute the checksum 				Page log=pageseek_p; 				log.header_base=data; 				log.header=page; 				log.header_len=headerbytes;  				log.body_base=data; 				log.body=page+headerbytes; 				log.body_len=bodybytes; 				log.checksum();  				// Compare 				if(chksum[0]!=data[page+22] || 					chksum[1]!=data[page+23] || 					chksum[2]!=data[page+24] || 					chksum[3]!=data[page+25])  				{ 					// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all) 					// replace the computed checksum with the one actually read in 					Array.Copy(chksum' 0' data' page+22' 4); 					// Bad checksum. Lose sync */  					headerbytes=0; 					bodybytes=0; 					// search for possible capture 					next=0; 					for(int ii=0; ii<bytes-1; ii++)  					{ 						if(data[page+1+ii]=='O'){next=page+1+ii; break;} 					} 					//next=memchr(page+1''O''bytes-1); 					if(next==0) next=fill; 					returned=next; 					return(-(next-page)); 				} 			}
Magic Number,csogg,SyncState,C:\repos\mono_csvorbis\csogg\SyncState.cs,pageseek,The following statement contains a magic number: lock(chksum)  			{ 				// Grab the checksum bytes' set the header field to zero      				Array.Copy(data' page+22' chksum' 0' 4); 				data[page+22]=0; 				data[page+23]=0; 				data[page+24]=0; 				data[page+25]=0;      				// set up a temp page struct and recompute the checksum 				Page log=pageseek_p; 				log.header_base=data; 				log.header=page; 				log.header_len=headerbytes;  				log.body_base=data; 				log.body=page+headerbytes; 				log.body_len=bodybytes; 				log.checksum();  				// Compare 				if(chksum[0]!=data[page+22] || 					chksum[1]!=data[page+23] || 					chksum[2]!=data[page+24] || 					chksum[3]!=data[page+25])  				{ 					// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all) 					// replace the computed checksum with the one actually read in 					Array.Copy(chksum' 0' data' page+22' 4); 					// Bad checksum. Lose sync */  					headerbytes=0; 					bodybytes=0; 					// search for possible capture 					next=0; 					for(int ii=0; ii<bytes-1; ii++)  					{ 						if(data[page+1+ii]=='O'){next=page+1+ii; break;} 					} 					//next=memchr(page+1''O''bytes-1); 					if(next==0) next=fill; 					returned=next; 					return(-(next-page)); 				} 			}
Magic Number,csogg,SyncState,C:\repos\mono_csvorbis\csogg\SyncState.cs,pageseek,The following statement contains a magic number: lock(chksum)  			{ 				// Grab the checksum bytes' set the header field to zero      				Array.Copy(data' page+22' chksum' 0' 4); 				data[page+22]=0; 				data[page+23]=0; 				data[page+24]=0; 				data[page+25]=0;      				// set up a temp page struct and recompute the checksum 				Page log=pageseek_p; 				log.header_base=data; 				log.header=page; 				log.header_len=headerbytes;  				log.body_base=data; 				log.body=page+headerbytes; 				log.body_len=bodybytes; 				log.checksum();  				// Compare 				if(chksum[0]!=data[page+22] || 					chksum[1]!=data[page+23] || 					chksum[2]!=data[page+24] || 					chksum[3]!=data[page+25])  				{ 					// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all) 					// replace the computed checksum with the one actually read in 					Array.Copy(chksum' 0' data' page+22' 4); 					// Bad checksum. Lose sync */  					headerbytes=0; 					bodybytes=0; 					// search for possible capture 					next=0; 					for(int ii=0; ii<bytes-1; ii++)  					{ 						if(data[page+1+ii]=='O'){next=page+1+ii; break;} 					} 					//next=memchr(page+1''O''bytes-1); 					if(next==0) next=fill; 					returned=next; 					return(-(next-page)); 				} 			}
