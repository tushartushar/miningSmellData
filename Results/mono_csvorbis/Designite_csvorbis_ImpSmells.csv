Implementation smell,Namespace,Class,File,Method,Description
Long Method,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradfg,The method has 313 lines of code.
Long Method,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The method has 324 lines of code.
Long Method,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,synthesis_blockin,The method has 124 lines of code.
Long Method,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,look,The method has 113 lines of code.
Long Method,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,inverse1,The method has 119 lines of code.
Long Method,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,unpack_books,The method has 150 lines of code.
Long Method,csvorbis,Mapping0,C:\repos\mono_csvorbis\csvorbis\Mapping0.cs,inverse,The method has 171 lines of code.
Long Method,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,pack,The method has 134 lines of code.
Long Method,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,unpack,The method has 150 lines of code.
Long Method,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,process_packet,The method has 124 lines of code.
Long Method,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,pcm_seek,The method has 115 lines of code.
Long Method,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The method has 129 lines of code.
Complex Method,csvorbis,Block,C:\repos\mono_csvorbis\csvorbis\Block.cs,synthesis,Cyclomatic complexity of the method is 8
Complex Method,csvorbis,CodeBook,C:\repos\mono_csvorbis\csvorbis\CodeBook.cs,best,Cyclomatic complexity of the method is 14
Complex Method,csvorbis,CodeBook,C:\repos\mono_csvorbis\csvorbis\CodeBook.cs,make_words,Cyclomatic complexity of the method is 11
Complex Method,csvorbis,CodeBook,C:\repos\mono_csvorbis\csvorbis\CodeBook.cs,make_decode_tree,Cyclomatic complexity of the method is 12
Complex Method,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,drfti1,Cyclomatic complexity of the method is 10
Complex Method,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf2,Cyclomatic complexity of the method is 8
Complex Method,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf4,Cyclomatic complexity of the method is 8
Complex Method,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradfg,Cyclomatic complexity of the method is 34
Complex Method,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,drftf1,Cyclomatic complexity of the method is 8
Complex Method,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb2,Cyclomatic complexity of the method is 8
Complex Method,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb4,Cyclomatic complexity of the method is 8
Complex Method,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,Cyclomatic complexity of the method is 42
Complex Method,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,drftb1,Cyclomatic complexity of the method is 9
Complex Method,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,synthesis_blockin,Cyclomatic complexity of the method is 13
Complex Method,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,inverse1,Cyclomatic complexity of the method is 9
Complex Method,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,pack,Cyclomatic complexity of the method is 8
Complex Method,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,unpack,Cyclomatic complexity of the method is 12
Complex Method,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,look,Cyclomatic complexity of the method is 14
Complex Method,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,inverse1,Cyclomatic complexity of the method is 14
Complex Method,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,clear,Cyclomatic complexity of the method is 9
Complex Method,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,unpack_books,Cyclomatic complexity of the method is 28
Complex Method,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,pack_books,Cyclomatic complexity of the method is 8
Complex Method,csvorbis,Lpc,C:\repos\mono_csvorbis\csvorbis\Lpc.cs,lpc_from_data,Cyclomatic complexity of the method is 9
Complex Method,csvorbis,Mapping0,C:\repos\mono_csvorbis\csvorbis\Mapping0.cs,unpack,Cyclomatic complexity of the method is 13
Complex Method,csvorbis,Residue0,C:\repos\mono_csvorbis\csvorbis\Residue0.cs,look,Cyclomatic complexity of the method is 8
Complex Method,csvorbis,Residue0,C:\repos\mono_csvorbis\csvorbis\Residue0.cs,_01inverse,Cyclomatic complexity of the method is 15
Complex Method,csvorbis,Residue0,C:\repos\mono_csvorbis\csvorbis\Residue0.cs,_2inverse,Cyclomatic complexity of the method is 10
Complex Method,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,pack,Cyclomatic complexity of the method is 9
Complex Method,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,bisect_forward_serialno,Cyclomatic complexity of the method is 8
Complex Method,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,fetch_headers,Cyclomatic complexity of the method is 12
Complex Method,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,process_packet,Cyclomatic complexity of the method is 16
Complex Method,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,pcm_seek,Cyclomatic complexity of the method is 15
Complex Method,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,Cyclomatic complexity of the method is 11
Long Parameter List,csvorbis,CodeBook,C:\repos\mono_csvorbis\csvorbis\CodeBook.cs,decodevv_add,The method has 5 parameters. Parameters: a' offset' ch' b' n
Long Parameter List,csvorbis,CodeBook,C:\repos\mono_csvorbis\csvorbis\CodeBook.cs,decodevs,The method has 5 parameters. Parameters: a' index' b' step' addmul
Long Parameter List,csvorbis,CodeBook,C:\repos\mono_csvorbis\csvorbis\CodeBook.cs,dist,The method has 5 parameters. Parameters: el' rref' index' b' step
Long Parameter List,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf2,The method has 6 parameters. Parameters: ido' l1' cc' ch' wa1' index
Long Parameter List,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf4,The method has 10 parameters. Parameters: ido' l1' cc' ch' wa1' index1' wa2' index2' wa3' index3
Long Parameter List,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradfg,The method has 11 parameters. Parameters: ido' ip' l1' idl1' cc' c1' c2' ch' ch2' wa' index
Long Parameter List,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,drftf1,The method has 5 parameters. Parameters: n' c' ch' wa' ifac
Long Parameter List,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb2,The method has 6 parameters. Parameters: ido' l1' cc' ch' wa1' index
Long Parameter List,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb3,The method has 8 parameters. Parameters: ido' l1' cc' ch' wa1' index1' wa2' index2
Long Parameter List,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb4,The method has 10 parameters. Parameters: ido' l1' cc' ch' wa1' index1' wa2' index2' wa3' index3
Long Parameter List,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The method has 11 parameters. Parameters: ido' ip' l1' idl1' cc' c1' c2' ch' ch2' wa' index
Long Parameter List,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,drftb1,The method has 6 parameters. Parameters: n' c' ch' wa' index' ifac
Long Parameter List,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,forward,The method has 5 parameters. Parameters: vb' i' fin' fout' vs
Long Parameter List,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,lpc_to_curve,The method has 6 parameters. Parameters: curve' lpc' amp' l' name' frameno
Long Parameter List,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,forward,The method has 5 parameters. Parameters: vb' i' fin' fout' vs
Long Parameter List,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,render_point,The method has 5 parameters. Parameters: x0' x1' y0' y1' x
Long Parameter List,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,render_line,The method has 5 parameters. Parameters: x0' x1' y0' y1' d
Long Parameter List,csvorbis,FuncFloor,C:\repos\mono_csvorbis\csvorbis\FuncFloor.cs,forward,The method has 5 parameters. Parameters: vb' i' fin' fout' vs
Long Parameter List,csvorbis,FuncResidue,C:\repos\mono_csvorbis\csvorbis\FuncResidue.cs,inverse,The method has 5 parameters. Parameters: vb' vl' fin' nonzero' ch
Long Parameter List,csvorbis,Lsp,C:\repos\mono_csvorbis\csvorbis\Lsp.cs,lsp_to_curve,The method has 8 parameters. Parameters: curve' map' n' ln' lsp' m' amp' ampoffset
Long Parameter List,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,mdct_kernel,The method has 6 parameters. Parameters: x' w' n' n2' n4' n8
Long Parameter List,csvorbis,Residue0,C:\repos\mono_csvorbis\csvorbis\Residue0.cs,_01inverse,The method has 5 parameters. Parameters: vb' vl' fin' ch' decodepart
Long Parameter List,csvorbis,Residue0,C:\repos\mono_csvorbis\csvorbis\Residue0.cs,inverse,The method has 5 parameters. Parameters: vb' vl' fin' nonzero' ch
Long Parameter List,csvorbis,Residue1,C:\repos\mono_csvorbis\csvorbis\Residue1.cs,inverse,The method has 5 parameters. Parameters: vb' vl' fin' nonzero' ch
Long Parameter List,csvorbis,Residue2,C:\repos\mono_csvorbis\csvorbis\Residue2.cs,inverse,The method has 5 parameters. Parameters: vb' vl' fin' nonzero' ch
Long Parameter List,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,StaticCodeBook,The method has 11 parameters. Parameters: dim' entries' lengthlist' maptype' q_min' q_delta' q_quant' q_sequencep' quantlist' nearest_tree' thresh_tree
Long Parameter List,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,bisect_forward_serialno,The method has 5 parameters. Parameters: begin' searched' end' currentno' m
Long Parameter List,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The method has 6 parameters. Parameters: buffer' length' bigendianp' word' sgned' bitstream
Complex Conditional,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,unpack,The conditional expression  "(info.order<1)|| 				(info.rate<1)|| 				(info.barkmap<1)|| 				(info.numbooks<1)"  is complex.
Complex Conditional,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,unpack_info,The conditional expression  "(rate<1) || 				(channels<1)|| 				(blocksizes[0]<8)|| 				(blocksizes[1]<blocksizes[0]) || 				(opb.read(1)!=1)"  is complex.
Complex Conditional,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,synthesis_headerin,The conditional expression  "buffer[0]!='v' || buffer[1]!='o' || buffer[2]!='r' || 					buffer[3]!='b' || buffer[4]!='i' || buffer[5]!='s'"  is complex.
Complex Conditional,csvorbis,Mapping0,C:\repos\mono_csvorbis\csvorbis\Mapping0.cs,unpack,The conditional expression  "testM<0 || 						testA<0 || 						testM==testA || 						testM>=vi.channels || 						testA>=vi.channels"  is complex.
Magic Number,csvorbis,Block,C:\repos\mono_csvorbis\csvorbis\Block.cs,synthesis,The following statement contains a magic number: sequence=op.packetno-3;
Magic Number,csvorbis,CodeBook,C:\repos\mono_csvorbis\csvorbis\CodeBook.cs,decodev_add,The following statement contains a magic number: if(dim>8)  			{  				for(i=0;i<n;)  				{  					entry = decode(b);  					if(entry==-1)return(-1);  					t=entry*dim;  					for(j=0;j<dim;)  					{  						a[offset+(i++)]+=valuelist[t+(j++)];  					}  				}  			}  			else  			{  				for(i=0;i<n;)  				{  					entry=decode(b);  					if(entry==-1)return(-1);  					t=entry*dim;  					j=0;  					for(k=0; k < dim; k++)  					{  						a[offset+(i++)]+=valuelist[t+(j++)];  					}  				}  			}
Magic Number,csvorbis,CodeBook,C:\repos\mono_csvorbis\csvorbis\CodeBook.cs,best,The following statement contains a magic number: if(nt!=null)  			{  				// optimized using the decision tree  				while(true)  				{  					double cc=0.0;  					int p=nt.p[ptr];  					int q=nt.q[ptr];  					for(int k=0'o=0;k<dim;k++'o+=step)  					{  						cc+=(valuelist[p+k]-valuelist[q+k])*  							(a[o]-(valuelist[p+k]+valuelist[q+k])*.5);  					}  					if(cc>0.0)  					{ // in A  						ptr= -nt.ptr0[ptr];  					}  					else  					{     // in B  						ptr= -nt.ptr1[ptr];  					}  					if(ptr<=0)break;  				}  				return(-ptr);  			}
Magic Number,csvorbis,CodeBook,C:\repos\mono_csvorbis\csvorbis\CodeBook.cs,make_words,The following statement contains a magic number: int[] marker=new int[33];
Magic Number,csvorbis,CodeBook,C:\repos\mono_csvorbis\csvorbis\CodeBook.cs,make_words,The following statement contains a magic number: for(int i=0;i<n;i++)  			{  				int length=l[i];  				if(length>0)  				{  					int entry=marker[length];          					// when we claim a node for an entry' we also claim the nodes  					// below it (pruning off the imagined tree that may have dangled  					// from it) as well as blocking the use of any nodes directly  					// above for leaves          					// update ourself  					if(length<32 && ((uint)entry>>length)!=0)  					{  						// error condition; the lengths must specify an overpopulated tree  						//free(r);  						return(null);  					}  					r[i]=entry;        					// Look to see if the next shorter marker points to the node  					// above. if so' update it and repeat.  				{  					for(int j=length;j>0;j--)  					{  						if((marker[j]&1)!=0)  						{  							// have to jump branches  							if(j==1)marker[1]++;  							else marker[j]=marker[j-1]<<1;  							break; // invariant says next upper marker would already  							// have been moved if it was on the same path  						}  						marker[j]++;  					}  				}          					// prune the tree; the implicit invariant says all the longer  					// markers were dangling from our just-taken node.  Dangle them  					// from our *new* node.  					for(int j=length+1;j<33;j++)  					{  						if(((uint)marker[j]>>1) == entry)  						{  							entry=marker[j];  							marker[j]=marker[j-1]<<1;  						}  						else  						{  							break;  						}  					}      				}  			}
Magic Number,csvorbis,CodeBook,C:\repos\mono_csvorbis\csvorbis\CodeBook.cs,make_words,The following statement contains a magic number: for(int i=0;i<n;i++)  			{  				int length=l[i];  				if(length>0)  				{  					int entry=marker[length];          					// when we claim a node for an entry' we also claim the nodes  					// below it (pruning off the imagined tree that may have dangled  					// from it) as well as blocking the use of any nodes directly  					// above for leaves          					// update ourself  					if(length<32 && ((uint)entry>>length)!=0)  					{  						// error condition; the lengths must specify an overpopulated tree  						//free(r);  						return(null);  					}  					r[i]=entry;        					// Look to see if the next shorter marker points to the node  					// above. if so' update it and repeat.  				{  					for(int j=length;j>0;j--)  					{  						if((marker[j]&1)!=0)  						{  							// have to jump branches  							if(j==1)marker[1]++;  							else marker[j]=marker[j-1]<<1;  							break; // invariant says next upper marker would already  							// have been moved if it was on the same path  						}  						marker[j]++;  					}  				}          					// prune the tree; the implicit invariant says all the longer  					// markers were dangling from our just-taken node.  Dangle them  					// from our *new* node.  					for(int j=length+1;j<33;j++)  					{  						if(((uint)marker[j]>>1) == entry)  						{  							entry=marker[j];  							marker[j]=marker[j-1]<<1;  						}  						else  						{  							break;  						}  					}      				}  			}
Magic Number,csvorbis,CodeBook,C:\repos\mono_csvorbis\csvorbis\CodeBook.cs,make_decode_tree,The following statement contains a magic number: int[] ptr0=t.ptr0=new int[entries*2];
Magic Number,csvorbis,CodeBook,C:\repos\mono_csvorbis\csvorbis\CodeBook.cs,make_decode_tree,The following statement contains a magic number: int[] ptr1=t.ptr1=new int[entries*2];
Magic Number,csvorbis,CodeBook,C:\repos\mono_csvorbis\csvorbis\CodeBook.cs,make_decode_tree,The following statement contains a magic number: t.aux=entries*2;
Magic Number,csvorbis,CodeBook,C:\repos\mono_csvorbis\csvorbis\CodeBook.cs,make_decode_tree,The following statement contains a magic number: t.tabn = ilog(entries)-4;
Magic Number,csvorbis,CodeBook,C:\repos\mono_csvorbis\csvorbis\CodeBook.cs,make_decode_tree,The following statement contains a magic number: if(t.tabn<5)t.tabn=5;
Magic Number,csvorbis,CodeBook,C:\repos\mono_csvorbis\csvorbis\CodeBook.cs,make_decode_tree,The following statement contains a magic number: if(t.tabn<5)t.tabn=5;
Magic Number,csvorbis,Comment,C:\repos\mono_csvorbis\csvorbis\Comment.cs,add,The following statement contains a magic number: byte[][] foo=new byte[comments+2][];
Magic Number,csvorbis,Comment,C:\repos\mono_csvorbis\csvorbis\Comment.cs,add,The following statement contains a magic number: int[] goo=new int[comments+2];
Magic Number,csvorbis,Comment,C:\repos\mono_csvorbis\csvorbis\Comment.cs,query,The following statement contains a magic number: byte[] fulltag = new byte[taglen+2];
Magic Number,csvorbis,Comment,C:\repos\mono_csvorbis\csvorbis\Comment.cs,unpack,The following statement contains a magic number: int vendorlen=opb.read(32);
Magic Number,csvorbis,Comment,C:\repos\mono_csvorbis\csvorbis\Comment.cs,unpack,The following statement contains a magic number: comments=opb.read(32);
Magic Number,csvorbis,Comment,C:\repos\mono_csvorbis\csvorbis\Comment.cs,unpack,The following statement contains a magic number: for(int i=0;i<comments;i++)  			{ 				int len=opb.read(32); 				if(len<0)  				{ 					//goto err_out; 					clear(); 					return(-1); 				} 				comment_lengths[i]=len; 				user_comments[i]=new byte[len+1]; 				opb.read(user_comments[i]' len); 			}
Magic Number,csvorbis,Comment,C:\repos\mono_csvorbis\csvorbis\Comment.cs,pack,The following statement contains a magic number: opb.write(0x03'8);
Magic Number,csvorbis,Comment,C:\repos\mono_csvorbis\csvorbis\Comment.cs,pack,The following statement contains a magic number: opb.write(temp.Length'32);
Magic Number,csvorbis,Comment,C:\repos\mono_csvorbis\csvorbis\Comment.cs,pack,The following statement contains a magic number: opb.write(comments'32);
Magic Number,csvorbis,Comment,C:\repos\mono_csvorbis\csvorbis\Comment.cs,pack,The following statement contains a magic number: if(comments!=0)  			{ 				for(int i=0;i<comments;i++)  				{ 					if(user_comments[i]!=null)  					{ 						opb.write(comment_lengths[i]'32); 						opb.write(user_comments[i]); 					} 					else  					{ 						opb.write(0'32); 					} 				} 			}
Magic Number,csvorbis,Comment,C:\repos\mono_csvorbis\csvorbis\Comment.cs,pack,The following statement contains a magic number: if(comments!=0)  			{ 				for(int i=0;i<comments;i++)  				{ 					if(user_comments[i]!=null)  					{ 						opb.write(comment_lengths[i]'32); 						opb.write(user_comments[i]); 					} 					else  					{ 						opb.write(0'32); 					} 				} 			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,init,The following statement contains a magic number: trigcache=new float[3*n];
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,init,The following statement contains a magic number: splitcache=new int[32];
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,drfti1,The following statement contains a magic number: if (j < 4)  				ntry=ntryh[j];  			else  				ntry+=2;
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,drfti1,The following statement contains a magic number: if (j < 4)  				ntry=ntryh[j];  			else  				ntry+=2;
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,drfti1,The following statement contains a magic number: if(ntry!=2) goto L107;
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,drfti1,The following statement contains a magic number: ifac[2] = 2;
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,drfti1,The following statement contains a magic number: ifac[2] = 2;
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,drfti1,The following statement contains a magic number: for (k1=0;k1<nfm1;k1++)  			{  				ip=ifac[k1+2];  				ld=0;  				l2=l1*ip;  				ido=n/l2;  				ipm=ip-1;    				for (j=0;j<ipm;j++)  				{  					ld+=l1;  					i=iis;  					argld=(float)ld*argh;  					fi=0.0f;  					for (ii=2;ii<ido;ii+=2)  					{  						fi+=1.0f;  						arg=fi*argld;  						wa[index+i++]=(float)Math.Cos(arg);  						wa[index+i++]=(float)Math.Sin(arg);  					}  					iis+=ido;  				}  				l1=l2;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,drfti1,The following statement contains a magic number: for (k1=0;k1<nfm1;k1++)  			{  				ip=ifac[k1+2];  				ld=0;  				l2=l1*ip;  				ido=n/l2;  				ipm=ip-1;    				for (j=0;j<ipm;j++)  				{  					ld+=l1;  					i=iis;  					argld=(float)ld*argh;  					fi=0.0f;  					for (ii=2;ii<ido;ii+=2)  					{  						fi+=1.0f;  						arg=fi*argld;  						wa[index+i++]=(float)Math.Cos(arg);  						wa[index+i++]=(float)Math.Sin(arg);  					}  					iis+=ido;  				}  				l1=l2;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,drfti1,The following statement contains a magic number: for (k1=0;k1<nfm1;k1++)  			{  				ip=ifac[k1+2];  				ld=0;  				l2=l1*ip;  				ido=n/l2;  				ipm=ip-1;    				for (j=0;j<ipm;j++)  				{  					ld+=l1;  					i=iis;  					argld=(float)ld*argh;  					fi=0.0f;  					for (ii=2;ii<ido;ii+=2)  					{  						fi+=1.0f;  						arg=fi*argld;  						wa[index+i++]=(float)Math.Cos(arg);  						wa[index+i++]=(float)Math.Sin(arg);  					}  					iis+=ido;  				}  				l1=l2;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: if(ido<2) return;
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: if(ido==2) goto L105;
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t3=t2;  				t4=(t1<<1)+(ido<<1);  				t5=t1;  				t6=t1+t1;  				for(i=2;i<ido;i+=2)  				{  					t3+=2;  					t4-=2;  					t5+=2;  					t6+=2;  					tr2=wa1[index+i-2]*cc[t3-1]+wa1[index+i-1]*cc[t3];  					ti2=wa1[index+i-2]*cc[t3]-wa1[index+i-1]*cc[t3-1];  					ch[t6]=cc[t5]+ti2;  					ch[t4]=ti2-cc[t5];  					ch[t6-1]=cc[t5-1]+tr2;  					ch[t4-1]=cc[t5-1]-tr2;  				}  				t1+=ido;  				t2+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t3=t2;  				t4=(t1<<1)+(ido<<1);  				t5=t1;  				t6=t1+t1;  				for(i=2;i<ido;i+=2)  				{  					t3+=2;  					t4-=2;  					t5+=2;  					t6+=2;  					tr2=wa1[index+i-2]*cc[t3-1]+wa1[index+i-1]*cc[t3];  					ti2=wa1[index+i-2]*cc[t3]-wa1[index+i-1]*cc[t3-1];  					ch[t6]=cc[t5]+ti2;  					ch[t4]=ti2-cc[t5];  					ch[t6-1]=cc[t5-1]+tr2;  					ch[t4-1]=cc[t5-1]-tr2;  				}  				t1+=ido;  				t2+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t3=t2;  				t4=(t1<<1)+(ido<<1);  				t5=t1;  				t6=t1+t1;  				for(i=2;i<ido;i+=2)  				{  					t3+=2;  					t4-=2;  					t5+=2;  					t6+=2;  					tr2=wa1[index+i-2]*cc[t3-1]+wa1[index+i-1]*cc[t3];  					ti2=wa1[index+i-2]*cc[t3]-wa1[index+i-1]*cc[t3-1];  					ch[t6]=cc[t5]+ti2;  					ch[t4]=ti2-cc[t5];  					ch[t6-1]=cc[t5-1]+tr2;  					ch[t4-1]=cc[t5-1]-tr2;  				}  				t1+=ido;  				t2+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t3=t2;  				t4=(t1<<1)+(ido<<1);  				t5=t1;  				t6=t1+t1;  				for(i=2;i<ido;i+=2)  				{  					t3+=2;  					t4-=2;  					t5+=2;  					t6+=2;  					tr2=wa1[index+i-2]*cc[t3-1]+wa1[index+i-1]*cc[t3];  					ti2=wa1[index+i-2]*cc[t3]-wa1[index+i-1]*cc[t3-1];  					ch[t6]=cc[t5]+ti2;  					ch[t4]=ti2-cc[t5];  					ch[t6-1]=cc[t5-1]+tr2;  					ch[t4-1]=cc[t5-1]-tr2;  				}  				t1+=ido;  				t2+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t3=t2;  				t4=(t1<<1)+(ido<<1);  				t5=t1;  				t6=t1+t1;  				for(i=2;i<ido;i+=2)  				{  					t3+=2;  					t4-=2;  					t5+=2;  					t6+=2;  					tr2=wa1[index+i-2]*cc[t3-1]+wa1[index+i-1]*cc[t3];  					ti2=wa1[index+i-2]*cc[t3]-wa1[index+i-1]*cc[t3-1];  					ch[t6]=cc[t5]+ti2;  					ch[t4]=ti2-cc[t5];  					ch[t6-1]=cc[t5-1]+tr2;  					ch[t4-1]=cc[t5-1]-tr2;  				}  				t1+=ido;  				t2+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t3=t2;  				t4=(t1<<1)+(ido<<1);  				t5=t1;  				t6=t1+t1;  				for(i=2;i<ido;i+=2)  				{  					t3+=2;  					t4-=2;  					t5+=2;  					t6+=2;  					tr2=wa1[index+i-2]*cc[t3-1]+wa1[index+i-1]*cc[t3];  					ti2=wa1[index+i-2]*cc[t3]-wa1[index+i-1]*cc[t3-1];  					ch[t6]=cc[t5]+ti2;  					ch[t4]=ti2-cc[t5];  					ch[t6-1]=cc[t5-1]+tr2;  					ch[t4-1]=cc[t5-1]-tr2;  				}  				t1+=ido;  				t2+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t3=t2;  				t4=(t1<<1)+(ido<<1);  				t5=t1;  				t6=t1+t1;  				for(i=2;i<ido;i+=2)  				{  					t3+=2;  					t4-=2;  					t5+=2;  					t6+=2;  					tr2=wa1[index+i-2]*cc[t3-1]+wa1[index+i-1]*cc[t3];  					ti2=wa1[index+i-2]*cc[t3]-wa1[index+i-1]*cc[t3-1];  					ch[t6]=cc[t5]+ti2;  					ch[t4]=ti2-cc[t5];  					ch[t6-1]=cc[t5-1]+tr2;  					ch[t4-1]=cc[t5-1]-tr2;  				}  				t1+=ido;  				t2+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t3=t2;  				t4=(t1<<1)+(ido<<1);  				t5=t1;  				t6=t1+t1;  				for(i=2;i<ido;i+=2)  				{  					t3+=2;  					t4-=2;  					t5+=2;  					t6+=2;  					tr2=wa1[index+i-2]*cc[t3-1]+wa1[index+i-1]*cc[t3];  					ti2=wa1[index+i-2]*cc[t3]-wa1[index+i-1]*cc[t3-1];  					ch[t6]=cc[t5]+ti2;  					ch[t4]=ti2-cc[t5];  					ch[t6-1]=cc[t5-1]+tr2;  					ch[t4-1]=cc[t5-1]-tr2;  				}  				t1+=ido;  				t2+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: if(ido%2==1)return;
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				tr1=cc[t1]+cc[t2];  				tr2=cc[t3]+cc[t4];    				ch[t5=t3<<2]=tr1+tr2;  				ch[(ido<<2)+t5-1]=tr2-tr1;  				ch[(t5+=(ido<<1))-1]=cc[t3]-cc[t4];  				ch[t5]=cc[t2]-cc[t1];          				t1+=ido;  				t2+=ido;  				t3+=ido;  				t4+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				tr1=cc[t1]+cc[t2];  				tr2=cc[t3]+cc[t4];    				ch[t5=t3<<2]=tr1+tr2;  				ch[(ido<<2)+t5-1]=tr2-tr1;  				ch[(t5+=(ido<<1))-1]=cc[t3]-cc[t4];  				ch[t5]=cc[t2]-cc[t1];          				t1+=ido;  				t2+=ido;  				t3+=ido;  				t4+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: if(ido<2)return;
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: if(ido==2) goto L105;
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t2=t1;  				t4=t1<<2;  				t5=(t6=ido<<1)+t4;  				for(i=2;i<ido;i+=2)  				{  					t3=(t2+=2);  					t4+=2;  					t5-=2;    					t3+=t0;  					cr2=wa1[index1+i-2]*cc[t3-1]+wa1[index1+i-1]*cc[t3];  					ci2=wa1[index1+i-2]*cc[t3]-wa1[index1+i-1]*cc[t3-1];  					t3+=t0;  					cr3=wa2[index2+i-2]*cc[t3-1]+wa2[index2+i-1]*cc[t3];  					ci3=wa2[index2+i-2]*cc[t3]-wa2[index2+i-1]*cc[t3-1];  					t3+=t0;  					cr4=wa3[index3+i-2]*cc[t3-1]+wa3[index3+i-1]*cc[t3];  					ci4=wa3[index3+i-2]*cc[t3]-wa3[index3+i-1]*cc[t3-1];    					tr1=cr2+cr4;  					tr4=cr4-cr2;  					ti1=ci2+ci4;  					ti4=ci2-ci4;    					ti2=cc[t2]+ci3;  					ti3=cc[t2]-ci3;  					tr2=cc[t2-1]+cr3;  					tr3=cc[t2-1]-cr3;  	    					ch[t4-1]=tr1+tr2;  					ch[t4]=ti1+ti2;    					ch[t5-1]=tr3-ti4;  					ch[t5]=tr4-ti3;    					ch[t4+t6-1]=ti4+tr3;  					ch[t4+t6]=tr4+ti3;    					ch[t5+t6-1]=tr2-tr1;  					ch[t5+t6]=ti1-ti2;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t2=t1;  				t4=t1<<2;  				t5=(t6=ido<<1)+t4;  				for(i=2;i<ido;i+=2)  				{  					t3=(t2+=2);  					t4+=2;  					t5-=2;    					t3+=t0;  					cr2=wa1[index1+i-2]*cc[t3-1]+wa1[index1+i-1]*cc[t3];  					ci2=wa1[index1+i-2]*cc[t3]-wa1[index1+i-1]*cc[t3-1];  					t3+=t0;  					cr3=wa2[index2+i-2]*cc[t3-1]+wa2[index2+i-1]*cc[t3];  					ci3=wa2[index2+i-2]*cc[t3]-wa2[index2+i-1]*cc[t3-1];  					t3+=t0;  					cr4=wa3[index3+i-2]*cc[t3-1]+wa3[index3+i-1]*cc[t3];  					ci4=wa3[index3+i-2]*cc[t3]-wa3[index3+i-1]*cc[t3-1];    					tr1=cr2+cr4;  					tr4=cr4-cr2;  					ti1=ci2+ci4;  					ti4=ci2-ci4;    					ti2=cc[t2]+ci3;  					ti3=cc[t2]-ci3;  					tr2=cc[t2-1]+cr3;  					tr3=cc[t2-1]-cr3;  	    					ch[t4-1]=tr1+tr2;  					ch[t4]=ti1+ti2;    					ch[t5-1]=tr3-ti4;  					ch[t5]=tr4-ti3;    					ch[t4+t6-1]=ti4+tr3;  					ch[t4+t6]=tr4+ti3;    					ch[t5+t6-1]=tr2-tr1;  					ch[t5+t6]=ti1-ti2;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t2=t1;  				t4=t1<<2;  				t5=(t6=ido<<1)+t4;  				for(i=2;i<ido;i+=2)  				{  					t3=(t2+=2);  					t4+=2;  					t5-=2;    					t3+=t0;  					cr2=wa1[index1+i-2]*cc[t3-1]+wa1[index1+i-1]*cc[t3];  					ci2=wa1[index1+i-2]*cc[t3]-wa1[index1+i-1]*cc[t3-1];  					t3+=t0;  					cr3=wa2[index2+i-2]*cc[t3-1]+wa2[index2+i-1]*cc[t3];  					ci3=wa2[index2+i-2]*cc[t3]-wa2[index2+i-1]*cc[t3-1];  					t3+=t0;  					cr4=wa3[index3+i-2]*cc[t3-1]+wa3[index3+i-1]*cc[t3];  					ci4=wa3[index3+i-2]*cc[t3]-wa3[index3+i-1]*cc[t3-1];    					tr1=cr2+cr4;  					tr4=cr4-cr2;  					ti1=ci2+ci4;  					ti4=ci2-ci4;    					ti2=cc[t2]+ci3;  					ti3=cc[t2]-ci3;  					tr2=cc[t2-1]+cr3;  					tr3=cc[t2-1]-cr3;  	    					ch[t4-1]=tr1+tr2;  					ch[t4]=ti1+ti2;    					ch[t5-1]=tr3-ti4;  					ch[t5]=tr4-ti3;    					ch[t4+t6-1]=ti4+tr3;  					ch[t4+t6]=tr4+ti3;    					ch[t5+t6-1]=tr2-tr1;  					ch[t5+t6]=ti1-ti2;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t2=t1;  				t4=t1<<2;  				t5=(t6=ido<<1)+t4;  				for(i=2;i<ido;i+=2)  				{  					t3=(t2+=2);  					t4+=2;  					t5-=2;    					t3+=t0;  					cr2=wa1[index1+i-2]*cc[t3-1]+wa1[index1+i-1]*cc[t3];  					ci2=wa1[index1+i-2]*cc[t3]-wa1[index1+i-1]*cc[t3-1];  					t3+=t0;  					cr3=wa2[index2+i-2]*cc[t3-1]+wa2[index2+i-1]*cc[t3];  					ci3=wa2[index2+i-2]*cc[t3]-wa2[index2+i-1]*cc[t3-1];  					t3+=t0;  					cr4=wa3[index3+i-2]*cc[t3-1]+wa3[index3+i-1]*cc[t3];  					ci4=wa3[index3+i-2]*cc[t3]-wa3[index3+i-1]*cc[t3-1];    					tr1=cr2+cr4;  					tr4=cr4-cr2;  					ti1=ci2+ci4;  					ti4=ci2-ci4;    					ti2=cc[t2]+ci3;  					ti3=cc[t2]-ci3;  					tr2=cc[t2-1]+cr3;  					tr3=cc[t2-1]-cr3;  	    					ch[t4-1]=tr1+tr2;  					ch[t4]=ti1+ti2;    					ch[t5-1]=tr3-ti4;  					ch[t5]=tr4-ti3;    					ch[t4+t6-1]=ti4+tr3;  					ch[t4+t6]=tr4+ti3;    					ch[t5+t6-1]=tr2-tr1;  					ch[t5+t6]=ti1-ti2;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t2=t1;  				t4=t1<<2;  				t5=(t6=ido<<1)+t4;  				for(i=2;i<ido;i+=2)  				{  					t3=(t2+=2);  					t4+=2;  					t5-=2;    					t3+=t0;  					cr2=wa1[index1+i-2]*cc[t3-1]+wa1[index1+i-1]*cc[t3];  					ci2=wa1[index1+i-2]*cc[t3]-wa1[index1+i-1]*cc[t3-1];  					t3+=t0;  					cr3=wa2[index2+i-2]*cc[t3-1]+wa2[index2+i-1]*cc[t3];  					ci3=wa2[index2+i-2]*cc[t3]-wa2[index2+i-1]*cc[t3-1];  					t3+=t0;  					cr4=wa3[index3+i-2]*cc[t3-1]+wa3[index3+i-1]*cc[t3];  					ci4=wa3[index3+i-2]*cc[t3]-wa3[index3+i-1]*cc[t3-1];    					tr1=cr2+cr4;  					tr4=cr4-cr2;  					ti1=ci2+ci4;  					ti4=ci2-ci4;    					ti2=cc[t2]+ci3;  					ti3=cc[t2]-ci3;  					tr2=cc[t2-1]+cr3;  					tr3=cc[t2-1]-cr3;  	    					ch[t4-1]=tr1+tr2;  					ch[t4]=ti1+ti2;    					ch[t5-1]=tr3-ti4;  					ch[t5]=tr4-ti3;    					ch[t4+t6-1]=ti4+tr3;  					ch[t4+t6]=tr4+ti3;    					ch[t5+t6-1]=tr2-tr1;  					ch[t5+t6]=ti1-ti2;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t2=t1;  				t4=t1<<2;  				t5=(t6=ido<<1)+t4;  				for(i=2;i<ido;i+=2)  				{  					t3=(t2+=2);  					t4+=2;  					t5-=2;    					t3+=t0;  					cr2=wa1[index1+i-2]*cc[t3-1]+wa1[index1+i-1]*cc[t3];  					ci2=wa1[index1+i-2]*cc[t3]-wa1[index1+i-1]*cc[t3-1];  					t3+=t0;  					cr3=wa2[index2+i-2]*cc[t3-1]+wa2[index2+i-1]*cc[t3];  					ci3=wa2[index2+i-2]*cc[t3]-wa2[index2+i-1]*cc[t3-1];  					t3+=t0;  					cr4=wa3[index3+i-2]*cc[t3-1]+wa3[index3+i-1]*cc[t3];  					ci4=wa3[index3+i-2]*cc[t3]-wa3[index3+i-1]*cc[t3-1];    					tr1=cr2+cr4;  					tr4=cr4-cr2;  					ti1=ci2+ci4;  					ti4=ci2-ci4;    					ti2=cc[t2]+ci3;  					ti3=cc[t2]-ci3;  					tr2=cc[t2-1]+cr3;  					tr3=cc[t2-1]-cr3;  	    					ch[t4-1]=tr1+tr2;  					ch[t4]=ti1+ti2;    					ch[t5-1]=tr3-ti4;  					ch[t5]=tr4-ti3;    					ch[t4+t6-1]=ti4+tr3;  					ch[t4+t6]=tr4+ti3;    					ch[t5+t6-1]=tr2-tr1;  					ch[t5+t6]=ti1-ti2;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t2=t1;  				t4=t1<<2;  				t5=(t6=ido<<1)+t4;  				for(i=2;i<ido;i+=2)  				{  					t3=(t2+=2);  					t4+=2;  					t5-=2;    					t3+=t0;  					cr2=wa1[index1+i-2]*cc[t3-1]+wa1[index1+i-1]*cc[t3];  					ci2=wa1[index1+i-2]*cc[t3]-wa1[index1+i-1]*cc[t3-1];  					t3+=t0;  					cr3=wa2[index2+i-2]*cc[t3-1]+wa2[index2+i-1]*cc[t3];  					ci3=wa2[index2+i-2]*cc[t3]-wa2[index2+i-1]*cc[t3-1];  					t3+=t0;  					cr4=wa3[index3+i-2]*cc[t3-1]+wa3[index3+i-1]*cc[t3];  					ci4=wa3[index3+i-2]*cc[t3]-wa3[index3+i-1]*cc[t3-1];    					tr1=cr2+cr4;  					tr4=cr4-cr2;  					ti1=ci2+ci4;  					ti4=ci2-ci4;    					ti2=cc[t2]+ci3;  					ti3=cc[t2]-ci3;  					tr2=cc[t2-1]+cr3;  					tr3=cc[t2-1]-cr3;  	    					ch[t4-1]=tr1+tr2;  					ch[t4]=ti1+ti2;    					ch[t5-1]=tr3-ti4;  					ch[t5]=tr4-ti3;    					ch[t4+t6-1]=ti4+tr3;  					ch[t4+t6]=tr4+ti3;    					ch[t5+t6-1]=tr2-tr1;  					ch[t5+t6]=ti1-ti2;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t2=t1;  				t4=t1<<2;  				t5=(t6=ido<<1)+t4;  				for(i=2;i<ido;i+=2)  				{  					t3=(t2+=2);  					t4+=2;  					t5-=2;    					t3+=t0;  					cr2=wa1[index1+i-2]*cc[t3-1]+wa1[index1+i-1]*cc[t3];  					ci2=wa1[index1+i-2]*cc[t3]-wa1[index1+i-1]*cc[t3-1];  					t3+=t0;  					cr3=wa2[index2+i-2]*cc[t3-1]+wa2[index2+i-1]*cc[t3];  					ci3=wa2[index2+i-2]*cc[t3]-wa2[index2+i-1]*cc[t3-1];  					t3+=t0;  					cr4=wa3[index3+i-2]*cc[t3-1]+wa3[index3+i-1]*cc[t3];  					ci4=wa3[index3+i-2]*cc[t3]-wa3[index3+i-1]*cc[t3-1];    					tr1=cr2+cr4;  					tr4=cr4-cr2;  					ti1=ci2+ci4;  					ti4=ci2-ci4;    					ti2=cc[t2]+ci3;  					ti3=cc[t2]-ci3;  					tr2=cc[t2-1]+cr3;  					tr3=cc[t2-1]-cr3;  	    					ch[t4-1]=tr1+tr2;  					ch[t4]=ti1+ti2;    					ch[t5-1]=tr3-ti4;  					ch[t5]=tr4-ti3;    					ch[t4+t6-1]=ti4+tr3;  					ch[t4+t6]=tr4+ti3;    					ch[t5+t6-1]=tr2-tr1;  					ch[t5+t6]=ti1-ti2;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t2=t1;  				t4=t1<<2;  				t5=(t6=ido<<1)+t4;  				for(i=2;i<ido;i+=2)  				{  					t3=(t2+=2);  					t4+=2;  					t5-=2;    					t3+=t0;  					cr2=wa1[index1+i-2]*cc[t3-1]+wa1[index1+i-1]*cc[t3];  					ci2=wa1[index1+i-2]*cc[t3]-wa1[index1+i-1]*cc[t3-1];  					t3+=t0;  					cr3=wa2[index2+i-2]*cc[t3-1]+wa2[index2+i-1]*cc[t3];  					ci3=wa2[index2+i-2]*cc[t3]-wa2[index2+i-1]*cc[t3-1];  					t3+=t0;  					cr4=wa3[index3+i-2]*cc[t3-1]+wa3[index3+i-1]*cc[t3];  					ci4=wa3[index3+i-2]*cc[t3]-wa3[index3+i-1]*cc[t3-1];    					tr1=cr2+cr4;  					tr4=cr4-cr2;  					ti1=ci2+ci4;  					ti4=ci2-ci4;    					ti2=cc[t2]+ci3;  					ti3=cc[t2]-ci3;  					tr2=cc[t2-1]+cr3;  					tr3=cc[t2-1]-cr3;  	    					ch[t4-1]=tr1+tr2;  					ch[t4]=ti1+ti2;    					ch[t5-1]=tr3-ti4;  					ch[t5]=tr4-ti3;    					ch[t4+t6-1]=ti4+tr3;  					ch[t4+t6]=tr4+ti3;    					ch[t5+t6-1]=tr2-tr1;  					ch[t5+t6]=ti1-ti2;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t2=t1;  				t4=t1<<2;  				t5=(t6=ido<<1)+t4;  				for(i=2;i<ido;i+=2)  				{  					t3=(t2+=2);  					t4+=2;  					t5-=2;    					t3+=t0;  					cr2=wa1[index1+i-2]*cc[t3-1]+wa1[index1+i-1]*cc[t3];  					ci2=wa1[index1+i-2]*cc[t3]-wa1[index1+i-1]*cc[t3-1];  					t3+=t0;  					cr3=wa2[index2+i-2]*cc[t3-1]+wa2[index2+i-1]*cc[t3];  					ci3=wa2[index2+i-2]*cc[t3]-wa2[index2+i-1]*cc[t3-1];  					t3+=t0;  					cr4=wa3[index3+i-2]*cc[t3-1]+wa3[index3+i-1]*cc[t3];  					ci4=wa3[index3+i-2]*cc[t3]-wa3[index3+i-1]*cc[t3-1];    					tr1=cr2+cr4;  					tr4=cr4-cr2;  					ti1=ci2+ci4;  					ti4=ci2-ci4;    					ti2=cc[t2]+ci3;  					ti3=cc[t2]-ci3;  					tr2=cc[t2-1]+cr3;  					tr3=cc[t2-1]-cr3;  	    					ch[t4-1]=tr1+tr2;  					ch[t4]=ti1+ti2;    					ch[t5-1]=tr3-ti4;  					ch[t5]=tr4-ti3;    					ch[t4+t6-1]=ti4+tr3;  					ch[t4+t6]=tr4+ti3;    					ch[t5+t6-1]=tr2-tr1;  					ch[t5+t6]=ti1-ti2;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t2=t1;  				t4=t1<<2;  				t5=(t6=ido<<1)+t4;  				for(i=2;i<ido;i+=2)  				{  					t3=(t2+=2);  					t4+=2;  					t5-=2;    					t3+=t0;  					cr2=wa1[index1+i-2]*cc[t3-1]+wa1[index1+i-1]*cc[t3];  					ci2=wa1[index1+i-2]*cc[t3]-wa1[index1+i-1]*cc[t3-1];  					t3+=t0;  					cr3=wa2[index2+i-2]*cc[t3-1]+wa2[index2+i-1]*cc[t3];  					ci3=wa2[index2+i-2]*cc[t3]-wa2[index2+i-1]*cc[t3-1];  					t3+=t0;  					cr4=wa3[index3+i-2]*cc[t3-1]+wa3[index3+i-1]*cc[t3];  					ci4=wa3[index3+i-2]*cc[t3]-wa3[index3+i-1]*cc[t3-1];    					tr1=cr2+cr4;  					tr4=cr4-cr2;  					ti1=ci2+ci4;  					ti4=ci2-ci4;    					ti2=cc[t2]+ci3;  					ti3=cc[t2]-ci3;  					tr2=cc[t2-1]+cr3;  					tr3=cc[t2-1]-cr3;  	    					ch[t4-1]=tr1+tr2;  					ch[t4]=ti1+ti2;    					ch[t5-1]=tr3-ti4;  					ch[t5]=tr4-ti3;    					ch[t4+t6-1]=ti4+tr3;  					ch[t4+t6]=tr4+ti3;    					ch[t5+t6-1]=tr2-tr1;  					ch[t5+t6]=ti1-ti2;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t2=t1;  				t4=t1<<2;  				t5=(t6=ido<<1)+t4;  				for(i=2;i<ido;i+=2)  				{  					t3=(t2+=2);  					t4+=2;  					t5-=2;    					t3+=t0;  					cr2=wa1[index1+i-2]*cc[t3-1]+wa1[index1+i-1]*cc[t3];  					ci2=wa1[index1+i-2]*cc[t3]-wa1[index1+i-1]*cc[t3-1];  					t3+=t0;  					cr3=wa2[index2+i-2]*cc[t3-1]+wa2[index2+i-1]*cc[t3];  					ci3=wa2[index2+i-2]*cc[t3]-wa2[index2+i-1]*cc[t3-1];  					t3+=t0;  					cr4=wa3[index3+i-2]*cc[t3-1]+wa3[index3+i-1]*cc[t3];  					ci4=wa3[index3+i-2]*cc[t3]-wa3[index3+i-1]*cc[t3-1];    					tr1=cr2+cr4;  					tr4=cr4-cr2;  					ti1=ci2+ci4;  					ti4=ci2-ci4;    					ti2=cc[t2]+ci3;  					ti3=cc[t2]-ci3;  					tr2=cc[t2-1]+cr3;  					tr3=cc[t2-1]-cr3;  	    					ch[t4-1]=tr1+tr2;  					ch[t4]=ti1+ti2;    					ch[t5-1]=tr3-ti4;  					ch[t5]=tr4-ti3;    					ch[t4+t6-1]=ti4+tr3;  					ch[t4+t6]=tr4+ti3;    					ch[t5+t6-1]=tr2-tr1;  					ch[t5+t6]=ti1-ti2;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: t3=ido<<2;
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if(nbd>l1)  			{  				for(j=1;j<ip;j++)  				{  					t1+=t0;  					iis+=ido;  					t2= -ido+t1;  					for(k=0;k<l1;k++)  					{  						idij=iis-1;  						t2+=ido;  						t3=t2;  						for(i=2;i<ido;i+=2)  						{  							idij+=2;  							t3+=2;  							ch[t3-1]=wa[index+idij-1]*c1[t3-1]+wa[index+idij]*c1[t3];  							ch[t3]=wa[index+idij-1]*c1[t3]-wa[index+idij]*c1[t3-1];  						}  					}  				}  			}  			else  			{    				for(j=1;j<ip;j++)  				{  					iis+=ido;  					idij=iis-1;  					t1+=t0;  					t2=t1;  					for(i=2;i<ido;i+=2)  					{  						idij+=2;  						t2+=2;  						t3=t2;  						for(k=0;k<l1;k++)  						{  							ch[t3-1]=wa[index+idij-1]*c1[t3-1]+wa[index+idij]*c1[t3];  							ch[t3]=wa[index+idij-1]*c1[t3]-wa[index+idij]*c1[t3-1];  							t3+=ido;  						}  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if(nbd>l1)  			{  				for(j=1;j<ip;j++)  				{  					t1+=t0;  					iis+=ido;  					t2= -ido+t1;  					for(k=0;k<l1;k++)  					{  						idij=iis-1;  						t2+=ido;  						t3=t2;  						for(i=2;i<ido;i+=2)  						{  							idij+=2;  							t3+=2;  							ch[t3-1]=wa[index+idij-1]*c1[t3-1]+wa[index+idij]*c1[t3];  							ch[t3]=wa[index+idij-1]*c1[t3]-wa[index+idij]*c1[t3-1];  						}  					}  				}  			}  			else  			{    				for(j=1;j<ip;j++)  				{  					iis+=ido;  					idij=iis-1;  					t1+=t0;  					t2=t1;  					for(i=2;i<ido;i+=2)  					{  						idij+=2;  						t2+=2;  						t3=t2;  						for(k=0;k<l1;k++)  						{  							ch[t3-1]=wa[index+idij-1]*c1[t3-1]+wa[index+idij]*c1[t3];  							ch[t3]=wa[index+idij-1]*c1[t3]-wa[index+idij]*c1[t3-1];  							t3+=ido;  						}  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if(nbd>l1)  			{  				for(j=1;j<ip;j++)  				{  					t1+=t0;  					iis+=ido;  					t2= -ido+t1;  					for(k=0;k<l1;k++)  					{  						idij=iis-1;  						t2+=ido;  						t3=t2;  						for(i=2;i<ido;i+=2)  						{  							idij+=2;  							t3+=2;  							ch[t3-1]=wa[index+idij-1]*c1[t3-1]+wa[index+idij]*c1[t3];  							ch[t3]=wa[index+idij-1]*c1[t3]-wa[index+idij]*c1[t3-1];  						}  					}  				}  			}  			else  			{    				for(j=1;j<ip;j++)  				{  					iis+=ido;  					idij=iis-1;  					t1+=t0;  					t2=t1;  					for(i=2;i<ido;i+=2)  					{  						idij+=2;  						t2+=2;  						t3=t2;  						for(k=0;k<l1;k++)  						{  							ch[t3-1]=wa[index+idij-1]*c1[t3-1]+wa[index+idij]*c1[t3];  							ch[t3]=wa[index+idij-1]*c1[t3]-wa[index+idij]*c1[t3-1];  							t3+=ido;  						}  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if(nbd>l1)  			{  				for(j=1;j<ip;j++)  				{  					t1+=t0;  					iis+=ido;  					t2= -ido+t1;  					for(k=0;k<l1;k++)  					{  						idij=iis-1;  						t2+=ido;  						t3=t2;  						for(i=2;i<ido;i+=2)  						{  							idij+=2;  							t3+=2;  							ch[t3-1]=wa[index+idij-1]*c1[t3-1]+wa[index+idij]*c1[t3];  							ch[t3]=wa[index+idij-1]*c1[t3]-wa[index+idij]*c1[t3-1];  						}  					}  				}  			}  			else  			{    				for(j=1;j<ip;j++)  				{  					iis+=ido;  					idij=iis-1;  					t1+=t0;  					t2=t1;  					for(i=2;i<ido;i+=2)  					{  						idij+=2;  						t2+=2;  						t3=t2;  						for(k=0;k<l1;k++)  						{  							ch[t3-1]=wa[index+idij-1]*c1[t3-1]+wa[index+idij]*c1[t3];  							ch[t3]=wa[index+idij-1]*c1[t3]-wa[index+idij]*c1[t3-1];  							t3+=ido;  						}  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if(nbd>l1)  			{  				for(j=1;j<ip;j++)  				{  					t1+=t0;  					iis+=ido;  					t2= -ido+t1;  					for(k=0;k<l1;k++)  					{  						idij=iis-1;  						t2+=ido;  						t3=t2;  						for(i=2;i<ido;i+=2)  						{  							idij+=2;  							t3+=2;  							ch[t3-1]=wa[index+idij-1]*c1[t3-1]+wa[index+idij]*c1[t3];  							ch[t3]=wa[index+idij-1]*c1[t3]-wa[index+idij]*c1[t3-1];  						}  					}  				}  			}  			else  			{    				for(j=1;j<ip;j++)  				{  					iis+=ido;  					idij=iis-1;  					t1+=t0;  					t2=t1;  					for(i=2;i<ido;i+=2)  					{  						idij+=2;  						t2+=2;  						t3=t2;  						for(k=0;k<l1;k++)  						{  							ch[t3-1]=wa[index+idij-1]*c1[t3-1]+wa[index+idij]*c1[t3];  							ch[t3]=wa[index+idij-1]*c1[t3]-wa[index+idij]*c1[t3-1];  							t3+=ido;  						}  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if(nbd>l1)  			{  				for(j=1;j<ip;j++)  				{  					t1+=t0;  					iis+=ido;  					t2= -ido+t1;  					for(k=0;k<l1;k++)  					{  						idij=iis-1;  						t2+=ido;  						t3=t2;  						for(i=2;i<ido;i+=2)  						{  							idij+=2;  							t3+=2;  							ch[t3-1]=wa[index+idij-1]*c1[t3-1]+wa[index+idij]*c1[t3];  							ch[t3]=wa[index+idij-1]*c1[t3]-wa[index+idij]*c1[t3-1];  						}  					}  				}  			}  			else  			{    				for(j=1;j<ip;j++)  				{  					iis+=ido;  					idij=iis-1;  					t1+=t0;  					t2=t1;  					for(i=2;i<ido;i+=2)  					{  						idij+=2;  						t2+=2;  						t3=t2;  						for(k=0;k<l1;k++)  						{  							ch[t3-1]=wa[index+idij-1]*c1[t3-1]+wa[index+idij]*c1[t3];  							ch[t3]=wa[index+idij-1]*c1[t3]-wa[index+idij]*c1[t3-1];  							t3+=ido;  						}  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if(nbd>l1)  			{  				for(j=1;j<ip;j++)  				{  					t1+=t0;  					iis+=ido;  					t2= -ido+t1;  					for(k=0;k<l1;k++)  					{  						idij=iis-1;  						t2+=ido;  						t3=t2;  						for(i=2;i<ido;i+=2)  						{  							idij+=2;  							t3+=2;  							ch[t3-1]=wa[index+idij-1]*c1[t3-1]+wa[index+idij]*c1[t3];  							ch[t3]=wa[index+idij-1]*c1[t3]-wa[index+idij]*c1[t3-1];  						}  					}  				}  			}  			else  			{    				for(j=1;j<ip;j++)  				{  					iis+=ido;  					idij=iis-1;  					t1+=t0;  					t2=t1;  					for(i=2;i<ido;i+=2)  					{  						idij+=2;  						t2+=2;  						t3=t2;  						for(k=0;k<l1;k++)  						{  							ch[t3-1]=wa[index+idij-1]*c1[t3-1]+wa[index+idij]*c1[t3];  							ch[t3]=wa[index+idij-1]*c1[t3]-wa[index+idij]*c1[t3-1];  							t3+=ido;  						}  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if(nbd>l1)  			{  				for(j=1;j<ip;j++)  				{  					t1+=t0;  					iis+=ido;  					t2= -ido+t1;  					for(k=0;k<l1;k++)  					{  						idij=iis-1;  						t2+=ido;  						t3=t2;  						for(i=2;i<ido;i+=2)  						{  							idij+=2;  							t3+=2;  							ch[t3-1]=wa[index+idij-1]*c1[t3-1]+wa[index+idij]*c1[t3];  							ch[t3]=wa[index+idij-1]*c1[t3]-wa[index+idij]*c1[t3-1];  						}  					}  				}  			}  			else  			{    				for(j=1;j<ip;j++)  				{  					iis+=ido;  					idij=iis-1;  					t1+=t0;  					t2=t1;  					for(i=2;i<ido;i+=2)  					{  						idij+=2;  						t2+=2;  						t3=t2;  						for(k=0;k<l1;k++)  						{  							ch[t3-1]=wa[index+idij-1]*c1[t3-1]+wa[index+idij]*c1[t3];  							ch[t3]=wa[index+idij-1]*c1[t3]-wa[index+idij]*c1[t3-1];  							t3+=ido;  						}  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if(nbd<l1)  			{  				for(j=1;j<ipph;j++)  				{  					t1+=t0;  					t2-=t0;  					t3=t1;  					t4=t2;  					for(i=2;i<ido;i+=2)  					{  						t3+=2;  						t4+=2;  						t5=t3-ido;  						t6=t4-ido;  						for(k=0;k<l1;k++)  						{  							t5+=ido;  							t6+=ido;  							c1[t5-1]=ch[t5-1]+ch[t6-1];  							c1[t6-1]=ch[t5]-ch[t6];  							c1[t5]=ch[t5]+ch[t6];  							c1[t6]=ch[t6-1]-ch[t5-1];  						}  					}  				}  			}  			else  			{  				for(j=1;j<ipph;j++)  				{  					t1+=t0;  					t2-=t0;  					t3=t1;  					t4=t2;  					for(k=0;k<l1;k++)  					{  						t5=t3;  						t6=t4;  						for(i=2;i<ido;i+=2)  						{  							t5+=2;  							t6+=2;  							c1[t5-1]=ch[t5-1]+ch[t6-1];  							c1[t6-1]=ch[t5]-ch[t6];  							c1[t5]=ch[t5]+ch[t6];  							c1[t6]=ch[t6-1]-ch[t5-1];  						}  						t3+=ido;  						t4+=ido;  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if(nbd<l1)  			{  				for(j=1;j<ipph;j++)  				{  					t1+=t0;  					t2-=t0;  					t3=t1;  					t4=t2;  					for(i=2;i<ido;i+=2)  					{  						t3+=2;  						t4+=2;  						t5=t3-ido;  						t6=t4-ido;  						for(k=0;k<l1;k++)  						{  							t5+=ido;  							t6+=ido;  							c1[t5-1]=ch[t5-1]+ch[t6-1];  							c1[t6-1]=ch[t5]-ch[t6];  							c1[t5]=ch[t5]+ch[t6];  							c1[t6]=ch[t6-1]-ch[t5-1];  						}  					}  				}  			}  			else  			{  				for(j=1;j<ipph;j++)  				{  					t1+=t0;  					t2-=t0;  					t3=t1;  					t4=t2;  					for(k=0;k<l1;k++)  					{  						t5=t3;  						t6=t4;  						for(i=2;i<ido;i+=2)  						{  							t5+=2;  							t6+=2;  							c1[t5-1]=ch[t5-1]+ch[t6-1];  							c1[t6-1]=ch[t5]-ch[t6];  							c1[t5]=ch[t5]+ch[t6];  							c1[t6]=ch[t6-1]-ch[t5-1];  						}  						t3+=ido;  						t4+=ido;  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if(nbd<l1)  			{  				for(j=1;j<ipph;j++)  				{  					t1+=t0;  					t2-=t0;  					t3=t1;  					t4=t2;  					for(i=2;i<ido;i+=2)  					{  						t3+=2;  						t4+=2;  						t5=t3-ido;  						t6=t4-ido;  						for(k=0;k<l1;k++)  						{  							t5+=ido;  							t6+=ido;  							c1[t5-1]=ch[t5-1]+ch[t6-1];  							c1[t6-1]=ch[t5]-ch[t6];  							c1[t5]=ch[t5]+ch[t6];  							c1[t6]=ch[t6-1]-ch[t5-1];  						}  					}  				}  			}  			else  			{  				for(j=1;j<ipph;j++)  				{  					t1+=t0;  					t2-=t0;  					t3=t1;  					t4=t2;  					for(k=0;k<l1;k++)  					{  						t5=t3;  						t6=t4;  						for(i=2;i<ido;i+=2)  						{  							t5+=2;  							t6+=2;  							c1[t5-1]=ch[t5-1]+ch[t6-1];  							c1[t6-1]=ch[t5]-ch[t6];  							c1[t5]=ch[t5]+ch[t6];  							c1[t6]=ch[t6-1]-ch[t5-1];  						}  						t3+=ido;  						t4+=ido;  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if(nbd<l1)  			{  				for(j=1;j<ipph;j++)  				{  					t1+=t0;  					t2-=t0;  					t3=t1;  					t4=t2;  					for(i=2;i<ido;i+=2)  					{  						t3+=2;  						t4+=2;  						t5=t3-ido;  						t6=t4-ido;  						for(k=0;k<l1;k++)  						{  							t5+=ido;  							t6+=ido;  							c1[t5-1]=ch[t5-1]+ch[t6-1];  							c1[t6-1]=ch[t5]-ch[t6];  							c1[t5]=ch[t5]+ch[t6];  							c1[t6]=ch[t6-1]-ch[t5-1];  						}  					}  				}  			}  			else  			{  				for(j=1;j<ipph;j++)  				{  					t1+=t0;  					t2-=t0;  					t3=t1;  					t4=t2;  					for(k=0;k<l1;k++)  					{  						t5=t3;  						t6=t4;  						for(i=2;i<ido;i+=2)  						{  							t5+=2;  							t6+=2;  							c1[t5-1]=ch[t5-1]+ch[t6-1];  							c1[t6-1]=ch[t5]-ch[t6];  							c1[t5]=ch[t5]+ch[t6];  							c1[t6]=ch[t6-1]-ch[t5-1];  						}  						t3+=ido;  						t4+=ido;  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if(nbd<l1)  			{  				for(j=1;j<ipph;j++)  				{  					t1+=t0;  					t2-=t0;  					t3=t1;  					t4=t2;  					for(i=2;i<ido;i+=2)  					{  						t3+=2;  						t4+=2;  						t5=t3-ido;  						t6=t4-ido;  						for(k=0;k<l1;k++)  						{  							t5+=ido;  							t6+=ido;  							c1[t5-1]=ch[t5-1]+ch[t6-1];  							c1[t6-1]=ch[t5]-ch[t6];  							c1[t5]=ch[t5]+ch[t6];  							c1[t6]=ch[t6-1]-ch[t5-1];  						}  					}  				}  			}  			else  			{  				for(j=1;j<ipph;j++)  				{  					t1+=t0;  					t2-=t0;  					t3=t1;  					t4=t2;  					for(k=0;k<l1;k++)  					{  						t5=t3;  						t6=t4;  						for(i=2;i<ido;i+=2)  						{  							t5+=2;  							t6+=2;  							c1[t5-1]=ch[t5-1]+ch[t6-1];  							c1[t6-1]=ch[t5]-ch[t6];  							c1[t5]=ch[t5]+ch[t6];  							c1[t6]=ch[t6-1]-ch[t5-1];  						}  						t3+=ido;  						t4+=ido;  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if(nbd<l1)  			{  				for(j=1;j<ipph;j++)  				{  					t1+=t0;  					t2-=t0;  					t3=t1;  					t4=t2;  					for(i=2;i<ido;i+=2)  					{  						t3+=2;  						t4+=2;  						t5=t3-ido;  						t6=t4-ido;  						for(k=0;k<l1;k++)  						{  							t5+=ido;  							t6+=ido;  							c1[t5-1]=ch[t5-1]+ch[t6-1];  							c1[t6-1]=ch[t5]-ch[t6];  							c1[t5]=ch[t5]+ch[t6];  							c1[t6]=ch[t6-1]-ch[t5-1];  						}  					}  				}  			}  			else  			{  				for(j=1;j<ipph;j++)  				{  					t1+=t0;  					t2-=t0;  					t3=t1;  					t4=t2;  					for(k=0;k<l1;k++)  					{  						t5=t3;  						t6=t4;  						for(i=2;i<ido;i+=2)  						{  							t5+=2;  							t6+=2;  							c1[t5-1]=ch[t5-1]+ch[t6-1];  							c1[t6-1]=ch[t5]-ch[t6];  							c1[t5]=ch[t5]+ch[t6];  							c1[t6]=ch[t6-1]-ch[t5-1];  						}  						t3+=ido;  						t4+=ido;  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if(nbd<l1)  			{  				for(j=1;j<ipph;j++)  				{  					t1+=t0;  					t2-=t0;  					t3=t1;  					t4=t2;  					for(i=2;i<ido;i+=2)  					{  						t3+=2;  						t4+=2;  						t5=t3-ido;  						t6=t4-ido;  						for(k=0;k<l1;k++)  						{  							t5+=ido;  							t6+=ido;  							c1[t5-1]=ch[t5-1]+ch[t6-1];  							c1[t6-1]=ch[t5]-ch[t6];  							c1[t5]=ch[t5]+ch[t6];  							c1[t6]=ch[t6-1]-ch[t5-1];  						}  					}  				}  			}  			else  			{  				for(j=1;j<ipph;j++)  				{  					t1+=t0;  					t2-=t0;  					t3=t1;  					t4=t2;  					for(k=0;k<l1;k++)  					{  						t5=t3;  						t6=t4;  						for(i=2;i<ido;i+=2)  						{  							t5+=2;  							t6+=2;  							c1[t5-1]=ch[t5-1]+ch[t6-1];  							c1[t6-1]=ch[t5]-ch[t6];  							c1[t5]=ch[t5]+ch[t6];  							c1[t6]=ch[t6-1]-ch[t5-1];  						}  						t3+=ido;  						t4+=ido;  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if(nbd<l1)  			{  				for(j=1;j<ipph;j++)  				{  					t1+=t0;  					t2-=t0;  					t3=t1;  					t4=t2;  					for(i=2;i<ido;i+=2)  					{  						t3+=2;  						t4+=2;  						t5=t3-ido;  						t6=t4-ido;  						for(k=0;k<l1;k++)  						{  							t5+=ido;  							t6+=ido;  							c1[t5-1]=ch[t5-1]+ch[t6-1];  							c1[t6-1]=ch[t5]-ch[t6];  							c1[t5]=ch[t5]+ch[t6];  							c1[t6]=ch[t6-1]-ch[t5-1];  						}  					}  				}  			}  			else  			{  				for(j=1;j<ipph;j++)  				{  					t1+=t0;  					t2-=t0;  					t3=t1;  					t4=t2;  					for(k=0;k<l1;k++)  					{  						t5=t3;  						t6=t4;  						for(i=2;i<ido;i+=2)  						{  							t5+=2;  							t6+=2;  							c1[t5-1]=ch[t5-1]+ch[t6-1];  							c1[t6-1]=ch[t5]-ch[t6];  							c1[t5]=ch[t5]+ch[t6];  							c1[t6]=ch[t6-1]-ch[t5-1];  						}  						t3+=ido;  						t4+=ido;  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for(l=1;l<ipph;l++)  			{  				t1+=idl1;  				t2-=idl1;  				ar1h=dcp*ar1-dsp*ai1;  				ai1=dcp*ai1+dsp*ar1;  				ar1=ar1h;  				t4=t1;  				t5=t2;  				t6=t3;  				t7=idl1;    				for(ik=0;ik<idl1;ik++)  				{  					ch2[t4++]=c2[ik]+ar1*c2[t7++];  					ch2[t5++]=ai1*c2[t6++];  				}    				dc2=ar1;  				ds2=ai1;  				ar2=ar1;  				ai2=ai1;    				t4=idl1;  				t5=(ipp2-1)*idl1;  				for(j=2;j<ipph;j++)  				{  					t4+=idl1;  					t5-=idl1;    					ar2h=dc2*ar2-ds2*ai2;  					ai2=dc2*ai2+ds2*ar2;  					ar2=ar2h;    					t6=t1;  					t7=t2;  					t8=t4;  					t9=t5;  					for(ik=0;ik<idl1;ik++)  					{  						ch2[t6]+=ar2*c2[t8++];  						t6++;  						ch2[t7]+=ai2*c2[t9++];  						t7++;  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for(j=1;j<ipph;j++)  			{  				t1+=t2;  				t3+=t2;  				t4+=t0;  				t5-=t0;  				t6=t1;  				t7=t3;  				t8=t4;  				t9=t5;  				for(k=0;k<l1;k++)  				{  					for(i=2;i<ido;i+=2)  					{  						ic=idp2-i;  						cc[i+t7-1]=ch[i+t8-1]+ch[i+t9-1];  						cc[ic+t6-1]=ch[i+t8-1]-ch[i+t9-1];  						cc[i+t7]=ch[i+t8]+ch[i+t9];  						cc[ic+t6]=ch[i+t9]-ch[i+t8];  					}  					t6+=t10;  					t7+=t10;  					t8+=ido;  					t9+=ido;  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for(j=1;j<ipph;j++)  			{  				t1+=t2;  				t3+=t2;  				t4+=t0;  				t5-=t0;  				t6=t1;  				t7=t3;  				t8=t4;  				t9=t5;  				for(k=0;k<l1;k++)  				{  					for(i=2;i<ido;i+=2)  					{  						ic=idp2-i;  						cc[i+t7-1]=ch[i+t8-1]+ch[i+t9-1];  						cc[ic+t6-1]=ch[i+t8-1]-ch[i+t9-1];  						cc[i+t7]=ch[i+t8]+ch[i+t9];  						cc[ic+t6]=ch[i+t9]-ch[i+t8];  					}  					t6+=t10;  					t7+=t10;  					t8+=ido;  					t9+=ido;  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for(j=1;j<ipph;j++)  			{  				t1+=t2;  				t3+=t2;  				t4+=t0;  				t5-=t0;  				for(i=2;i<ido;i+=2)  				{  					t6=idp2+t1-i;  					t7=i+t3;  					t8=i+t4;  					t9=i+t5;  					for(k=0;k<l1;k++)  					{  						cc[t7-1]=ch[t8-1]+ch[t9-1];  						cc[t6-1]=ch[t8-1]-ch[t9-1];  						cc[t7]=ch[t8]+ch[t9];  						cc[t6]=ch[t9]-ch[t8];  						t6+=t10;  						t7+=t10;  						t8+=ido;  						t9+=ido;  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for(j=1;j<ipph;j++)  			{  				t1+=t2;  				t3+=t2;  				t4+=t0;  				t5-=t0;  				for(i=2;i<ido;i+=2)  				{  					t6=idp2+t1-i;  					t7=i+t3;  					t8=i+t4;  					t9=i+t5;  					for(k=0;k<l1;k++)  					{  						cc[t7-1]=ch[t8-1]+ch[t9-1];  						cc[t6-1]=ch[t8-1]-ch[t9-1];  						cc[t7]=ch[t8]+ch[t9];  						cc[t6]=ch[t9]-ch[t8];  						t6+=t10;  						t7+=t10;  						t8+=ido;  						t9+=ido;  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,drftf1,The following statement contains a magic number: for(k1=0;k1<nf;k1++)  			{  				kh=nf-k1;  				ip=ifac[kh+1];  				l1=l2/ip;  				ido=n/l2;  				idl1=ido*l1;  				iw-=(ip-1)*ido;  				na=1-na;    				if(ip!=4) goto L102;    				ix2=iw+ido;  				ix3=ix2+ido;  				if(na!=0)  					dradf4(ido'l1'ch'c'wa'iw-1'wa'ix2-1'wa'ix3-1);  				else  					dradf4(ido'l1'c'ch'wa'iw-1'wa'ix2-1'wa'ix3-1);  				goto L110;    			L102: if(ip!=2) goto L104;  				if(na!=0) goto L103;  				  				dradf2(ido'l1'c'ch'wa' iw-1);  				goto L110;    			L103: dradf2(ido'l1'ch'c'wa' iw-1);  				goto L110;    			L104: if(ido==1)na=1-na;  				if(na!=0) goto L109;  				dradfg(ido'ip'l1'idl1'c'c'c'ch'ch'wa'iw-1);  				na=1;  				goto L110;    			L109: dradfg(ido'ip'l1'idl1'ch'ch'ch'c'c'wa'iw-1);  				na=0;  				l2=l1;  				break;    			L110: l2=l1;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,drftf1,The following statement contains a magic number: for(k1=0;k1<nf;k1++)  			{  				kh=nf-k1;  				ip=ifac[kh+1];  				l1=l2/ip;  				ido=n/l2;  				idl1=ido*l1;  				iw-=(ip-1)*ido;  				na=1-na;    				if(ip!=4) goto L102;    				ix2=iw+ido;  				ix3=ix2+ido;  				if(na!=0)  					dradf4(ido'l1'ch'c'wa'iw-1'wa'ix2-1'wa'ix3-1);  				else  					dradf4(ido'l1'c'ch'wa'iw-1'wa'ix2-1'wa'ix3-1);  				goto L110;    			L102: if(ip!=2) goto L104;  				if(na!=0) goto L103;  				  				dradf2(ido'l1'c'ch'wa' iw-1);  				goto L110;    			L103: dradf2(ido'l1'ch'c'wa' iw-1);  				goto L110;    			L104: if(ido==1)na=1-na;  				if(na!=0) goto L109;  				dradfg(ido'ip'l1'idl1'c'c'c'ch'ch'wa'iw-1);  				na=1;  				goto L110;    			L109: dradfg(ido'ip'l1'idl1'ch'ch'ch'c'c'wa'iw-1);  				na=0;  				l2=l1;  				break;    			L110: l2=l1;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: if(ido<2)return;
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: if(ido==2) goto L105;
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t3=t1;  				t5=(t4=t2)+(ido<<1);  				t6=t0+t1;  				for(i=2;i<ido;i+=2)  				{  					t3+=2;  					t4+=2;  					t5-=2;  					t6+=2;  					ch[t3-1]=cc[t4-1]+cc[t5-1];  					tr2=cc[t4-1]-cc[t5-1];  					ch[t3]=cc[t4]-cc[t5];  					ti2=cc[t4]+cc[t5];  					ch[t6-1]=wa1[index+i-2]*tr2-wa1[index+i-1]*ti2;  					ch[t6]=wa1[index+i-2]*ti2+wa1[index+i-1]*tr2;  				}  				t2=(t1+=ido)<<1;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t3=t1;  				t5=(t4=t2)+(ido<<1);  				t6=t0+t1;  				for(i=2;i<ido;i+=2)  				{  					t3+=2;  					t4+=2;  					t5-=2;  					t6+=2;  					ch[t3-1]=cc[t4-1]+cc[t5-1];  					tr2=cc[t4-1]-cc[t5-1];  					ch[t3]=cc[t4]-cc[t5];  					ti2=cc[t4]+cc[t5];  					ch[t6-1]=wa1[index+i-2]*tr2-wa1[index+i-1]*ti2;  					ch[t6]=wa1[index+i-2]*ti2+wa1[index+i-1]*tr2;  				}  				t2=(t1+=ido)<<1;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t3=t1;  				t5=(t4=t2)+(ido<<1);  				t6=t0+t1;  				for(i=2;i<ido;i+=2)  				{  					t3+=2;  					t4+=2;  					t5-=2;  					t6+=2;  					ch[t3-1]=cc[t4-1]+cc[t5-1];  					tr2=cc[t4-1]-cc[t5-1];  					ch[t3]=cc[t4]-cc[t5];  					ti2=cc[t4]+cc[t5];  					ch[t6-1]=wa1[index+i-2]*tr2-wa1[index+i-1]*ti2;  					ch[t6]=wa1[index+i-2]*ti2+wa1[index+i-1]*tr2;  				}  				t2=(t1+=ido)<<1;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t3=t1;  				t5=(t4=t2)+(ido<<1);  				t6=t0+t1;  				for(i=2;i<ido;i+=2)  				{  					t3+=2;  					t4+=2;  					t5-=2;  					t6+=2;  					ch[t3-1]=cc[t4-1]+cc[t5-1];  					tr2=cc[t4-1]-cc[t5-1];  					ch[t3]=cc[t4]-cc[t5];  					ti2=cc[t4]+cc[t5];  					ch[t6-1]=wa1[index+i-2]*tr2-wa1[index+i-1]*ti2;  					ch[t6]=wa1[index+i-2]*ti2+wa1[index+i-1]*tr2;  				}  				t2=(t1+=ido)<<1;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t3=t1;  				t5=(t4=t2)+(ido<<1);  				t6=t0+t1;  				for(i=2;i<ido;i+=2)  				{  					t3+=2;  					t4+=2;  					t5-=2;  					t6+=2;  					ch[t3-1]=cc[t4-1]+cc[t5-1];  					tr2=cc[t4-1]-cc[t5-1];  					ch[t3]=cc[t4]-cc[t5];  					ti2=cc[t4]+cc[t5];  					ch[t6-1]=wa1[index+i-2]*tr2-wa1[index+i-1]*ti2;  					ch[t6]=wa1[index+i-2]*ti2+wa1[index+i-1]*tr2;  				}  				t2=(t1+=ido)<<1;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t3=t1;  				t5=(t4=t2)+(ido<<1);  				t6=t0+t1;  				for(i=2;i<ido;i+=2)  				{  					t3+=2;  					t4+=2;  					t5-=2;  					t6+=2;  					ch[t3-1]=cc[t4-1]+cc[t5-1];  					tr2=cc[t4-1]-cc[t5-1];  					ch[t3]=cc[t4]-cc[t5];  					ti2=cc[t4]+cc[t5];  					ch[t6-1]=wa1[index+i-2]*tr2-wa1[index+i-1]*ti2;  					ch[t6]=wa1[index+i-2]*ti2+wa1[index+i-1]*tr2;  				}  				t2=(t1+=ido)<<1;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t3=t1;  				t5=(t4=t2)+(ido<<1);  				t6=t0+t1;  				for(i=2;i<ido;i+=2)  				{  					t3+=2;  					t4+=2;  					t5-=2;  					t6+=2;  					ch[t3-1]=cc[t4-1]+cc[t5-1];  					tr2=cc[t4-1]-cc[t5-1];  					ch[t3]=cc[t4]-cc[t5];  					ti2=cc[t4]+cc[t5];  					ch[t6-1]=wa1[index+i-2]*tr2-wa1[index+i-1]*ti2;  					ch[t6]=wa1[index+i-2]*ti2+wa1[index+i-1]*tr2;  				}  				t2=(t1+=ido)<<1;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t3=t1;  				t5=(t4=t2)+(ido<<1);  				t6=t0+t1;  				for(i=2;i<ido;i+=2)  				{  					t3+=2;  					t4+=2;  					t5-=2;  					t6+=2;  					ch[t3-1]=cc[t4-1]+cc[t5-1];  					tr2=cc[t4-1]-cc[t5-1];  					ch[t3]=cc[t4]-cc[t5];  					ti2=cc[t4]+cc[t5];  					ch[t6-1]=wa1[index+i-2]*tr2-wa1[index+i-1]*ti2;  					ch[t6]=wa1[index+i-2]*ti2+wa1[index+i-1]*tr2;  				}  				t2=(t1+=ido)<<1;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: if((ido%2)==1)return;
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t7=t1+(t1<<1);  				t6=(t5=t7+t3);  				t8=t1;  				t10=(t9=t1+t0)+t0;    				for(i=2;i<ido;i+=2)  				{  					t5+=2;  					t6-=2;  					t7+=2;  					t8+=2;  					t9+=2;  					t10+=2;  					tr2=cc[t5-1]+cc[t6-1];  					cr2=cc[t7-1]+(taur*tr2);  					ch[t8-1]=cc[t7-1]+tr2;  					ti2=cc[t5]-cc[t6];  					ci2=cc[t7]+(taur*ti2);  					ch[t8]=cc[t7]+ti2;  					cr3=taui*(cc[t5-1]-cc[t6-1]);  					ci3=taui*(cc[t5]+cc[t6]);  					dr2=cr2-ci3;  					dr3=cr2+ci3;  					di2=ci2+cr3;  					di3=ci2-cr3;  					ch[t9-1]=wa1[index1+i-2]*dr2-wa1[index1+i-1]*di2;  					ch[t9]=wa1[index1+i-2]*di2+wa1[index1+i-1]*dr2;  					ch[t10-1]=wa2[index2+i-2]*dr3-wa2[index2+i-1]*di3;  					ch[t10]=wa2[index2+i-2]*di3+wa2[index2+i-1]*dr3;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t7=t1+(t1<<1);  				t6=(t5=t7+t3);  				t8=t1;  				t10=(t9=t1+t0)+t0;    				for(i=2;i<ido;i+=2)  				{  					t5+=2;  					t6-=2;  					t7+=2;  					t8+=2;  					t9+=2;  					t10+=2;  					tr2=cc[t5-1]+cc[t6-1];  					cr2=cc[t7-1]+(taur*tr2);  					ch[t8-1]=cc[t7-1]+tr2;  					ti2=cc[t5]-cc[t6];  					ci2=cc[t7]+(taur*ti2);  					ch[t8]=cc[t7]+ti2;  					cr3=taui*(cc[t5-1]-cc[t6-1]);  					ci3=taui*(cc[t5]+cc[t6]);  					dr2=cr2-ci3;  					dr3=cr2+ci3;  					di2=ci2+cr3;  					di3=ci2-cr3;  					ch[t9-1]=wa1[index1+i-2]*dr2-wa1[index1+i-1]*di2;  					ch[t9]=wa1[index1+i-2]*di2+wa1[index1+i-1]*dr2;  					ch[t10-1]=wa2[index2+i-2]*dr3-wa2[index2+i-1]*di3;  					ch[t10]=wa2[index2+i-2]*di3+wa2[index2+i-1]*dr3;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t7=t1+(t1<<1);  				t6=(t5=t7+t3);  				t8=t1;  				t10=(t9=t1+t0)+t0;    				for(i=2;i<ido;i+=2)  				{  					t5+=2;  					t6-=2;  					t7+=2;  					t8+=2;  					t9+=2;  					t10+=2;  					tr2=cc[t5-1]+cc[t6-1];  					cr2=cc[t7-1]+(taur*tr2);  					ch[t8-1]=cc[t7-1]+tr2;  					ti2=cc[t5]-cc[t6];  					ci2=cc[t7]+(taur*ti2);  					ch[t8]=cc[t7]+ti2;  					cr3=taui*(cc[t5-1]-cc[t6-1]);  					ci3=taui*(cc[t5]+cc[t6]);  					dr2=cr2-ci3;  					dr3=cr2+ci3;  					di2=ci2+cr3;  					di3=ci2-cr3;  					ch[t9-1]=wa1[index1+i-2]*dr2-wa1[index1+i-1]*di2;  					ch[t9]=wa1[index1+i-2]*di2+wa1[index1+i-1]*dr2;  					ch[t10-1]=wa2[index2+i-2]*dr3-wa2[index2+i-1]*di3;  					ch[t10]=wa2[index2+i-2]*di3+wa2[index2+i-1]*dr3;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t7=t1+(t1<<1);  				t6=(t5=t7+t3);  				t8=t1;  				t10=(t9=t1+t0)+t0;    				for(i=2;i<ido;i+=2)  				{  					t5+=2;  					t6-=2;  					t7+=2;  					t8+=2;  					t9+=2;  					t10+=2;  					tr2=cc[t5-1]+cc[t6-1];  					cr2=cc[t7-1]+(taur*tr2);  					ch[t8-1]=cc[t7-1]+tr2;  					ti2=cc[t5]-cc[t6];  					ci2=cc[t7]+(taur*ti2);  					ch[t8]=cc[t7]+ti2;  					cr3=taui*(cc[t5-1]-cc[t6-1]);  					ci3=taui*(cc[t5]+cc[t6]);  					dr2=cr2-ci3;  					dr3=cr2+ci3;  					di2=ci2+cr3;  					di3=ci2-cr3;  					ch[t9-1]=wa1[index1+i-2]*dr2-wa1[index1+i-1]*di2;  					ch[t9]=wa1[index1+i-2]*di2+wa1[index1+i-1]*dr2;  					ch[t10-1]=wa2[index2+i-2]*dr3-wa2[index2+i-1]*di3;  					ch[t10]=wa2[index2+i-2]*di3+wa2[index2+i-1]*dr3;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t7=t1+(t1<<1);  				t6=(t5=t7+t3);  				t8=t1;  				t10=(t9=t1+t0)+t0;    				for(i=2;i<ido;i+=2)  				{  					t5+=2;  					t6-=2;  					t7+=2;  					t8+=2;  					t9+=2;  					t10+=2;  					tr2=cc[t5-1]+cc[t6-1];  					cr2=cc[t7-1]+(taur*tr2);  					ch[t8-1]=cc[t7-1]+tr2;  					ti2=cc[t5]-cc[t6];  					ci2=cc[t7]+(taur*ti2);  					ch[t8]=cc[t7]+ti2;  					cr3=taui*(cc[t5-1]-cc[t6-1]);  					ci3=taui*(cc[t5]+cc[t6]);  					dr2=cr2-ci3;  					dr3=cr2+ci3;  					di2=ci2+cr3;  					di3=ci2-cr3;  					ch[t9-1]=wa1[index1+i-2]*dr2-wa1[index1+i-1]*di2;  					ch[t9]=wa1[index1+i-2]*di2+wa1[index1+i-1]*dr2;  					ch[t10-1]=wa2[index2+i-2]*dr3-wa2[index2+i-1]*di3;  					ch[t10]=wa2[index2+i-2]*di3+wa2[index2+i-1]*dr3;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t7=t1+(t1<<1);  				t6=(t5=t7+t3);  				t8=t1;  				t10=(t9=t1+t0)+t0;    				for(i=2;i<ido;i+=2)  				{  					t5+=2;  					t6-=2;  					t7+=2;  					t8+=2;  					t9+=2;  					t10+=2;  					tr2=cc[t5-1]+cc[t6-1];  					cr2=cc[t7-1]+(taur*tr2);  					ch[t8-1]=cc[t7-1]+tr2;  					ti2=cc[t5]-cc[t6];  					ci2=cc[t7]+(taur*ti2);  					ch[t8]=cc[t7]+ti2;  					cr3=taui*(cc[t5-1]-cc[t6-1]);  					ci3=taui*(cc[t5]+cc[t6]);  					dr2=cr2-ci3;  					dr3=cr2+ci3;  					di2=ci2+cr3;  					di3=ci2-cr3;  					ch[t9-1]=wa1[index1+i-2]*dr2-wa1[index1+i-1]*di2;  					ch[t9]=wa1[index1+i-2]*di2+wa1[index1+i-1]*dr2;  					ch[t10-1]=wa2[index2+i-2]*dr3-wa2[index2+i-1]*di3;  					ch[t10]=wa2[index2+i-2]*di3+wa2[index2+i-1]*dr3;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t7=t1+(t1<<1);  				t6=(t5=t7+t3);  				t8=t1;  				t10=(t9=t1+t0)+t0;    				for(i=2;i<ido;i+=2)  				{  					t5+=2;  					t6-=2;  					t7+=2;  					t8+=2;  					t9+=2;  					t10+=2;  					tr2=cc[t5-1]+cc[t6-1];  					cr2=cc[t7-1]+(taur*tr2);  					ch[t8-1]=cc[t7-1]+tr2;  					ti2=cc[t5]-cc[t6];  					ci2=cc[t7]+(taur*ti2);  					ch[t8]=cc[t7]+ti2;  					cr3=taui*(cc[t5-1]-cc[t6-1]);  					ci3=taui*(cc[t5]+cc[t6]);  					dr2=cr2-ci3;  					dr3=cr2+ci3;  					di2=ci2+cr3;  					di3=ci2-cr3;  					ch[t9-1]=wa1[index1+i-2]*dr2-wa1[index1+i-1]*di2;  					ch[t9]=wa1[index1+i-2]*di2+wa1[index1+i-1]*dr2;  					ch[t10-1]=wa2[index2+i-2]*dr3-wa2[index2+i-1]*di3;  					ch[t10]=wa2[index2+i-2]*di3+wa2[index2+i-1]*dr3;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t7=t1+(t1<<1);  				t6=(t5=t7+t3);  				t8=t1;  				t10=(t9=t1+t0)+t0;    				for(i=2;i<ido;i+=2)  				{  					t5+=2;  					t6-=2;  					t7+=2;  					t8+=2;  					t9+=2;  					t10+=2;  					tr2=cc[t5-1]+cc[t6-1];  					cr2=cc[t7-1]+(taur*tr2);  					ch[t8-1]=cc[t7-1]+tr2;  					ti2=cc[t5]-cc[t6];  					ci2=cc[t7]+(taur*ti2);  					ch[t8]=cc[t7]+ti2;  					cr3=taui*(cc[t5-1]-cc[t6-1]);  					ci3=taui*(cc[t5]+cc[t6]);  					dr2=cr2-ci3;  					dr3=cr2+ci3;  					di2=ci2+cr3;  					di3=ci2-cr3;  					ch[t9-1]=wa1[index1+i-2]*dr2-wa1[index1+i-1]*di2;  					ch[t9]=wa1[index1+i-2]*di2+wa1[index1+i-1]*dr2;  					ch[t10-1]=wa2[index2+i-2]*dr3-wa2[index2+i-1]*di3;  					ch[t10]=wa2[index2+i-2]*di3+wa2[index2+i-1]*dr3;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t7=t1+(t1<<1);  				t6=(t5=t7+t3);  				t8=t1;  				t10=(t9=t1+t0)+t0;    				for(i=2;i<ido;i+=2)  				{  					t5+=2;  					t6-=2;  					t7+=2;  					t8+=2;  					t9+=2;  					t10+=2;  					tr2=cc[t5-1]+cc[t6-1];  					cr2=cc[t7-1]+(taur*tr2);  					ch[t8-1]=cc[t7-1]+tr2;  					ti2=cc[t5]-cc[t6];  					ci2=cc[t7]+(taur*ti2);  					ch[t8]=cc[t7]+ti2;  					cr3=taui*(cc[t5-1]-cc[t6-1]);  					ci3=taui*(cc[t5]+cc[t6]);  					dr2=cr2-ci3;  					dr3=cr2+ci3;  					di2=ci2+cr3;  					di3=ci2-cr3;  					ch[t9-1]=wa1[index1+i-2]*dr2-wa1[index1+i-1]*di2;  					ch[t9]=wa1[index1+i-2]*di2+wa1[index1+i-1]*dr2;  					ch[t10-1]=wa2[index2+i-2]*dr3-wa2[index2+i-1]*di3;  					ch[t10]=wa2[index2+i-2]*di3+wa2[index2+i-1]*dr3;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t7=t1+(t1<<1);  				t6=(t5=t7+t3);  				t8=t1;  				t10=(t9=t1+t0)+t0;    				for(i=2;i<ido;i+=2)  				{  					t5+=2;  					t6-=2;  					t7+=2;  					t8+=2;  					t9+=2;  					t10+=2;  					tr2=cc[t5-1]+cc[t6-1];  					cr2=cc[t7-1]+(taur*tr2);  					ch[t8-1]=cc[t7-1]+tr2;  					ti2=cc[t5]-cc[t6];  					ci2=cc[t7]+(taur*ti2);  					ch[t8]=cc[t7]+ti2;  					cr3=taui*(cc[t5-1]-cc[t6-1]);  					ci3=taui*(cc[t5]+cc[t6]);  					dr2=cr2-ci3;  					dr3=cr2+ci3;  					di2=ci2+cr3;  					di3=ci2-cr3;  					ch[t9-1]=wa1[index1+i-2]*dr2-wa1[index1+i-1]*di2;  					ch[t9]=wa1[index1+i-2]*di2+wa1[index1+i-1]*dr2;  					ch[t10-1]=wa2[index2+i-2]*dr3-wa2[index2+i-1]*di3;  					ch[t10]=wa2[index2+i-2]*di3+wa2[index2+i-1]*dr3;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t7=t1+(t1<<1);  				t6=(t5=t7+t3);  				t8=t1;  				t10=(t9=t1+t0)+t0;    				for(i=2;i<ido;i+=2)  				{  					t5+=2;  					t6-=2;  					t7+=2;  					t8+=2;  					t9+=2;  					t10+=2;  					tr2=cc[t5-1]+cc[t6-1];  					cr2=cc[t7-1]+(taur*tr2);  					ch[t8-1]=cc[t7-1]+tr2;  					ti2=cc[t5]-cc[t6];  					ci2=cc[t7]+(taur*ti2);  					ch[t8]=cc[t7]+ti2;  					cr3=taui*(cc[t5-1]-cc[t6-1]);  					ci3=taui*(cc[t5]+cc[t6]);  					dr2=cr2-ci3;  					dr3=cr2+ci3;  					di2=ci2+cr3;  					di3=ci2-cr3;  					ch[t9-1]=wa1[index1+i-2]*dr2-wa1[index1+i-1]*di2;  					ch[t9]=wa1[index1+i-2]*di2+wa1[index1+i-1]*dr2;  					ch[t10-1]=wa2[index2+i-2]*dr3-wa2[index2+i-1]*di3;  					ch[t10]=wa2[index2+i-2]*di3+wa2[index2+i-1]*dr3;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t7=t1+(t1<<1);  				t6=(t5=t7+t3);  				t8=t1;  				t10=(t9=t1+t0)+t0;    				for(i=2;i<ido;i+=2)  				{  					t5+=2;  					t6-=2;  					t7+=2;  					t8+=2;  					t9+=2;  					t10+=2;  					tr2=cc[t5-1]+cc[t6-1];  					cr2=cc[t7-1]+(taur*tr2);  					ch[t8-1]=cc[t7-1]+tr2;  					ti2=cc[t5]-cc[t6];  					ci2=cc[t7]+(taur*ti2);  					ch[t8]=cc[t7]+ti2;  					cr3=taui*(cc[t5-1]-cc[t6-1]);  					ci3=taui*(cc[t5]+cc[t6]);  					dr2=cr2-ci3;  					dr3=cr2+ci3;  					di2=ci2+cr3;  					di3=ci2-cr3;  					ch[t9-1]=wa1[index1+i-2]*dr2-wa1[index1+i-1]*di2;  					ch[t9]=wa1[index1+i-2]*di2+wa1[index1+i-1]*dr2;  					ch[t10-1]=wa2[index2+i-2]*dr3-wa2[index2+i-1]*di3;  					ch[t10]=wa2[index2+i-2]*di3+wa2[index2+i-1]*dr3;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: t2=ido<<2;
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: if(ido<2)return;
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: if(ido==2) goto L105;
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t5=(t4=(t3=(t2=t1<<2)+t6))+t6;  				t7=t1;  				for(i=2;i<ido;i+=2)  				{  					t2+=2;  					t3+=2;  					t4-=2;  					t5-=2;  					t7+=2;  					ti1=cc[t2]+cc[t5];  					ti2=cc[t2]-cc[t5];  					ti3=cc[t3]-cc[t4];  					tr4=cc[t3]+cc[t4];  					tr1=cc[t2-1]-cc[t5-1];  					tr2=cc[t2-1]+cc[t5-1];  					ti4=cc[t3-1]-cc[t4-1];  					tr3=cc[t3-1]+cc[t4-1];  					ch[t7-1]=tr2+tr3;  					cr3=tr2-tr3;  					ch[t7]=ti2+ti3;  					ci3=ti2-ti3;  					cr2=tr1-tr4;  					cr4=tr1+tr4;  					ci2=ti1+ti4;  					ci4=ti1-ti4;    					ch[(t8=t7+t0)-1]=wa1[index1+i-2]*cr2-wa1[index1+i-1]*ci2;  					ch[t8]=wa1[index1+i-2]*ci2+wa1[index1+i-1]*cr2;  					ch[(t8+=t0)-1]=wa2[index2+i-2]*cr3-wa2[index2+i-1]*ci3;  					ch[t8]=wa2[index2+i-2]*ci3+wa2[index2+i-1]*cr3;  					ch[(t8+=t0)-1]=wa3[index3+i-2]*cr4-wa3[index3+i-1]*ci4;  					ch[t8]=wa3[index3+i-2]*ci4+wa3[index3+i-1]*cr4;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t5=(t4=(t3=(t2=t1<<2)+t6))+t6;  				t7=t1;  				for(i=2;i<ido;i+=2)  				{  					t2+=2;  					t3+=2;  					t4-=2;  					t5-=2;  					t7+=2;  					ti1=cc[t2]+cc[t5];  					ti2=cc[t2]-cc[t5];  					ti3=cc[t3]-cc[t4];  					tr4=cc[t3]+cc[t4];  					tr1=cc[t2-1]-cc[t5-1];  					tr2=cc[t2-1]+cc[t5-1];  					ti4=cc[t3-1]-cc[t4-1];  					tr3=cc[t3-1]+cc[t4-1];  					ch[t7-1]=tr2+tr3;  					cr3=tr2-tr3;  					ch[t7]=ti2+ti3;  					ci3=ti2-ti3;  					cr2=tr1-tr4;  					cr4=tr1+tr4;  					ci2=ti1+ti4;  					ci4=ti1-ti4;    					ch[(t8=t7+t0)-1]=wa1[index1+i-2]*cr2-wa1[index1+i-1]*ci2;  					ch[t8]=wa1[index1+i-2]*ci2+wa1[index1+i-1]*cr2;  					ch[(t8+=t0)-1]=wa2[index2+i-2]*cr3-wa2[index2+i-1]*ci3;  					ch[t8]=wa2[index2+i-2]*ci3+wa2[index2+i-1]*cr3;  					ch[(t8+=t0)-1]=wa3[index3+i-2]*cr4-wa3[index3+i-1]*ci4;  					ch[t8]=wa3[index3+i-2]*ci4+wa3[index3+i-1]*cr4;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t5=(t4=(t3=(t2=t1<<2)+t6))+t6;  				t7=t1;  				for(i=2;i<ido;i+=2)  				{  					t2+=2;  					t3+=2;  					t4-=2;  					t5-=2;  					t7+=2;  					ti1=cc[t2]+cc[t5];  					ti2=cc[t2]-cc[t5];  					ti3=cc[t3]-cc[t4];  					tr4=cc[t3]+cc[t4];  					tr1=cc[t2-1]-cc[t5-1];  					tr2=cc[t2-1]+cc[t5-1];  					ti4=cc[t3-1]-cc[t4-1];  					tr3=cc[t3-1]+cc[t4-1];  					ch[t7-1]=tr2+tr3;  					cr3=tr2-tr3;  					ch[t7]=ti2+ti3;  					ci3=ti2-ti3;  					cr2=tr1-tr4;  					cr4=tr1+tr4;  					ci2=ti1+ti4;  					ci4=ti1-ti4;    					ch[(t8=t7+t0)-1]=wa1[index1+i-2]*cr2-wa1[index1+i-1]*ci2;  					ch[t8]=wa1[index1+i-2]*ci2+wa1[index1+i-1]*cr2;  					ch[(t8+=t0)-1]=wa2[index2+i-2]*cr3-wa2[index2+i-1]*ci3;  					ch[t8]=wa2[index2+i-2]*ci3+wa2[index2+i-1]*cr3;  					ch[(t8+=t0)-1]=wa3[index3+i-2]*cr4-wa3[index3+i-1]*ci4;  					ch[t8]=wa3[index3+i-2]*ci4+wa3[index3+i-1]*cr4;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t5=(t4=(t3=(t2=t1<<2)+t6))+t6;  				t7=t1;  				for(i=2;i<ido;i+=2)  				{  					t2+=2;  					t3+=2;  					t4-=2;  					t5-=2;  					t7+=2;  					ti1=cc[t2]+cc[t5];  					ti2=cc[t2]-cc[t5];  					ti3=cc[t3]-cc[t4];  					tr4=cc[t3]+cc[t4];  					tr1=cc[t2-1]-cc[t5-1];  					tr2=cc[t2-1]+cc[t5-1];  					ti4=cc[t3-1]-cc[t4-1];  					tr3=cc[t3-1]+cc[t4-1];  					ch[t7-1]=tr2+tr3;  					cr3=tr2-tr3;  					ch[t7]=ti2+ti3;  					ci3=ti2-ti3;  					cr2=tr1-tr4;  					cr4=tr1+tr4;  					ci2=ti1+ti4;  					ci4=ti1-ti4;    					ch[(t8=t7+t0)-1]=wa1[index1+i-2]*cr2-wa1[index1+i-1]*ci2;  					ch[t8]=wa1[index1+i-2]*ci2+wa1[index1+i-1]*cr2;  					ch[(t8+=t0)-1]=wa2[index2+i-2]*cr3-wa2[index2+i-1]*ci3;  					ch[t8]=wa2[index2+i-2]*ci3+wa2[index2+i-1]*cr3;  					ch[(t8+=t0)-1]=wa3[index3+i-2]*cr4-wa3[index3+i-1]*ci4;  					ch[t8]=wa3[index3+i-2]*ci4+wa3[index3+i-1]*cr4;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t5=(t4=(t3=(t2=t1<<2)+t6))+t6;  				t7=t1;  				for(i=2;i<ido;i+=2)  				{  					t2+=2;  					t3+=2;  					t4-=2;  					t5-=2;  					t7+=2;  					ti1=cc[t2]+cc[t5];  					ti2=cc[t2]-cc[t5];  					ti3=cc[t3]-cc[t4];  					tr4=cc[t3]+cc[t4];  					tr1=cc[t2-1]-cc[t5-1];  					tr2=cc[t2-1]+cc[t5-1];  					ti4=cc[t3-1]-cc[t4-1];  					tr3=cc[t3-1]+cc[t4-1];  					ch[t7-1]=tr2+tr3;  					cr3=tr2-tr3;  					ch[t7]=ti2+ti3;  					ci3=ti2-ti3;  					cr2=tr1-tr4;  					cr4=tr1+tr4;  					ci2=ti1+ti4;  					ci4=ti1-ti4;    					ch[(t8=t7+t0)-1]=wa1[index1+i-2]*cr2-wa1[index1+i-1]*ci2;  					ch[t8]=wa1[index1+i-2]*ci2+wa1[index1+i-1]*cr2;  					ch[(t8+=t0)-1]=wa2[index2+i-2]*cr3-wa2[index2+i-1]*ci3;  					ch[t8]=wa2[index2+i-2]*ci3+wa2[index2+i-1]*cr3;  					ch[(t8+=t0)-1]=wa3[index3+i-2]*cr4-wa3[index3+i-1]*ci4;  					ch[t8]=wa3[index3+i-2]*ci4+wa3[index3+i-1]*cr4;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t5=(t4=(t3=(t2=t1<<2)+t6))+t6;  				t7=t1;  				for(i=2;i<ido;i+=2)  				{  					t2+=2;  					t3+=2;  					t4-=2;  					t5-=2;  					t7+=2;  					ti1=cc[t2]+cc[t5];  					ti2=cc[t2]-cc[t5];  					ti3=cc[t3]-cc[t4];  					tr4=cc[t3]+cc[t4];  					tr1=cc[t2-1]-cc[t5-1];  					tr2=cc[t2-1]+cc[t5-1];  					ti4=cc[t3-1]-cc[t4-1];  					tr3=cc[t3-1]+cc[t4-1];  					ch[t7-1]=tr2+tr3;  					cr3=tr2-tr3;  					ch[t7]=ti2+ti3;  					ci3=ti2-ti3;  					cr2=tr1-tr4;  					cr4=tr1+tr4;  					ci2=ti1+ti4;  					ci4=ti1-ti4;    					ch[(t8=t7+t0)-1]=wa1[index1+i-2]*cr2-wa1[index1+i-1]*ci2;  					ch[t8]=wa1[index1+i-2]*ci2+wa1[index1+i-1]*cr2;  					ch[(t8+=t0)-1]=wa2[index2+i-2]*cr3-wa2[index2+i-1]*ci3;  					ch[t8]=wa2[index2+i-2]*ci3+wa2[index2+i-1]*cr3;  					ch[(t8+=t0)-1]=wa3[index3+i-2]*cr4-wa3[index3+i-1]*ci4;  					ch[t8]=wa3[index3+i-2]*ci4+wa3[index3+i-1]*cr4;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t5=(t4=(t3=(t2=t1<<2)+t6))+t6;  				t7=t1;  				for(i=2;i<ido;i+=2)  				{  					t2+=2;  					t3+=2;  					t4-=2;  					t5-=2;  					t7+=2;  					ti1=cc[t2]+cc[t5];  					ti2=cc[t2]-cc[t5];  					ti3=cc[t3]-cc[t4];  					tr4=cc[t3]+cc[t4];  					tr1=cc[t2-1]-cc[t5-1];  					tr2=cc[t2-1]+cc[t5-1];  					ti4=cc[t3-1]-cc[t4-1];  					tr3=cc[t3-1]+cc[t4-1];  					ch[t7-1]=tr2+tr3;  					cr3=tr2-tr3;  					ch[t7]=ti2+ti3;  					ci3=ti2-ti3;  					cr2=tr1-tr4;  					cr4=tr1+tr4;  					ci2=ti1+ti4;  					ci4=ti1-ti4;    					ch[(t8=t7+t0)-1]=wa1[index1+i-2]*cr2-wa1[index1+i-1]*ci2;  					ch[t8]=wa1[index1+i-2]*ci2+wa1[index1+i-1]*cr2;  					ch[(t8+=t0)-1]=wa2[index2+i-2]*cr3-wa2[index2+i-1]*ci3;  					ch[t8]=wa2[index2+i-2]*ci3+wa2[index2+i-1]*cr3;  					ch[(t8+=t0)-1]=wa3[index3+i-2]*cr4-wa3[index3+i-1]*ci4;  					ch[t8]=wa3[index3+i-2]*ci4+wa3[index3+i-1]*cr4;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t5=(t4=(t3=(t2=t1<<2)+t6))+t6;  				t7=t1;  				for(i=2;i<ido;i+=2)  				{  					t2+=2;  					t3+=2;  					t4-=2;  					t5-=2;  					t7+=2;  					ti1=cc[t2]+cc[t5];  					ti2=cc[t2]-cc[t5];  					ti3=cc[t3]-cc[t4];  					tr4=cc[t3]+cc[t4];  					tr1=cc[t2-1]-cc[t5-1];  					tr2=cc[t2-1]+cc[t5-1];  					ti4=cc[t3-1]-cc[t4-1];  					tr3=cc[t3-1]+cc[t4-1];  					ch[t7-1]=tr2+tr3;  					cr3=tr2-tr3;  					ch[t7]=ti2+ti3;  					ci3=ti2-ti3;  					cr2=tr1-tr4;  					cr4=tr1+tr4;  					ci2=ti1+ti4;  					ci4=ti1-ti4;    					ch[(t8=t7+t0)-1]=wa1[index1+i-2]*cr2-wa1[index1+i-1]*ci2;  					ch[t8]=wa1[index1+i-2]*ci2+wa1[index1+i-1]*cr2;  					ch[(t8+=t0)-1]=wa2[index2+i-2]*cr3-wa2[index2+i-1]*ci3;  					ch[t8]=wa2[index2+i-2]*ci3+wa2[index2+i-1]*cr3;  					ch[(t8+=t0)-1]=wa3[index3+i-2]*cr4-wa3[index3+i-1]*ci4;  					ch[t8]=wa3[index3+i-2]*ci4+wa3[index3+i-1]*cr4;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t5=(t4=(t3=(t2=t1<<2)+t6))+t6;  				t7=t1;  				for(i=2;i<ido;i+=2)  				{  					t2+=2;  					t3+=2;  					t4-=2;  					t5-=2;  					t7+=2;  					ti1=cc[t2]+cc[t5];  					ti2=cc[t2]-cc[t5];  					ti3=cc[t3]-cc[t4];  					tr4=cc[t3]+cc[t4];  					tr1=cc[t2-1]-cc[t5-1];  					tr2=cc[t2-1]+cc[t5-1];  					ti4=cc[t3-1]-cc[t4-1];  					tr3=cc[t3-1]+cc[t4-1];  					ch[t7-1]=tr2+tr3;  					cr3=tr2-tr3;  					ch[t7]=ti2+ti3;  					ci3=ti2-ti3;  					cr2=tr1-tr4;  					cr4=tr1+tr4;  					ci2=ti1+ti4;  					ci4=ti1-ti4;    					ch[(t8=t7+t0)-1]=wa1[index1+i-2]*cr2-wa1[index1+i-1]*ci2;  					ch[t8]=wa1[index1+i-2]*ci2+wa1[index1+i-1]*cr2;  					ch[(t8+=t0)-1]=wa2[index2+i-2]*cr3-wa2[index2+i-1]*ci3;  					ch[t8]=wa2[index2+i-2]*ci3+wa2[index2+i-1]*cr3;  					ch[(t8+=t0)-1]=wa3[index3+i-2]*cr4-wa3[index3+i-1]*ci4;  					ch[t8]=wa3[index3+i-2]*ci4+wa3[index3+i-1]*cr4;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t5=(t4=(t3=(t2=t1<<2)+t6))+t6;  				t7=t1;  				for(i=2;i<ido;i+=2)  				{  					t2+=2;  					t3+=2;  					t4-=2;  					t5-=2;  					t7+=2;  					ti1=cc[t2]+cc[t5];  					ti2=cc[t2]-cc[t5];  					ti3=cc[t3]-cc[t4];  					tr4=cc[t3]+cc[t4];  					tr1=cc[t2-1]-cc[t5-1];  					tr2=cc[t2-1]+cc[t5-1];  					ti4=cc[t3-1]-cc[t4-1];  					tr3=cc[t3-1]+cc[t4-1];  					ch[t7-1]=tr2+tr3;  					cr3=tr2-tr3;  					ch[t7]=ti2+ti3;  					ci3=ti2-ti3;  					cr2=tr1-tr4;  					cr4=tr1+tr4;  					ci2=ti1+ti4;  					ci4=ti1-ti4;    					ch[(t8=t7+t0)-1]=wa1[index1+i-2]*cr2-wa1[index1+i-1]*ci2;  					ch[t8]=wa1[index1+i-2]*ci2+wa1[index1+i-1]*cr2;  					ch[(t8+=t0)-1]=wa2[index2+i-2]*cr3-wa2[index2+i-1]*ci3;  					ch[t8]=wa2[index2+i-2]*ci3+wa2[index2+i-1]*cr3;  					ch[(t8+=t0)-1]=wa3[index3+i-2]*cr4-wa3[index3+i-1]*ci4;  					ch[t8]=wa3[index3+i-2]*ci4+wa3[index3+i-1]*cr4;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t5=(t4=(t3=(t2=t1<<2)+t6))+t6;  				t7=t1;  				for(i=2;i<ido;i+=2)  				{  					t2+=2;  					t3+=2;  					t4-=2;  					t5-=2;  					t7+=2;  					ti1=cc[t2]+cc[t5];  					ti2=cc[t2]-cc[t5];  					ti3=cc[t3]-cc[t4];  					tr4=cc[t3]+cc[t4];  					tr1=cc[t2-1]-cc[t5-1];  					tr2=cc[t2-1]+cc[t5-1];  					ti4=cc[t3-1]-cc[t4-1];  					tr3=cc[t3-1]+cc[t4-1];  					ch[t7-1]=tr2+tr3;  					cr3=tr2-tr3;  					ch[t7]=ti2+ti3;  					ci3=ti2-ti3;  					cr2=tr1-tr4;  					cr4=tr1+tr4;  					ci2=ti1+ti4;  					ci4=ti1-ti4;    					ch[(t8=t7+t0)-1]=wa1[index1+i-2]*cr2-wa1[index1+i-1]*ci2;  					ch[t8]=wa1[index1+i-2]*ci2+wa1[index1+i-1]*cr2;  					ch[(t8+=t0)-1]=wa2[index2+i-2]*cr3-wa2[index2+i-1]*ci3;  					ch[t8]=wa2[index2+i-2]*ci3+wa2[index2+i-1]*cr3;  					ch[(t8+=t0)-1]=wa3[index3+i-2]*cr4-wa3[index3+i-1]*ci4;  					ch[t8]=wa3[index3+i-2]*ci4+wa3[index3+i-1]*cr4;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t5=(t4=(t3=(t2=t1<<2)+t6))+t6;  				t7=t1;  				for(i=2;i<ido;i+=2)  				{  					t2+=2;  					t3+=2;  					t4-=2;  					t5-=2;  					t7+=2;  					ti1=cc[t2]+cc[t5];  					ti2=cc[t2]-cc[t5];  					ti3=cc[t3]-cc[t4];  					tr4=cc[t3]+cc[t4];  					tr1=cc[t2-1]-cc[t5-1];  					tr2=cc[t2-1]+cc[t5-1];  					ti4=cc[t3-1]-cc[t4-1];  					tr3=cc[t3-1]+cc[t4-1];  					ch[t7-1]=tr2+tr3;  					cr3=tr2-tr3;  					ch[t7]=ti2+ti3;  					ci3=ti2-ti3;  					cr2=tr1-tr4;  					cr4=tr1+tr4;  					ci2=ti1+ti4;  					ci4=ti1-ti4;    					ch[(t8=t7+t0)-1]=wa1[index1+i-2]*cr2-wa1[index1+i-1]*ci2;  					ch[t8]=wa1[index1+i-2]*ci2+wa1[index1+i-1]*cr2;  					ch[(t8+=t0)-1]=wa2[index2+i-2]*cr3-wa2[index2+i-1]*ci3;  					ch[t8]=wa2[index2+i-2]*ci3+wa2[index2+i-1]*cr3;  					ch[(t8+=t0)-1]=wa3[index3+i-2]*cr4-wa3[index3+i-1]*ci4;  					ch[t8]=wa3[index3+i-2]*ci4+wa3[index3+i-1]*cr4;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t5=(t4=(t3=(t2=t1<<2)+t6))+t6;  				t7=t1;  				for(i=2;i<ido;i+=2)  				{  					t2+=2;  					t3+=2;  					t4-=2;  					t5-=2;  					t7+=2;  					ti1=cc[t2]+cc[t5];  					ti2=cc[t2]-cc[t5];  					ti3=cc[t3]-cc[t4];  					tr4=cc[t3]+cc[t4];  					tr1=cc[t2-1]-cc[t5-1];  					tr2=cc[t2-1]+cc[t5-1];  					ti4=cc[t3-1]-cc[t4-1];  					tr3=cc[t3-1]+cc[t4-1];  					ch[t7-1]=tr2+tr3;  					cr3=tr2-tr3;  					ch[t7]=ti2+ti3;  					ci3=ti2-ti3;  					cr2=tr1-tr4;  					cr4=tr1+tr4;  					ci2=ti1+ti4;  					ci4=ti1-ti4;    					ch[(t8=t7+t0)-1]=wa1[index1+i-2]*cr2-wa1[index1+i-1]*ci2;  					ch[t8]=wa1[index1+i-2]*ci2+wa1[index1+i-1]*cr2;  					ch[(t8+=t0)-1]=wa2[index2+i-2]*cr3-wa2[index2+i-1]*ci3;  					ch[t8]=wa2[index2+i-2]*ci3+wa2[index2+i-1]*cr3;  					ch[(t8+=t0)-1]=wa3[index3+i-2]*cr4-wa3[index3+i-1]*ci4;  					ch[t8]=wa3[index3+i-2]*ci4+wa3[index3+i-1]*cr4;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for(k=0;k<l1;k++)  			{  				t5=(t4=(t3=(t2=t1<<2)+t6))+t6;  				t7=t1;  				for(i=2;i<ido;i+=2)  				{  					t2+=2;  					t3+=2;  					t4-=2;  					t5-=2;  					t7+=2;  					ti1=cc[t2]+cc[t5];  					ti2=cc[t2]-cc[t5];  					ti3=cc[t3]-cc[t4];  					tr4=cc[t3]+cc[t4];  					tr1=cc[t2-1]-cc[t5-1];  					tr2=cc[t2-1]+cc[t5-1];  					ti4=cc[t3-1]-cc[t4-1];  					tr3=cc[t3-1]+cc[t4-1];  					ch[t7-1]=tr2+tr3;  					cr3=tr2-tr3;  					ch[t7]=ti2+ti3;  					ci3=ti2-ti3;  					cr2=tr1-tr4;  					cr4=tr1+tr4;  					ci2=ti1+ti4;  					ci4=ti1-ti4;    					ch[(t8=t7+t0)-1]=wa1[index1+i-2]*cr2-wa1[index1+i-1]*ci2;  					ch[t8]=wa1[index1+i-2]*ci2+wa1[index1+i-1]*cr2;  					ch[(t8+=t0)-1]=wa2[index2+i-2]*cr3-wa2[index2+i-1]*ci3;  					ch[t8]=wa2[index2+i-2]*ci3+wa2[index2+i-1]*cr3;  					ch[(t8+=t0)-1]=wa3[index3+i-2]*cr4-wa3[index3+i-1]*ci4;  					ch[t8]=wa3[index3+i-2]*ci4+wa3[index3+i-1]*cr4;  				}  				t1+=ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: if(ido%2 == 1)return;
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: t2=ido<<2;
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for(j=1;j<ipph;j++)  			{  				t1+=t0;  				t2-=t0;  				t3=t1;  				t4=t2;    				t7+=(ido<<1);  				t8=t7;  				for(k=0;k<l1;k++)  				{  					t5=t3;  					t6=t4;  					t9=t8;  					t11=t8;  					for(i=2;i<ido;i+=2)  					{  						t5+=2;  						t6+=2;  						t9+=2;  						t11-=2;  						ch[t5-1]=cc[t9-1]+cc[t11-1];  						ch[t6-1]=cc[t9-1]-cc[t11-1];  						ch[t5]=cc[t9]-cc[t11];  						ch[t6]=cc[t9]+cc[t11];  					}  					t3+=ido;  					t4+=ido;  					t8+=t10;  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for(j=1;j<ipph;j++)  			{  				t1+=t0;  				t2-=t0;  				t3=t1;  				t4=t2;    				t7+=(ido<<1);  				t8=t7;  				for(k=0;k<l1;k++)  				{  					t5=t3;  					t6=t4;  					t9=t8;  					t11=t8;  					for(i=2;i<ido;i+=2)  					{  						t5+=2;  						t6+=2;  						t9+=2;  						t11-=2;  						ch[t5-1]=cc[t9-1]+cc[t11-1];  						ch[t6-1]=cc[t9-1]-cc[t11-1];  						ch[t5]=cc[t9]-cc[t11];  						ch[t6]=cc[t9]+cc[t11];  					}  					t3+=ido;  					t4+=ido;  					t8+=t10;  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for(j=1;j<ipph;j++)  			{  				t1+=t0;  				t2-=t0;  				t3=t1;  				t4=t2;    				t7+=(ido<<1);  				t8=t7;  				for(k=0;k<l1;k++)  				{  					t5=t3;  					t6=t4;  					t9=t8;  					t11=t8;  					for(i=2;i<ido;i+=2)  					{  						t5+=2;  						t6+=2;  						t9+=2;  						t11-=2;  						ch[t5-1]=cc[t9-1]+cc[t11-1];  						ch[t6-1]=cc[t9-1]-cc[t11-1];  						ch[t5]=cc[t9]-cc[t11];  						ch[t6]=cc[t9]+cc[t11];  					}  					t3+=ido;  					t4+=ido;  					t8+=t10;  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for(j=1;j<ipph;j++)  			{  				t1+=t0;  				t2-=t0;  				t3=t1;  				t4=t2;    				t7+=(ido<<1);  				t8=t7;  				for(k=0;k<l1;k++)  				{  					t5=t3;  					t6=t4;  					t9=t8;  					t11=t8;  					for(i=2;i<ido;i+=2)  					{  						t5+=2;  						t6+=2;  						t9+=2;  						t11-=2;  						ch[t5-1]=cc[t9-1]+cc[t11-1];  						ch[t6-1]=cc[t9-1]-cc[t11-1];  						ch[t5]=cc[t9]-cc[t11];  						ch[t6]=cc[t9]+cc[t11];  					}  					t3+=ido;  					t4+=ido;  					t8+=t10;  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for(j=1;j<ipph;j++)  			{  				t1+=t0;  				t2-=t0;  				t3=t1;  				t4=t2;    				t7+=(ido<<1);  				t8=t7;  				for(k=0;k<l1;k++)  				{  					t5=t3;  					t6=t4;  					t9=t8;  					t11=t8;  					for(i=2;i<ido;i+=2)  					{  						t5+=2;  						t6+=2;  						t9+=2;  						t11-=2;  						ch[t5-1]=cc[t9-1]+cc[t11-1];  						ch[t6-1]=cc[t9-1]-cc[t11-1];  						ch[t5]=cc[t9]-cc[t11];  						ch[t6]=cc[t9]+cc[t11];  					}  					t3+=ido;  					t4+=ido;  					t8+=t10;  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for(j=1;j<ipph;j++)  			{  				t1+=t0;  				t2-=t0;  				t3=t1;  				t4=t2;    				t7+=(ido<<1);  				t8=t7;  				for(k=0;k<l1;k++)  				{  					t5=t3;  					t6=t4;  					t9=t8;  					t11=t8;  					for(i=2;i<ido;i+=2)  					{  						t5+=2;  						t6+=2;  						t9+=2;  						t11-=2;  						ch[t5-1]=cc[t9-1]+cc[t11-1];  						ch[t6-1]=cc[t9-1]-cc[t11-1];  						ch[t5]=cc[t9]-cc[t11];  						ch[t6]=cc[t9]+cc[t11];  					}  					t3+=ido;  					t4+=ido;  					t8+=t10;  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for(j=1;j<ipph;j++)  			{  				t1+=t0;  				t2-=t0;  				t3=t1;  				t4=t2;  				t7+=(ido<<1);  				t8=t7;  				t9=t7;  				for(i=2;i<ido;i+=2)  				{  					t3+=2;  					t4+=2;  					t8+=2;  					t9-=2;  					t5=t3;  					t6=t4;  					t11=t8;  					t12=t9;  					for(k=0;k<l1;k++)  					{  						ch[t5-1]=cc[t11-1]+cc[t12-1];  						ch[t6-1]=cc[t11-1]-cc[t12-1];  						ch[t5]=cc[t11]-cc[t12];  						ch[t6]=cc[t11]+cc[t12];  						t5+=ido;  						t6+=ido;  						t11+=t10;  						t12+=t10;  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for(j=1;j<ipph;j++)  			{  				t1+=t0;  				t2-=t0;  				t3=t1;  				t4=t2;  				t7+=(ido<<1);  				t8=t7;  				t9=t7;  				for(i=2;i<ido;i+=2)  				{  					t3+=2;  					t4+=2;  					t8+=2;  					t9-=2;  					t5=t3;  					t6=t4;  					t11=t8;  					t12=t9;  					for(k=0;k<l1;k++)  					{  						ch[t5-1]=cc[t11-1]+cc[t12-1];  						ch[t6-1]=cc[t11-1]-cc[t12-1];  						ch[t5]=cc[t11]-cc[t12];  						ch[t6]=cc[t11]+cc[t12];  						t5+=ido;  						t6+=ido;  						t11+=t10;  						t12+=t10;  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for(j=1;j<ipph;j++)  			{  				t1+=t0;  				t2-=t0;  				t3=t1;  				t4=t2;  				t7+=(ido<<1);  				t8=t7;  				t9=t7;  				for(i=2;i<ido;i+=2)  				{  					t3+=2;  					t4+=2;  					t8+=2;  					t9-=2;  					t5=t3;  					t6=t4;  					t11=t8;  					t12=t9;  					for(k=0;k<l1;k++)  					{  						ch[t5-1]=cc[t11-1]+cc[t12-1];  						ch[t6-1]=cc[t11-1]-cc[t12-1];  						ch[t5]=cc[t11]-cc[t12];  						ch[t6]=cc[t11]+cc[t12];  						t5+=ido;  						t6+=ido;  						t11+=t10;  						t12+=t10;  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for(j=1;j<ipph;j++)  			{  				t1+=t0;  				t2-=t0;  				t3=t1;  				t4=t2;  				t7+=(ido<<1);  				t8=t7;  				t9=t7;  				for(i=2;i<ido;i+=2)  				{  					t3+=2;  					t4+=2;  					t8+=2;  					t9-=2;  					t5=t3;  					t6=t4;  					t11=t8;  					t12=t9;  					for(k=0;k<l1;k++)  					{  						ch[t5-1]=cc[t11-1]+cc[t12-1];  						ch[t6-1]=cc[t11-1]-cc[t12-1];  						ch[t5]=cc[t11]-cc[t12];  						ch[t6]=cc[t11]+cc[t12];  						t5+=ido;  						t6+=ido;  						t11+=t10;  						t12+=t10;  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for(j=1;j<ipph;j++)  			{  				t1+=t0;  				t2-=t0;  				t3=t1;  				t4=t2;  				t7+=(ido<<1);  				t8=t7;  				t9=t7;  				for(i=2;i<ido;i+=2)  				{  					t3+=2;  					t4+=2;  					t8+=2;  					t9-=2;  					t5=t3;  					t6=t4;  					t11=t8;  					t12=t9;  					for(k=0;k<l1;k++)  					{  						ch[t5-1]=cc[t11-1]+cc[t12-1];  						ch[t6-1]=cc[t11-1]-cc[t12-1];  						ch[t5]=cc[t11]-cc[t12];  						ch[t6]=cc[t11]+cc[t12];  						t5+=ido;  						t6+=ido;  						t11+=t10;  						t12+=t10;  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for(j=1;j<ipph;j++)  			{  				t1+=t0;  				t2-=t0;  				t3=t1;  				t4=t2;  				t7+=(ido<<1);  				t8=t7;  				t9=t7;  				for(i=2;i<ido;i+=2)  				{  					t3+=2;  					t4+=2;  					t8+=2;  					t9-=2;  					t5=t3;  					t6=t4;  					t11=t8;  					t12=t9;  					for(k=0;k<l1;k++)  					{  						ch[t5-1]=cc[t11-1]+cc[t12-1];  						ch[t6-1]=cc[t11-1]-cc[t12-1];  						ch[t5]=cc[t11]-cc[t12];  						ch[t6]=cc[t11]+cc[t12];  						t5+=ido;  						t6+=ido;  						t11+=t10;  						t12+=t10;  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for(l=1;l<ipph;l++)  			{  				t1+=idl1;  				t2-=idl1;  	    				ar1h=dcp*ar1-dsp*ai1;  				ai1=dcp*ai1+dsp*ar1;  				ar1=ar1h;  				t4=t1;  				t5=t2;  				t6=0;  				t7=idl1;  				t8=t3;  				for(ik=0;ik<idl1;ik++)  				{  					c2[t4++]=ch2[t6++]+ar1*ch2[t7++];  					c2[t5++]=ai1*ch2[t8++];  				}  				dc2=ar1;  				ds2=ai1;  				ar2=ar1;  				ai2=ai1;    				t6=idl1;  				t7=t9-idl1;  				for(j=2;j<ipph;j++)  				{  					t6+=idl1;  					t7-=idl1;  					ar2h=dc2*ar2-ds2*ai2;  					ai2=dc2*ai2+ds2*ar2;  					ar2=ar2h;  					t4=t1;  					t5=t2;  					t11=t6;  					t12=t7;  					for(ik=0;ik<idl1;ik++)  					{  						c2[t4]+=ar2*ch2[t11++];  						t4++;  						c2[t5]+=ai2*ch2[t12++];  						t5++;  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for(j=1;j<ipph;j++)  			{  				t1+=t0;  				t2-=t0;  				t3=t1;  				t4=t2;  				for(k=0;k<l1;k++)  				{  					t5=t3;  					t6=t4;  					for(i=2;i<ido;i+=2)  					{  						t5+=2;  						t6+=2;  						ch[t5-1]=c1[t5-1]-c1[t6];  						ch[t6-1]=c1[t5-1]+c1[t6];  						ch[t5]=c1[t5]+c1[t6-1];  						ch[t6]=c1[t5]-c1[t6-1];  					}  					t3+=ido;  					t4+=ido;  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for(j=1;j<ipph;j++)  			{  				t1+=t0;  				t2-=t0;  				t3=t1;  				t4=t2;  				for(k=0;k<l1;k++)  				{  					t5=t3;  					t6=t4;  					for(i=2;i<ido;i+=2)  					{  						t5+=2;  						t6+=2;  						ch[t5-1]=c1[t5-1]-c1[t6];  						ch[t6-1]=c1[t5-1]+c1[t6];  						ch[t5]=c1[t5]+c1[t6-1];  						ch[t6]=c1[t5]-c1[t6-1];  					}  					t3+=ido;  					t4+=ido;  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for(j=1;j<ipph;j++)  			{  				t1+=t0;  				t2-=t0;  				t3=t1;  				t4=t2;  				for(k=0;k<l1;k++)  				{  					t5=t3;  					t6=t4;  					for(i=2;i<ido;i+=2)  					{  						t5+=2;  						t6+=2;  						ch[t5-1]=c1[t5-1]-c1[t6];  						ch[t6-1]=c1[t5-1]+c1[t6];  						ch[t5]=c1[t5]+c1[t6-1];  						ch[t6]=c1[t5]-c1[t6-1];  					}  					t3+=ido;  					t4+=ido;  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for(j=1;j<ipph;j++)  			{  				t1+=t0;  				t2-=t0;  				t3=t1;  				t4=t2;  				for(k=0;k<l1;k++)  				{  					t5=t3;  					t6=t4;  					for(i=2;i<ido;i+=2)  					{  						t5+=2;  						t6+=2;  						ch[t5-1]=c1[t5-1]-c1[t6];  						ch[t6-1]=c1[t5-1]+c1[t6];  						ch[t5]=c1[t5]+c1[t6-1];  						ch[t6]=c1[t5]-c1[t6-1];  					}  					t3+=ido;  					t4+=ido;  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for(j=1;j<ipph;j++)  			{  				t1+=t0;  				t2-=t0;  				t3=t1;  				t4=t2;  				for(i=2;i<ido;i+=2)  				{  					t3+=2;  					t4+=2;  					t5=t3;  					t6=t4;  					for(k=0;k<l1;k++)  					{  						ch[t5-1]=c1[t5-1]-c1[t6];  						ch[t6-1]=c1[t5-1]+c1[t6];  						ch[t5]=c1[t5]+c1[t6-1];  						ch[t6]=c1[t5]-c1[t6-1];  						t5+=ido;  						t6+=ido;  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for(j=1;j<ipph;j++)  			{  				t1+=t0;  				t2-=t0;  				t3=t1;  				t4=t2;  				for(i=2;i<ido;i+=2)  				{  					t3+=2;  					t4+=2;  					t5=t3;  					t6=t4;  					for(k=0;k<l1;k++)  					{  						ch[t5-1]=c1[t5-1]-c1[t6];  						ch[t6-1]=c1[t5-1]+c1[t6];  						ch[t5]=c1[t5]+c1[t6-1];  						ch[t6]=c1[t5]-c1[t6-1];  						t5+=ido;  						t6+=ido;  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for(j=1;j<ipph;j++)  			{  				t1+=t0;  				t2-=t0;  				t3=t1;  				t4=t2;  				for(i=2;i<ido;i+=2)  				{  					t3+=2;  					t4+=2;  					t5=t3;  					t6=t4;  					for(k=0;k<l1;k++)  					{  						ch[t5-1]=c1[t5-1]-c1[t6];  						ch[t6-1]=c1[t5-1]+c1[t6];  						ch[t5]=c1[t5]+c1[t6-1];  						ch[t6]=c1[t5]-c1[t6-1];  						t5+=ido;  						t6+=ido;  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for(j=1;j<ipph;j++)  			{  				t1+=t0;  				t2-=t0;  				t3=t1;  				t4=t2;  				for(i=2;i<ido;i+=2)  				{  					t3+=2;  					t4+=2;  					t5=t3;  					t6=t4;  					for(k=0;k<l1;k++)  					{  						ch[t5-1]=c1[t5-1]-c1[t6];  						ch[t6-1]=c1[t5-1]+c1[t6];  						ch[t5]=c1[t5]+c1[t6-1];  						ch[t6]=c1[t5]-c1[t6-1];  						t5+=ido;  						t6+=ido;  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for(j=1;j<ip;j++)  			{  				iis+=ido;  				t1+=t0;  				idij=iis;  				t2=t1;  				for(i=2;i<ido;i+=2)  				{  					t2+=2;  					idij+=2;  					t3=t2;  					for(k=0;k<l1;k++)  					{  						c1[t3-1]=wa[index+idij-1]*ch[t3-1]-wa[index+idij]*ch[t3];  						c1[t3]=wa[index+idij-1]*ch[t3]+wa[index+idij]*ch[t3-1];  						t3+=ido;  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for(j=1;j<ip;j++)  			{  				iis+=ido;  				t1+=t0;  				idij=iis;  				t2=t1;  				for(i=2;i<ido;i+=2)  				{  					t2+=2;  					idij+=2;  					t3=t2;  					for(k=0;k<l1;k++)  					{  						c1[t3-1]=wa[index+idij-1]*ch[t3-1]-wa[index+idij]*ch[t3];  						c1[t3]=wa[index+idij-1]*ch[t3]+wa[index+idij]*ch[t3-1];  						t3+=ido;  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for(j=1;j<ip;j++)  			{  				iis+=ido;  				t1+=t0;  				idij=iis;  				t2=t1;  				for(i=2;i<ido;i+=2)  				{  					t2+=2;  					idij+=2;  					t3=t2;  					for(k=0;k<l1;k++)  					{  						c1[t3-1]=wa[index+idij-1]*ch[t3-1]-wa[index+idij]*ch[t3];  						c1[t3]=wa[index+idij-1]*ch[t3]+wa[index+idij]*ch[t3-1];  						t3+=ido;  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for(j=1;j<ip;j++)  			{  				iis+=ido;  				t1+=t0;  				idij=iis;  				t2=t1;  				for(i=2;i<ido;i+=2)  				{  					t2+=2;  					idij+=2;  					t3=t2;  					for(k=0;k<l1;k++)  					{  						c1[t3-1]=wa[index+idij-1]*ch[t3-1]-wa[index+idij]*ch[t3];  						c1[t3]=wa[index+idij-1]*ch[t3]+wa[index+idij]*ch[t3-1];  						t3+=ido;  					}  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for(j=1;j<ip;j++)  			{  				iis+=ido;  				t1+=t0;  				t2=t1;  				for(k=0;k<l1;k++)  				{  					idij=iis;  					t3=t2;  					for(i=2;i<ido;i+=2)  					{  						idij+=2;  						t3+=2;  						c1[t3-1]=wa[index+idij-1]*ch[t3-1]-wa[index+idij]*ch[t3];  						c1[t3]=wa[index+idij-1]*ch[t3]+wa[index+idij]*ch[t3-1];  					}  					t2+=ido;  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for(j=1;j<ip;j++)  			{  				iis+=ido;  				t1+=t0;  				t2=t1;  				for(k=0;k<l1;k++)  				{  					idij=iis;  					t3=t2;  					for(i=2;i<ido;i+=2)  					{  						idij+=2;  						t3+=2;  						c1[t3-1]=wa[index+idij-1]*ch[t3-1]-wa[index+idij]*ch[t3];  						c1[t3]=wa[index+idij-1]*ch[t3]+wa[index+idij]*ch[t3-1];  					}  					t2+=ido;  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for(j=1;j<ip;j++)  			{  				iis+=ido;  				t1+=t0;  				t2=t1;  				for(k=0;k<l1;k++)  				{  					idij=iis;  					t3=t2;  					for(i=2;i<ido;i+=2)  					{  						idij+=2;  						t3+=2;  						c1[t3-1]=wa[index+idij-1]*ch[t3-1]-wa[index+idij]*ch[t3];  						c1[t3]=wa[index+idij-1]*ch[t3]+wa[index+idij]*ch[t3-1];  					}  					t2+=ido;  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for(j=1;j<ip;j++)  			{  				iis+=ido;  				t1+=t0;  				t2=t1;  				for(k=0;k<l1;k++)  				{  					idij=iis;  					t3=t2;  					for(i=2;i<ido;i+=2)  					{  						idij+=2;  						t3+=2;  						c1[t3-1]=wa[index+idij-1]*ch[t3-1]-wa[index+idij]*ch[t3];  						c1[t3]=wa[index+idij-1]*ch[t3]+wa[index+idij]*ch[t3-1];  					}  					t2+=ido;  				}  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,drftb1,The following statement contains a magic number: for(k1=0;k1<nf;k1++)  			{  				ip=ifac[k1 + 2];  				l2=ip*l1;  				ido=n/l2;  				idl1=ido*l1;  				if(ip!=4) goto L103;  				ix2=iw+ido;  				ix3=ix2+ido;    				if(na!=0)  					dradb4(ido'l1'ch'c'wa'index+iw-1'wa'index+ix2-1'wa'index+ix3-1);  				else  					dradb4(ido'l1'c'ch'wa'index+iw-1'wa'index+ix2-1'wa'index+ix3-1);  				na=1-na;  				goto L115;							  			L103: if(ip!=2) goto L106;  											  				if(na!=0)  					dradb2(ido'l1'ch'c'wa'index+iw-1);  				else  					dradb2(ido'l1'c'ch'wa'index+iw-1);  				na=1-na;  				goto L115;    			L106: if(ip!=3) goto L109;  											  				ix2=iw+ido;  				if(na!=0)  					dradb3(ido'l1'ch'c'wa'index+iw-1'wa'index+ix2-1);  				else  					dradb3(ido'l1'c'ch'wa'index+iw-1'wa'index+ix2-1);  				na=1-na;  				goto L115;  										  			L109: if(na!=0)  					  dradbg(ido'ip'l1'idl1'ch'ch'ch'c'c'wa'index+iw-1);  				  else  					  dradbg(ido'ip'l1'idl1'c'c'c'ch'ch'wa'index+iw-1);  				if(ido==1)na=1-na;  				l1=l2;  				iw+=(ip-1)*ido;    			L115: l1=l2;  				iw+=(ip-1)*ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,drftb1,The following statement contains a magic number: for(k1=0;k1<nf;k1++)  			{  				ip=ifac[k1 + 2];  				l2=ip*l1;  				ido=n/l2;  				idl1=ido*l1;  				if(ip!=4) goto L103;  				ix2=iw+ido;  				ix3=ix2+ido;    				if(na!=0)  					dradb4(ido'l1'ch'c'wa'index+iw-1'wa'index+ix2-1'wa'index+ix3-1);  				else  					dradb4(ido'l1'c'ch'wa'index+iw-1'wa'index+ix2-1'wa'index+ix3-1);  				na=1-na;  				goto L115;							  			L103: if(ip!=2) goto L106;  											  				if(na!=0)  					dradb2(ido'l1'ch'c'wa'index+iw-1);  				else  					dradb2(ido'l1'c'ch'wa'index+iw-1);  				na=1-na;  				goto L115;    			L106: if(ip!=3) goto L109;  											  				ix2=iw+ido;  				if(na!=0)  					dradb3(ido'l1'ch'c'wa'index+iw-1'wa'index+ix2-1);  				else  					dradb3(ido'l1'c'ch'wa'index+iw-1'wa'index+ix2-1);  				na=1-na;  				goto L115;  										  			L109: if(na!=0)  					  dradbg(ido'ip'l1'idl1'ch'ch'ch'c'c'wa'index+iw-1);  				  else  					  dradbg(ido'ip'l1'idl1'c'c'c'ch'ch'wa'index+iw-1);  				if(ido==1)na=1-na;  				l1=l2;  				iw+=(ip-1)*ido;    			L115: l1=l2;  				iw+=(ip-1)*ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,drftb1,The following statement contains a magic number: for(k1=0;k1<nf;k1++)  			{  				ip=ifac[k1 + 2];  				l2=ip*l1;  				ido=n/l2;  				idl1=ido*l1;  				if(ip!=4) goto L103;  				ix2=iw+ido;  				ix3=ix2+ido;    				if(na!=0)  					dradb4(ido'l1'ch'c'wa'index+iw-1'wa'index+ix2-1'wa'index+ix3-1);  				else  					dradb4(ido'l1'c'ch'wa'index+iw-1'wa'index+ix2-1'wa'index+ix3-1);  				na=1-na;  				goto L115;							  			L103: if(ip!=2) goto L106;  											  				if(na!=0)  					dradb2(ido'l1'ch'c'wa'index+iw-1);  				else  					dradb2(ido'l1'c'ch'wa'index+iw-1);  				na=1-na;  				goto L115;    			L106: if(ip!=3) goto L109;  											  				ix2=iw+ido;  				if(na!=0)  					dradb3(ido'l1'ch'c'wa'index+iw-1'wa'index+ix2-1);  				else  					dradb3(ido'l1'c'ch'wa'index+iw-1'wa'index+ix2-1);  				na=1-na;  				goto L115;  										  			L109: if(na!=0)  					  dradbg(ido'ip'l1'idl1'ch'ch'ch'c'c'wa'index+iw-1);  				  else  					  dradbg(ido'ip'l1'idl1'c'c'c'ch'ch'wa'index+iw-1);  				if(ido==1)na=1-na;  				l1=l2;  				iw+=(ip-1)*ido;    			L115: l1=l2;  				iw+=(ip-1)*ido;  			}
Magic Number,csvorbis,Drft,C:\repos\mono_csvorbis\csvorbis\Drft.cs,drftb1,The following statement contains a magic number: for(k1=0;k1<nf;k1++)  			{  				ip=ifac[k1 + 2];  				l2=ip*l1;  				ido=n/l2;  				idl1=ido*l1;  				if(ip!=4) goto L103;  				ix2=iw+ido;  				ix3=ix2+ido;    				if(na!=0)  					dradb4(ido'l1'ch'c'wa'index+iw-1'wa'index+ix2-1'wa'index+ix3-1);  				else  					dradb4(ido'l1'c'ch'wa'index+iw-1'wa'index+ix2-1'wa'index+ix3-1);  				na=1-na;  				goto L115;							  			L103: if(ip!=2) goto L106;  											  				if(na!=0)  					dradb2(ido'l1'ch'c'wa'index+iw-1);  				else  					dradb2(ido'l1'c'ch'wa'index+iw-1);  				na=1-na;  				goto L115;    			L106: if(ip!=3) goto L109;  											  				ix2=iw+ido;  				if(na!=0)  					dradb3(ido'l1'ch'c'wa'index+iw-1'wa'index+ix2-1);  				else  					dradb3(ido'l1'c'ch'wa'index+iw-1'wa'index+ix2-1);  				na=1-na;  				goto L115;  										  			L109: if(na!=0)  					  dradbg(ido'ip'l1'idl1'ch'ch'ch'c'c'wa'index+iw-1);  				  else  					  dradbg(ido'ip'l1'idl1'c'c'c'ch'ch'wa'index+iw-1);  				if(ido==1)na=1-na;  				l1=l2;  				iw+=(ip-1)*ido;    			L115: l1=l2;  				iw+=(ip-1)*ido;  			}
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,DspState,The following statement contains a magic number: transform=new Object[2][];
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,DspState,The following statement contains a magic number: wnd=new float[2][][][][];
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,DspState,The following statement contains a magic number: wnd[0]=new float[2][][][];
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,DspState,The following statement contains a magic number: wnd[0][0]=new float[2][][];
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,DspState,The following statement contains a magic number: wnd[0][1]=new float[2][][];
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,DspState,The following statement contains a magic number: wnd[0][0][0]=new float[2][];
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,DspState,The following statement contains a magic number: wnd[0][0][1]=new float[2][];
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,DspState,The following statement contains a magic number: wnd[0][1][0]=new float[2][];
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,DspState,The following statement contains a magic number: wnd[0][1][1]=new float[2][];
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,DspState,The following statement contains a magic number: wnd[1]=new float[2][][][];
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,DspState,The following statement contains a magic number: wnd[1][0]=new float[2][][];
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,DspState,The following statement contains a magic number: wnd[1][1]=new float[2][][];
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,DspState,The following statement contains a magic number: wnd[1][0][0]=new float[2][];
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,DspState,The following statement contains a magic number: wnd[1][0][1]=new float[2][];
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,DspState,The following statement contains a magic number: wnd[1][1][0]=new float[2][];
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,DspState,The following statement contains a magic number: wnd[1][1][1]=new float[2][];
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,window,The following statement contains a magic number: switch(type)  			{ 				case 0: 					// The 'vorbis window' (window 0) is sin(sin(x)*sin(x)*2pi) 				{ 					int leftbegin=wnd/4-left/2; 					int rightbegin=wnd-wnd/4-right/2;      					for(int i=0;i<left;i++)  					{ 						float x=(float)((i+.5)/left*M_PI/2.0); 						x=(float)Math.Sin(x); 						x*=x; 						x*=(float)(M_PI/2.0); 						x=(float)Math.Sin(x); 						ret[i+leftbegin]=x; 					}        					for(int i=leftbegin+left;i<rightbegin;i++)  					{ 						ret[i]=1.0f; 					}        					for(int i=0;i<right;i++)  					{ 						float x=(float)((right-i-.5)/right*M_PI/2.0); 						x=(float)Math.Sin(x); 						x*=x; 						x*=(float)(M_PI/2.0); 						x=(float)Math.Sin(x); 						ret[i+rightbegin]=x; 					} 				} 					break; 				default: 					//free(ret); 					return(null); 			}
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,window,The following statement contains a magic number: switch(type)  			{ 				case 0: 					// The 'vorbis window' (window 0) is sin(sin(x)*sin(x)*2pi) 				{ 					int leftbegin=wnd/4-left/2; 					int rightbegin=wnd-wnd/4-right/2;      					for(int i=0;i<left;i++)  					{ 						float x=(float)((i+.5)/left*M_PI/2.0); 						x=(float)Math.Sin(x); 						x*=x; 						x*=(float)(M_PI/2.0); 						x=(float)Math.Sin(x); 						ret[i+leftbegin]=x; 					}        					for(int i=leftbegin+left;i<rightbegin;i++)  					{ 						ret[i]=1.0f; 					}        					for(int i=0;i<right;i++)  					{ 						float x=(float)((right-i-.5)/right*M_PI/2.0); 						x=(float)Math.Sin(x); 						x*=x; 						x*=(float)(M_PI/2.0); 						x=(float)Math.Sin(x); 						ret[i+rightbegin]=x; 					} 				} 					break; 				default: 					//free(ret); 					return(null); 			}
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,window,The following statement contains a magic number: switch(type)  			{ 				case 0: 					// The 'vorbis window' (window 0) is sin(sin(x)*sin(x)*2pi) 				{ 					int leftbegin=wnd/4-left/2; 					int rightbegin=wnd-wnd/4-right/2;      					for(int i=0;i<left;i++)  					{ 						float x=(float)((i+.5)/left*M_PI/2.0); 						x=(float)Math.Sin(x); 						x*=x; 						x*=(float)(M_PI/2.0); 						x=(float)Math.Sin(x); 						ret[i+leftbegin]=x; 					}        					for(int i=leftbegin+left;i<rightbegin;i++)  					{ 						ret[i]=1.0f; 					}        					for(int i=0;i<right;i++)  					{ 						float x=(float)((right-i-.5)/right*M_PI/2.0); 						x=(float)Math.Sin(x); 						x*=x; 						x*=(float)(M_PI/2.0); 						x=(float)Math.Sin(x); 						ret[i+rightbegin]=x; 					} 				} 					break; 				default: 					//free(ret); 					return(null); 			}
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,window,The following statement contains a magic number: switch(type)  			{ 				case 0: 					// The 'vorbis window' (window 0) is sin(sin(x)*sin(x)*2pi) 				{ 					int leftbegin=wnd/4-left/2; 					int rightbegin=wnd-wnd/4-right/2;      					for(int i=0;i<left;i++)  					{ 						float x=(float)((i+.5)/left*M_PI/2.0); 						x=(float)Math.Sin(x); 						x*=x; 						x*=(float)(M_PI/2.0); 						x=(float)Math.Sin(x); 						ret[i+leftbegin]=x; 					}        					for(int i=leftbegin+left;i<rightbegin;i++)  					{ 						ret[i]=1.0f; 					}        					for(int i=0;i<right;i++)  					{ 						float x=(float)((right-i-.5)/right*M_PI/2.0); 						x=(float)Math.Sin(x); 						x*=x; 						x*=(float)(M_PI/2.0); 						x=(float)Math.Sin(x); 						ret[i+rightbegin]=x; 					} 				} 					break; 				default: 					//free(ret); 					return(null); 			}
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,window,The following statement contains a magic number: switch(type)  			{ 				case 0: 					// The 'vorbis window' (window 0) is sin(sin(x)*sin(x)*2pi) 				{ 					int leftbegin=wnd/4-left/2; 					int rightbegin=wnd-wnd/4-right/2;      					for(int i=0;i<left;i++)  					{ 						float x=(float)((i+.5)/left*M_PI/2.0); 						x=(float)Math.Sin(x); 						x*=x; 						x*=(float)(M_PI/2.0); 						x=(float)Math.Sin(x); 						ret[i+leftbegin]=x; 					}        					for(int i=leftbegin+left;i<rightbegin;i++)  					{ 						ret[i]=1.0f; 					}        					for(int i=0;i<right;i++)  					{ 						float x=(float)((right-i-.5)/right*M_PI/2.0); 						x=(float)Math.Sin(x); 						x*=x; 						x*=(float)(M_PI/2.0); 						x=(float)Math.Sin(x); 						ret[i+rightbegin]=x; 					} 				} 					break; 				default: 					//free(ret); 					return(null); 			}
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,window,The following statement contains a magic number: switch(type)  			{ 				case 0: 					// The 'vorbis window' (window 0) is sin(sin(x)*sin(x)*2pi) 				{ 					int leftbegin=wnd/4-left/2; 					int rightbegin=wnd-wnd/4-right/2;      					for(int i=0;i<left;i++)  					{ 						float x=(float)((i+.5)/left*M_PI/2.0); 						x=(float)Math.Sin(x); 						x*=x; 						x*=(float)(M_PI/2.0); 						x=(float)Math.Sin(x); 						ret[i+leftbegin]=x; 					}        					for(int i=leftbegin+left;i<rightbegin;i++)  					{ 						ret[i]=1.0f; 					}        					for(int i=0;i<right;i++)  					{ 						float x=(float)((right-i-.5)/right*M_PI/2.0); 						x=(float)Math.Sin(x); 						x*=x; 						x*=(float)(M_PI/2.0); 						x=(float)Math.Sin(x); 						ret[i+rightbegin]=x; 					} 				} 					break; 				default: 					//free(ret); 					return(null); 			}
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,window,The following statement contains a magic number: switch(type)  			{ 				case 0: 					// The 'vorbis window' (window 0) is sin(sin(x)*sin(x)*2pi) 				{ 					int leftbegin=wnd/4-left/2; 					int rightbegin=wnd-wnd/4-right/2;      					for(int i=0;i<left;i++)  					{ 						float x=(float)((i+.5)/left*M_PI/2.0); 						x=(float)Math.Sin(x); 						x*=x; 						x*=(float)(M_PI/2.0); 						x=(float)Math.Sin(x); 						ret[i+leftbegin]=x; 					}        					for(int i=leftbegin+left;i<rightbegin;i++)  					{ 						ret[i]=1.0f; 					}        					for(int i=0;i<right;i++)  					{ 						float x=(float)((right-i-.5)/right*M_PI/2.0); 						x=(float)Math.Sin(x); 						x*=x; 						x*=(float)(M_PI/2.0); 						x=(float)Math.Sin(x); 						ret[i+rightbegin]=x; 					} 				} 					break; 				default: 					//free(ret); 					return(null); 			}
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,window,The following statement contains a magic number: switch(type)  			{ 				case 0: 					// The 'vorbis window' (window 0) is sin(sin(x)*sin(x)*2pi) 				{ 					int leftbegin=wnd/4-left/2; 					int rightbegin=wnd-wnd/4-right/2;      					for(int i=0;i<left;i++)  					{ 						float x=(float)((i+.5)/left*M_PI/2.0); 						x=(float)Math.Sin(x); 						x*=x; 						x*=(float)(M_PI/2.0); 						x=(float)Math.Sin(x); 						ret[i+leftbegin]=x; 					}        					for(int i=leftbegin+left;i<rightbegin;i++)  					{ 						ret[i]=1.0f; 					}        					for(int i=0;i<right;i++)  					{ 						float x=(float)((right-i-.5)/right*M_PI/2.0); 						x=(float)Math.Sin(x); 						x*=x; 						x*=(float)(M_PI/2.0); 						x=(float)Math.Sin(x); 						ret[i+rightbegin]=x; 					} 				} 					break; 				default: 					//free(ret); 					return(null); 			}
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,window,The following statement contains a magic number: switch(type)  			{ 				case 0: 					// The 'vorbis window' (window 0) is sin(sin(x)*sin(x)*2pi) 				{ 					int leftbegin=wnd/4-left/2; 					int rightbegin=wnd-wnd/4-right/2;      					for(int i=0;i<left;i++)  					{ 						float x=(float)((i+.5)/left*M_PI/2.0); 						x=(float)Math.Sin(x); 						x*=x; 						x*=(float)(M_PI/2.0); 						x=(float)Math.Sin(x); 						ret[i+leftbegin]=x; 					}        					for(int i=leftbegin+left;i<rightbegin;i++)  					{ 						ret[i]=1.0f; 					}        					for(int i=0;i<right;i++)  					{ 						float x=(float)((right-i-.5)/right*M_PI/2.0); 						x=(float)Math.Sin(x); 						x*=x; 						x*=(float)(M_PI/2.0); 						x=(float)Math.Sin(x); 						ret[i+rightbegin]=x; 					} 				} 					break; 				default: 					//free(ret); 					return(null); 			}
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,window,The following statement contains a magic number: switch(type)  			{ 				case 0: 					// The 'vorbis window' (window 0) is sin(sin(x)*sin(x)*2pi) 				{ 					int leftbegin=wnd/4-left/2; 					int rightbegin=wnd-wnd/4-right/2;      					for(int i=0;i<left;i++)  					{ 						float x=(float)((i+.5)/left*M_PI/2.0); 						x=(float)Math.Sin(x); 						x*=x; 						x*=(float)(M_PI/2.0); 						x=(float)Math.Sin(x); 						ret[i+leftbegin]=x; 					}        					for(int i=leftbegin+left;i<rightbegin;i++)  					{ 						ret[i]=1.0f; 					}        					for(int i=0;i<right;i++)  					{ 						float x=(float)((right-i-.5)/right*M_PI/2.0); 						x=(float)Math.Sin(x); 						x*=x; 						x*=(float)(M_PI/2.0); 						x=(float)Math.Sin(x); 						ret[i+rightbegin]=x; 					} 				} 					break; 				default: 					//free(ret); 					return(null); 			}
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,init,The following statement contains a magic number: for(int i=0;i<VI_WINDOWB;i++)  			{ 				wnd[0][0][0][i]= 					window(i'vi.blocksizes[0]'vi.blocksizes[0]/2'vi.blocksizes[0]/2); 				wnd[1][0][0][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[0]/2'vi.blocksizes[0]/2); 				wnd[1][0][1][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[0]/2'vi.blocksizes[1]/2); 				wnd[1][1][0][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[1]/2'vi.blocksizes[0]/2); 				wnd[1][1][1][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[1]/2'vi.blocksizes[1]/2); 			}
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,init,The following statement contains a magic number: for(int i=0;i<VI_WINDOWB;i++)  			{ 				wnd[0][0][0][i]= 					window(i'vi.blocksizes[0]'vi.blocksizes[0]/2'vi.blocksizes[0]/2); 				wnd[1][0][0][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[0]/2'vi.blocksizes[0]/2); 				wnd[1][0][1][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[0]/2'vi.blocksizes[1]/2); 				wnd[1][1][0][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[1]/2'vi.blocksizes[0]/2); 				wnd[1][1][1][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[1]/2'vi.blocksizes[1]/2); 			}
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,init,The following statement contains a magic number: for(int i=0;i<VI_WINDOWB;i++)  			{ 				wnd[0][0][0][i]= 					window(i'vi.blocksizes[0]'vi.blocksizes[0]/2'vi.blocksizes[0]/2); 				wnd[1][0][0][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[0]/2'vi.blocksizes[0]/2); 				wnd[1][0][1][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[0]/2'vi.blocksizes[1]/2); 				wnd[1][1][0][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[1]/2'vi.blocksizes[0]/2); 				wnd[1][1][1][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[1]/2'vi.blocksizes[1]/2); 			}
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,init,The following statement contains a magic number: for(int i=0;i<VI_WINDOWB;i++)  			{ 				wnd[0][0][0][i]= 					window(i'vi.blocksizes[0]'vi.blocksizes[0]/2'vi.blocksizes[0]/2); 				wnd[1][0][0][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[0]/2'vi.blocksizes[0]/2); 				wnd[1][0][1][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[0]/2'vi.blocksizes[1]/2); 				wnd[1][1][0][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[1]/2'vi.blocksizes[0]/2); 				wnd[1][1][1][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[1]/2'vi.blocksizes[1]/2); 			}
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,init,The following statement contains a magic number: for(int i=0;i<VI_WINDOWB;i++)  			{ 				wnd[0][0][0][i]= 					window(i'vi.blocksizes[0]'vi.blocksizes[0]/2'vi.blocksizes[0]/2); 				wnd[1][0][0][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[0]/2'vi.blocksizes[0]/2); 				wnd[1][0][1][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[0]/2'vi.blocksizes[1]/2); 				wnd[1][1][0][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[1]/2'vi.blocksizes[0]/2); 				wnd[1][1][1][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[1]/2'vi.blocksizes[1]/2); 			}
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,init,The following statement contains a magic number: for(int i=0;i<VI_WINDOWB;i++)  			{ 				wnd[0][0][0][i]= 					window(i'vi.blocksizes[0]'vi.blocksizes[0]/2'vi.blocksizes[0]/2); 				wnd[1][0][0][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[0]/2'vi.blocksizes[0]/2); 				wnd[1][0][1][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[0]/2'vi.blocksizes[1]/2); 				wnd[1][1][0][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[1]/2'vi.blocksizes[0]/2); 				wnd[1][1][1][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[1]/2'vi.blocksizes[1]/2); 			}
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,init,The following statement contains a magic number: for(int i=0;i<VI_WINDOWB;i++)  			{ 				wnd[0][0][0][i]= 					window(i'vi.blocksizes[0]'vi.blocksizes[0]/2'vi.blocksizes[0]/2); 				wnd[1][0][0][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[0]/2'vi.blocksizes[0]/2); 				wnd[1][0][1][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[0]/2'vi.blocksizes[1]/2); 				wnd[1][1][0][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[1]/2'vi.blocksizes[0]/2); 				wnd[1][1][1][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[1]/2'vi.blocksizes[1]/2); 			}
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,init,The following statement contains a magic number: for(int i=0;i<VI_WINDOWB;i++)  			{ 				wnd[0][0][0][i]= 					window(i'vi.blocksizes[0]'vi.blocksizes[0]/2'vi.blocksizes[0]/2); 				wnd[1][0][0][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[0]/2'vi.blocksizes[0]/2); 				wnd[1][0][1][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[0]/2'vi.blocksizes[1]/2); 				wnd[1][1][0][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[1]/2'vi.blocksizes[0]/2); 				wnd[1][1][1][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[1]/2'vi.blocksizes[1]/2); 			}
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,init,The following statement contains a magic number: for(int i=0;i<VI_WINDOWB;i++)  			{ 				wnd[0][0][0][i]= 					window(i'vi.blocksizes[0]'vi.blocksizes[0]/2'vi.blocksizes[0]/2); 				wnd[1][0][0][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[0]/2'vi.blocksizes[0]/2); 				wnd[1][0][1][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[0]/2'vi.blocksizes[1]/2); 				wnd[1][1][0][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[1]/2'vi.blocksizes[0]/2); 				wnd[1][1][1][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[1]/2'vi.blocksizes[1]/2); 			}
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,init,The following statement contains a magic number: for(int i=0;i<VI_WINDOWB;i++)  			{ 				wnd[0][0][0][i]= 					window(i'vi.blocksizes[0]'vi.blocksizes[0]/2'vi.blocksizes[0]/2); 				wnd[1][0][0][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[0]/2'vi.blocksizes[0]/2); 				wnd[1][0][1][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[0]/2'vi.blocksizes[1]/2); 				wnd[1][1][0][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[1]/2'vi.blocksizes[0]/2); 				wnd[1][1][1][i]= 					window(i'vi.blocksizes[1]'vi.blocksizes[1]/2'vi.blocksizes[1]/2); 			}
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,init,The following statement contains a magic number: pcm_storage=8192;
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,init,The following statement contains a magic number: centerW=vi.blocksizes[1]/2;
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,synthesis_init,The following statement contains a magic number: centerW-= vi.blocksizes[W]/4+vi.blocksizes[lW]/4;
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,synthesis_init,The following statement contains a magic number: centerW-= vi.blocksizes[W]/4+vi.blocksizes[lW]/4;
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,DspState,The following statement contains a magic number: centerW-= vi.blocksizes[W]/4+vi.blocksizes[lW]/4;
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,DspState,The following statement contains a magic number: centerW-= vi.blocksizes[W]/4+vi.blocksizes[lW]/4;
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,synthesis_blockin,The following statement contains a magic number: if(centerW>vi.blocksizes[1]/2 && pcm_returned>8192)  			{ 				// don't shift too much; we need to have a minimum PCM buffer of 				// 1/2 long block  				int shiftPCM=centerW-vi.blocksizes[1]/2; 				shiftPCM=(pcm_returned<shiftPCM?pcm_returned:shiftPCM);  				pcm_current-=shiftPCM; 				centerW-=shiftPCM; 				pcm_returned-=shiftPCM; 				if(shiftPCM!=0)  				{ 					for(int i=0;i<vi.channels;i++)  					{ 						Array.Copy(pcm[i]' shiftPCM' pcm[i]' 0' pcm_current); 					} 				} 			}
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,synthesis_blockin,The following statement contains a magic number: if(centerW>vi.blocksizes[1]/2 && pcm_returned>8192)  			{ 				// don't shift too much; we need to have a minimum PCM buffer of 				// 1/2 long block  				int shiftPCM=centerW-vi.blocksizes[1]/2; 				shiftPCM=(pcm_returned<shiftPCM?pcm_returned:shiftPCM);  				pcm_current-=shiftPCM; 				centerW-=shiftPCM; 				pcm_returned-=shiftPCM; 				if(shiftPCM!=0)  				{ 					for(int i=0;i<vi.channels;i++)  					{ 						Array.Copy(pcm[i]' shiftPCM' pcm[i]' 0' pcm_current); 					} 				} 			}
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,synthesis_blockin,The following statement contains a magic number: if(centerW>vi.blocksizes[1]/2 && pcm_returned>8192)  			{ 				// don't shift too much; we need to have a minimum PCM buffer of 				// 1/2 long block  				int shiftPCM=centerW-vi.blocksizes[1]/2; 				shiftPCM=(pcm_returned<shiftPCM?pcm_returned:shiftPCM);  				pcm_current-=shiftPCM; 				centerW-=shiftPCM; 				pcm_returned-=shiftPCM; 				if(shiftPCM!=0)  				{ 					for(int i=0;i<vi.channels;i++)  					{ 						Array.Copy(pcm[i]' shiftPCM' pcm[i]' 0' pcm_current); 					} 				} 			}
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,synthesis_blockin,The following statement contains a magic number: { 			int sizeW=vi.blocksizes[W]; 			int _centerW=centerW+vi.blocksizes[lW]/4+sizeW/4; 			int beginW=_centerW-sizeW/2; 			int endW=beginW+sizeW; 			int beginSl=0; 			int endSl=0;  			// Do we have enough PCM/mult storage for the block? 			if(endW>pcm_storage)  			{ 				// expand the storage 				pcm_storage=endW+vi.blocksizes[1]; 				for(int i=0;i<vi.channels;i++)  				{ 					float[] foo=new float[pcm_storage]; 					Array.Copy(pcm[i]' 0' foo' 0' pcm[i].Length); 					pcm[i]=foo; 				} 			}  			// overlap/add PCM 			switch(W)  			{ 				case 0: 					beginSl=0; 					endSl=vi.blocksizes[0]/2; 					break; 				case 1: 					beginSl=vi.blocksizes[1]/4-vi.blocksizes[lW]/4; 					endSl=beginSl+vi.blocksizes[lW]/2; 					break; 			}  			for(int j=0;j<vi.channels;j++)  			{ 				int _pcm=beginW; 				// the overlap/add section 				int i=0; 				for(i=beginSl;i<endSl;i++)  				{ 					pcm[j][_pcm+i]+=vb.pcm[j][i]; 				} 				// the remaining section 				for(;i<sizeW;i++)  				{ 					pcm[j][_pcm+i]=vb.pcm[j][i]; 				} 			}  			// track the frame number... This is for convenience' but also 			// making sure our last packet doesn't end with added padding.  If 			// the last packet is partial' the number of samples we'll have to 			// return will be past the vb->granulepos. 			//        			// This is not foolproof!  It will be confused if we begin 			// decoding at the last page after a seek or hole.  In that case' 			// we don't have a starting point to judge where the last frame 			// is.  For this reason' vorbisfile will always try to make sure 			// it reads the last two marked pages in proper sequence  			if(granulepos==-1)  			{ 				granulepos=vb.granulepos; 			} 			else  			{ 				granulepos+=(_centerW-centerW); 				if(vb.granulepos!=-1 && granulepos!=vb.granulepos)  				{ 					if(granulepos>vb.granulepos && vb.eofflag!=0)  					{ 						// partial last frame.  Strip the padding off 						_centerW = _centerW - (int)(granulepos-vb.granulepos); 					}// else{ Shouldn't happen *unless* the bitstream is out of 					// spec.  Either way' believe the bitstream } 					granulepos=vb.granulepos; 				} 			}  			// Update' cleanup  			centerW=_centerW; 			pcm_current=endW; 			if(vb.eofflag!=0)eofflag=1; 		}
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,synthesis_blockin,The following statement contains a magic number: { 			int sizeW=vi.blocksizes[W]; 			int _centerW=centerW+vi.blocksizes[lW]/4+sizeW/4; 			int beginW=_centerW-sizeW/2; 			int endW=beginW+sizeW; 			int beginSl=0; 			int endSl=0;  			// Do we have enough PCM/mult storage for the block? 			if(endW>pcm_storage)  			{ 				// expand the storage 				pcm_storage=endW+vi.blocksizes[1]; 				for(int i=0;i<vi.channels;i++)  				{ 					float[] foo=new float[pcm_storage]; 					Array.Copy(pcm[i]' 0' foo' 0' pcm[i].Length); 					pcm[i]=foo; 				} 			}  			// overlap/add PCM 			switch(W)  			{ 				case 0: 					beginSl=0; 					endSl=vi.blocksizes[0]/2; 					break; 				case 1: 					beginSl=vi.blocksizes[1]/4-vi.blocksizes[lW]/4; 					endSl=beginSl+vi.blocksizes[lW]/2; 					break; 			}  			for(int j=0;j<vi.channels;j++)  			{ 				int _pcm=beginW; 				// the overlap/add section 				int i=0; 				for(i=beginSl;i<endSl;i++)  				{ 					pcm[j][_pcm+i]+=vb.pcm[j][i]; 				} 				// the remaining section 				for(;i<sizeW;i++)  				{ 					pcm[j][_pcm+i]=vb.pcm[j][i]; 				} 			}  			// track the frame number... This is for convenience' but also 			// making sure our last packet doesn't end with added padding.  If 			// the last packet is partial' the number of samples we'll have to 			// return will be past the vb->granulepos. 			//        			// This is not foolproof!  It will be confused if we begin 			// decoding at the last page after a seek or hole.  In that case' 			// we don't have a starting point to judge where the last frame 			// is.  For this reason' vorbisfile will always try to make sure 			// it reads the last two marked pages in proper sequence  			if(granulepos==-1)  			{ 				granulepos=vb.granulepos; 			} 			else  			{ 				granulepos+=(_centerW-centerW); 				if(vb.granulepos!=-1 && granulepos!=vb.granulepos)  				{ 					if(granulepos>vb.granulepos && vb.eofflag!=0)  					{ 						// partial last frame.  Strip the padding off 						_centerW = _centerW - (int)(granulepos-vb.granulepos); 					}// else{ Shouldn't happen *unless* the bitstream is out of 					// spec.  Either way' believe the bitstream } 					granulepos=vb.granulepos; 				} 			}  			// Update' cleanup  			centerW=_centerW; 			pcm_current=endW; 			if(vb.eofflag!=0)eofflag=1; 		}
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,synthesis_blockin,The following statement contains a magic number: { 			int sizeW=vi.blocksizes[W]; 			int _centerW=centerW+vi.blocksizes[lW]/4+sizeW/4; 			int beginW=_centerW-sizeW/2; 			int endW=beginW+sizeW; 			int beginSl=0; 			int endSl=0;  			// Do we have enough PCM/mult storage for the block? 			if(endW>pcm_storage)  			{ 				// expand the storage 				pcm_storage=endW+vi.blocksizes[1]; 				for(int i=0;i<vi.channels;i++)  				{ 					float[] foo=new float[pcm_storage]; 					Array.Copy(pcm[i]' 0' foo' 0' pcm[i].Length); 					pcm[i]=foo; 				} 			}  			// overlap/add PCM 			switch(W)  			{ 				case 0: 					beginSl=0; 					endSl=vi.blocksizes[0]/2; 					break; 				case 1: 					beginSl=vi.blocksizes[1]/4-vi.blocksizes[lW]/4; 					endSl=beginSl+vi.blocksizes[lW]/2; 					break; 			}  			for(int j=0;j<vi.channels;j++)  			{ 				int _pcm=beginW; 				// the overlap/add section 				int i=0; 				for(i=beginSl;i<endSl;i++)  				{ 					pcm[j][_pcm+i]+=vb.pcm[j][i]; 				} 				// the remaining section 				for(;i<sizeW;i++)  				{ 					pcm[j][_pcm+i]=vb.pcm[j][i]; 				} 			}  			// track the frame number... This is for convenience' but also 			// making sure our last packet doesn't end with added padding.  If 			// the last packet is partial' the number of samples we'll have to 			// return will be past the vb->granulepos. 			//        			// This is not foolproof!  It will be confused if we begin 			// decoding at the last page after a seek or hole.  In that case' 			// we don't have a starting point to judge where the last frame 			// is.  For this reason' vorbisfile will always try to make sure 			// it reads the last two marked pages in proper sequence  			if(granulepos==-1)  			{ 				granulepos=vb.granulepos; 			} 			else  			{ 				granulepos+=(_centerW-centerW); 				if(vb.granulepos!=-1 && granulepos!=vb.granulepos)  				{ 					if(granulepos>vb.granulepos && vb.eofflag!=0)  					{ 						// partial last frame.  Strip the padding off 						_centerW = _centerW - (int)(granulepos-vb.granulepos); 					}// else{ Shouldn't happen *unless* the bitstream is out of 					// spec.  Either way' believe the bitstream } 					granulepos=vb.granulepos; 				} 			}  			// Update' cleanup  			centerW=_centerW; 			pcm_current=endW; 			if(vb.eofflag!=0)eofflag=1; 		}
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,synthesis_blockin,The following statement contains a magic number: { 			int sizeW=vi.blocksizes[W]; 			int _centerW=centerW+vi.blocksizes[lW]/4+sizeW/4; 			int beginW=_centerW-sizeW/2; 			int endW=beginW+sizeW; 			int beginSl=0; 			int endSl=0;  			// Do we have enough PCM/mult storage for the block? 			if(endW>pcm_storage)  			{ 				// expand the storage 				pcm_storage=endW+vi.blocksizes[1]; 				for(int i=0;i<vi.channels;i++)  				{ 					float[] foo=new float[pcm_storage]; 					Array.Copy(pcm[i]' 0' foo' 0' pcm[i].Length); 					pcm[i]=foo; 				} 			}  			// overlap/add PCM 			switch(W)  			{ 				case 0: 					beginSl=0; 					endSl=vi.blocksizes[0]/2; 					break; 				case 1: 					beginSl=vi.blocksizes[1]/4-vi.blocksizes[lW]/4; 					endSl=beginSl+vi.blocksizes[lW]/2; 					break; 			}  			for(int j=0;j<vi.channels;j++)  			{ 				int _pcm=beginW; 				// the overlap/add section 				int i=0; 				for(i=beginSl;i<endSl;i++)  				{ 					pcm[j][_pcm+i]+=vb.pcm[j][i]; 				} 				// the remaining section 				for(;i<sizeW;i++)  				{ 					pcm[j][_pcm+i]=vb.pcm[j][i]; 				} 			}  			// track the frame number... This is for convenience' but also 			// making sure our last packet doesn't end with added padding.  If 			// the last packet is partial' the number of samples we'll have to 			// return will be past the vb->granulepos. 			//        			// This is not foolproof!  It will be confused if we begin 			// decoding at the last page after a seek or hole.  In that case' 			// we don't have a starting point to judge where the last frame 			// is.  For this reason' vorbisfile will always try to make sure 			// it reads the last two marked pages in proper sequence  			if(granulepos==-1)  			{ 				granulepos=vb.granulepos; 			} 			else  			{ 				granulepos+=(_centerW-centerW); 				if(vb.granulepos!=-1 && granulepos!=vb.granulepos)  				{ 					if(granulepos>vb.granulepos && vb.eofflag!=0)  					{ 						// partial last frame.  Strip the padding off 						_centerW = _centerW - (int)(granulepos-vb.granulepos); 					}// else{ Shouldn't happen *unless* the bitstream is out of 					// spec.  Either way' believe the bitstream } 					granulepos=vb.granulepos; 				} 			}  			// Update' cleanup  			centerW=_centerW; 			pcm_current=endW; 			if(vb.eofflag!=0)eofflag=1; 		}
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,synthesis_blockin,The following statement contains a magic number: { 			int sizeW=vi.blocksizes[W]; 			int _centerW=centerW+vi.blocksizes[lW]/4+sizeW/4; 			int beginW=_centerW-sizeW/2; 			int endW=beginW+sizeW; 			int beginSl=0; 			int endSl=0;  			// Do we have enough PCM/mult storage for the block? 			if(endW>pcm_storage)  			{ 				// expand the storage 				pcm_storage=endW+vi.blocksizes[1]; 				for(int i=0;i<vi.channels;i++)  				{ 					float[] foo=new float[pcm_storage]; 					Array.Copy(pcm[i]' 0' foo' 0' pcm[i].Length); 					pcm[i]=foo; 				} 			}  			// overlap/add PCM 			switch(W)  			{ 				case 0: 					beginSl=0; 					endSl=vi.blocksizes[0]/2; 					break; 				case 1: 					beginSl=vi.blocksizes[1]/4-vi.blocksizes[lW]/4; 					endSl=beginSl+vi.blocksizes[lW]/2; 					break; 			}  			for(int j=0;j<vi.channels;j++)  			{ 				int _pcm=beginW; 				// the overlap/add section 				int i=0; 				for(i=beginSl;i<endSl;i++)  				{ 					pcm[j][_pcm+i]+=vb.pcm[j][i]; 				} 				// the remaining section 				for(;i<sizeW;i++)  				{ 					pcm[j][_pcm+i]=vb.pcm[j][i]; 				} 			}  			// track the frame number... This is for convenience' but also 			// making sure our last packet doesn't end with added padding.  If 			// the last packet is partial' the number of samples we'll have to 			// return will be past the vb->granulepos. 			//        			// This is not foolproof!  It will be confused if we begin 			// decoding at the last page after a seek or hole.  In that case' 			// we don't have a starting point to judge where the last frame 			// is.  For this reason' vorbisfile will always try to make sure 			// it reads the last two marked pages in proper sequence  			if(granulepos==-1)  			{ 				granulepos=vb.granulepos; 			} 			else  			{ 				granulepos+=(_centerW-centerW); 				if(vb.granulepos!=-1 && granulepos!=vb.granulepos)  				{ 					if(granulepos>vb.granulepos && vb.eofflag!=0)  					{ 						// partial last frame.  Strip the padding off 						_centerW = _centerW - (int)(granulepos-vb.granulepos); 					}// else{ Shouldn't happen *unless* the bitstream is out of 					// spec.  Either way' believe the bitstream } 					granulepos=vb.granulepos; 				} 			}  			// Update' cleanup  			centerW=_centerW; 			pcm_current=endW; 			if(vb.eofflag!=0)eofflag=1; 		}
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,synthesis_blockin,The following statement contains a magic number: { 			int sizeW=vi.blocksizes[W]; 			int _centerW=centerW+vi.blocksizes[lW]/4+sizeW/4; 			int beginW=_centerW-sizeW/2; 			int endW=beginW+sizeW; 			int beginSl=0; 			int endSl=0;  			// Do we have enough PCM/mult storage for the block? 			if(endW>pcm_storage)  			{ 				// expand the storage 				pcm_storage=endW+vi.blocksizes[1]; 				for(int i=0;i<vi.channels;i++)  				{ 					float[] foo=new float[pcm_storage]; 					Array.Copy(pcm[i]' 0' foo' 0' pcm[i].Length); 					pcm[i]=foo; 				} 			}  			// overlap/add PCM 			switch(W)  			{ 				case 0: 					beginSl=0; 					endSl=vi.blocksizes[0]/2; 					break; 				case 1: 					beginSl=vi.blocksizes[1]/4-vi.blocksizes[lW]/4; 					endSl=beginSl+vi.blocksizes[lW]/2; 					break; 			}  			for(int j=0;j<vi.channels;j++)  			{ 				int _pcm=beginW; 				// the overlap/add section 				int i=0; 				for(i=beginSl;i<endSl;i++)  				{ 					pcm[j][_pcm+i]+=vb.pcm[j][i]; 				} 				// the remaining section 				for(;i<sizeW;i++)  				{ 					pcm[j][_pcm+i]=vb.pcm[j][i]; 				} 			}  			// track the frame number... This is for convenience' but also 			// making sure our last packet doesn't end with added padding.  If 			// the last packet is partial' the number of samples we'll have to 			// return will be past the vb->granulepos. 			//        			// This is not foolproof!  It will be confused if we begin 			// decoding at the last page after a seek or hole.  In that case' 			// we don't have a starting point to judge where the last frame 			// is.  For this reason' vorbisfile will always try to make sure 			// it reads the last two marked pages in proper sequence  			if(granulepos==-1)  			{ 				granulepos=vb.granulepos; 			} 			else  			{ 				granulepos+=(_centerW-centerW); 				if(vb.granulepos!=-1 && granulepos!=vb.granulepos)  				{ 					if(granulepos>vb.granulepos && vb.eofflag!=0)  					{ 						// partial last frame.  Strip the padding off 						_centerW = _centerW - (int)(granulepos-vb.granulepos); 					}// else{ Shouldn't happen *unless* the bitstream is out of 					// spec.  Either way' believe the bitstream } 					granulepos=vb.granulepos; 				} 			}  			// Update' cleanup  			centerW=_centerW; 			pcm_current=endW; 			if(vb.eofflag!=0)eofflag=1; 		}
Magic Number,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,synthesis_blockin,The following statement contains a magic number: { 			int sizeW=vi.blocksizes[W]; 			int _centerW=centerW+vi.blocksizes[lW]/4+sizeW/4; 			int beginW=_centerW-sizeW/2; 			int endW=beginW+sizeW; 			int beginSl=0; 			int endSl=0;  			// Do we have enough PCM/mult storage for the block? 			if(endW>pcm_storage)  			{ 				// expand the storage 				pcm_storage=endW+vi.blocksizes[1]; 				for(int i=0;i<vi.channels;i++)  				{ 					float[] foo=new float[pcm_storage]; 					Array.Copy(pcm[i]' 0' foo' 0' pcm[i].Length); 					pcm[i]=foo; 				} 			}  			// overlap/add PCM 			switch(W)  			{ 				case 0: 					beginSl=0; 					endSl=vi.blocksizes[0]/2; 					break; 				case 1: 					beginSl=vi.blocksizes[1]/4-vi.blocksizes[lW]/4; 					endSl=beginSl+vi.blocksizes[lW]/2; 					break; 			}  			for(int j=0;j<vi.channels;j++)  			{ 				int _pcm=beginW; 				// the overlap/add section 				int i=0; 				for(i=beginSl;i<endSl;i++)  				{ 					pcm[j][_pcm+i]+=vb.pcm[j][i]; 				} 				// the remaining section 				for(;i<sizeW;i++)  				{ 					pcm[j][_pcm+i]=vb.pcm[j][i]; 				} 			}  			// track the frame number... This is for convenience' but also 			// making sure our last packet doesn't end with added padding.  If 			// the last packet is partial' the number of samples we'll have to 			// return will be past the vb->granulepos. 			//        			// This is not foolproof!  It will be confused if we begin 			// decoding at the last page after a seek or hole.  In that case' 			// we don't have a starting point to judge where the last frame 			// is.  For this reason' vorbisfile will always try to make sure 			// it reads the last two marked pages in proper sequence  			if(granulepos==-1)  			{ 				granulepos=vb.granulepos; 			} 			else  			{ 				granulepos+=(_centerW-centerW); 				if(vb.granulepos!=-1 && granulepos!=vb.granulepos)  				{ 					if(granulepos>vb.granulepos && vb.eofflag!=0)  					{ 						// partial last frame.  Strip the padding off 						_centerW = _centerW - (int)(granulepos-vb.granulepos); 					}// else{ Shouldn't happen *unless* the bitstream is out of 					// spec.  Either way' believe the bitstream } 					granulepos=vb.granulepos; 				} 			}  			// Update' cleanup  			centerW=_centerW; 			pcm_current=endW; 			if(vb.eofflag!=0)eofflag=1; 		}
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,pack,The following statement contains a magic number: opb.write(info.order'8);
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,pack,The following statement contains a magic number: opb.write(info.rate'16);
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,pack,The following statement contains a magic number: opb.write(info.barkmap'16);
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,pack,The following statement contains a magic number: opb.write(info.ampbits'6);
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,pack,The following statement contains a magic number: opb.write(info.ampdB'8);
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,pack,The following statement contains a magic number: opb.write(info.numbooks-1'4);
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,pack,The following statement contains a magic number: for(int j=0;j<info.numbooks;j++) 				opb.write(info.books[j]'8);
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,unpack,The following statement contains a magic number: info.order=opb.read(8);
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,unpack,The following statement contains a magic number: info.rate=opb.read(16);
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,unpack,The following statement contains a magic number: info.barkmap=opb.read(16);
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,unpack,The following statement contains a magic number: info.ampbits=opb.read(6);
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,unpack,The following statement contains a magic number: info.ampdB=opb.read(8);
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,unpack,The following statement contains a magic number: info.numbooks=opb.read(4)+1;
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,unpack,The following statement contains a magic number: for(int j=0;j<info.numbooks;j++)  			{ 				info.books[j]=opb.read(8); 				if(info.books[j]<0 || info.books[j]>=vi.books)  				{ 					//free_info(info); 					return(null); 				} 			}
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,look,The following statement contains a magic number: look.n=vi.blocksizes[mi.blockflag]/2;
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,look,The following statement contains a magic number: scale = look.ln / (float)toBARK((float)(info.rate/2.0));
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,look,The following statement contains a magic number: for(int j=0; j<look.n; j++)  			{ 				int val=(int)Math.Floor(toBARK((float)((info.rate/2.0)/look.n*j))  					*scale); // bark numbers represent band edges 				if(val>=look.ln) val=look.ln; // guard against the approximation 				look.linearmap[j]=val; 			}
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,toBARK,The following statement contains a magic number: a = 13.1 * Math.Atan(0.00074 * f);
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,toBARK,The following statement contains a magic number: a = 13.1 * Math.Atan(0.00074 * f);
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,toBARK,The following statement contains a magic number: b = 2.24 * Math.Atan(f * f * 1.85e-8);
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,toBARK,The following statement contains a magic number: b = 2.24 * Math.Atan(f * f * 1.85e-8);
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,toBARK,The following statement contains a magic number: c = 1.0e-4 * f;
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,fromdB,The following statement contains a magic number: return (float)(Math.Exp((x)*.11512925));
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,lsp_to_lpc,The following statement contains a magic number: int i'j'm2=m/2;
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,lsp_to_lpc,The following statement contains a magic number: for(i=0;i<m2;i++)  			{ 				O[i]=(float)(-2.0*Math.Cos(lsp[i*2])); 				E[i]=(float)(-2.0*Math.Cos(lsp[i*2+1])); 			}
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,lsp_to_lpc,The following statement contains a magic number: for(i=0;i<m2;i++)  			{ 				O[i]=(float)(-2.0*Math.Cos(lsp[i*2])); 				E[i]=(float)(-2.0*Math.Cos(lsp[i*2+1])); 			}
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,lsp_to_lpc,The following statement contains a magic number: for(i=0;i<m2;i++)  			{ 				O[i]=(float)(-2.0*Math.Cos(lsp[i*2])); 				E[i]=(float)(-2.0*Math.Cos(lsp[i*2+1])); 			}
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,lsp_to_lpc,The following statement contains a magic number: for(i=0;i<m2;i++)  			{ 				O[i]=(float)(-2.0*Math.Cos(lsp[i*2])); 				E[i]=(float)(-2.0*Math.Cos(lsp[i*2+1])); 			}
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,lsp_to_lpc,The following statement contains a magic number: for(i=1;i<m+1;i++)  			{ 				A=B=0.0f; 				for(j=0;j<m2;j++)  				{ 					temp=O[j]*Ao[j]+Ae[j]; 					Ae[j]=Ao[j]; 					Ao[j]=A; 					A+=temp;  					temp=E[j]*Bo[j]+Be[j]; 					Be[j]=Bo[j]; 					Bo[j]=B; 					B+=temp; 				} 				lpc[i-1]=(A+Ao[j]+B-Ae[j])/2; 				Ao[j]=A; 				Ae[j]=B; 			}
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,lpc_to_curve,The following statement contains a magic number: float[] lcurve=new float[Math.Max(l.ln*2'l.m*2+2)];
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,lpc_to_curve,The following statement contains a magic number: float[] lcurve=new float[Math.Max(l.ln*2'l.m*2+2)];
Magic Number,csvorbis,Floor0,C:\repos\mono_csvorbis\csvorbis\Floor0.cs,lpc_to_curve,The following statement contains a magic number: float[] lcurve=new float[Math.Max(l.ln*2'l.m*2+2)];
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,pack,The following statement contains a magic number: opb.write(info.partitions'5);
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,pack,The following statement contains a magic number: for(int j=0;j<info.partitions;j++)  			{ 				opb.write(info.partitionclass[j]'4); /* only 0 to 15 legal */ 				if(maxclass<info.partitionclass[j]) 					maxclass=info.partitionclass[j]; 			}
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,pack,The following statement contains a magic number: for(int j=0;j<maxclass+1;j++)  			{ 				opb.write(info.class_dim[j]-1'3); /* 1 to 8 */ 				opb.write(info.class_subs[j]'2); /* 0 to 3 */ 				if(info.class_subs[j]!=0)  				{ 					opb.write(info.class_book[j]'8); 				} 				for(int k=0;k<(1<<info.class_subs[j]);k++)  				{ 					opb.write(info.class_subbook[j][k]+1'8); 				} 			}
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,pack,The following statement contains a magic number: for(int j=0;j<maxclass+1;j++)  			{ 				opb.write(info.class_dim[j]-1'3); /* 1 to 8 */ 				opb.write(info.class_subs[j]'2); /* 0 to 3 */ 				if(info.class_subs[j]!=0)  				{ 					opb.write(info.class_book[j]'8); 				} 				for(int k=0;k<(1<<info.class_subs[j]);k++)  				{ 					opb.write(info.class_subbook[j][k]+1'8); 				} 			}
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,pack,The following statement contains a magic number: for(int j=0;j<maxclass+1;j++)  			{ 				opb.write(info.class_dim[j]-1'3); /* 1 to 8 */ 				opb.write(info.class_subs[j]'2); /* 0 to 3 */ 				if(info.class_subs[j]!=0)  				{ 					opb.write(info.class_book[j]'8); 				} 				for(int k=0;k<(1<<info.class_subs[j]);k++)  				{ 					opb.write(info.class_subbook[j][k]+1'8); 				} 			}
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,pack,The following statement contains a magic number: for(int j=0;j<maxclass+1;j++)  			{ 				opb.write(info.class_dim[j]-1'3); /* 1 to 8 */ 				opb.write(info.class_subs[j]'2); /* 0 to 3 */ 				if(info.class_subs[j]!=0)  				{ 					opb.write(info.class_book[j]'8); 				} 				for(int k=0;k<(1<<info.class_subs[j]);k++)  				{ 					opb.write(info.class_subbook[j][k]+1'8); 				} 			}
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,pack,The following statement contains a magic number: opb.write(info.mult-1'2);
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,pack,The following statement contains a magic number: opb.write(ilog2(maxposit)'4);
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,pack,The following statement contains a magic number: for(int j=0'k=0;j<info.partitions;j++)  			{ 				count+=info.class_dim[info.partitionclass[j]]; 				for(;k<count;k++)  				{ 					opb.write(info.postlist[k+2]'rangebits); 				} 			}
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,unpack,The following statement contains a magic number: info.partitions=opb.read(5);
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,unpack,The following statement contains a magic number: for(int j=0;j<info.partitions;j++)  			{ 				info.partitionclass[j]=opb.read(4); /* only 0 to 15 legal */ 				if(maxclass<info.partitionclass[j]) 					maxclass=info.partitionclass[j]; 			}
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,unpack,The following statement contains a magic number: for(int j=0;j<maxclass+1;j++)  			{ 				info.class_dim[j]=opb.read(3)+1; /* 1 to 8 */ 				info.class_subs[j]=opb.read(2);  /* 0'1'2'3 bits */ 				if(info.class_subs[j]<0)  				{ 					//goto err_out; 					info.free(); 					return(null); 				} 				if(info.class_subs[j]!=0)  				{ 					info.class_book[j]=opb.read(8); 				} 				if(info.class_book[j]<0 || info.class_book[j]>=vi.books)  				{ 					//goto err_out; 					info.free(); 					return(null); 				} 				for(int k=0;k<(1<<info.class_subs[j]);k++)  				{ 					info.class_subbook[j][k]=opb.read(8)-1; 					if(info.class_subbook[j][k]<-1 || info.class_subbook[j][k]>=vi.books)  					{ 						//goto err_out; 						info.free(); 						return(null); 					} 				} 			}
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,unpack,The following statement contains a magic number: for(int j=0;j<maxclass+1;j++)  			{ 				info.class_dim[j]=opb.read(3)+1; /* 1 to 8 */ 				info.class_subs[j]=opb.read(2);  /* 0'1'2'3 bits */ 				if(info.class_subs[j]<0)  				{ 					//goto err_out; 					info.free(); 					return(null); 				} 				if(info.class_subs[j]!=0)  				{ 					info.class_book[j]=opb.read(8); 				} 				if(info.class_book[j]<0 || info.class_book[j]>=vi.books)  				{ 					//goto err_out; 					info.free(); 					return(null); 				} 				for(int k=0;k<(1<<info.class_subs[j]);k++)  				{ 					info.class_subbook[j][k]=opb.read(8)-1; 					if(info.class_subbook[j][k]<-1 || info.class_subbook[j][k]>=vi.books)  					{ 						//goto err_out; 						info.free(); 						return(null); 					} 				} 			}
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,unpack,The following statement contains a magic number: for(int j=0;j<maxclass+1;j++)  			{ 				info.class_dim[j]=opb.read(3)+1; /* 1 to 8 */ 				info.class_subs[j]=opb.read(2);  /* 0'1'2'3 bits */ 				if(info.class_subs[j]<0)  				{ 					//goto err_out; 					info.free(); 					return(null); 				} 				if(info.class_subs[j]!=0)  				{ 					info.class_book[j]=opb.read(8); 				} 				if(info.class_book[j]<0 || info.class_book[j]>=vi.books)  				{ 					//goto err_out; 					info.free(); 					return(null); 				} 				for(int k=0;k<(1<<info.class_subs[j]);k++)  				{ 					info.class_subbook[j][k]=opb.read(8)-1; 					if(info.class_subbook[j][k]<-1 || info.class_subbook[j][k]>=vi.books)  					{ 						//goto err_out; 						info.free(); 						return(null); 					} 				} 			}
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,unpack,The following statement contains a magic number: for(int j=0;j<maxclass+1;j++)  			{ 				info.class_dim[j]=opb.read(3)+1; /* 1 to 8 */ 				info.class_subs[j]=opb.read(2);  /* 0'1'2'3 bits */ 				if(info.class_subs[j]<0)  				{ 					//goto err_out; 					info.free(); 					return(null); 				} 				if(info.class_subs[j]!=0)  				{ 					info.class_book[j]=opb.read(8); 				} 				if(info.class_book[j]<0 || info.class_book[j]>=vi.books)  				{ 					//goto err_out; 					info.free(); 					return(null); 				} 				for(int k=0;k<(1<<info.class_subs[j]);k++)  				{ 					info.class_subbook[j][k]=opb.read(8)-1; 					if(info.class_subbook[j][k]<-1 || info.class_subbook[j][k]>=vi.books)  					{ 						//goto err_out; 						info.free(); 						return(null); 					} 				} 			}
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,unpack,The following statement contains a magic number: info.mult=opb.read(2)+1;
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,unpack,The following statement contains a magic number: rangebits=opb.read(4);
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,unpack,The following statement contains a magic number: for(int j=0'k=0;j<info.partitions;j++)  			{ 				count+=info.class_dim[info.partitionclass[j]]; 				for(;k<count;k++)  				{ 					int t=info.postlist[k+2]=opb.read(rangebits); 					if(t<0 || t>=(1<<rangebits))  					{ 						//goto err_out; 						info.free(); 						return(null); 					} 				} 			}
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,look,The following statement contains a magic number: int[] sortpointer=new int[VIF_POSIT+2];
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,look,The following statement contains a magic number: _n+=2;
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,look,The following statement contains a magic number: switch(info.mult)  			{ 				case 1: /* 1024 -> 256 */ 					look.quant_q=256; 					break; 				case 2: /* 1024 -> 128 */ 					look.quant_q=128; 					break; 				case 3: /* 1024 -> 86 */ 					look.quant_q=86; 					break; 				case 4: /* 1024 -> 64 */ 					look.quant_q=64; 					break; 				default: 					look.quant_q=-1; 					break; 			}
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,look,The following statement contains a magic number: switch(info.mult)  			{ 				case 1: /* 1024 -> 256 */ 					look.quant_q=256; 					break; 				case 2: /* 1024 -> 128 */ 					look.quant_q=128; 					break; 				case 3: /* 1024 -> 86 */ 					look.quant_q=86; 					break; 				case 4: /* 1024 -> 64 */ 					look.quant_q=64; 					break; 				default: 					look.quant_q=-1; 					break; 			}
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,look,The following statement contains a magic number: switch(info.mult)  			{ 				case 1: /* 1024 -> 256 */ 					look.quant_q=256; 					break; 				case 2: /* 1024 -> 128 */ 					look.quant_q=128; 					break; 				case 3: /* 1024 -> 86 */ 					look.quant_q=86; 					break; 				case 4: /* 1024 -> 64 */ 					look.quant_q=64; 					break; 				default: 					look.quant_q=-1; 					break; 			}
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,look,The following statement contains a magic number: switch(info.mult)  			{ 				case 1: /* 1024 -> 256 */ 					look.quant_q=256; 					break; 				case 2: /* 1024 -> 128 */ 					look.quant_q=128; 					break; 				case 3: /* 1024 -> 86 */ 					look.quant_q=86; 					break; 				case 4: /* 1024 -> 64 */ 					look.quant_q=64; 					break; 				default: 					look.quant_q=-1; 					break; 			}
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,look,The following statement contains a magic number: switch(info.mult)  			{ 				case 1: /* 1024 -> 256 */ 					look.quant_q=256; 					break; 				case 2: /* 1024 -> 128 */ 					look.quant_q=128; 					break; 				case 3: /* 1024 -> 86 */ 					look.quant_q=86; 					break; 				case 4: /* 1024 -> 64 */ 					look.quant_q=64; 					break; 				default: 					look.quant_q=-1; 					break; 			}
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,look,The following statement contains a magic number: switch(info.mult)  			{ 				case 1: /* 1024 -> 256 */ 					look.quant_q=256; 					break; 				case 2: /* 1024 -> 128 */ 					look.quant_q=128; 					break; 				case 3: /* 1024 -> 86 */ 					look.quant_q=86; 					break; 				case 4: /* 1024 -> 64 */ 					look.quant_q=64; 					break; 				default: 					look.quant_q=-1; 					break; 			}
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,look,The following statement contains a magic number: switch(info.mult)  			{ 				case 1: /* 1024 -> 256 */ 					look.quant_q=256; 					break; 				case 2: /* 1024 -> 128 */ 					look.quant_q=128; 					break; 				case 3: /* 1024 -> 86 */ 					look.quant_q=86; 					break; 				case 4: /* 1024 -> 64 */ 					look.quant_q=64; 					break; 				default: 					look.quant_q=-1; 					break; 			}
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,look,The following statement contains a magic number: for(int j=0;j<_n-2;j++)  			{ 				int lo=0; 				int hi=1; 				int lx=0; 				int hx=look.n; 				int currentx=info.postlist[j+2]; 				for(int k=0;k<j+2;k++)  				{ 					int x=info.postlist[k]; 					if(x>lx && x<currentx)  					{ 						lo=k; 						lx=x; 					} 					if(x<hx && x>currentx)  					{ 						hi=k; 						hx=x; 					} 				} 				look.loneighbor[j]=lo; 				look.hineighbor[j]=hi; 			}
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,look,The following statement contains a magic number: for(int j=0;j<_n-2;j++)  			{ 				int lo=0; 				int hi=1; 				int lx=0; 				int hx=look.n; 				int currentx=info.postlist[j+2]; 				for(int k=0;k<j+2;k++)  				{ 					int x=info.postlist[k]; 					if(x>lx && x<currentx)  					{ 						lo=k; 						lx=x; 					} 					if(x<hx && x>currentx)  					{ 						hi=k; 						hx=x; 					} 				} 				look.loneighbor[j]=lo; 				look.hineighbor[j]=hi; 			}
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,look,The following statement contains a magic number: for(int j=0;j<_n-2;j++)  			{ 				int lo=0; 				int hi=1; 				int lx=0; 				int hx=look.n; 				int currentx=info.postlist[j+2]; 				for(int k=0;k<j+2;k++)  				{ 					int x=info.postlist[k]; 					if(x>lx && x<currentx)  					{ 						lo=k; 						lx=x; 					} 					if(x<hx && x>currentx)  					{ 						hi=k; 						hx=x; 					} 				} 				look.loneighbor[j]=lo; 				look.hineighbor[j]=hi; 			}
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,inverse1,The following statement contains a magic number: if(vb.opb.read(1)==1)  			{ 				int[] fit_value=null; 				if(memo is int[])  				{ 					fit_value=(int[])memo; 				} 				if(fit_value==null || fit_value.Length<look.posts)  				{ 					fit_value=new int[look.posts]; 				} 				else  				{ 					for(int i=0; i<fit_value.Length; i++) fit_value[i]=0; 				}  				fit_value[0]=vb.opb.read(ilog(look.quant_q-1)); 				fit_value[1]=vb.opb.read(ilog(look.quant_q-1));  				/* partition by partition */ 				for(int i=0'j=2;i<info.partitions;i++)  				{ 					int clss=info.partitionclass[i]; 					int cdim=info.class_dim[clss]; 					int csubbits=info.class_subs[clss]; 					int csub=1<<csubbits; 					int cval=0;  					/* decode the partition's first stage cascade value */ 					if(csubbits!=0)  					{ 						cval=books[info.class_book[clss]].decode(vb.opb);  						if(cval==-1)  						{ 							//goto eop; 							return(null); 						} 					}  					for(int k=0;k<cdim;k++)  					{ 						int book=info.class_subbook[clss][cval&(csub-1)]; 						cval = (int)((uint)cval >> csubbits); 						if(book>=0)  						{ 							if((fit_value[j+k]=books[book].decode(vb.opb))==-1)  							{ 								return(null); 							} 						} 						else  						{ 							fit_value[j+k]=0; 						} 					} 					j+=cdim; 				}  				/* unwrap positive values and reconsitute via linear interpolation */ 				for(int i=2;i<look.posts;i++)  				{ 					int predicted=render_point(info.postlist[look.loneighbor[i-2]]' 						info.postlist[look.hineighbor[i-2]]' 						fit_value[look.loneighbor[i-2]]' 						fit_value[look.hineighbor[i-2]]' 						info.postlist[i]); 					int hiroom=look.quant_q-predicted; 					int loroom=predicted; 					int room=(hiroom<loroom?hiroom:loroom)<<1; 					int val=fit_value[i];  					if(val!=0)  					{ 						if(val>=room)  						{ 							if(hiroom>loroom)  							{ 								val = val-loroom; 							} 							else  							{ 								val = -1-(val-hiroom); 							} 						} 						else  						{ 							if((val&1)!=0)  							{ 								val= (int)(-((uint)(val+1) >> 1)); 							} 							else  							{ 								val>>=1; 							} 						}  						fit_value[i]=val+predicted; 						fit_value[look.loneighbor[i-2]]&=0x7fff; 						fit_value[look.hineighbor[i-2]]&=0x7fff; 					} 					else  					{ 						fit_value[i]=predicted|0x8000; 					} 				} 				return(fit_value); 			}
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,inverse1,The following statement contains a magic number: if(vb.opb.read(1)==1)  			{ 				int[] fit_value=null; 				if(memo is int[])  				{ 					fit_value=(int[])memo; 				} 				if(fit_value==null || fit_value.Length<look.posts)  				{ 					fit_value=new int[look.posts]; 				} 				else  				{ 					for(int i=0; i<fit_value.Length; i++) fit_value[i]=0; 				}  				fit_value[0]=vb.opb.read(ilog(look.quant_q-1)); 				fit_value[1]=vb.opb.read(ilog(look.quant_q-1));  				/* partition by partition */ 				for(int i=0'j=2;i<info.partitions;i++)  				{ 					int clss=info.partitionclass[i]; 					int cdim=info.class_dim[clss]; 					int csubbits=info.class_subs[clss]; 					int csub=1<<csubbits; 					int cval=0;  					/* decode the partition's first stage cascade value */ 					if(csubbits!=0)  					{ 						cval=books[info.class_book[clss]].decode(vb.opb);  						if(cval==-1)  						{ 							//goto eop; 							return(null); 						} 					}  					for(int k=0;k<cdim;k++)  					{ 						int book=info.class_subbook[clss][cval&(csub-1)]; 						cval = (int)((uint)cval >> csubbits); 						if(book>=0)  						{ 							if((fit_value[j+k]=books[book].decode(vb.opb))==-1)  							{ 								return(null); 							} 						} 						else  						{ 							fit_value[j+k]=0; 						} 					} 					j+=cdim; 				}  				/* unwrap positive values and reconsitute via linear interpolation */ 				for(int i=2;i<look.posts;i++)  				{ 					int predicted=render_point(info.postlist[look.loneighbor[i-2]]' 						info.postlist[look.hineighbor[i-2]]' 						fit_value[look.loneighbor[i-2]]' 						fit_value[look.hineighbor[i-2]]' 						info.postlist[i]); 					int hiroom=look.quant_q-predicted; 					int loroom=predicted; 					int room=(hiroom<loroom?hiroom:loroom)<<1; 					int val=fit_value[i];  					if(val!=0)  					{ 						if(val>=room)  						{ 							if(hiroom>loroom)  							{ 								val = val-loroom; 							} 							else  							{ 								val = -1-(val-hiroom); 							} 						} 						else  						{ 							if((val&1)!=0)  							{ 								val= (int)(-((uint)(val+1) >> 1)); 							} 							else  							{ 								val>>=1; 							} 						}  						fit_value[i]=val+predicted; 						fit_value[look.loneighbor[i-2]]&=0x7fff; 						fit_value[look.hineighbor[i-2]]&=0x7fff; 					} 					else  					{ 						fit_value[i]=predicted|0x8000; 					} 				} 				return(fit_value); 			}
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,inverse1,The following statement contains a magic number: if(vb.opb.read(1)==1)  			{ 				int[] fit_value=null; 				if(memo is int[])  				{ 					fit_value=(int[])memo; 				} 				if(fit_value==null || fit_value.Length<look.posts)  				{ 					fit_value=new int[look.posts]; 				} 				else  				{ 					for(int i=0; i<fit_value.Length; i++) fit_value[i]=0; 				}  				fit_value[0]=vb.opb.read(ilog(look.quant_q-1)); 				fit_value[1]=vb.opb.read(ilog(look.quant_q-1));  				/* partition by partition */ 				for(int i=0'j=2;i<info.partitions;i++)  				{ 					int clss=info.partitionclass[i]; 					int cdim=info.class_dim[clss]; 					int csubbits=info.class_subs[clss]; 					int csub=1<<csubbits; 					int cval=0;  					/* decode the partition's first stage cascade value */ 					if(csubbits!=0)  					{ 						cval=books[info.class_book[clss]].decode(vb.opb);  						if(cval==-1)  						{ 							//goto eop; 							return(null); 						} 					}  					for(int k=0;k<cdim;k++)  					{ 						int book=info.class_subbook[clss][cval&(csub-1)]; 						cval = (int)((uint)cval >> csubbits); 						if(book>=0)  						{ 							if((fit_value[j+k]=books[book].decode(vb.opb))==-1)  							{ 								return(null); 							} 						} 						else  						{ 							fit_value[j+k]=0; 						} 					} 					j+=cdim; 				}  				/* unwrap positive values and reconsitute via linear interpolation */ 				for(int i=2;i<look.posts;i++)  				{ 					int predicted=render_point(info.postlist[look.loneighbor[i-2]]' 						info.postlist[look.hineighbor[i-2]]' 						fit_value[look.loneighbor[i-2]]' 						fit_value[look.hineighbor[i-2]]' 						info.postlist[i]); 					int hiroom=look.quant_q-predicted; 					int loroom=predicted; 					int room=(hiroom<loroom?hiroom:loroom)<<1; 					int val=fit_value[i];  					if(val!=0)  					{ 						if(val>=room)  						{ 							if(hiroom>loroom)  							{ 								val = val-loroom; 							} 							else  							{ 								val = -1-(val-hiroom); 							} 						} 						else  						{ 							if((val&1)!=0)  							{ 								val= (int)(-((uint)(val+1) >> 1)); 							} 							else  							{ 								val>>=1; 							} 						}  						fit_value[i]=val+predicted; 						fit_value[look.loneighbor[i-2]]&=0x7fff; 						fit_value[look.hineighbor[i-2]]&=0x7fff; 					} 					else  					{ 						fit_value[i]=predicted|0x8000; 					} 				} 				return(fit_value); 			}
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,inverse1,The following statement contains a magic number: if(vb.opb.read(1)==1)  			{ 				int[] fit_value=null; 				if(memo is int[])  				{ 					fit_value=(int[])memo; 				} 				if(fit_value==null || fit_value.Length<look.posts)  				{ 					fit_value=new int[look.posts]; 				} 				else  				{ 					for(int i=0; i<fit_value.Length; i++) fit_value[i]=0; 				}  				fit_value[0]=vb.opb.read(ilog(look.quant_q-1)); 				fit_value[1]=vb.opb.read(ilog(look.quant_q-1));  				/* partition by partition */ 				for(int i=0'j=2;i<info.partitions;i++)  				{ 					int clss=info.partitionclass[i]; 					int cdim=info.class_dim[clss]; 					int csubbits=info.class_subs[clss]; 					int csub=1<<csubbits; 					int cval=0;  					/* decode the partition's first stage cascade value */ 					if(csubbits!=0)  					{ 						cval=books[info.class_book[clss]].decode(vb.opb);  						if(cval==-1)  						{ 							//goto eop; 							return(null); 						} 					}  					for(int k=0;k<cdim;k++)  					{ 						int book=info.class_subbook[clss][cval&(csub-1)]; 						cval = (int)((uint)cval >> csubbits); 						if(book>=0)  						{ 							if((fit_value[j+k]=books[book].decode(vb.opb))==-1)  							{ 								return(null); 							} 						} 						else  						{ 							fit_value[j+k]=0; 						} 					} 					j+=cdim; 				}  				/* unwrap positive values and reconsitute via linear interpolation */ 				for(int i=2;i<look.posts;i++)  				{ 					int predicted=render_point(info.postlist[look.loneighbor[i-2]]' 						info.postlist[look.hineighbor[i-2]]' 						fit_value[look.loneighbor[i-2]]' 						fit_value[look.hineighbor[i-2]]' 						info.postlist[i]); 					int hiroom=look.quant_q-predicted; 					int loroom=predicted; 					int room=(hiroom<loroom?hiroom:loroom)<<1; 					int val=fit_value[i];  					if(val!=0)  					{ 						if(val>=room)  						{ 							if(hiroom>loroom)  							{ 								val = val-loroom; 							} 							else  							{ 								val = -1-(val-hiroom); 							} 						} 						else  						{ 							if((val&1)!=0)  							{ 								val= (int)(-((uint)(val+1) >> 1)); 							} 							else  							{ 								val>>=1; 							} 						}  						fit_value[i]=val+predicted; 						fit_value[look.loneighbor[i-2]]&=0x7fff; 						fit_value[look.hineighbor[i-2]]&=0x7fff; 					} 					else  					{ 						fit_value[i]=predicted|0x8000; 					} 				} 				return(fit_value); 			}
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,inverse1,The following statement contains a magic number: if(vb.opb.read(1)==1)  			{ 				int[] fit_value=null; 				if(memo is int[])  				{ 					fit_value=(int[])memo; 				} 				if(fit_value==null || fit_value.Length<look.posts)  				{ 					fit_value=new int[look.posts]; 				} 				else  				{ 					for(int i=0; i<fit_value.Length; i++) fit_value[i]=0; 				}  				fit_value[0]=vb.opb.read(ilog(look.quant_q-1)); 				fit_value[1]=vb.opb.read(ilog(look.quant_q-1));  				/* partition by partition */ 				for(int i=0'j=2;i<info.partitions;i++)  				{ 					int clss=info.partitionclass[i]; 					int cdim=info.class_dim[clss]; 					int csubbits=info.class_subs[clss]; 					int csub=1<<csubbits; 					int cval=0;  					/* decode the partition's first stage cascade value */ 					if(csubbits!=0)  					{ 						cval=books[info.class_book[clss]].decode(vb.opb);  						if(cval==-1)  						{ 							//goto eop; 							return(null); 						} 					}  					for(int k=0;k<cdim;k++)  					{ 						int book=info.class_subbook[clss][cval&(csub-1)]; 						cval = (int)((uint)cval >> csubbits); 						if(book>=0)  						{ 							if((fit_value[j+k]=books[book].decode(vb.opb))==-1)  							{ 								return(null); 							} 						} 						else  						{ 							fit_value[j+k]=0; 						} 					} 					j+=cdim; 				}  				/* unwrap positive values and reconsitute via linear interpolation */ 				for(int i=2;i<look.posts;i++)  				{ 					int predicted=render_point(info.postlist[look.loneighbor[i-2]]' 						info.postlist[look.hineighbor[i-2]]' 						fit_value[look.loneighbor[i-2]]' 						fit_value[look.hineighbor[i-2]]' 						info.postlist[i]); 					int hiroom=look.quant_q-predicted; 					int loroom=predicted; 					int room=(hiroom<loroom?hiroom:loroom)<<1; 					int val=fit_value[i];  					if(val!=0)  					{ 						if(val>=room)  						{ 							if(hiroom>loroom)  							{ 								val = val-loroom; 							} 							else  							{ 								val = -1-(val-hiroom); 							} 						} 						else  						{ 							if((val&1)!=0)  							{ 								val= (int)(-((uint)(val+1) >> 1)); 							} 							else  							{ 								val>>=1; 							} 						}  						fit_value[i]=val+predicted; 						fit_value[look.loneighbor[i-2]]&=0x7fff; 						fit_value[look.hineighbor[i-2]]&=0x7fff; 					} 					else  					{ 						fit_value[i]=predicted|0x8000; 					} 				} 				return(fit_value); 			}
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,inverse1,The following statement contains a magic number: if(vb.opb.read(1)==1)  			{ 				int[] fit_value=null; 				if(memo is int[])  				{ 					fit_value=(int[])memo; 				} 				if(fit_value==null || fit_value.Length<look.posts)  				{ 					fit_value=new int[look.posts]; 				} 				else  				{ 					for(int i=0; i<fit_value.Length; i++) fit_value[i]=0; 				}  				fit_value[0]=vb.opb.read(ilog(look.quant_q-1)); 				fit_value[1]=vb.opb.read(ilog(look.quant_q-1));  				/* partition by partition */ 				for(int i=0'j=2;i<info.partitions;i++)  				{ 					int clss=info.partitionclass[i]; 					int cdim=info.class_dim[clss]; 					int csubbits=info.class_subs[clss]; 					int csub=1<<csubbits; 					int cval=0;  					/* decode the partition's first stage cascade value */ 					if(csubbits!=0)  					{ 						cval=books[info.class_book[clss]].decode(vb.opb);  						if(cval==-1)  						{ 							//goto eop; 							return(null); 						} 					}  					for(int k=0;k<cdim;k++)  					{ 						int book=info.class_subbook[clss][cval&(csub-1)]; 						cval = (int)((uint)cval >> csubbits); 						if(book>=0)  						{ 							if((fit_value[j+k]=books[book].decode(vb.opb))==-1)  							{ 								return(null); 							} 						} 						else  						{ 							fit_value[j+k]=0; 						} 					} 					j+=cdim; 				}  				/* unwrap positive values and reconsitute via linear interpolation */ 				for(int i=2;i<look.posts;i++)  				{ 					int predicted=render_point(info.postlist[look.loneighbor[i-2]]' 						info.postlist[look.hineighbor[i-2]]' 						fit_value[look.loneighbor[i-2]]' 						fit_value[look.hineighbor[i-2]]' 						info.postlist[i]); 					int hiroom=look.quant_q-predicted; 					int loroom=predicted; 					int room=(hiroom<loroom?hiroom:loroom)<<1; 					int val=fit_value[i];  					if(val!=0)  					{ 						if(val>=room)  						{ 							if(hiroom>loroom)  							{ 								val = val-loroom; 							} 							else  							{ 								val = -1-(val-hiroom); 							} 						} 						else  						{ 							if((val&1)!=0)  							{ 								val= (int)(-((uint)(val+1) >> 1)); 							} 							else  							{ 								val>>=1; 							} 						}  						fit_value[i]=val+predicted; 						fit_value[look.loneighbor[i-2]]&=0x7fff; 						fit_value[look.hineighbor[i-2]]&=0x7fff; 					} 					else  					{ 						fit_value[i]=predicted|0x8000; 					} 				} 				return(fit_value); 			}
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,inverse1,The following statement contains a magic number: if(vb.opb.read(1)==1)  			{ 				int[] fit_value=null; 				if(memo is int[])  				{ 					fit_value=(int[])memo; 				} 				if(fit_value==null || fit_value.Length<look.posts)  				{ 					fit_value=new int[look.posts]; 				} 				else  				{ 					for(int i=0; i<fit_value.Length; i++) fit_value[i]=0; 				}  				fit_value[0]=vb.opb.read(ilog(look.quant_q-1)); 				fit_value[1]=vb.opb.read(ilog(look.quant_q-1));  				/* partition by partition */ 				for(int i=0'j=2;i<info.partitions;i++)  				{ 					int clss=info.partitionclass[i]; 					int cdim=info.class_dim[clss]; 					int csubbits=info.class_subs[clss]; 					int csub=1<<csubbits; 					int cval=0;  					/* decode the partition's first stage cascade value */ 					if(csubbits!=0)  					{ 						cval=books[info.class_book[clss]].decode(vb.opb);  						if(cval==-1)  						{ 							//goto eop; 							return(null); 						} 					}  					for(int k=0;k<cdim;k++)  					{ 						int book=info.class_subbook[clss][cval&(csub-1)]; 						cval = (int)((uint)cval >> csubbits); 						if(book>=0)  						{ 							if((fit_value[j+k]=books[book].decode(vb.opb))==-1)  							{ 								return(null); 							} 						} 						else  						{ 							fit_value[j+k]=0; 						} 					} 					j+=cdim; 				}  				/* unwrap positive values and reconsitute via linear interpolation */ 				for(int i=2;i<look.posts;i++)  				{ 					int predicted=render_point(info.postlist[look.loneighbor[i-2]]' 						info.postlist[look.hineighbor[i-2]]' 						fit_value[look.loneighbor[i-2]]' 						fit_value[look.hineighbor[i-2]]' 						info.postlist[i]); 					int hiroom=look.quant_q-predicted; 					int loroom=predicted; 					int room=(hiroom<loroom?hiroom:loroom)<<1; 					int val=fit_value[i];  					if(val!=0)  					{ 						if(val>=room)  						{ 							if(hiroom>loroom)  							{ 								val = val-loroom; 							} 							else  							{ 								val = -1-(val-hiroom); 							} 						} 						else  						{ 							if((val&1)!=0)  							{ 								val= (int)(-((uint)(val+1) >> 1)); 							} 							else  							{ 								val>>=1; 							} 						}  						fit_value[i]=val+predicted; 						fit_value[look.loneighbor[i-2]]&=0x7fff; 						fit_value[look.hineighbor[i-2]]&=0x7fff; 					} 					else  					{ 						fit_value[i]=predicted|0x8000; 					} 				} 				return(fit_value); 			}
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,inverse1,The following statement contains a magic number: if(vb.opb.read(1)==1)  			{ 				int[] fit_value=null; 				if(memo is int[])  				{ 					fit_value=(int[])memo; 				} 				if(fit_value==null || fit_value.Length<look.posts)  				{ 					fit_value=new int[look.posts]; 				} 				else  				{ 					for(int i=0; i<fit_value.Length; i++) fit_value[i]=0; 				}  				fit_value[0]=vb.opb.read(ilog(look.quant_q-1)); 				fit_value[1]=vb.opb.read(ilog(look.quant_q-1));  				/* partition by partition */ 				for(int i=0'j=2;i<info.partitions;i++)  				{ 					int clss=info.partitionclass[i]; 					int cdim=info.class_dim[clss]; 					int csubbits=info.class_subs[clss]; 					int csub=1<<csubbits; 					int cval=0;  					/* decode the partition's first stage cascade value */ 					if(csubbits!=0)  					{ 						cval=books[info.class_book[clss]].decode(vb.opb);  						if(cval==-1)  						{ 							//goto eop; 							return(null); 						} 					}  					for(int k=0;k<cdim;k++)  					{ 						int book=info.class_subbook[clss][cval&(csub-1)]; 						cval = (int)((uint)cval >> csubbits); 						if(book>=0)  						{ 							if((fit_value[j+k]=books[book].decode(vb.opb))==-1)  							{ 								return(null); 							} 						} 						else  						{ 							fit_value[j+k]=0; 						} 					} 					j+=cdim; 				}  				/* unwrap positive values and reconsitute via linear interpolation */ 				for(int i=2;i<look.posts;i++)  				{ 					int predicted=render_point(info.postlist[look.loneighbor[i-2]]' 						info.postlist[look.hineighbor[i-2]]' 						fit_value[look.loneighbor[i-2]]' 						fit_value[look.hineighbor[i-2]]' 						info.postlist[i]); 					int hiroom=look.quant_q-predicted; 					int loroom=predicted; 					int room=(hiroom<loroom?hiroom:loroom)<<1; 					int val=fit_value[i];  					if(val!=0)  					{ 						if(val>=room)  						{ 							if(hiroom>loroom)  							{ 								val = val-loroom; 							} 							else  							{ 								val = -1-(val-hiroom); 							} 						} 						else  						{ 							if((val&1)!=0)  							{ 								val= (int)(-((uint)(val+1) >> 1)); 							} 							else  							{ 								val>>=1; 							} 						}  						fit_value[i]=val+predicted; 						fit_value[look.loneighbor[i-2]]&=0x7fff; 						fit_value[look.hineighbor[i-2]]&=0x7fff; 					} 					else  					{ 						fit_value[i]=predicted|0x8000; 					} 				} 				return(fit_value); 			}
Magic Number,csvorbis,Floor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,inverse2,The following statement contains a magic number: int n=vb.vd.vi.blocksizes[vb.mode]/2;
Magic Number,csvorbis,InfoFloor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,InfoFloor1,The following statement contains a magic number: for(int i=0; i<class_subbook.Length; i++)  			{ 				class_subbook[i]=new int[8];       			}
Magic Number,csvorbis,InfoFloor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,copy_info,The following statement contains a magic number: for(int j=0; j<VIF_CLASS; j++)  			{ 				Array.Copy(info.class_subbook[j]' 0'  					ret.class_subbook[j]' 0' 8); 			}
Magic Number,csvorbis,InfoFloor1,C:\repos\mono_csvorbis\csvorbis\Floor1.cs,copy_info,The following statement contains a magic number: Array.Copy(info.postlist' 0' ret.postlist' 0' VIF_POSIT+2);
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,unpack_info,The following statement contains a magic number: version=opb.read(32);
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,unpack_info,The following statement contains a magic number: channels=opb.read(8);
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,unpack_info,The following statement contains a magic number: rate=opb.read(32);
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,unpack_info,The following statement contains a magic number: bitrate_upper=opb.read(32);
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,unpack_info,The following statement contains a magic number: bitrate_nominal=opb.read(32);
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,unpack_info,The following statement contains a magic number: bitrate_lower=opb.read(32);
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,unpack_info,The following statement contains a magic number: blocksizes[0]=1<<opb.read(4);
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,unpack_info,The following statement contains a magic number: blocksizes[1]=1<<opb.read(4);
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,unpack_info,The following statement contains a magic number: if((rate<1) || 				(channels<1)|| 				(blocksizes[0]<8)|| 				(blocksizes[1]<blocksizes[0]) || 				(opb.read(1)!=1))  			{ 				//goto err_out; // EOP check 				clear(); 				return(-1); 			}
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: books=opb.read(8)+1;
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: times=opb.read(6)+1;
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: for(int i=0;i<times;i++)  			{ 				time_type[i]=opb.read(16); 				if(time_type[i]<0 || time_type[i]>=VI_TIMEB)  				{ 					//goto err_out; 					clear(); 					return(-1); 				} 				time_param[i]=FuncTime.time_P[time_type[i]].unpack(this' opb); 				if(time_param[i]==null)  				{ 					//goto err_out; 					clear(); 					return(-1); 				} 			}
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: floors=opb.read(6)+1;
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: for(int i=0;i<floors;i++)  			{ 				floor_type[i]=opb.read(16); 				if(floor_type[i]<0 || floor_type[i]>=VI_FLOORB)  				{ 					//goto err_out; 					clear(); 					return(-1); 				}  				floor_param[i]=FuncFloor.floor_P[floor_type[i]].unpack(this'opb); 				if(floor_param[i]==null)  				{ 					//goto err_out; 					clear(); 					return(-1); 				} 			}
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: residues=opb.read(6)+1;
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: for(int i=0;i<residues;i++)  			{ 				residue_type[i]=opb.read(16); 				if(residue_type[i]<0 || residue_type[i]>=VI_RESB)  				{ 					//	goto err_out; 					clear(); 					return(-1); 				} 				residue_param[i]=FuncResidue.residue_P[residue_type[i]].unpack(this'opb); 				if(residue_param[i]==null)  				{ 					//	goto err_out; 					clear(); 					return(-1); 				} 			}
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: maps=opb.read(6)+1;
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: for(int i=0;i<maps;i++)  			{ 				map_type[i]=opb.read(16); 				if(map_type[i]<0 || map_type[i]>=VI_MAPB)  				{ 					//	goto err_out; 					clear(); 					return(-1); 				} 				map_param[i]=FuncMapping.mapping_P[map_type[i]].unpack(this'opb); 				if(map_param[i]==null)  				{ 					//    goto err_out; 					clear(); 					return(-1); 				} 			}
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: modes=opb.read(6)+1;
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: for(int i=0;i<modes;i++)  			{ 				mode_param[i]=new InfoMode(); 				mode_param[i].blockflag=opb.read(1); 				mode_param[i].windowtype=opb.read(16); 				mode_param[i].transformtype=opb.read(16); 				mode_param[i].mapping=opb.read(8);  				if((mode_param[i].windowtype>=VI_WINDOWB)|| 					(mode_param[i].transformtype>=VI_WINDOWB)|| 					(mode_param[i].mapping>=maps))  				{ 					//      goto err_out; 					clear(); 					return(-1); 				} 			}
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: for(int i=0;i<modes;i++)  			{ 				mode_param[i]=new InfoMode(); 				mode_param[i].blockflag=opb.read(1); 				mode_param[i].windowtype=opb.read(16); 				mode_param[i].transformtype=opb.read(16); 				mode_param[i].mapping=opb.read(8);  				if((mode_param[i].windowtype>=VI_WINDOWB)|| 					(mode_param[i].transformtype>=VI_WINDOWB)|| 					(mode_param[i].mapping>=maps))  				{ 					//      goto err_out; 					clear(); 					return(-1); 				} 			}
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: for(int i=0;i<modes;i++)  			{ 				mode_param[i]=new InfoMode(); 				mode_param[i].blockflag=opb.read(1); 				mode_param[i].windowtype=opb.read(16); 				mode_param[i].transformtype=opb.read(16); 				mode_param[i].mapping=opb.read(8);  				if((mode_param[i].windowtype>=VI_WINDOWB)|| 					(mode_param[i].transformtype>=VI_WINDOWB)|| 					(mode_param[i].mapping>=maps))  				{ 					//      goto err_out; 					clear(); 					return(-1); 				} 			}
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,synthesis_headerin,The following statement contains a magic number: if(op!=null)  			{   				opb.readinit(op.packet_base' op.packet' op.bytes);  				// Which of the three types of header is this? 				// Also verify header-ness' vorbis 			{ 				byte[] buffer=new byte[6]; 				int packtype=opb.read(8); 				//memset(buffer'0'6); 				opb.read(buffer'6); 				if(buffer[0]!='v' || buffer[1]!='o' || buffer[2]!='r' || 					buffer[3]!='b' || buffer[4]!='i' || buffer[5]!='s')  				{ 					// not a vorbis header 					return(-1); 				} 				switch(packtype)  				{ 					case 0x01: // least significant *bit* is read first 						if(op.b_o_s==0)  						{ 							// Not the initial packet 							return(-1); 						} 						if(rate!=0)  						{ 							// previously initialized info header 							return(-1); 						} 						return(unpack_info(opb)); 					case 0x03: // least significant *bit* is read first 						if(rate==0)  						{ 							// um... we didn't get the initial header 							return(-1); 						} 						return(vc.unpack(opb)); 					case 0x05: // least significant *bit* is read first 						if(rate==0 || vc.vendor==null)  						{ 							// um... we didn;t get the initial header or comments yet 							return(-1); 						} 						return(unpack_books(opb)); 					default: 						// Not a valid vorbis header type 						//return(-1); 						break; 				} 			} 			}
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,synthesis_headerin,The following statement contains a magic number: if(op!=null)  			{   				opb.readinit(op.packet_base' op.packet' op.bytes);  				// Which of the three types of header is this? 				// Also verify header-ness' vorbis 			{ 				byte[] buffer=new byte[6]; 				int packtype=opb.read(8); 				//memset(buffer'0'6); 				opb.read(buffer'6); 				if(buffer[0]!='v' || buffer[1]!='o' || buffer[2]!='r' || 					buffer[3]!='b' || buffer[4]!='i' || buffer[5]!='s')  				{ 					// not a vorbis header 					return(-1); 				} 				switch(packtype)  				{ 					case 0x01: // least significant *bit* is read first 						if(op.b_o_s==0)  						{ 							// Not the initial packet 							return(-1); 						} 						if(rate!=0)  						{ 							// previously initialized info header 							return(-1); 						} 						return(unpack_info(opb)); 					case 0x03: // least significant *bit* is read first 						if(rate==0)  						{ 							// um... we didn't get the initial header 							return(-1); 						} 						return(vc.unpack(opb)); 					case 0x05: // least significant *bit* is read first 						if(rate==0 || vc.vendor==null)  						{ 							// um... we didn;t get the initial header or comments yet 							return(-1); 						} 						return(unpack_books(opb)); 					default: 						// Not a valid vorbis header type 						//return(-1); 						break; 				} 			} 			}
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,synthesis_headerin,The following statement contains a magic number: if(op!=null)  			{   				opb.readinit(op.packet_base' op.packet' op.bytes);  				// Which of the three types of header is this? 				// Also verify header-ness' vorbis 			{ 				byte[] buffer=new byte[6]; 				int packtype=opb.read(8); 				//memset(buffer'0'6); 				opb.read(buffer'6); 				if(buffer[0]!='v' || buffer[1]!='o' || buffer[2]!='r' || 					buffer[3]!='b' || buffer[4]!='i' || buffer[5]!='s')  				{ 					// not a vorbis header 					return(-1); 				} 				switch(packtype)  				{ 					case 0x01: // least significant *bit* is read first 						if(op.b_o_s==0)  						{ 							// Not the initial packet 							return(-1); 						} 						if(rate!=0)  						{ 							// previously initialized info header 							return(-1); 						} 						return(unpack_info(opb)); 					case 0x03: // least significant *bit* is read first 						if(rate==0)  						{ 							// um... we didn't get the initial header 							return(-1); 						} 						return(vc.unpack(opb)); 					case 0x05: // least significant *bit* is read first 						if(rate==0 || vc.vendor==null)  						{ 							// um... we didn;t get the initial header or comments yet 							return(-1); 						} 						return(unpack_books(opb)); 					default: 						// Not a valid vorbis header type 						//return(-1); 						break; 				} 			} 			}
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,synthesis_headerin,The following statement contains a magic number: if(op!=null)  			{   				opb.readinit(op.packet_base' op.packet' op.bytes);  				// Which of the three types of header is this? 				// Also verify header-ness' vorbis 			{ 				byte[] buffer=new byte[6]; 				int packtype=opb.read(8); 				//memset(buffer'0'6); 				opb.read(buffer'6); 				if(buffer[0]!='v' || buffer[1]!='o' || buffer[2]!='r' || 					buffer[3]!='b' || buffer[4]!='i' || buffer[5]!='s')  				{ 					// not a vorbis header 					return(-1); 				} 				switch(packtype)  				{ 					case 0x01: // least significant *bit* is read first 						if(op.b_o_s==0)  						{ 							// Not the initial packet 							return(-1); 						} 						if(rate!=0)  						{ 							// previously initialized info header 							return(-1); 						} 						return(unpack_info(opb)); 					case 0x03: // least significant *bit* is read first 						if(rate==0)  						{ 							// um... we didn't get the initial header 							return(-1); 						} 						return(vc.unpack(opb)); 					case 0x05: // least significant *bit* is read first 						if(rate==0 || vc.vendor==null)  						{ 							// um... we didn;t get the initial header or comments yet 							return(-1); 						} 						return(unpack_books(opb)); 					default: 						// Not a valid vorbis header type 						//return(-1); 						break; 				} 			} 			}
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,synthesis_headerin,The following statement contains a magic number: if(op!=null)  			{   				opb.readinit(op.packet_base' op.packet' op.bytes);  				// Which of the three types of header is this? 				// Also verify header-ness' vorbis 			{ 				byte[] buffer=new byte[6]; 				int packtype=opb.read(8); 				//memset(buffer'0'6); 				opb.read(buffer'6); 				if(buffer[0]!='v' || buffer[1]!='o' || buffer[2]!='r' || 					buffer[3]!='b' || buffer[4]!='i' || buffer[5]!='s')  				{ 					// not a vorbis header 					return(-1); 				} 				switch(packtype)  				{ 					case 0x01: // least significant *bit* is read first 						if(op.b_o_s==0)  						{ 							// Not the initial packet 							return(-1); 						} 						if(rate!=0)  						{ 							// previously initialized info header 							return(-1); 						} 						return(unpack_info(opb)); 					case 0x03: // least significant *bit* is read first 						if(rate==0)  						{ 							// um... we didn't get the initial header 							return(-1); 						} 						return(vc.unpack(opb)); 					case 0x05: // least significant *bit* is read first 						if(rate==0 || vc.vendor==null)  						{ 							// um... we didn;t get the initial header or comments yet 							return(-1); 						} 						return(unpack_books(opb)); 					default: 						// Not a valid vorbis header type 						//return(-1); 						break; 				} 			} 			}
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,synthesis_headerin,The following statement contains a magic number: if(op!=null)  			{   				opb.readinit(op.packet_base' op.packet' op.bytes);  				// Which of the three types of header is this? 				// Also verify header-ness' vorbis 			{ 				byte[] buffer=new byte[6]; 				int packtype=opb.read(8); 				//memset(buffer'0'6); 				opb.read(buffer'6); 				if(buffer[0]!='v' || buffer[1]!='o' || buffer[2]!='r' || 					buffer[3]!='b' || buffer[4]!='i' || buffer[5]!='s')  				{ 					// not a vorbis header 					return(-1); 				} 				switch(packtype)  				{ 					case 0x01: // least significant *bit* is read first 						if(op.b_o_s==0)  						{ 							// Not the initial packet 							return(-1); 						} 						if(rate!=0)  						{ 							// previously initialized info header 							return(-1); 						} 						return(unpack_info(opb)); 					case 0x03: // least significant *bit* is read first 						if(rate==0)  						{ 							// um... we didn't get the initial header 							return(-1); 						} 						return(vc.unpack(opb)); 					case 0x05: // least significant *bit* is read first 						if(rate==0 || vc.vendor==null)  						{ 							// um... we didn;t get the initial header or comments yet 							return(-1); 						} 						return(unpack_books(opb)); 					default: 						// Not a valid vorbis header type 						//return(-1); 						break; 				} 			} 			}
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,synthesis_headerin,The following statement contains a magic number: if(op!=null)  			{   				opb.readinit(op.packet_base' op.packet' op.bytes);  				// Which of the three types of header is this? 				// Also verify header-ness' vorbis 			{ 				byte[] buffer=new byte[6]; 				int packtype=opb.read(8); 				//memset(buffer'0'6); 				opb.read(buffer'6); 				if(buffer[0]!='v' || buffer[1]!='o' || buffer[2]!='r' || 					buffer[3]!='b' || buffer[4]!='i' || buffer[5]!='s')  				{ 					// not a vorbis header 					return(-1); 				} 				switch(packtype)  				{ 					case 0x01: // least significant *bit* is read first 						if(op.b_o_s==0)  						{ 							// Not the initial packet 							return(-1); 						} 						if(rate!=0)  						{ 							// previously initialized info header 							return(-1); 						} 						return(unpack_info(opb)); 					case 0x03: // least significant *bit* is read first 						if(rate==0)  						{ 							// um... we didn't get the initial header 							return(-1); 						} 						return(vc.unpack(opb)); 					case 0x05: // least significant *bit* is read first 						if(rate==0 || vc.vendor==null)  						{ 							// um... we didn;t get the initial header or comments yet 							return(-1); 						} 						return(unpack_books(opb)); 					default: 						// Not a valid vorbis header type 						//return(-1); 						break; 				} 			} 			}
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,pack_info,The following statement contains a magic number: opb.write(0x01'8);
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,pack_info,The following statement contains a magic number: opb.write(0x00'32);
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,pack_info,The following statement contains a magic number: opb.write(channels'8);
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,pack_info,The following statement contains a magic number: opb.write(rate'32);
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,pack_info,The following statement contains a magic number: opb.write(bitrate_upper'32);
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,pack_info,The following statement contains a magic number: opb.write(bitrate_nominal'32);
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,pack_info,The following statement contains a magic number: opb.write(bitrate_lower'32);
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,pack_info,The following statement contains a magic number: opb.write(ilog2(blocksizes[0])'4);
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,pack_info,The following statement contains a magic number: opb.write(ilog2(blocksizes[1])'4);
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,pack_books,The following statement contains a magic number: opb.write(0x05'8);
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,pack_books,The following statement contains a magic number: opb.write(books-1'8);
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,pack_books,The following statement contains a magic number: opb.write(times-1'6);
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,pack_books,The following statement contains a magic number: for(int i=0;i<times;i++)  			{ 				opb.write(time_type[i]'16); 				FuncTime.time_P[time_type[i]].pack(this.time_param[i]'opb); 			}
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,pack_books,The following statement contains a magic number: opb.write(floors-1'6);
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,pack_books,The following statement contains a magic number: for(int i=0;i<floors;i++)  			{ 				opb.write(floor_type[i]'16); 				FuncFloor.floor_P[floor_type[i]].pack(floor_param[i]'opb); 			}
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,pack_books,The following statement contains a magic number: opb.write(residues-1'6);
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,pack_books,The following statement contains a magic number: for(int i=0;i<residues;i++)  			{ 				opb.write(residue_type[i]'16); 				FuncResidue.residue_P[residue_type[i]].pack(residue_param[i]'opb); 			}
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,pack_books,The following statement contains a magic number: opb.write(maps-1'6);
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,pack_books,The following statement contains a magic number: for(int i=0;i<maps;i++)  			{ 				opb.write(map_type[i]'16); 				FuncMapping.mapping_P[map_type[i]].pack(this'map_param[i]'opb); 			}
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,pack_books,The following statement contains a magic number: opb.write(modes-1'6);
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,pack_books,The following statement contains a magic number: for(int i=0;i<modes;i++)  			{ 				opb.write(mode_param[i].blockflag'1); 				opb.write(mode_param[i].windowtype'16); 				opb.write(mode_param[i].transformtype'16); 				opb.write(mode_param[i].mapping'8); 			}
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,pack_books,The following statement contains a magic number: for(int i=0;i<modes;i++)  			{ 				opb.write(mode_param[i].blockflag'1); 				opb.write(mode_param[i].windowtype'16); 				opb.write(mode_param[i].transformtype'16); 				opb.write(mode_param[i].mapping'8); 			}
Magic Number,csvorbis,Info,C:\repos\mono_csvorbis\csvorbis\Info.cs,pack_books,The following statement contains a magic number: for(int i=0;i<modes;i++)  			{ 				opb.write(mode_param[i].blockflag'1); 				opb.write(mode_param[i].windowtype'16); 				opb.write(mode_param[i].transformtype'16); 				opb.write(mode_param[i].mapping'8); 			}
Magic Number,csvorbis,Lookup,C:\repos\mono_csvorbis\csvorbis\Lookup.cs,coslook,The following statement contains a magic number: double d=a*(.31830989*(float)COS_LOOKUP_SZ);
Magic Number,csvorbis,Lpc,C:\repos\mono_csvorbis\csvorbis\Lpc.cs,lpc_from_data,The following statement contains a magic number: for(i=0;i<m;i++)  			{ 				float r=-aut[i+1];  				if(error==0)  				{ 					for(int k=0; k<m; k++) lpc[k]=0.0f; 					return 0; 				}  				// Sum up this iteration's reflection coefficient; note that in 				// Vorbis we don't save it.  If anyone wants to recycle this code 				// and needs reflection coefficients' save the results of 'r' from 				// each iteration.  				for(j=0;j<i;j++)r-=lpc[j]*aut[i-j]; 				r/=error;   				// Update LPC coefficients and total error      				lpc[i]=r; 				for(j=0;j<i/2;j++)  				{ 					float tmp=lpc[j]; 					lpc[j]+=r*lpc[i-1-j]; 					lpc[i-1-j]+=r*tmp; 				} 				if(i%2!=0)lpc[j]+=lpc[j]*r;      				error*=(float)(1.0-r*r); 			}
Magic Number,csvorbis,Lpc,C:\repos\mono_csvorbis\csvorbis\Lpc.cs,lpc_from_data,The following statement contains a magic number: for(i=0;i<m;i++)  			{ 				float r=-aut[i+1];  				if(error==0)  				{ 					for(int k=0; k<m; k++) lpc[k]=0.0f; 					return 0; 				}  				// Sum up this iteration's reflection coefficient; note that in 				// Vorbis we don't save it.  If anyone wants to recycle this code 				// and needs reflection coefficients' save the results of 'r' from 				// each iteration.  				for(j=0;j<i;j++)r-=lpc[j]*aut[i-j]; 				r/=error;   				// Update LPC coefficients and total error      				lpc[i]=r; 				for(j=0;j<i/2;j++)  				{ 					float tmp=lpc[j]; 					lpc[j]+=r*lpc[i-1-j]; 					lpc[i-1-j]+=r*tmp; 				} 				if(i%2!=0)lpc[j]+=lpc[j]*r;      				error*=(float)(1.0-r*r); 			}
Magic Number,csvorbis,Lpc,C:\repos\mono_csvorbis\csvorbis\Lpc.cs,lpc_from_curve,The following statement contains a magic number: float fscale=(float)(.5/n);
Magic Number,csvorbis,Lpc,C:\repos\mono_csvorbis\csvorbis\Lpc.cs,lpc_from_curve,The following statement contains a magic number: for(i=0;i<n;i++)  			{ 				work[i*2]=curve[i]*fscale; 				work[i*2+1]=0; 			}
Magic Number,csvorbis,Lpc,C:\repos\mono_csvorbis\csvorbis\Lpc.cs,lpc_from_curve,The following statement contains a magic number: for(i=0;i<n;i++)  			{ 				work[i*2]=curve[i]*fscale; 				work[i*2+1]=0; 			}
Magic Number,csvorbis,Lpc,C:\repos\mono_csvorbis\csvorbis\Lpc.cs,lpc_from_curve,The following statement contains a magic number: work[n*2-1]=curve[n-1]*fscale;
Magic Number,csvorbis,Lpc,C:\repos\mono_csvorbis\csvorbis\Lpc.cs,lpc_from_curve,The following statement contains a magic number: n*=2;
Magic Number,csvorbis,Lpc,C:\repos\mono_csvorbis\csvorbis\Lpc.cs,lpc_from_curve,The following statement contains a magic number: for(i=0'j=n/2;i<n/2;)  			{ 				float temp=work[i]; 				work[i++]=work[j]; 				work[j++]=temp; 			}
Magic Number,csvorbis,Lpc,C:\repos\mono_csvorbis\csvorbis\Lpc.cs,lpc_from_curve,The following statement contains a magic number: for(i=0'j=n/2;i<n/2;)  			{ 				float temp=work[i]; 				work[i++]=work[j]; 				work[j++]=temp; 			}
Magic Number,csvorbis,Lpc,C:\repos\mono_csvorbis\csvorbis\Lpc.cs,init,The following statement contains a magic number: fft.init(mapped*2);
Magic Number,csvorbis,Lpc,C:\repos\mono_csvorbis\csvorbis\Lpc.cs,lpc_to_curve,The following statement contains a magic number: for(int i=0; i<ln*2; i++)curve[i]=0.0f;
Magic Number,csvorbis,Lpc,C:\repos\mono_csvorbis\csvorbis\Lpc.cs,lpc_to_curve,The following statement contains a magic number: for(int i=0;i<m;i++)  			{ 				curve[i*2+1]=lpc[i]/(4*amp); 				curve[i*2+2]=-lpc[i]/(4*amp); 			}
Magic Number,csvorbis,Lpc,C:\repos\mono_csvorbis\csvorbis\Lpc.cs,lpc_to_curve,The following statement contains a magic number: for(int i=0;i<m;i++)  			{ 				curve[i*2+1]=lpc[i]/(4*amp); 				curve[i*2+2]=-lpc[i]/(4*amp); 			}
Magic Number,csvorbis,Lpc,C:\repos\mono_csvorbis\csvorbis\Lpc.cs,lpc_to_curve,The following statement contains a magic number: for(int i=0;i<m;i++)  			{ 				curve[i*2+1]=lpc[i]/(4*amp); 				curve[i*2+2]=-lpc[i]/(4*amp); 			}
Magic Number,csvorbis,Lpc,C:\repos\mono_csvorbis\csvorbis\Lpc.cs,lpc_to_curve,The following statement contains a magic number: for(int i=0;i<m;i++)  			{ 				curve[i*2+1]=lpc[i]/(4*amp); 				curve[i*2+2]=-lpc[i]/(4*amp); 			}
Magic Number,csvorbis,Lpc,C:\repos\mono_csvorbis\csvorbis\Lpc.cs,lpc_to_curve,The following statement contains a magic number: for(int i=0;i<m;i++)  			{ 				curve[i*2+1]=lpc[i]/(4*amp); 				curve[i*2+2]=-lpc[i]/(4*amp); 			}
Magic Number,csvorbis,Lpc,C:\repos\mono_csvorbis\csvorbis\Lpc.cs,lpc_to_curve,The following statement contains a magic number: int l2=ln*2;
Magic Number,csvorbis,Lpc,C:\repos\mono_csvorbis\csvorbis\Lpc.cs,lpc_to_curve,The following statement contains a magic number: curve[0]=(float)(1.0/(curve[0]*2+unit));
Magic Number,csvorbis,Lsp,C:\repos\mono_csvorbis\csvorbis\Lsp.cs,lsp_to_curve,The following statement contains a magic number: int m2=(m/2)*2;
Magic Number,csvorbis,Lsp,C:\repos\mono_csvorbis\csvorbis\Lsp.cs,lsp_to_curve,The following statement contains a magic number: int m2=(m/2)*2;
Magic Number,csvorbis,Lsp,C:\repos\mono_csvorbis\csvorbis\Lsp.cs,lsp_to_curve,The following statement contains a magic number: while(i<n)  			{  				FloatHack fh = new FloatHack();  				int k=map[i];  				float p=.7071067812f;  				float q=.7071067812f;  				float w=Lookup.coslook(wdel*k);  				//int ftmp=0;  				int c=(int)((uint)m >> 1);    				for(int j=0;j<m2;j+=2)  				{  					q*=lsp[j]-w;  					p*=lsp[j+1]-w;  				}    				if((m&1)!=0)  				{  					/* odd order filter; slightly assymetric */  					/* the last coefficient */  					q*=lsp[m-1]-w;  					q*=q;  					p*=p*(1.0f-w*w);  				}  				else  				{  					/* even order filter; still symmetric */  					q*=q*(1.0f+w);  					p*=p*(1.0f-w);  				}    				//  q=frexp(p+q'&qexp);  				q=p+q;  				fh.fh_float = q;  				int hx=fh.fh_int;  				int ix=0x7fffffff&hx;  				int qexp=0;    				if(ix>=0x7f800000||(ix==0))  				{  					// 0'inf'nan  				}  				else  				{  					if(ix<0x00800000)  					{            // subnormal  						q*=3.3554432000e+07F;        // 0x4c000000  						fh.fh_float = q;  						hx=fh.fh_int;  						ix=0x7fffffff&hx;  						qexp=-25;  					}  					qexp += (int)(((uint)ix >> 23)-126);  					hx=(int)((hx&0x807fffff)|0x3f000000);  					fh.fh_int = hx;  					q=fh.fh_float;  				}    				q=Lookup.fromdBlook(amp*  					Lookup.invsqlook(q)*  					Lookup.invsq2explook(qexp+m)-ampoffset);    				do{curve[i]*=q; i++;}  					//    do{curve[i++]=q;}  				while(i<n&&map[i]==k);    			}
Magic Number,csvorbis,Lsp,C:\repos\mono_csvorbis\csvorbis\Lsp.cs,lsp_to_curve,The following statement contains a magic number: while(i<n)  			{  				FloatHack fh = new FloatHack();  				int k=map[i];  				float p=.7071067812f;  				float q=.7071067812f;  				float w=Lookup.coslook(wdel*k);  				//int ftmp=0;  				int c=(int)((uint)m >> 1);    				for(int j=0;j<m2;j+=2)  				{  					q*=lsp[j]-w;  					p*=lsp[j+1]-w;  				}    				if((m&1)!=0)  				{  					/* odd order filter; slightly assymetric */  					/* the last coefficient */  					q*=lsp[m-1]-w;  					q*=q;  					p*=p*(1.0f-w*w);  				}  				else  				{  					/* even order filter; still symmetric */  					q*=q*(1.0f+w);  					p*=p*(1.0f-w);  				}    				//  q=frexp(p+q'&qexp);  				q=p+q;  				fh.fh_float = q;  				int hx=fh.fh_int;  				int ix=0x7fffffff&hx;  				int qexp=0;    				if(ix>=0x7f800000||(ix==0))  				{  					// 0'inf'nan  				}  				else  				{  					if(ix<0x00800000)  					{            // subnormal  						q*=3.3554432000e+07F;        // 0x4c000000  						fh.fh_float = q;  						hx=fh.fh_int;  						ix=0x7fffffff&hx;  						qexp=-25;  					}  					qexp += (int)(((uint)ix >> 23)-126);  					hx=(int)((hx&0x807fffff)|0x3f000000);  					fh.fh_int = hx;  					q=fh.fh_float;  				}    				q=Lookup.fromdBlook(amp*  					Lookup.invsqlook(q)*  					Lookup.invsq2explook(qexp+m)-ampoffset);    				do{curve[i]*=q; i++;}  					//    do{curve[i++]=q;}  				while(i<n&&map[i]==k);    			}
Magic Number,csvorbis,Lsp,C:\repos\mono_csvorbis\csvorbis\Lsp.cs,lsp_to_curve,The following statement contains a magic number: while(i<n)  			{  				FloatHack fh = new FloatHack();  				int k=map[i];  				float p=.7071067812f;  				float q=.7071067812f;  				float w=Lookup.coslook(wdel*k);  				//int ftmp=0;  				int c=(int)((uint)m >> 1);    				for(int j=0;j<m2;j+=2)  				{  					q*=lsp[j]-w;  					p*=lsp[j+1]-w;  				}    				if((m&1)!=0)  				{  					/* odd order filter; slightly assymetric */  					/* the last coefficient */  					q*=lsp[m-1]-w;  					q*=q;  					p*=p*(1.0f-w*w);  				}  				else  				{  					/* even order filter; still symmetric */  					q*=q*(1.0f+w);  					p*=p*(1.0f-w);  				}    				//  q=frexp(p+q'&qexp);  				q=p+q;  				fh.fh_float = q;  				int hx=fh.fh_int;  				int ix=0x7fffffff&hx;  				int qexp=0;    				if(ix>=0x7f800000||(ix==0))  				{  					// 0'inf'nan  				}  				else  				{  					if(ix<0x00800000)  					{            // subnormal  						q*=3.3554432000e+07F;        // 0x4c000000  						fh.fh_float = q;  						hx=fh.fh_int;  						ix=0x7fffffff&hx;  						qexp=-25;  					}  					qexp += (int)(((uint)ix >> 23)-126);  					hx=(int)((hx&0x807fffff)|0x3f000000);  					fh.fh_int = hx;  					q=fh.fh_float;  				}    				q=Lookup.fromdBlook(amp*  					Lookup.invsqlook(q)*  					Lookup.invsq2explook(qexp+m)-ampoffset);    				do{curve[i]*=q; i++;}  					//    do{curve[i++]=q;}  				while(i<n&&map[i]==k);    			}
Magic Number,csvorbis,Lsp,C:\repos\mono_csvorbis\csvorbis\Lsp.cs,lsp_to_curve,The following statement contains a magic number: while(i<n)  			{  				FloatHack fh = new FloatHack();  				int k=map[i];  				float p=.7071067812f;  				float q=.7071067812f;  				float w=Lookup.coslook(wdel*k);  				//int ftmp=0;  				int c=(int)((uint)m >> 1);    				for(int j=0;j<m2;j+=2)  				{  					q*=lsp[j]-w;  					p*=lsp[j+1]-w;  				}    				if((m&1)!=0)  				{  					/* odd order filter; slightly assymetric */  					/* the last coefficient */  					q*=lsp[m-1]-w;  					q*=q;  					p*=p*(1.0f-w*w);  				}  				else  				{  					/* even order filter; still symmetric */  					q*=q*(1.0f+w);  					p*=p*(1.0f-w);  				}    				//  q=frexp(p+q'&qexp);  				q=p+q;  				fh.fh_float = q;  				int hx=fh.fh_int;  				int ix=0x7fffffff&hx;  				int qexp=0;    				if(ix>=0x7f800000||(ix==0))  				{  					// 0'inf'nan  				}  				else  				{  					if(ix<0x00800000)  					{            // subnormal  						q*=3.3554432000e+07F;        // 0x4c000000  						fh.fh_float = q;  						hx=fh.fh_int;  						ix=0x7fffffff&hx;  						qexp=-25;  					}  					qexp += (int)(((uint)ix >> 23)-126);  					hx=(int)((hx&0x807fffff)|0x3f000000);  					fh.fh_int = hx;  					q=fh.fh_float;  				}    				q=Lookup.fromdBlook(amp*  					Lookup.invsqlook(q)*  					Lookup.invsq2explook(qexp+m)-ampoffset);    				do{curve[i]*=q; i++;}  					//    do{curve[i++]=q;}  				while(i<n&&map[i]==k);    			}
Magic Number,csvorbis,Mapping0,C:\repos\mono_csvorbis\csvorbis\Mapping0.cs,pack,The following statement contains a magic number: if(info.submaps>1)  			{ 				opb.write(1'1); 				opb.write(info.submaps-1'4); 			} 			else  			{ 				opb.write(0'1); 			}
Magic Number,csvorbis,Mapping0,C:\repos\mono_csvorbis\csvorbis\Mapping0.cs,pack,The following statement contains a magic number: if(info.coupling_steps>0)  			{ 				opb.write(1'1); 				opb.write(info.coupling_steps-1'8); 				for(int i=0;i<info.coupling_steps;i++)  				{ 					opb.write(info.coupling_mag[i]'ilog2(vi.channels)); 					opb.write(info.coupling_ang[i]'ilog2(vi.channels)); 				} 			} 			else  			{ 				opb.write(0'1); 			}
Magic Number,csvorbis,Mapping0,C:\repos\mono_csvorbis\csvorbis\Mapping0.cs,pack,The following statement contains a magic number: opb.write(0'2);
Magic Number,csvorbis,Mapping0,C:\repos\mono_csvorbis\csvorbis\Mapping0.cs,pack,The following statement contains a magic number: if(info.submaps>1)  			{ 				for(int i=0;i<vi.channels;i++) 					opb.write(info.chmuxlist[i]'4); 			}
Magic Number,csvorbis,Mapping0,C:\repos\mono_csvorbis\csvorbis\Mapping0.cs,pack,The following statement contains a magic number: for(int i=0;i<info.submaps;i++)  			{ 				opb.write(info.timesubmap[i]'8); 				opb.write(info.floorsubmap[i]'8); 				opb.write(info.residuesubmap[i]'8); 			}
Magic Number,csvorbis,Mapping0,C:\repos\mono_csvorbis\csvorbis\Mapping0.cs,pack,The following statement contains a magic number: for(int i=0;i<info.submaps;i++)  			{ 				opb.write(info.timesubmap[i]'8); 				opb.write(info.floorsubmap[i]'8); 				opb.write(info.residuesubmap[i]'8); 			}
Magic Number,csvorbis,Mapping0,C:\repos\mono_csvorbis\csvorbis\Mapping0.cs,pack,The following statement contains a magic number: for(int i=0;i<info.submaps;i++)  			{ 				opb.write(info.timesubmap[i]'8); 				opb.write(info.floorsubmap[i]'8); 				opb.write(info.residuesubmap[i]'8); 			}
Magic Number,csvorbis,Mapping0,C:\repos\mono_csvorbis\csvorbis\Mapping0.cs,unpack,The following statement contains a magic number: if(opb.read(1)!=0)  			{ 				info.submaps=opb.read(4)+1; 			} 			else  			{ 				info.submaps=1; 			}
Magic Number,csvorbis,Mapping0,C:\repos\mono_csvorbis\csvorbis\Mapping0.cs,unpack,The following statement contains a magic number: if(opb.read(1)!=0)  			{ 				info.coupling_steps=opb.read(8)+1;  				for(int i=0;i<info.coupling_steps;i++)  				{ 					int testM=info.coupling_mag[i]=opb.read(ilog2(vi.channels)); 					int testA=info.coupling_ang[i]=opb.read(ilog2(vi.channels));  					if(testM<0 || 						testA<0 || 						testM==testA || 						testM>=vi.channels || 						testA>=vi.channels)  					{ 						//goto err_out; 						info.free(); 						return(null); 					} 				} 			}
Magic Number,csvorbis,Mapping0,C:\repos\mono_csvorbis\csvorbis\Mapping0.cs,unpack,The following statement contains a magic number: if(opb.read(2)>0)  			{ /* 2'3:reserved */ 				//goto err_out; 				info.free(); 				return(null); 			}
Magic Number,csvorbis,Mapping0,C:\repos\mono_csvorbis\csvorbis\Mapping0.cs,unpack,The following statement contains a magic number: if(info.submaps>1)  			{ 				for(int i=0;i<vi.channels;i++)  				{ 					info.chmuxlist[i]=opb.read(4); 					if(info.chmuxlist[i]>=info.submaps)  					{ 						//goto err_out; 						info.free(); 						return(null); 					} 				} 			}
Magic Number,csvorbis,Mapping0,C:\repos\mono_csvorbis\csvorbis\Mapping0.cs,unpack,The following statement contains a magic number: for(int i=0;i<info.submaps;i++)  			{ 				info.timesubmap[i]=opb.read(8); 				if(info.timesubmap[i]>=vi.times)  				{ 					//goto err_out; 					info.free(); 					return(null); 				} 				info.floorsubmap[i]=opb.read(8); 				if(info.floorsubmap[i]>=vi.floors)  				{ 					//goto err_out; 					info.free(); 					return(null); 				} 				info.residuesubmap[i]=opb.read(8); 				if(info.residuesubmap[i]>=vi.residues)  				{ 					//goto err_out; 					info.free(); 					return(null); 				} 			}
Magic Number,csvorbis,Mapping0,C:\repos\mono_csvorbis\csvorbis\Mapping0.cs,unpack,The following statement contains a magic number: for(int i=0;i<info.submaps;i++)  			{ 				info.timesubmap[i]=opb.read(8); 				if(info.timesubmap[i]>=vi.times)  				{ 					//goto err_out; 					info.free(); 					return(null); 				} 				info.floorsubmap[i]=opb.read(8); 				if(info.floorsubmap[i]>=vi.floors)  				{ 					//goto err_out; 					info.free(); 					return(null); 				} 				info.residuesubmap[i]=opb.read(8); 				if(info.residuesubmap[i]>=vi.residues)  				{ 					//goto err_out; 					info.free(); 					return(null); 				} 			}
Magic Number,csvorbis,Mapping0,C:\repos\mono_csvorbis\csvorbis\Mapping0.cs,unpack,The following statement contains a magic number: for(int i=0;i<info.submaps;i++)  			{ 				info.timesubmap[i]=opb.read(8); 				if(info.timesubmap[i]>=vi.times)  				{ 					//goto err_out; 					info.free(); 					return(null); 				} 				info.floorsubmap[i]=opb.read(8); 				if(info.floorsubmap[i]>=vi.floors)  				{ 					//goto err_out; 					info.free(); 					return(null); 				} 				info.residuesubmap[i]=opb.read(8); 				if(info.residuesubmap[i]>=vi.residues)  				{ 					//goto err_out; 					info.free(); 					return(null); 				} 			}
Magic Number,csvorbis,Mapping0,C:\repos\mono_csvorbis\csvorbis\Mapping0.cs,inverse,The following statement contains a magic number: lock(this)  			{ 				//System.err.println("Mapping0.inverse"); 				DspState vd=vb.vd; 				Info vi=vd.vi; 				LookMapping0 look=(LookMapping0)l; 				InfoMapping0 info=look.map; 				InfoMode mode=look.mode; 				int n=vb.pcmend=vi.blocksizes[vb.W];  				float[] window=vd.wnd[vb.W][vb.lW][vb.nW][mode.windowtype]; 				// float[][] pcmbundle=new float[vi.channels][]; 				// int[] nonzero=new int[vi.channels]; 				if(pcmbundle==null || pcmbundle.Length<vi.channels)  				{ 					pcmbundle=new float[vi.channels][]; 					nonzero=new int[vi.channels]; 					zerobundle=new int[vi.channels]; 					floormemo=new Object[vi.channels]; 				}    				// time domain information decode (note that applying the 				// information would have to happen later; we'll probably add a 				// function entry to the harness for that later 				// NOT IMPLEMENTED  				// recover the spectral envelope; store it in the PCM vector for now  				for(int i=0;i<vi.channels;i++)  				{ 					float[] pcm=vb.pcm[i]; 					int submap=info.chmuxlist[i];  					floormemo[i]=look.floor_func[submap].inverse1(vb'look. 						floor_look[submap]' 						floormemo[i] 						); 					if(floormemo[i]!=null){ nonzero[i]=1; } 					else{ nonzero[i]=0; } 					for(int j=0; j<n/2; j++)  					{ 						pcm[j]=0; 					}                   					//_analysis_output("ifloor"'seq+i'pcm'n/2'0'1); 				}  				for(int i=0; i<info.coupling_steps; i++)  				{ 					if(nonzero[info.coupling_mag[i]]!=0 || 						nonzero[info.coupling_ang[i]]!=0)  					{ 						nonzero[info.coupling_mag[i]]=1; 						nonzero[info.coupling_ang[i]]=1; 					} 				}  				// recover the residue' apply directly to the spectral envelope  				for(int i=0;i<info.submaps;i++)  				{ 					int ch_in_bundle=0; 					for(int j=0;j<vi.channels;j++)  					{ 						if(info.chmuxlist[j]==i)  						{ 							if(nonzero[j]!=0)  							{ 								zerobundle[ch_in_bundle]=1; 							} 							else  							{ 								zerobundle[ch_in_bundle]=0; 							} 							pcmbundle[ch_in_bundle++]=vb.pcm[j]; 						} 					}  					look.residue_func[i].inverse(vb'look.residue_look[i]' 						pcmbundle'zerobundle'ch_in_bundle); 				}   				for(int i=info.coupling_steps-1;i>=0;i--)  				{ 					float[] pcmM=vb.pcm[info.coupling_mag[i]]; 					float[] pcmA=vb.pcm[info.coupling_ang[i]];  					for(int j=0;j<n/2;j++)  					{ 						float mag=pcmM[j]; 						float ang=pcmA[j];  						if(mag>0)  						{ 							if(ang>0)  							{ 								pcmM[j]=mag; 								pcmA[j]=mag-ang; 							} 							else  							{ 								pcmA[j]=mag; 								pcmM[j]=mag+ang; 							} 						} 						else  						{ 							if(ang>0)  							{ 								pcmM[j]=mag; 								pcmA[j]=mag+ang; 							} 							else  							{ 								pcmA[j]=mag; 								pcmM[j]=mag-ang; 							} 						} 					} 				}  				//    /* compute and apply spectral envelope */  				for(int i=0;i<vi.channels;i++)  				{ 					float[] pcm=vb.pcm[i]; 					int submap=info.chmuxlist[i]; 					look.floor_func[submap].inverse2(vb'look.floor_look[submap]'floormemo[i]'pcm); 				}  				// transform the PCM data; takes PCM vector' vb; modifies PCM vector 				// only MDCT right now....  				for(int i=0;i<vi.channels;i++)  				{ 					float[] pcm=vb.pcm[i]; 					//_analysis_output("out"'seq+i'pcm'n/2'0'0); 					((Mdct)vd.transform[vb.W][0]).backward(pcm'pcm); 				}  				// now apply the decoded pre-window time information 				// NOT IMPLEMENTED    				// window the data 				for(int i=0;i<vi.channels;i++)  				{ 					float[] pcm=vb.pcm[i]; 					if(nonzero[i]!=0)  					{ 						for(int j=0;j<n;j++)  						{ 							pcm[j]*=window[j]; 						} 					} 					else  					{ 						for(int j=0;j<n;j++)  						{ 							pcm[j]=0.0f; 						} 					} 					//_analysis_output("final"'seq++'pcm'n'0'0); 				} 	     				// now apply the decoded post-window time information 				// NOT IMPLEMENTED 				// all done! 				return(0); 			}
Magic Number,csvorbis,Mapping0,C:\repos\mono_csvorbis\csvorbis\Mapping0.cs,inverse,The following statement contains a magic number: lock(this)  			{ 				//System.err.println("Mapping0.inverse"); 				DspState vd=vb.vd; 				Info vi=vd.vi; 				LookMapping0 look=(LookMapping0)l; 				InfoMapping0 info=look.map; 				InfoMode mode=look.mode; 				int n=vb.pcmend=vi.blocksizes[vb.W];  				float[] window=vd.wnd[vb.W][vb.lW][vb.nW][mode.windowtype]; 				// float[][] pcmbundle=new float[vi.channels][]; 				// int[] nonzero=new int[vi.channels]; 				if(pcmbundle==null || pcmbundle.Length<vi.channels)  				{ 					pcmbundle=new float[vi.channels][]; 					nonzero=new int[vi.channels]; 					zerobundle=new int[vi.channels]; 					floormemo=new Object[vi.channels]; 				}    				// time domain information decode (note that applying the 				// information would have to happen later; we'll probably add a 				// function entry to the harness for that later 				// NOT IMPLEMENTED  				// recover the spectral envelope; store it in the PCM vector for now  				for(int i=0;i<vi.channels;i++)  				{ 					float[] pcm=vb.pcm[i]; 					int submap=info.chmuxlist[i];  					floormemo[i]=look.floor_func[submap].inverse1(vb'look. 						floor_look[submap]' 						floormemo[i] 						); 					if(floormemo[i]!=null){ nonzero[i]=1; } 					else{ nonzero[i]=0; } 					for(int j=0; j<n/2; j++)  					{ 						pcm[j]=0; 					}                   					//_analysis_output("ifloor"'seq+i'pcm'n/2'0'1); 				}  				for(int i=0; i<info.coupling_steps; i++)  				{ 					if(nonzero[info.coupling_mag[i]]!=0 || 						nonzero[info.coupling_ang[i]]!=0)  					{ 						nonzero[info.coupling_mag[i]]=1; 						nonzero[info.coupling_ang[i]]=1; 					} 				}  				// recover the residue' apply directly to the spectral envelope  				for(int i=0;i<info.submaps;i++)  				{ 					int ch_in_bundle=0; 					for(int j=0;j<vi.channels;j++)  					{ 						if(info.chmuxlist[j]==i)  						{ 							if(nonzero[j]!=0)  							{ 								zerobundle[ch_in_bundle]=1; 							} 							else  							{ 								zerobundle[ch_in_bundle]=0; 							} 							pcmbundle[ch_in_bundle++]=vb.pcm[j]; 						} 					}  					look.residue_func[i].inverse(vb'look.residue_look[i]' 						pcmbundle'zerobundle'ch_in_bundle); 				}   				for(int i=info.coupling_steps-1;i>=0;i--)  				{ 					float[] pcmM=vb.pcm[info.coupling_mag[i]]; 					float[] pcmA=vb.pcm[info.coupling_ang[i]];  					for(int j=0;j<n/2;j++)  					{ 						float mag=pcmM[j]; 						float ang=pcmA[j];  						if(mag>0)  						{ 							if(ang>0)  							{ 								pcmM[j]=mag; 								pcmA[j]=mag-ang; 							} 							else  							{ 								pcmA[j]=mag; 								pcmM[j]=mag+ang; 							} 						} 						else  						{ 							if(ang>0)  							{ 								pcmM[j]=mag; 								pcmA[j]=mag+ang; 							} 							else  							{ 								pcmA[j]=mag; 								pcmM[j]=mag-ang; 							} 						} 					} 				}  				//    /* compute and apply spectral envelope */  				for(int i=0;i<vi.channels;i++)  				{ 					float[] pcm=vb.pcm[i]; 					int submap=info.chmuxlist[i]; 					look.floor_func[submap].inverse2(vb'look.floor_look[submap]'floormemo[i]'pcm); 				}  				// transform the PCM data; takes PCM vector' vb; modifies PCM vector 				// only MDCT right now....  				for(int i=0;i<vi.channels;i++)  				{ 					float[] pcm=vb.pcm[i]; 					//_analysis_output("out"'seq+i'pcm'n/2'0'0); 					((Mdct)vd.transform[vb.W][0]).backward(pcm'pcm); 				}  				// now apply the decoded pre-window time information 				// NOT IMPLEMENTED    				// window the data 				for(int i=0;i<vi.channels;i++)  				{ 					float[] pcm=vb.pcm[i]; 					if(nonzero[i]!=0)  					{ 						for(int j=0;j<n;j++)  						{ 							pcm[j]*=window[j]; 						} 					} 					else  					{ 						for(int j=0;j<n;j++)  						{ 							pcm[j]=0.0f; 						} 					} 					//_analysis_output("final"'seq++'pcm'n'0'0); 				} 	     				// now apply the decoded post-window time information 				// NOT IMPLEMENTED 				// all done! 				return(0); 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,init,The following statement contains a magic number: bitrev=new int[n/4];
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,init,The following statement contains a magic number: trig=new float[n+n/4];
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,init,The following statement contains a magic number: log2n=(int)Math.Round(Math.Log(n)/Math.Log(2));
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,init,The following statement contains a magic number: int BE=AE+n/2;
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,init,The following statement contains a magic number: int CE=BE+n/2;
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,init,The following statement contains a magic number: for(int i=0;i<n/4;i++)  			{ 				trig[AE+i*2]=(float)Math.Cos((Math.PI/n)*(4*i)); 				trig[AO+i*2]=(float)-Math.Sin((Math.PI/n)*(4*i)); 				trig[BE+i*2]=(float)Math.Cos((Math.PI/(2*n))*(2*i+1)); 				trig[BO+i*2]=(float)Math.Sin((Math.PI/(2*n))*(2*i+1)); 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,init,The following statement contains a magic number: for(int i=0;i<n/4;i++)  			{ 				trig[AE+i*2]=(float)Math.Cos((Math.PI/n)*(4*i)); 				trig[AO+i*2]=(float)-Math.Sin((Math.PI/n)*(4*i)); 				trig[BE+i*2]=(float)Math.Cos((Math.PI/(2*n))*(2*i+1)); 				trig[BO+i*2]=(float)Math.Sin((Math.PI/(2*n))*(2*i+1)); 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,init,The following statement contains a magic number: for(int i=0;i<n/4;i++)  			{ 				trig[AE+i*2]=(float)Math.Cos((Math.PI/n)*(4*i)); 				trig[AO+i*2]=(float)-Math.Sin((Math.PI/n)*(4*i)); 				trig[BE+i*2]=(float)Math.Cos((Math.PI/(2*n))*(2*i+1)); 				trig[BO+i*2]=(float)Math.Sin((Math.PI/(2*n))*(2*i+1)); 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,init,The following statement contains a magic number: for(int i=0;i<n/4;i++)  			{ 				trig[AE+i*2]=(float)Math.Cos((Math.PI/n)*(4*i)); 				trig[AO+i*2]=(float)-Math.Sin((Math.PI/n)*(4*i)); 				trig[BE+i*2]=(float)Math.Cos((Math.PI/(2*n))*(2*i+1)); 				trig[BO+i*2]=(float)Math.Sin((Math.PI/(2*n))*(2*i+1)); 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,init,The following statement contains a magic number: for(int i=0;i<n/4;i++)  			{ 				trig[AE+i*2]=(float)Math.Cos((Math.PI/n)*(4*i)); 				trig[AO+i*2]=(float)-Math.Sin((Math.PI/n)*(4*i)); 				trig[BE+i*2]=(float)Math.Cos((Math.PI/(2*n))*(2*i+1)); 				trig[BO+i*2]=(float)Math.Sin((Math.PI/(2*n))*(2*i+1)); 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,init,The following statement contains a magic number: for(int i=0;i<n/4;i++)  			{ 				trig[AE+i*2]=(float)Math.Cos((Math.PI/n)*(4*i)); 				trig[AO+i*2]=(float)-Math.Sin((Math.PI/n)*(4*i)); 				trig[BE+i*2]=(float)Math.Cos((Math.PI/(2*n))*(2*i+1)); 				trig[BO+i*2]=(float)Math.Sin((Math.PI/(2*n))*(2*i+1)); 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,init,The following statement contains a magic number: for(int i=0;i<n/4;i++)  			{ 				trig[AE+i*2]=(float)Math.Cos((Math.PI/n)*(4*i)); 				trig[AO+i*2]=(float)-Math.Sin((Math.PI/n)*(4*i)); 				trig[BE+i*2]=(float)Math.Cos((Math.PI/(2*n))*(2*i+1)); 				trig[BO+i*2]=(float)Math.Sin((Math.PI/(2*n))*(2*i+1)); 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,init,The following statement contains a magic number: for(int i=0;i<n/4;i++)  			{ 				trig[AE+i*2]=(float)Math.Cos((Math.PI/n)*(4*i)); 				trig[AO+i*2]=(float)-Math.Sin((Math.PI/n)*(4*i)); 				trig[BE+i*2]=(float)Math.Cos((Math.PI/(2*n))*(2*i+1)); 				trig[BO+i*2]=(float)Math.Sin((Math.PI/(2*n))*(2*i+1)); 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,init,The following statement contains a magic number: for(int i=0;i<n/4;i++)  			{ 				trig[AE+i*2]=(float)Math.Cos((Math.PI/n)*(4*i)); 				trig[AO+i*2]=(float)-Math.Sin((Math.PI/n)*(4*i)); 				trig[BE+i*2]=(float)Math.Cos((Math.PI/(2*n))*(2*i+1)); 				trig[BO+i*2]=(float)Math.Sin((Math.PI/(2*n))*(2*i+1)); 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,init,The following statement contains a magic number: for(int i=0;i<n/4;i++)  			{ 				trig[AE+i*2]=(float)Math.Cos((Math.PI/n)*(4*i)); 				trig[AO+i*2]=(float)-Math.Sin((Math.PI/n)*(4*i)); 				trig[BE+i*2]=(float)Math.Cos((Math.PI/(2*n))*(2*i+1)); 				trig[BO+i*2]=(float)Math.Sin((Math.PI/(2*n))*(2*i+1)); 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,init,The following statement contains a magic number: for(int i=0;i<n/4;i++)  			{ 				trig[AE+i*2]=(float)Math.Cos((Math.PI/n)*(4*i)); 				trig[AO+i*2]=(float)-Math.Sin((Math.PI/n)*(4*i)); 				trig[BE+i*2]=(float)Math.Cos((Math.PI/(2*n))*(2*i+1)); 				trig[BO+i*2]=(float)Math.Sin((Math.PI/(2*n))*(2*i+1)); 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,init,The following statement contains a magic number: for(int i=0;i<n/8;i++)  			{ 				trig[CE+i*2]=(float)Math.Cos((Math.PI/n)*(4*i+2)); 				trig[CO+i*2]=(float)-Math.Sin((Math.PI/n)*(4*i+2)); 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,init,The following statement contains a magic number: for(int i=0;i<n/8;i++)  			{ 				trig[CE+i*2]=(float)Math.Cos((Math.PI/n)*(4*i+2)); 				trig[CO+i*2]=(float)-Math.Sin((Math.PI/n)*(4*i+2)); 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,init,The following statement contains a magic number: for(int i=0;i<n/8;i++)  			{ 				trig[CE+i*2]=(float)Math.Cos((Math.PI/n)*(4*i+2)); 				trig[CO+i*2]=(float)-Math.Sin((Math.PI/n)*(4*i+2)); 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,init,The following statement contains a magic number: for(int i=0;i<n/8;i++)  			{ 				trig[CE+i*2]=(float)Math.Cos((Math.PI/n)*(4*i+2)); 				trig[CO+i*2]=(float)-Math.Sin((Math.PI/n)*(4*i+2)); 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,init,The following statement contains a magic number: for(int i=0;i<n/8;i++)  			{ 				trig[CE+i*2]=(float)Math.Cos((Math.PI/n)*(4*i+2)); 				trig[CO+i*2]=(float)-Math.Sin((Math.PI/n)*(4*i+2)); 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,init,The following statement contains a magic number: for(int i=0;i<n/8;i++)  			{ 				trig[CE+i*2]=(float)Math.Cos((Math.PI/n)*(4*i+2)); 				trig[CO+i*2]=(float)-Math.Sin((Math.PI/n)*(4*i+2)); 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,init,The following statement contains a magic number: for(int i=0;i<n/8;i++)  			{ 				trig[CE+i*2]=(float)Math.Cos((Math.PI/n)*(4*i+2)); 				trig[CO+i*2]=(float)-Math.Sin((Math.PI/n)*(4*i+2)); 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,init,The following statement contains a magic number: { 			int mask=(1<<(log2n-1))-1; 			int msb=1<<(log2n-2); 			for(int i=0;i<n/8;i++)  			{ 				int acc=0; 				for(int j=0; (((uint)msb) >> j) != 0; j++) 					if(((((uint)msb>>j))&i) != 0)  						acc |= 1 << j; 				bitrev[i*2]=((~acc)&mask); 				//	bitrev[i*2]=((~acc)&mask)-1; 				bitrev[i*2+1]=acc; 			} 		}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,init,The following statement contains a magic number: { 			int mask=(1<<(log2n-1))-1; 			int msb=1<<(log2n-2); 			for(int i=0;i<n/8;i++)  			{ 				int acc=0; 				for(int j=0; (((uint)msb) >> j) != 0; j++) 					if(((((uint)msb>>j))&i) != 0)  						acc |= 1 << j; 				bitrev[i*2]=((~acc)&mask); 				//	bitrev[i*2]=((~acc)&mask)-1; 				bitrev[i*2+1]=acc; 			} 		}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,init,The following statement contains a magic number: { 			int mask=(1<<(log2n-1))-1; 			int msb=1<<(log2n-2); 			for(int i=0;i<n/8;i++)  			{ 				int acc=0; 				for(int j=0; (((uint)msb) >> j) != 0; j++) 					if(((((uint)msb>>j))&i) != 0)  						acc |= 1 << j; 				bitrev[i*2]=((~acc)&mask); 				//	bitrev[i*2]=((~acc)&mask)-1; 				bitrev[i*2+1]=acc; 			} 		}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,init,The following statement contains a magic number: { 			int mask=(1<<(log2n-1))-1; 			int msb=1<<(log2n-2); 			for(int i=0;i<n/8;i++)  			{ 				int acc=0; 				for(int j=0; (((uint)msb) >> j) != 0; j++) 					if(((((uint)msb>>j))&i) != 0)  						acc |= 1 << j; 				bitrev[i*2]=((~acc)&mask); 				//	bitrev[i*2]=((~acc)&mask)-1; 				bitrev[i*2+1]=acc; 			} 		}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,backward,The following statement contains a magic number: if(_x.Length < n/2){_x=new float[n/2];}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,backward,The following statement contains a magic number: if(_x.Length < n/2){_x=new float[n/2];}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,backward,The following statement contains a magic number: if(_w.Length < n/2){_w=new float[n/2];}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,backward,The following statement contains a magic number: if(_w.Length < n/2){_w=new float[n/2];}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,backward,The following statement contains a magic number: int n4=(int)((uint)n >> 2);
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,backward,The following statement contains a magic number: int n8=(int)((uint)n >> 3);
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,backward,The following statement contains a magic number: { 				int inO=1; 				int xO=0; 				int A=n2;  				int i; 				for(i=0;i<n8;i++)  				{ 					A-=2; 					x[xO++]=-fin[inO+2]*trig[A+1] - fin[inO]*trig[A]; 					x[xO++]= fin[inO]*trig[A+1] - fin[inO+2]*trig[A]; 					inO+=4; 				}  				inO=n2-4;  				for(i=0;i<n8;i++)  				{ 					A-=2; 					x[xO++]=fin[inO]*trig[A+1] + fin[inO+2]*trig[A]; 					x[xO++]=fin[inO]*trig[A] - fin[inO+2]*trig[A+1]; 					inO-=4; 				} 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,backward,The following statement contains a magic number: { 				int inO=1; 				int xO=0; 				int A=n2;  				int i; 				for(i=0;i<n8;i++)  				{ 					A-=2; 					x[xO++]=-fin[inO+2]*trig[A+1] - fin[inO]*trig[A]; 					x[xO++]= fin[inO]*trig[A+1] - fin[inO+2]*trig[A]; 					inO+=4; 				}  				inO=n2-4;  				for(i=0;i<n8;i++)  				{ 					A-=2; 					x[xO++]=fin[inO]*trig[A+1] + fin[inO+2]*trig[A]; 					x[xO++]=fin[inO]*trig[A] - fin[inO+2]*trig[A+1]; 					inO-=4; 				} 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,backward,The following statement contains a magic number: { 				int inO=1; 				int xO=0; 				int A=n2;  				int i; 				for(i=0;i<n8;i++)  				{ 					A-=2; 					x[xO++]=-fin[inO+2]*trig[A+1] - fin[inO]*trig[A]; 					x[xO++]= fin[inO]*trig[A+1] - fin[inO+2]*trig[A]; 					inO+=4; 				}  				inO=n2-4;  				for(i=0;i<n8;i++)  				{ 					A-=2; 					x[xO++]=fin[inO]*trig[A+1] + fin[inO+2]*trig[A]; 					x[xO++]=fin[inO]*trig[A] - fin[inO+2]*trig[A+1]; 					inO-=4; 				} 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,backward,The following statement contains a magic number: { 				int inO=1; 				int xO=0; 				int A=n2;  				int i; 				for(i=0;i<n8;i++)  				{ 					A-=2; 					x[xO++]=-fin[inO+2]*trig[A+1] - fin[inO]*trig[A]; 					x[xO++]= fin[inO]*trig[A+1] - fin[inO+2]*trig[A]; 					inO+=4; 				}  				inO=n2-4;  				for(i=0;i<n8;i++)  				{ 					A-=2; 					x[xO++]=fin[inO]*trig[A+1] + fin[inO+2]*trig[A]; 					x[xO++]=fin[inO]*trig[A] - fin[inO+2]*trig[A+1]; 					inO-=4; 				} 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,backward,The following statement contains a magic number: { 				int inO=1; 				int xO=0; 				int A=n2;  				int i; 				for(i=0;i<n8;i++)  				{ 					A-=2; 					x[xO++]=-fin[inO+2]*trig[A+1] - fin[inO]*trig[A]; 					x[xO++]= fin[inO]*trig[A+1] - fin[inO+2]*trig[A]; 					inO+=4; 				}  				inO=n2-4;  				for(i=0;i<n8;i++)  				{ 					A-=2; 					x[xO++]=fin[inO]*trig[A+1] + fin[inO+2]*trig[A]; 					x[xO++]=fin[inO]*trig[A] - fin[inO+2]*trig[A+1]; 					inO-=4; 				} 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,backward,The following statement contains a magic number: { 				int inO=1; 				int xO=0; 				int A=n2;  				int i; 				for(i=0;i<n8;i++)  				{ 					A-=2; 					x[xO++]=-fin[inO+2]*trig[A+1] - fin[inO]*trig[A]; 					x[xO++]= fin[inO]*trig[A+1] - fin[inO+2]*trig[A]; 					inO+=4; 				}  				inO=n2-4;  				for(i=0;i<n8;i++)  				{ 					A-=2; 					x[xO++]=fin[inO]*trig[A+1] + fin[inO+2]*trig[A]; 					x[xO++]=fin[inO]*trig[A] - fin[inO+2]*trig[A+1]; 					inO-=4; 				} 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,backward,The following statement contains a magic number: { 				int inO=1; 				int xO=0; 				int A=n2;  				int i; 				for(i=0;i<n8;i++)  				{ 					A-=2; 					x[xO++]=-fin[inO+2]*trig[A+1] - fin[inO]*trig[A]; 					x[xO++]= fin[inO]*trig[A+1] - fin[inO+2]*trig[A]; 					inO+=4; 				}  				inO=n2-4;  				for(i=0;i<n8;i++)  				{ 					A-=2; 					x[xO++]=fin[inO]*trig[A+1] + fin[inO+2]*trig[A]; 					x[xO++]=fin[inO]*trig[A] - fin[inO+2]*trig[A+1]; 					inO-=4; 				} 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,backward,The following statement contains a magic number: { 				int inO=1; 				int xO=0; 				int A=n2;  				int i; 				for(i=0;i<n8;i++)  				{ 					A-=2; 					x[xO++]=-fin[inO+2]*trig[A+1] - fin[inO]*trig[A]; 					x[xO++]= fin[inO]*trig[A+1] - fin[inO+2]*trig[A]; 					inO+=4; 				}  				inO=n2-4;  				for(i=0;i<n8;i++)  				{ 					A-=2; 					x[xO++]=fin[inO]*trig[A+1] + fin[inO+2]*trig[A]; 					x[xO++]=fin[inO]*trig[A] - fin[inO+2]*trig[A+1]; 					inO-=4; 				} 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,backward,The following statement contains a magic number: { 				int inO=1; 				int xO=0; 				int A=n2;  				int i; 				for(i=0;i<n8;i++)  				{ 					A-=2; 					x[xO++]=-fin[inO+2]*trig[A+1] - fin[inO]*trig[A]; 					x[xO++]= fin[inO]*trig[A+1] - fin[inO+2]*trig[A]; 					inO+=4; 				}  				inO=n2-4;  				for(i=0;i<n8;i++)  				{ 					A-=2; 					x[xO++]=fin[inO]*trig[A+1] + fin[inO+2]*trig[A]; 					x[xO++]=fin[inO]*trig[A] - fin[inO+2]*trig[A+1]; 					inO-=4; 				} 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,backward,The following statement contains a magic number: { 				int B=n2; 				int o1=n4'o2=o1-1; 				int o3=n4+n2'o4=o3-1;      				for(int i=0;i<n4;i++)  				{ 					float temp1= (xxx[xx] * trig[B+1] - xxx[xx+1] * trig[B]); 					float temp2=-(xxx[xx] * trig[B] + xxx[xx+1] * trig[B+1]);      					fout[o1]=-temp1; 					fout[o2]= temp1; 					fout[o3]= temp2; 					fout[o4]= temp2;  					o1++; 					o2--; 					o3++; 					o4--; 					xx+=2; 					B+=2; 				} 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,backward,The following statement contains a magic number: { 				int B=n2; 				int o1=n4'o2=o1-1; 				int o3=n4+n2'o4=o3-1;      				for(int i=0;i<n4;i++)  				{ 					float temp1= (xxx[xx] * trig[B+1] - xxx[xx+1] * trig[B]); 					float temp2=-(xxx[xx] * trig[B] + xxx[xx+1] * trig[B+1]);      					fout[o1]=-temp1; 					fout[o2]= temp1; 					fout[o3]= temp2; 					fout[o4]= temp2;  					o1++; 					o2--; 					o3++; 					o4--; 					xx+=2; 					B+=2; 				} 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,mdct_kernel,The following statement contains a magic number: for(int i=0;i<n4;)  			{ 				float x0=x[xA] - x[xB]; 				float x1; 				w[w2+i]=x[xA++]+x[xB++];  				x1=x[xA]-x[xB]; 				A-=4;  				w[i++]=   x0 * trig[A] + x1 * trig[A+1]; 				w[i]=     x1 * trig[A] - x0 * trig[A+1];  				w[w2+i]=x[xA++]+x[xB++]; 				i++; 			}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,mdct_kernel,The following statement contains a magic number: { 			for(int i=0;i<log2n-3;i++)  			{ 				int k0=(int)((uint)n >> (i+2)); 				int k1=1 << (i+3); 				int wbase=n2-2;  				A=0; 				float[] temp;  				for(int r=0; r<((uint)k0>>2); r++)  				{ 					int w1=wbase; 					w2=w1-(k0>>1); 					float AEv= trig[A]'wA; 					float AOv= trig[A+1]'wB; 					wbase-=2; 		       					k0++; 					for(int s=0;s<(2<<i);s++)  					{ 						wB     =w[w1]   -w[w2]; 						x[w1]  =w[w1]   +w[w2];  						wA     =w[++w1] -w[++w2]; 						x[w1]  =w[w1]   +w[w2]; 	     						x[w2]  =wA*AEv  - wB*AOv; 						x[w2-1]=wB*AEv  + wA*AOv;  						w1-=k0; 						w2-=k0; 					} 					k0--; 					A+=k1; 				}  				temp=w; 				w=x; 				x=temp; 			} 		}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,mdct_kernel,The following statement contains a magic number: { 			for(int i=0;i<log2n-3;i++)  			{ 				int k0=(int)((uint)n >> (i+2)); 				int k1=1 << (i+3); 				int wbase=n2-2;  				A=0; 				float[] temp;  				for(int r=0; r<((uint)k0>>2); r++)  				{ 					int w1=wbase; 					w2=w1-(k0>>1); 					float AEv= trig[A]'wA; 					float AOv= trig[A+1]'wB; 					wbase-=2; 		       					k0++; 					for(int s=0;s<(2<<i);s++)  					{ 						wB     =w[w1]   -w[w2]; 						x[w1]  =w[w1]   +w[w2];  						wA     =w[++w1] -w[++w2]; 						x[w1]  =w[w1]   +w[w2]; 	     						x[w2]  =wA*AEv  - wB*AOv; 						x[w2-1]=wB*AEv  + wA*AOv;  						w1-=k0; 						w2-=k0; 					} 					k0--; 					A+=k1; 				}  				temp=w; 				w=x; 				x=temp; 			} 		}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,mdct_kernel,The following statement contains a magic number: { 			for(int i=0;i<log2n-3;i++)  			{ 				int k0=(int)((uint)n >> (i+2)); 				int k1=1 << (i+3); 				int wbase=n2-2;  				A=0; 				float[] temp;  				for(int r=0; r<((uint)k0>>2); r++)  				{ 					int w1=wbase; 					w2=w1-(k0>>1); 					float AEv= trig[A]'wA; 					float AOv= trig[A+1]'wB; 					wbase-=2; 		       					k0++; 					for(int s=0;s<(2<<i);s++)  					{ 						wB     =w[w1]   -w[w2]; 						x[w1]  =w[w1]   +w[w2];  						wA     =w[++w1] -w[++w2]; 						x[w1]  =w[w1]   +w[w2]; 	     						x[w2]  =wA*AEv  - wB*AOv; 						x[w2-1]=wB*AEv  + wA*AOv;  						w1-=k0; 						w2-=k0; 					} 					k0--; 					A+=k1; 				}  				temp=w; 				w=x; 				x=temp; 			} 		}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,mdct_kernel,The following statement contains a magic number: { 			for(int i=0;i<log2n-3;i++)  			{ 				int k0=(int)((uint)n >> (i+2)); 				int k1=1 << (i+3); 				int wbase=n2-2;  				A=0; 				float[] temp;  				for(int r=0; r<((uint)k0>>2); r++)  				{ 					int w1=wbase; 					w2=w1-(k0>>1); 					float AEv= trig[A]'wA; 					float AOv= trig[A+1]'wB; 					wbase-=2; 		       					k0++; 					for(int s=0;s<(2<<i);s++)  					{ 						wB     =w[w1]   -w[w2]; 						x[w1]  =w[w1]   +w[w2];  						wA     =w[++w1] -w[++w2]; 						x[w1]  =w[w1]   +w[w2]; 	     						x[w2]  =wA*AEv  - wB*AOv; 						x[w2-1]=wB*AEv  + wA*AOv;  						w1-=k0; 						w2-=k0; 					} 					k0--; 					A+=k1; 				}  				temp=w; 				w=x; 				x=temp; 			} 		}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,mdct_kernel,The following statement contains a magic number: { 			for(int i=0;i<log2n-3;i++)  			{ 				int k0=(int)((uint)n >> (i+2)); 				int k1=1 << (i+3); 				int wbase=n2-2;  				A=0; 				float[] temp;  				for(int r=0; r<((uint)k0>>2); r++)  				{ 					int w1=wbase; 					w2=w1-(k0>>1); 					float AEv= trig[A]'wA; 					float AOv= trig[A+1]'wB; 					wbase-=2; 		       					k0++; 					for(int s=0;s<(2<<i);s++)  					{ 						wB     =w[w1]   -w[w2]; 						x[w1]  =w[w1]   +w[w2];  						wA     =w[++w1] -w[++w2]; 						x[w1]  =w[w1]   +w[w2]; 	     						x[w2]  =wA*AEv  - wB*AOv; 						x[w2-1]=wB*AEv  + wA*AOv;  						w1-=k0; 						w2-=k0; 					} 					k0--; 					A+=k1; 				}  				temp=w; 				w=x; 				x=temp; 			} 		}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,mdct_kernel,The following statement contains a magic number: { 			for(int i=0;i<log2n-3;i++)  			{ 				int k0=(int)((uint)n >> (i+2)); 				int k1=1 << (i+3); 				int wbase=n2-2;  				A=0; 				float[] temp;  				for(int r=0; r<((uint)k0>>2); r++)  				{ 					int w1=wbase; 					w2=w1-(k0>>1); 					float AEv= trig[A]'wA; 					float AOv= trig[A+1]'wB; 					wbase-=2; 		       					k0++; 					for(int s=0;s<(2<<i);s++)  					{ 						wB     =w[w1]   -w[w2]; 						x[w1]  =w[w1]   +w[w2];  						wA     =w[++w1] -w[++w2]; 						x[w1]  =w[w1]   +w[w2]; 	     						x[w2]  =wA*AEv  - wB*AOv; 						x[w2-1]=wB*AEv  + wA*AOv;  						w1-=k0; 						w2-=k0; 					} 					k0--; 					A+=k1; 				}  				temp=w; 				w=x; 				x=temp; 			} 		}
Magic Number,csvorbis,Mdct,C:\repos\mono_csvorbis\csvorbis\Mdct.cs,mdct_kernel,The following statement contains a magic number: { 			for(int i=0;i<log2n-3;i++)  			{ 				int k0=(int)((uint)n >> (i+2)); 				int k1=1 << (i+3); 				int wbase=n2-2;  				A=0; 				float[] temp;  				for(int r=0; r<((uint)k0>>2); r++)  				{ 					int w1=wbase; 					w2=w1-(k0>>1); 					float AEv= trig[A]'wA; 					float AOv= trig[A+1]'wB; 					wbase-=2; 		       					k0++; 					for(int s=0;s<(2<<i);s++)  					{ 						wB     =w[w1]   -w[w2]; 						x[w1]  =w[w1]   +w[w2];  						wA     =w[++w1] -w[++w2]; 						x[w1]  =w[w1]   +w[w2]; 	     						x[w2]  =wA*AEv  - wB*AOv; 						x[w2-1]=wB*AEv  + wA*AOv;  						w1-=k0; 						w2-=k0; 					} 					k0--; 					A+=k1; 				}  				temp=w; 				w=x; 				x=temp; 			} 		}
Magic Number,csvorbis,Residue0,C:\repos\mono_csvorbis\csvorbis\Residue0.cs,pack,The following statement contains a magic number: opb.write(info.begin'24);
Magic Number,csvorbis,Residue0,C:\repos\mono_csvorbis\csvorbis\Residue0.cs,pack,The following statement contains a magic number: opb.write(info.end'24);
Magic Number,csvorbis,Residue0,C:\repos\mono_csvorbis\csvorbis\Residue0.cs,pack,The following statement contains a magic number: opb.write(info.grouping-1'24);
Magic Number,csvorbis,Residue0,C:\repos\mono_csvorbis\csvorbis\Residue0.cs,pack,The following statement contains a magic number: opb.write(info.partitions-1'6);
Magic Number,csvorbis,Residue0,C:\repos\mono_csvorbis\csvorbis\Residue0.cs,pack,The following statement contains a magic number: opb.write(info.groupbook'8);
Magic Number,csvorbis,Residue0,C:\repos\mono_csvorbis\csvorbis\Residue0.cs,pack,The following statement contains a magic number: for(int j=0;j<info.partitions;j++)  			{ 				if(ilog(info.secondstages[j])>3)  				{ 					/* yes' this is a minor hack due to not thinking ahead */ 					opb.write(info.secondstages[j]'3);  					opb.write(1'1); 					opb.write(info.secondstages[j] >> 3'5);  				} 				else  				{ 					opb.write(info.secondstages[j]'4); /* trailing zero */ 				} 				acc+=icount(info.secondstages[j]); 			}
Magic Number,csvorbis,Residue0,C:\repos\mono_csvorbis\csvorbis\Residue0.cs,pack,The following statement contains a magic number: for(int j=0;j<info.partitions;j++)  			{ 				if(ilog(info.secondstages[j])>3)  				{ 					/* yes' this is a minor hack due to not thinking ahead */ 					opb.write(info.secondstages[j]'3);  					opb.write(1'1); 					opb.write(info.secondstages[j] >> 3'5);  				} 				else  				{ 					opb.write(info.secondstages[j]'4); /* trailing zero */ 				} 				acc+=icount(info.secondstages[j]); 			}
Magic Number,csvorbis,Residue0,C:\repos\mono_csvorbis\csvorbis\Residue0.cs,pack,The following statement contains a magic number: for(int j=0;j<info.partitions;j++)  			{ 				if(ilog(info.secondstages[j])>3)  				{ 					/* yes' this is a minor hack due to not thinking ahead */ 					opb.write(info.secondstages[j]'3);  					opb.write(1'1); 					opb.write(info.secondstages[j] >> 3'5);  				} 				else  				{ 					opb.write(info.secondstages[j]'4); /* trailing zero */ 				} 				acc+=icount(info.secondstages[j]); 			}
Magic Number,csvorbis,Residue0,C:\repos\mono_csvorbis\csvorbis\Residue0.cs,pack,The following statement contains a magic number: for(int j=0;j<info.partitions;j++)  			{ 				if(ilog(info.secondstages[j])>3)  				{ 					/* yes' this is a minor hack due to not thinking ahead */ 					opb.write(info.secondstages[j]'3);  					opb.write(1'1); 					opb.write(info.secondstages[j] >> 3'5);  				} 				else  				{ 					opb.write(info.secondstages[j]'4); /* trailing zero */ 				} 				acc+=icount(info.secondstages[j]); 			}
Magic Number,csvorbis,Residue0,C:\repos\mono_csvorbis\csvorbis\Residue0.cs,pack,The following statement contains a magic number: for(int j=0;j<info.partitions;j++)  			{ 				if(ilog(info.secondstages[j])>3)  				{ 					/* yes' this is a minor hack due to not thinking ahead */ 					opb.write(info.secondstages[j]'3);  					opb.write(1'1); 					opb.write(info.secondstages[j] >> 3'5);  				} 				else  				{ 					opb.write(info.secondstages[j]'4); /* trailing zero */ 				} 				acc+=icount(info.secondstages[j]); 			}
Magic Number,csvorbis,Residue0,C:\repos\mono_csvorbis\csvorbis\Residue0.cs,pack,The following statement contains a magic number: for(int j=0;j<acc;j++)  			{ 				opb.write(info.booklist[j]'8); 			}
Magic Number,csvorbis,Residue0,C:\repos\mono_csvorbis\csvorbis\Residue0.cs,unpack,The following statement contains a magic number: info.begin=opb.read(24);
Magic Number,csvorbis,Residue0,C:\repos\mono_csvorbis\csvorbis\Residue0.cs,unpack,The following statement contains a magic number: info.end=opb.read(24);
Magic Number,csvorbis,Residue0,C:\repos\mono_csvorbis\csvorbis\Residue0.cs,unpack,The following statement contains a magic number: info.grouping=opb.read(24)+1;
Magic Number,csvorbis,Residue0,C:\repos\mono_csvorbis\csvorbis\Residue0.cs,unpack,The following statement contains a magic number: info.partitions=opb.read(6)+1;
Magic Number,csvorbis,Residue0,C:\repos\mono_csvorbis\csvorbis\Residue0.cs,unpack,The following statement contains a magic number: info.groupbook=opb.read(8);
Magic Number,csvorbis,Residue0,C:\repos\mono_csvorbis\csvorbis\Residue0.cs,unpack,The following statement contains a magic number: for(int j=0;j<info.partitions;j++)  			{ 				int cascade=opb.read(3); 				if(opb.read(1)!=0)  				{ 					cascade|=(opb.read(5)<<3); 				} 				info.secondstages[j]=cascade; 				acc+=icount(cascade); 			}
Magic Number,csvorbis,Residue0,C:\repos\mono_csvorbis\csvorbis\Residue0.cs,unpack,The following statement contains a magic number: for(int j=0;j<info.partitions;j++)  			{ 				int cascade=opb.read(3); 				if(opb.read(1)!=0)  				{ 					cascade|=(opb.read(5)<<3); 				} 				info.secondstages[j]=cascade; 				acc+=icount(cascade); 			}
Magic Number,csvorbis,Residue0,C:\repos\mono_csvorbis\csvorbis\Residue0.cs,unpack,The following statement contains a magic number: for(int j=0;j<info.partitions;j++)  			{ 				int cascade=opb.read(3); 				if(opb.read(1)!=0)  				{ 					cascade|=(opb.read(5)<<3); 				} 				info.secondstages[j]=cascade; 				acc+=icount(cascade); 			}
Magic Number,csvorbis,Residue0,C:\repos\mono_csvorbis\csvorbis\Residue0.cs,unpack,The following statement contains a magic number: for(int j=0;j<acc;j++)  			{ 				info.booklist[j]=opb.read(8); 				//    if(info.booklist[j]==255)info.booklist[j]=-1; 			}
Magic Number,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: opb.write(0x564342'24);
Magic Number,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: opb.write(dim' 16);
Magic Number,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: opb.write(entries' 24);
Magic Number,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: if(ordered)  			{ 				// length ordered.  We only need to say how many codewords of 				// each length.  The actual codewords are generated 				// deterministically  				int count=0; 				opb.write(1'1);               // ordered 				opb.write(lengthlist[0]-1'5); // 1 to 32  				for(i=1;i<entries;i++)  				{ 					int _this=lengthlist[i]; 					int _last=lengthlist[i-1]; 					if(_this>_last)  					{ 						for(int j=_last;j<_this;j++)  						{ 							opb.write(i-count'ilog(entries-count)); 							count=i; 						} 					} 				} 				opb.write(i-count'ilog(entries-count)); 			} 			else  			{ 				// length random.  Again' we don't code the codeword itself' just 				// the length.  This time' though' we have to encode each length 				opb.write(0'1);   // unordered      				// algortihmic mapping has use for 'unused entries'' which we tag 				// here.  The algorithmic mapping happens as usual' but the unused 				// entry has no codeword. 				for(i=0;i<entries;i++)  				{ 					if(lengthlist[i]==0)break; 				}  				if(i==entries)  				{ 					opb.write(0'1); // no unused entries 					for(i=0;i<entries;i++)  					{ 						opb.write(lengthlist[i]-1'5); 					} 				} 				else  				{ 					opb.write(1'1); // we have unused entries; thus we tag 					for(i=0;i<entries;i++)  					{ 						if(lengthlist[i]==0)  						{ 							opb.write(0'1); 						} 						else  						{ 							opb.write(1'1); 							opb.write(lengthlist[i]-1'5); 						} 					} 				} 			}
Magic Number,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: if(ordered)  			{ 				// length ordered.  We only need to say how many codewords of 				// each length.  The actual codewords are generated 				// deterministically  				int count=0; 				opb.write(1'1);               // ordered 				opb.write(lengthlist[0]-1'5); // 1 to 32  				for(i=1;i<entries;i++)  				{ 					int _this=lengthlist[i]; 					int _last=lengthlist[i-1]; 					if(_this>_last)  					{ 						for(int j=_last;j<_this;j++)  						{ 							opb.write(i-count'ilog(entries-count)); 							count=i; 						} 					} 				} 				opb.write(i-count'ilog(entries-count)); 			} 			else  			{ 				// length random.  Again' we don't code the codeword itself' just 				// the length.  This time' though' we have to encode each length 				opb.write(0'1);   // unordered      				// algortihmic mapping has use for 'unused entries'' which we tag 				// here.  The algorithmic mapping happens as usual' but the unused 				// entry has no codeword. 				for(i=0;i<entries;i++)  				{ 					if(lengthlist[i]==0)break; 				}  				if(i==entries)  				{ 					opb.write(0'1); // no unused entries 					for(i=0;i<entries;i++)  					{ 						opb.write(lengthlist[i]-1'5); 					} 				} 				else  				{ 					opb.write(1'1); // we have unused entries; thus we tag 					for(i=0;i<entries;i++)  					{ 						if(lengthlist[i]==0)  						{ 							opb.write(0'1); 						} 						else  						{ 							opb.write(1'1); 							opb.write(lengthlist[i]-1'5); 						} 					} 				} 			}
Magic Number,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: if(ordered)  			{ 				// length ordered.  We only need to say how many codewords of 				// each length.  The actual codewords are generated 				// deterministically  				int count=0; 				opb.write(1'1);               // ordered 				opb.write(lengthlist[0]-1'5); // 1 to 32  				for(i=1;i<entries;i++)  				{ 					int _this=lengthlist[i]; 					int _last=lengthlist[i-1]; 					if(_this>_last)  					{ 						for(int j=_last;j<_this;j++)  						{ 							opb.write(i-count'ilog(entries-count)); 							count=i; 						} 					} 				} 				opb.write(i-count'ilog(entries-count)); 			} 			else  			{ 				// length random.  Again' we don't code the codeword itself' just 				// the length.  This time' though' we have to encode each length 				opb.write(0'1);   // unordered      				// algortihmic mapping has use for 'unused entries'' which we tag 				// here.  The algorithmic mapping happens as usual' but the unused 				// entry has no codeword. 				for(i=0;i<entries;i++)  				{ 					if(lengthlist[i]==0)break; 				}  				if(i==entries)  				{ 					opb.write(0'1); // no unused entries 					for(i=0;i<entries;i++)  					{ 						opb.write(lengthlist[i]-1'5); 					} 				} 				else  				{ 					opb.write(1'1); // we have unused entries; thus we tag 					for(i=0;i<entries;i++)  					{ 						if(lengthlist[i]==0)  						{ 							opb.write(0'1); 						} 						else  						{ 							opb.write(1'1); 							opb.write(lengthlist[i]-1'5); 						} 					} 				} 			}
Magic Number,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: opb.write(maptype'4);
Magic Number,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: switch(maptype)  			{ 				case 0: 					// no mapping 					break; 				case 1: 				case 2: 					// implicitly populated value mapping 					// explicitly populated value mapping 					if(quantlist==null)  					{ 						// no quantlist?  error 						return(-1); 					}      					// values that define the dequantization 					opb.write(q_min'32); 					opb.write(q_delta'32); 					opb.write(q_quant-1'4); 					opb.write(q_sequencep'1);      				{ 					int quantvals=0; 					switch(maptype)  					{ 						case 1: 							// a single column of (c->entries/c->dim) quantized values for 							// building a full value list algorithmically (square lattice) 							quantvals=maptype1_quantvals(); 							break; 						case 2: 							// every value (c->entries*c->dim total) specified explicitly 							quantvals=entries*dim; 							break; 					}  					// quantized values 					for(i=0;i<quantvals;i++)  					{ 						opb.write(Math.Abs(quantlist[i])'q_quant); 					} 				} 					break; 				default: 					// error case; we don't have any other map types now 					return(-1); 			}
Magic Number,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: switch(maptype)  			{ 				case 0: 					// no mapping 					break; 				case 1: 				case 2: 					// implicitly populated value mapping 					// explicitly populated value mapping 					if(quantlist==null)  					{ 						// no quantlist?  error 						return(-1); 					}      					// values that define the dequantization 					opb.write(q_min'32); 					opb.write(q_delta'32); 					opb.write(q_quant-1'4); 					opb.write(q_sequencep'1);      				{ 					int quantvals=0; 					switch(maptype)  					{ 						case 1: 							// a single column of (c->entries/c->dim) quantized values for 							// building a full value list algorithmically (square lattice) 							quantvals=maptype1_quantvals(); 							break; 						case 2: 							// every value (c->entries*c->dim total) specified explicitly 							quantvals=entries*dim; 							break; 					}  					// quantized values 					for(i=0;i<quantvals;i++)  					{ 						opb.write(Math.Abs(quantlist[i])'q_quant); 					} 				} 					break; 				default: 					// error case; we don't have any other map types now 					return(-1); 			}
Magic Number,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: switch(maptype)  			{ 				case 0: 					// no mapping 					break; 				case 1: 				case 2: 					// implicitly populated value mapping 					// explicitly populated value mapping 					if(quantlist==null)  					{ 						// no quantlist?  error 						return(-1); 					}      					// values that define the dequantization 					opb.write(q_min'32); 					opb.write(q_delta'32); 					opb.write(q_quant-1'4); 					opb.write(q_sequencep'1);      				{ 					int quantvals=0; 					switch(maptype)  					{ 						case 1: 							// a single column of (c->entries/c->dim) quantized values for 							// building a full value list algorithmically (square lattice) 							quantvals=maptype1_quantvals(); 							break; 						case 2: 							// every value (c->entries*c->dim total) specified explicitly 							quantvals=entries*dim; 							break; 					}  					// quantized values 					for(i=0;i<quantvals;i++)  					{ 						opb.write(Math.Abs(quantlist[i])'q_quant); 					} 				} 					break; 				default: 					// error case; we don't have any other map types now 					return(-1); 			}
Magic Number,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: switch(maptype)  			{ 				case 0: 					// no mapping 					break; 				case 1: 				case 2: 					// implicitly populated value mapping 					// explicitly populated value mapping 					if(quantlist==null)  					{ 						// no quantlist?  error 						return(-1); 					}      					// values that define the dequantization 					opb.write(q_min'32); 					opb.write(q_delta'32); 					opb.write(q_quant-1'4); 					opb.write(q_sequencep'1);      				{ 					int quantvals=0; 					switch(maptype)  					{ 						case 1: 							// a single column of (c->entries/c->dim) quantized values for 							// building a full value list algorithmically (square lattice) 							quantvals=maptype1_quantvals(); 							break; 						case 2: 							// every value (c->entries*c->dim total) specified explicitly 							quantvals=entries*dim; 							break; 					}  					// quantized values 					for(i=0;i<quantvals;i++)  					{ 						opb.write(Math.Abs(quantlist[i])'q_quant); 					} 				} 					break; 				default: 					// error case; we don't have any other map types now 					return(-1); 			}
Magic Number,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: switch(maptype)  			{ 				case 0: 					// no mapping 					break; 				case 1: 				case 2: 					// implicitly populated value mapping 					// explicitly populated value mapping 					if(quantlist==null)  					{ 						// no quantlist?  error 						return(-1); 					}      					// values that define the dequantization 					opb.write(q_min'32); 					opb.write(q_delta'32); 					opb.write(q_quant-1'4); 					opb.write(q_sequencep'1);      				{ 					int quantvals=0; 					switch(maptype)  					{ 						case 1: 							// a single column of (c->entries/c->dim) quantized values for 							// building a full value list algorithmically (square lattice) 							quantvals=maptype1_quantvals(); 							break; 						case 2: 							// every value (c->entries*c->dim total) specified explicitly 							quantvals=entries*dim; 							break; 					}  					// quantized values 					for(i=0;i<quantvals;i++)  					{ 						opb.write(Math.Abs(quantlist[i])'q_quant); 					} 				} 					break; 				default: 					// error case; we don't have any other map types now 					return(-1); 			}
Magic Number,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: if(opb.read(24)!=0x564342)  			{ 				//    goto _eofout; 				clear(); 				return(-1);  			}
Magic Number,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: dim=opb.read(16);
Magic Number,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: entries=opb.read(24);
Magic Number,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: switch(opb.read(1))  			{ 				case 0: 					// unordered 					lengthlist=new int[entries];  					// allocated but unused entries? 					if(opb.read(1)!=0)  					{ 						// yes' unused entries  						for(i=0;i<entries;i++)  						{ 							if(opb.read(1)!=0)  							{ 								int num=opb.read(5); 								if(num==-1)  								{ 									//            goto _eofout; 									clear(); 									return(-1);  								} 								lengthlist[i]=num+1; 							} 							else  							{ 								lengthlist[i]=0; 							} 						} 					} 					else  					{ 						// all entries used; no tagging 						for(i=0;i<entries;i++)  						{ 							int num=opb.read(5); 							if(num==-1)  							{ 								//          goto _eofout; 								clear(); 								return(-1);  							} 							lengthlist[i]=num+1; 						} 					} 					break; 				case 1: 					// ordered 				{ 					int length=opb.read(5)+1; 					lengthlist=new int[entries];  					for(i=0;i<entries;)  					{ 						int num=opb.read(ilog(entries-i)); 						if(num==-1)  						{ 							//          goto _eofout; 							clear(); 							return(-1);  						} 						for(int j=0;j<num;j++'i++)  						{ 							lengthlist[i]=length; 						} 						length++; 					} 				} 					break; 				default: 					// EOF 					return(-1); 			}
Magic Number,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: switch(opb.read(1))  			{ 				case 0: 					// unordered 					lengthlist=new int[entries];  					// allocated but unused entries? 					if(opb.read(1)!=0)  					{ 						// yes' unused entries  						for(i=0;i<entries;i++)  						{ 							if(opb.read(1)!=0)  							{ 								int num=opb.read(5); 								if(num==-1)  								{ 									//            goto _eofout; 									clear(); 									return(-1);  								} 								lengthlist[i]=num+1; 							} 							else  							{ 								lengthlist[i]=0; 							} 						} 					} 					else  					{ 						// all entries used; no tagging 						for(i=0;i<entries;i++)  						{ 							int num=opb.read(5); 							if(num==-1)  							{ 								//          goto _eofout; 								clear(); 								return(-1);  							} 							lengthlist[i]=num+1; 						} 					} 					break; 				case 1: 					// ordered 				{ 					int length=opb.read(5)+1; 					lengthlist=new int[entries];  					for(i=0;i<entries;)  					{ 						int num=opb.read(ilog(entries-i)); 						if(num==-1)  						{ 							//          goto _eofout; 							clear(); 							return(-1);  						} 						for(int j=0;j<num;j++'i++)  						{ 							lengthlist[i]=length; 						} 						length++; 					} 				} 					break; 				default: 					// EOF 					return(-1); 			}
Magic Number,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: switch(opb.read(1))  			{ 				case 0: 					// unordered 					lengthlist=new int[entries];  					// allocated but unused entries? 					if(opb.read(1)!=0)  					{ 						// yes' unused entries  						for(i=0;i<entries;i++)  						{ 							if(opb.read(1)!=0)  							{ 								int num=opb.read(5); 								if(num==-1)  								{ 									//            goto _eofout; 									clear(); 									return(-1);  								} 								lengthlist[i]=num+1; 							} 							else  							{ 								lengthlist[i]=0; 							} 						} 					} 					else  					{ 						// all entries used; no tagging 						for(i=0;i<entries;i++)  						{ 							int num=opb.read(5); 							if(num==-1)  							{ 								//          goto _eofout; 								clear(); 								return(-1);  							} 							lengthlist[i]=num+1; 						} 					} 					break; 				case 1: 					// ordered 				{ 					int length=opb.read(5)+1; 					lengthlist=new int[entries];  					for(i=0;i<entries;)  					{ 						int num=opb.read(ilog(entries-i)); 						if(num==-1)  						{ 							//          goto _eofout; 							clear(); 							return(-1);  						} 						for(int j=0;j<num;j++'i++)  						{ 							lengthlist[i]=length; 						} 						length++; 					} 				} 					break; 				default: 					// EOF 					return(-1); 			}
Magic Number,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: switch((maptype=opb.read(4)))  			{ 				case 0: 					// no mapping 					break; 				case 1: 				case 2: 					// implicitly populated value mapping 					// explicitly populated value mapping 					q_min=opb.read(32); 					q_delta=opb.read(32); 					q_quant=opb.read(4)+1; 					q_sequencep=opb.read(1);  				{ 					int quantvals=0; 					switch(maptype)  					{ 						case 1: 							quantvals=maptype1_quantvals(); 							break; 						case 2: 							quantvals=entries*dim; 							break; 					}        					// quantized values 					quantlist=new int[quantvals]; 					for(i=0;i<quantvals;i++)  					{ 						quantlist[i]=opb.read(q_quant); 					} 					if(quantlist[quantvals-1]==-1)  					{ 						//        goto _eofout; 						clear(); 						return(-1);  					} 				} 					break; 				default: 					//    goto _eofout; 					clear(); 					return(-1);  			}
Magic Number,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: switch((maptype=opb.read(4)))  			{ 				case 0: 					// no mapping 					break; 				case 1: 				case 2: 					// implicitly populated value mapping 					// explicitly populated value mapping 					q_min=opb.read(32); 					q_delta=opb.read(32); 					q_quant=opb.read(4)+1; 					q_sequencep=opb.read(1);  				{ 					int quantvals=0; 					switch(maptype)  					{ 						case 1: 							quantvals=maptype1_quantvals(); 							break; 						case 2: 							quantvals=entries*dim; 							break; 					}        					// quantized values 					quantlist=new int[quantvals]; 					for(i=0;i<quantvals;i++)  					{ 						quantlist[i]=opb.read(q_quant); 					} 					if(quantlist[quantvals-1]==-1)  					{ 						//        goto _eofout; 						clear(); 						return(-1);  					} 				} 					break; 				default: 					//    goto _eofout; 					clear(); 					return(-1);  			}
Magic Number,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: switch((maptype=opb.read(4)))  			{ 				case 0: 					// no mapping 					break; 				case 1: 				case 2: 					// implicitly populated value mapping 					// explicitly populated value mapping 					q_min=opb.read(32); 					q_delta=opb.read(32); 					q_quant=opb.read(4)+1; 					q_sequencep=opb.read(1);  				{ 					int quantvals=0; 					switch(maptype)  					{ 						case 1: 							quantvals=maptype1_quantvals(); 							break; 						case 2: 							quantvals=entries*dim; 							break; 					}        					// quantized values 					quantlist=new int[quantvals]; 					for(i=0;i<quantvals;i++)  					{ 						quantlist[i]=opb.read(q_quant); 					} 					if(quantlist[quantvals-1]==-1)  					{ 						//        goto _eofout; 						clear(); 						return(-1);  					} 				} 					break; 				default: 					//    goto _eofout; 					clear(); 					return(-1);  			}
Magic Number,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: switch((maptype=opb.read(4)))  			{ 				case 0: 					// no mapping 					break; 				case 1: 				case 2: 					// implicitly populated value mapping 					// explicitly populated value mapping 					q_min=opb.read(32); 					q_delta=opb.read(32); 					q_quant=opb.read(4)+1; 					q_sequencep=opb.read(1);  				{ 					int quantvals=0; 					switch(maptype)  					{ 						case 1: 							quantvals=maptype1_quantvals(); 							break; 						case 2: 							quantvals=entries*dim; 							break; 					}        					// quantized values 					quantlist=new int[quantvals]; 					for(i=0;i<quantvals;i++)  					{ 						quantlist[i]=opb.read(q_quant); 					} 					if(quantlist[quantvals-1]==-1)  					{ 						//        goto _eofout; 						clear(); 						return(-1);  					} 				} 					break; 				default: 					//    goto _eofout; 					clear(); 					return(-1);  			}
Magic Number,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: switch((maptype=opb.read(4)))  			{ 				case 0: 					// no mapping 					break; 				case 1: 				case 2: 					// implicitly populated value mapping 					// explicitly populated value mapping 					q_min=opb.read(32); 					q_delta=opb.read(32); 					q_quant=opb.read(4)+1; 					q_sequencep=opb.read(1);  				{ 					int quantvals=0; 					switch(maptype)  					{ 						case 1: 							quantvals=maptype1_quantvals(); 							break; 						case 2: 							quantvals=entries*dim; 							break; 					}        					// quantized values 					quantlist=new int[quantvals]; 					for(i=0;i<quantvals;i++)  					{ 						quantlist[i]=opb.read(q_quant); 					} 					if(quantlist[quantvals-1]==-1)  					{ 						//        goto _eofout; 						clear(); 						return(-1);  					} 				} 					break; 				default: 					//    goto _eofout; 					clear(); 					return(-1);  			}
Magic Number,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: switch((maptype=opb.read(4)))  			{ 				case 0: 					// no mapping 					break; 				case 1: 				case 2: 					// implicitly populated value mapping 					// explicitly populated value mapping 					q_min=opb.read(32); 					q_delta=opb.read(32); 					q_quant=opb.read(4)+1; 					q_sequencep=opb.read(1);  				{ 					int quantvals=0; 					switch(maptype)  					{ 						case 1: 							quantvals=maptype1_quantvals(); 							break; 						case 2: 							quantvals=entries*dim; 							break; 					}        					// quantized values 					quantlist=new int[quantvals]; 					for(i=0;i<quantvals;i++)  					{ 						quantlist[i]=opb.read(q_quant); 					} 					if(quantlist[quantvals-1]==-1)  					{ 						//        goto _eofout; 						clear(); 						return(-1);  					} 				} 					break; 				default: 					//    goto _eofout; 					clear(); 					return(-1);  			}
Magic Number,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,unquantize,The following statement contains a magic number: if(maptype==1 || maptype==2)  			{ 				int quantvals; 				float mindel=float32_unpack(q_min); 				float delta=float32_unpack(q_delta); 				float[] r=new float[entries*dim];  				//System.err.println("q_min="+q_min+"' mindel="+mindel);  				// maptype 1 and 2 both use a quantized value vector' but 				// different sizes 				switch(maptype)  				{ 					case 1: 						// most of the time' entries%dimensions == 0' but we need to be 						// well defined.  We define that the possible vales at each 						// scalar is values == entries/dim.  If entries%dim != 0' we'll 						// have 'too few' values (values*dim<entries)' which means that 						// we'll have 'left over' entries; left over entries use zeroed 						// values (and are wasted).  So don't generate codebooks like that 						quantvals=maptype1_quantvals(); 						for(int j=0;j<entries;j++)  						{ 							float last=0.0f; 							int indexdiv=1; 							for(int k=0;k<dim;k++)  							{ 								int index=(j/indexdiv)%quantvals; 								float val=quantlist[index]; 								val=Math.Abs(val)*delta+mindel+last; 								if(q_sequencep!=0)last=val;	   								r[j*dim+k]=val; 								indexdiv*=quantvals; 							} 						} 						break; 					case 2: 						for(int j=0;j<entries;j++)  						{ 							float last=0.0f; 							for(int k=0;k<dim;k++)  							{ 								float val=quantlist[j*dim+k]; 								//if((j*dim+k)==0){System.err.println(" | 0 -> "+val+" | ");} 								val=Math.Abs(val)*delta+mindel+last; 								if(q_sequencep!=0)last=val;	   								r[j*dim+k]=val; 								//if((j*dim+k)==0){System.err.println(" $ r[0] -> "+r[0]+" | ");} 							} 						} 						//System.err.println("\nr[0]="+r[0]); 						break; 					default: 						break; 				} 				return(r); 			}
Magic Number,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,unquantize,The following statement contains a magic number: if(maptype==1 || maptype==2)  			{ 				int quantvals; 				float mindel=float32_unpack(q_min); 				float delta=float32_unpack(q_delta); 				float[] r=new float[entries*dim];  				//System.err.println("q_min="+q_min+"' mindel="+mindel);  				// maptype 1 and 2 both use a quantized value vector' but 				// different sizes 				switch(maptype)  				{ 					case 1: 						// most of the time' entries%dimensions == 0' but we need to be 						// well defined.  We define that the possible vales at each 						// scalar is values == entries/dim.  If entries%dim != 0' we'll 						// have 'too few' values (values*dim<entries)' which means that 						// we'll have 'left over' entries; left over entries use zeroed 						// values (and are wasted).  So don't generate codebooks like that 						quantvals=maptype1_quantvals(); 						for(int j=0;j<entries;j++)  						{ 							float last=0.0f; 							int indexdiv=1; 							for(int k=0;k<dim;k++)  							{ 								int index=(j/indexdiv)%quantvals; 								float val=quantlist[index]; 								val=Math.Abs(val)*delta+mindel+last; 								if(q_sequencep!=0)last=val;	   								r[j*dim+k]=val; 								indexdiv*=quantvals; 							} 						} 						break; 					case 2: 						for(int j=0;j<entries;j++)  						{ 							float last=0.0f; 							for(int k=0;k<dim;k++)  							{ 								float val=quantlist[j*dim+k]; 								//if((j*dim+k)==0){System.err.println(" | 0 -> "+val+" | ");} 								val=Math.Abs(val)*delta+mindel+last; 								if(q_sequencep!=0)last=val;	   								r[j*dim+k]=val; 								//if((j*dim+k)==0){System.err.println(" $ r[0] -> "+r[0]+" | ");} 							} 						} 						//System.err.println("\nr[0]="+r[0]); 						break; 					default: 						break; 				} 				return(r); 			}
Magic Number,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,float32_pack,The following statement contains a magic number: exp=(int)Math.Floor(Math.Log(val)/Math.Log(2));
Magic Number,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,ldexp,The following statement contains a magic number: return (float)(foo*Math.Pow(2' e));
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,bisect_forward_serialno,The following statement contains a magic number: while(searched<endsearched)  			{  				long bisect;  				if(endsearched-searched<CHUNKSIZE)  				{  					bisect=searched;  				}  				else  				{  					bisect=(searched+endsearched)/2;  				}    				seek_helper(bisect);  				ret=get_next_page(page' -1);  				if(ret==OV_EREAD) return OV_EREAD;  				if(ret<0 || page.serialno()!=currentno)  				{  					endsearched=bisect;  					if(ret>=0)next=ret;  				}  				else  				{  					searched=ret+page.header_len+page.body_len;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,bisect_forward_serialno,The following statement contains a magic number: if(searched>=end || ret==-1)  			{  				links=m+1;  				offsets=new long[m+2];  				offsets[m+1]=searched;  			}  			else  			{  				ret=bisect_forward_serialno(next' offset' end' page.serialno()' m+1);  				if(ret==OV_EREAD)return OV_EREAD;  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,fetch_headers,The following statement contains a magic number: while(i<3)  			{  				os.pagein(og_ptr);  				while(i<3)  				{  					int result=os.packetout(op);  					if(result==0)break;  					if(result==-1)  					{  						Console.Error.WriteLine("Corrupt header in logical bitstream.");  						//goto bail_header;  						vi.clear();  						vc.clear();  						os.clear();  						return -1;  					}  					if(vi.synthesis_headerin(vc' op)!=0)  					{  						Console.Error.WriteLine("Illegal header in logical bitstream.");  						//goto bail_header;  						vi.clear();  						vc.clear();  						os.clear();  						return -1;  					}  					i++;  				}  				if(i<3)  					if(get_next_page(og_ptr' 1)<0)  					{  						Console.Error.WriteLine("Missing header in logical bitstream.");  						//goto bail_header;  						vi.clear();  						vc.clear();  						os.clear();  						return -1;  					}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,fetch_headers,The following statement contains a magic number: while(i<3)  			{  				os.pagein(og_ptr);  				while(i<3)  				{  					int result=os.packetout(op);  					if(result==0)break;  					if(result==-1)  					{  						Console.Error.WriteLine("Corrupt header in logical bitstream.");  						//goto bail_header;  						vi.clear();  						vc.clear();  						os.clear();  						return -1;  					}  					if(vi.synthesis_headerin(vc' op)!=0)  					{  						Console.Error.WriteLine("Illegal header in logical bitstream.");  						//goto bail_header;  						vi.clear();  						vc.clear();  						os.clear();  						return -1;  					}  					i++;  				}  				if(i<3)  					if(get_next_page(og_ptr' 1)<0)  					{  						Console.Error.WriteLine("Missing header in logical bitstream.");  						//goto bail_header;  						vi.clear();  						vc.clear();  						os.clear();  						return -1;  					}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,fetch_headers,The following statement contains a magic number: while(i<3)  			{  				os.pagein(og_ptr);  				while(i<3)  				{  					int result=os.packetout(op);  					if(result==0)break;  					if(result==-1)  					{  						Console.Error.WriteLine("Corrupt header in logical bitstream.");  						//goto bail_header;  						vi.clear();  						vc.clear();  						os.clear();  						return -1;  					}  					if(vi.synthesis_headerin(vc' op)!=0)  					{  						Console.Error.WriteLine("Illegal header in logical bitstream.");  						//goto bail_header;  						vi.clear();  						vc.clear();  						os.clear();  						return -1;  					}  					i++;  				}  				if(i<3)  					if(get_next_page(og_ptr' 1)<0)  					{  						Console.Error.WriteLine("Missing header in logical bitstream.");  						//goto bail_header;  						vi.clear();  						vc.clear();  						os.clear();  						return -1;  					}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,process_packet,The following statement contains a magic number: while(true)  			{  				// process a packet if we can.  If the machine isn't loaded'  				// neither is a page  				if(decode_ready)  				{  					Packet op=new Packet();  					int result=os.packetout(op);  					long granulepos;  					// if(result==-1)return(-1); // hole in the data. For now' swallow  					// and go. We'll need to add a real  					// error code in a bit.  					if(result>0)  					{  						// got a packet.  process it  						granulepos=op.granulepos;  						if(vb.synthesis(op)==0)  						{ // lazy check for lazy  							// header handling.  The  							// header packets aren't  							// audio' so if/when we  							// submit them'  							// vorbis_synthesis will  							// reject them  							// suck in the synthesis data and track bitrate  						{  							int oldsamples=vd.synthesis_pcmout(null' null);  							vd.synthesis_blockin(vb);  							samptrack+=vd.synthesis_pcmout(null' null)-oldsamples;  							bittrack+=op.bytes*8;  						}  	    							// update the pcm offset.  							if(granulepos!=-1 && op.e_o_s==0)  							{  								int link=(skable?current_link:0);  								int samples;  								// this packet has a pcm_offset on it (the last packet  								// completed on a page carries the offset) After processing  								// (above)' we know the pcm position of the *last* sample  								// ready to be returned. Find the offset of the *first*  								//   								// As an aside' this trick is inaccurate if we begin  								// reading anew right at the last page; the end-of-stream  								// granulepos declares the last frame in the stream' and the  								// last packet of the last page may be a partial frame.  								// So' we need a previous granulepos from an in-sequence page  								// to have a reference point.  Thus the !op.e_o_s clause above  	      								samples=vd.synthesis_pcmout(null' null);  								granulepos-=samples;  								for(int i=0;i<link;i++)  								{  									granulepos+=pcmlengths[i];  								}  								pcm_offset=granulepos;  							}  							return(1);  						}  					}  				}    				if(readp==0)return(0);  				if(get_next_page(og'-1)<0)return(0); // eof. leave unitialized    				// bitrate tracking; add the header's bytes here' the body bytes  				// are done by packet above  				bittrack+=og.header_len*8;    				// has our decoding just traversed a bitstream boundary?  				if(decode_ready)  				{  					if(current_serialno!=og.serialno())  					{  						decode_clear();  					}  				}    				// Do we need to load a new machine before submitting the page?  				// This is different in the seekable and non-seekable cases.    				//   				// In the seekable case' we already have all the header  				// information loaded and cached; we just initialize the machine  				// with it and continue on our merry way.  				//   				// In the non-seekable (streaming) case' we'll only be at a  				// boundary if we just left the previous logical bitstream and  				// we're now nominally at the header of the next bitstream    				if(!decode_ready)  				{  					int i;  					if(skable)  					{  						current_serialno=og.serialno();  	  						// match the serialno to bitstream section.  We use this rather than  						// offset positions to avoid problems near logical bitstream  						// boundaries  						for(i=0;i<links;i++)  						{  							if(serialnos[i]==current_serialno)break;  						}  						if(i==links)return(-1); // sign of a bogus stream.  error out'  						// leave machine uninitialized  						current_link=i;    						os.init(current_serialno);  						os.reset();     					}  					else  					{  						// we're streaming  						// fetch the three header packets' build the info struct  						int[] foo = new int[1];  						int ret=fetch_headers(vi[0]' vc[0]' foo' og);  						current_serialno=foo[0];  						if(ret!=0)return ret;  						current_link++;  						i=0;  					}  					make_decode_ready();  				}  				os.pagein(og);  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,process_packet,The following statement contains a magic number: while(true)  			{  				// process a packet if we can.  If the machine isn't loaded'  				// neither is a page  				if(decode_ready)  				{  					Packet op=new Packet();  					int result=os.packetout(op);  					long granulepos;  					// if(result==-1)return(-1); // hole in the data. For now' swallow  					// and go. We'll need to add a real  					// error code in a bit.  					if(result>0)  					{  						// got a packet.  process it  						granulepos=op.granulepos;  						if(vb.synthesis(op)==0)  						{ // lazy check for lazy  							// header handling.  The  							// header packets aren't  							// audio' so if/when we  							// submit them'  							// vorbis_synthesis will  							// reject them  							// suck in the synthesis data and track bitrate  						{  							int oldsamples=vd.synthesis_pcmout(null' null);  							vd.synthesis_blockin(vb);  							samptrack+=vd.synthesis_pcmout(null' null)-oldsamples;  							bittrack+=op.bytes*8;  						}  	    							// update the pcm offset.  							if(granulepos!=-1 && op.e_o_s==0)  							{  								int link=(skable?current_link:0);  								int samples;  								// this packet has a pcm_offset on it (the last packet  								// completed on a page carries the offset) After processing  								// (above)' we know the pcm position of the *last* sample  								// ready to be returned. Find the offset of the *first*  								//   								// As an aside' this trick is inaccurate if we begin  								// reading anew right at the last page; the end-of-stream  								// granulepos declares the last frame in the stream' and the  								// last packet of the last page may be a partial frame.  								// So' we need a previous granulepos from an in-sequence page  								// to have a reference point.  Thus the !op.e_o_s clause above  	      								samples=vd.synthesis_pcmout(null' null);  								granulepos-=samples;  								for(int i=0;i<link;i++)  								{  									granulepos+=pcmlengths[i];  								}  								pcm_offset=granulepos;  							}  							return(1);  						}  					}  				}    				if(readp==0)return(0);  				if(get_next_page(og'-1)<0)return(0); // eof. leave unitialized    				// bitrate tracking; add the header's bytes here' the body bytes  				// are done by packet above  				bittrack+=og.header_len*8;    				// has our decoding just traversed a bitstream boundary?  				if(decode_ready)  				{  					if(current_serialno!=og.serialno())  					{  						decode_clear();  					}  				}    				// Do we need to load a new machine before submitting the page?  				// This is different in the seekable and non-seekable cases.    				//   				// In the seekable case' we already have all the header  				// information loaded and cached; we just initialize the machine  				// with it and continue on our merry way.  				//   				// In the non-seekable (streaming) case' we'll only be at a  				// boundary if we just left the previous logical bitstream and  				// we're now nominally at the header of the next bitstream    				if(!decode_ready)  				{  					int i;  					if(skable)  					{  						current_serialno=og.serialno();  	  						// match the serialno to bitstream section.  We use this rather than  						// offset positions to avoid problems near logical bitstream  						// boundaries  						for(i=0;i<links;i++)  						{  							if(serialnos[i]==current_serialno)break;  						}  						if(i==links)return(-1); // sign of a bogus stream.  error out'  						// leave machine uninitialized  						current_link=i;    						os.init(current_serialno);  						os.reset();     					}  					else  					{  						// we're streaming  						// fetch the three header packets' build the info struct  						int[] foo = new int[1];  						int ret=fetch_headers(vi[0]' vc[0]' foo' og);  						current_serialno=foo[0];  						if(ret!=0)return ret;  						current_link++;  						i=0;  					}  					make_decode_ready();  				}  				os.pagein(og);  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,bitrate,The following statement contains a magic number: if(i<0)  			{  				long bits=0;  				for(int j=0;j<links;j++)  				{  					bits+=(offsets[j+1]-dataoffsets[j])*8;  				}  				return((int)Math.Round(bits/time_total(-1)));  			}  			else  			{  				if(skable)  				{  					// return the actual bitrate  					return((int)Math.Round((offsets[i+1]-dataoffsets[i])*8/time_total(i)));  				}  				else  				{  					// return nominal if set  					if(vi[i].bitrate_nominal>0)  					{  						return vi[i].bitrate_nominal;  					}  					else  					{  						if(vi[i].bitrate_upper>0)  						{  							if(vi[i].bitrate_lower>0)  							{  								return (vi[i].bitrate_upper+vi[i].bitrate_lower)/2;  							}  							else  							{  								return vi[i].bitrate_upper;  							}  						}  						return(-1);  					}  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,bitrate,The following statement contains a magic number: if(i<0)  			{  				long bits=0;  				for(int j=0;j<links;j++)  				{  					bits+=(offsets[j+1]-dataoffsets[j])*8;  				}  				return((int)Math.Round(bits/time_total(-1)));  			}  			else  			{  				if(skable)  				{  					// return the actual bitrate  					return((int)Math.Round((offsets[i+1]-dataoffsets[i])*8/time_total(i)));  				}  				else  				{  					// return nominal if set  					if(vi[i].bitrate_nominal>0)  					{  						return vi[i].bitrate_nominal;  					}  					else  					{  						if(vi[i].bitrate_upper>0)  						{  							if(vi[i].bitrate_lower>0)  							{  								return (vi[i].bitrate_upper+vi[i].bitrate_lower)/2;  							}  							else  							{  								return vi[i].bitrate_upper;  							}  						}  						return(-1);  					}  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,bitrate,The following statement contains a magic number: if(i<0)  			{  				long bits=0;  				for(int j=0;j<links;j++)  				{  					bits+=(offsets[j+1]-dataoffsets[j])*8;  				}  				return((int)Math.Round(bits/time_total(-1)));  			}  			else  			{  				if(skable)  				{  					// return the actual bitrate  					return((int)Math.Round((offsets[i+1]-dataoffsets[i])*8/time_total(i)));  				}  				else  				{  					// return nominal if set  					if(vi[i].bitrate_nominal>0)  					{  						return vi[i].bitrate_nominal;  					}  					else  					{  						if(vi[i].bitrate_upper>0)  						{  							if(vi[i].bitrate_lower>0)  							{  								return (vi[i].bitrate_upper+vi[i].bitrate_lower)/2;  							}  							else  							{  								return vi[i].bitrate_upper;  							}  						}  						return(-1);  					}  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,bitrate_instant,The following statement contains a magic number: int ret=(int)(bittrack/samptrack*vi[_link].rate+.5);
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,pcm_seek,The following statement contains a magic number: {  			long target=pos-total;  			long end=offsets[link+1];  			long begin=offsets[link];  			int best=(int)begin;    			Page og=new Page();  			while(begin<end)  			{  				long bisect;  				int ret;        				if(end-begin<CHUNKSIZE)  				{  					bisect=begin;  				}  				else  				{  					bisect=(end+begin)/2;  				}        				seek_helper(bisect);  				ret=get_next_page(og'end-bisect);          				if(ret==-1)  				{  					end=bisect;  				}  				else  				{  					long granulepos=og.granulepos();  					if(granulepos<target)  					{  						best=ret;  // raw offset of packet with granulepos  						begin=offset; // raw offset of next packet  					}  					else  					{  						end=bisect;  					}  				}  			}  			// found our page. seek to it (call raw_seek).  			if(raw_seek(best)!=0)  			{  				//goto seek_error;  				pcm_offset=-1;  				decode_clear();  				return -1;  			}  		}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Magic Number,csvorbis,VorbisFile,C:\repos\mono_csvorbis\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while(true)  			{  				if(decode_ready)  				{  					float[][] pcm;  					float[][][] _pcm=new float[1][][];  					int[] _index=new int[getInfo(-1).channels];  					int samples=vd.synthesis_pcmout(_pcm' _index);  					pcm=_pcm[0];  					if(samples!=0)  					{  						// yay! proceed to pack data into the byte buffer  						int channels=getInfo(-1).channels;  						int bytespersample=word * channels;  						if(samples>length/bytespersample)samples=length/bytespersample;  	  						// a tight loop to pack each size  					{  						int val;  						if(word==1)  						{  							int off=(sgned!=0?0:128);  							for(int j=0;j<samples;j++)  							{  								for(int i=0;i<channels;i++)  								{  									val=(int)(pcm[i][_index[i]+j]*128.0 + 0.5);  									if(val>127)val=127;  									else if(val<-128)val=-128;  									buffer[index++]=(byte)(val+off);  								}  							}  						}  						else  						{  							int off=(sgned!=0?0:32768);    							if(host_endian==bigendianp)  							{  								if(sgned!=0)  								{  									for(int i=0;i<channels;i++)   									{ // It's faster in this order  										int src=_index[i];  										int dest=i*2;  										for(int j=0;j<samples;j++)   										{  											val=(int)(pcm[i][src+j]*32767.0);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)(val);  											buffer[dest+1]=(byte)((uint)val >> 8);  											dest+=bytespersample;  										}  									}  								}  								else  								{  									for(int i=0;i<channels;i++)   									{  										float[] src=pcm[i];  										int dest=i;  										for(int j=0;j<samples;j++)   										{  											val=(int)(src[j]*32768.0 + 0.5);  											if(val>32767)val=32767;  											else if(val<-32768)val=-32768;  											buffer[dest]=(byte)((uint)(val+off) >> 8);  											buffer[dest+1]=(byte)(val+off);  											dest+=channels*2;  										}  									}  								}  							}  							else if(bigendianp!=0)  							{  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)((uint)val >> 8);  										buffer[index++]=(byte)val;  									}  								}  							}  							else  							{  								//int val;  								for(int j=0;j<samples;j++)  								{  									for(int i=0;i<channels;i++)  									{  										val=(int)(pcm[i][j]*32768.0 + 0.5);  										if(val>32767)val=32767;  										else if(val<-32768)val=-32768;  										val+=off;  										buffer[index++]=(byte)val;  										buffer[index++]=(byte)((uint)val >> 8);  									}  								}  							}  						}  					}  	  						vd.synthesis_read(samples);  						pcm_offset+=samples;  						if(bitstream!=null)bitstream[0]=current_link;  						return(samples*bytespersample);  					}  				}    				// suck in another packet  				switch(process_packet(1))  				{  					case 0:  						return(0);  					case -1:  						return -1;  					default:  						break;  				}  			}
Missing Default,csvorbis,CodeBook,C:\repos\mono_csvorbis\csvorbis\CodeBook.cs,besterror,The following switch statement is missing a default case: switch(addmul)  			{  				case 0:  					for(int i=0'o=0;i<dim;i++'o+=step)  						a[o]-=valuelist[bestt*dim+i];  					break;  				case 1:  					for(int i=0'o=0;i<dim;i++'o+=step)  					{  						float val=valuelist[bestt*dim+i];  						if(val==0)  						{  							a[o]=0;  						}  						else  						{  							a[o]/=val;  						}  					}  					break;  			}
Missing Default,csvorbis,DspState,C:\repos\mono_csvorbis\csvorbis\DspState.cs,synthesis_blockin,The following switch statement is missing a default case: switch(W)  			{ 				case 0: 					beginSl=0; 					endSl=vi.blocksizes[0]/2; 					break; 				case 1: 					beginSl=vi.blocksizes[1]/4-vi.blocksizes[lW]/4; 					endSl=beginSl+vi.blocksizes[lW]/2; 					break; 			}
Missing Default,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,pack,The following switch statement is missing a default case: switch(maptype)  					{ 						case 1: 							// a single column of (c->entries/c->dim) quantized values for 							// building a full value list algorithmically (square lattice) 							quantvals=maptype1_quantvals(); 							break; 						case 2: 							// every value (c->entries*c->dim total) specified explicitly 							quantvals=entries*dim; 							break; 					}
Missing Default,csvorbis,StaticCodeBook,C:\repos\mono_csvorbis\csvorbis\StaticCodeBook.cs,unpack,The following switch statement is missing a default case: switch(maptype)  					{ 						case 1: 							quantvals=maptype1_quantvals(); 							break; 						case 2: 							quantvals=entries*dim; 							break; 					}
