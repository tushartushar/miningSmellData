Implementation smell,Namespace,Class,File,Method,Description
Long Method,LanguageExt.CodeGen,CodeGenUtil,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\CodeGenUtil.cs,MakeToString,The method has 152 lines of code.
Long Method,LanguageExt.CodeGen,CodeGenUtil,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\CodeGenUtil.cs,MakeGetHashCode,The method has 102 lines of code.
Long Method,LanguageExt.CodeGen,CodeGenUtil,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\CodeGenUtil.cs,MakeOrderingMembers,The method has 224 lines of code.
Long Method,LanguageExt.CodeGen,CodeGenUtil,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\CodeGenUtil.cs,MakeEqualityMembers,The method has 140 lines of code.
Long Method,LanguageExt.CodeGen,CodeGenUtil,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\CodeGenUtil.cs,MakeClassOperatorMembers,The method has 405 lines of code.
Long Method,LanguageExt.CodeGen,CodeGenUtil,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\CodeGenUtil.cs,MakeSerialisationMembers,The method has 116 lines of code.
Long Method,LanguageExt.CodeGen,CodeGenUtil,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\CodeGenUtil.cs,MakeCaseType,The method has 139 lines of code.
Long Method,LanguageExt.CodeGen,ReaderGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\ReaderGenerator.cs,GenerateAsync,The method has 1170 lines of code.
Long Method,LanguageExt.CodeGen,RWSGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\RWSGenerator.cs,GenerateAsync,The method has 1999 lines of code.
Long Method,LanguageExt.CodeGen,UnionGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\UnionGenerator.cs,MakeAbstractClass,The method has 560 lines of code.
Complex Method,LanguageExt.CodeGen,CodeGenUtil,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\CodeGenUtil.cs,AddMembersToPrelude,Cyclomatic complexity of the method is 8
Complex Method,LanguageExt.CodeGen,CodeGenUtil,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\CodeGenUtil.cs,MakeCaseType,Cyclomatic complexity of the method is 8
Complex Method,LanguageExt.CodeGen,RWSGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\RWSGenerator.cs,GenerateAsync,Cyclomatic complexity of the method is 8
Long Parameter List,LanguageExt.CodeGen,CodeGenUtil,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\CodeGenUtil.cs,Report,The method has 5 parameters. Parameters: message' codeGenCategory' severity' node' progress
Long Parameter List,LanguageExt.CodeGen,CodeGenUtil,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\CodeGenUtil.cs,MakeDataTypeMembers,The method has 6 parameters. Parameters: typeName' thisType' baseType' members' baseSpec' typeIsClass
Long Parameter List,LanguageExt.CodeGen,CodeGenUtil,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\CodeGenUtil.cs,MakeCaseType,The method has 13 parameters. Parameters: context' applyToIdentifier' applyToMembers' applyToTypeParams' applyToModifiers' applyToConstraints' caseIdentifier' caseTypeParams' caseParams' baseSpec' caseIsClass' caseIsPartial' tag
Long Parameter List,LanguageExt.CodeGen,CodeGenUtil,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\CodeGenUtil.cs,MakeExplicitInterfaceImpl,The method has 5 parameters. Parameters: interfaceType' resultType' identifier' caseParams' caseTypeParams
Long Parameter List,LanguageExt.CodeGen,UnionGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\UnionGenerator.cs,AllMembersReturnInterface,The method has 5 parameters. Parameters: applyToIdentifier' applyToMembers' applyToTypeParams' context' progress
Long Parameter List,LanguageExt,RWSAttribute,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\RWSAttribute.cs,RWSAttribute,The method has 5 parameters. Parameters: WriterMonoid' Env' State' Constructor' Fail
Long Statement,LanguageExt.CodeGen,CodeGenUtil,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\CodeGenUtil.cs,AddLens,The length of the statement  "                        member.Modifiers.Where(m => m.IsKind(SyntaxKind.PublicKeyword) || m.IsKind(SyntaxKind.PrivateKeyword) || m.IsKind(SyntaxKind.ProtectedKeyword))' " is 144.
Long Statement,LanguageExt.CodeGen,CodeGenUtil,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\CodeGenUtil.cs,AddMembersToPrelude,The length of the statement  "                            var generics = TypeParameterList(SeparatedList<TypeParameterSyntax>(method.TypeParameters.Select(a => TypeParameter(a.Name)))); " is 127.
Long Statement,LanguageExt.CodeGen,CodeGenUtil,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\CodeGenUtil.cs,MakeCaseType,The length of the statement  "            var lmodifiers = applyToModifiers.Where(t => !t.IsKind(SyntaxKind.PartialKeyword) && !t.IsKind(SyntaxKind.AbstractKeyword)) " is 123.
Long Statement,LanguageExt.CodeGen,ReaderGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\ReaderGenerator.cs,GenerateAsync,The length of the statement  "                CodeGenUtil.ReportError($"Type can't be made into a Reader.  It must be a partial struct with one or more generic parameters."' "Reader Code-Gen"' context.ProcessingNode' progress); " is 181.
Long Statement,LanguageExt.CodeGen,RecordGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\RecordGenerator.cs,GenerateAsync,The length of the statement  "                CodeGenUtil.ReportError($"Type can't be made into a record.  It must be a partial class or a partial struct"' "Union Code-Gen"' context.ProcessingNode' progress); " is 162.
Long Statement,LanguageExt.CodeGen,RecordWithGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\RecordWith.cs,GenerateAsync,The length of the statement  "            var (partialClass' returnType' fields) = CodeGenUtil.GetState(context' progress' AllowedType.ClassOrStruct' "With code-gen"); " is 125.
Long Statement,LanguageExt.CodeGen,RecordWithAndLensGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\RecordWithAndLens.cs,GenerateAsync,The length of the statement  "            var (partialClass' returnType' fields) = CodeGenUtil.GetState(context' progress' AllowedType.ClassOrStruct' "WithLens code-gen"); " is 129.
Long Statement,LanguageExt.CodeGen,RWSGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\RWSGenerator.cs,GenerateAsync,The length of the statement  "                var genS = fixedState ? sType : applyToStruct.TypeParameterList.Parameters[applyToStruct.TypeParameterList.Parameters.Count - 2].ToString(); " is 140.
Long Statement,LanguageExt.CodeGen,RWSGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\RWSGenerator.cs,GenerateAsync,The length of the statement  "                var noAGen = TypeParameterList(applyToStruct.TypeParameterList.Parameters.RemoveAt(applyToStruct.TypeParameterList.Parameters.Count - 1)); " is 138.
Long Statement,LanguageExt.CodeGen,RWSGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\RWSGenerator.cs,GenerateAsync,The length of the statement  "                var resultTypeA = SyntaxFactory.ParseTypeName($"LanguageExt.RWSResult<{monoidWType}' {rType}' {wType}' {genS}' {genA}>"); " is 121.
Long Statement,LanguageExt.CodeGen,RWSGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\RWSGenerator.cs,GenerateAsync,The length of the statement  "                var resultTypeR = SyntaxFactory.ParseTypeName($"LanguageExt.RWSResult<{monoidWType}' {rType}' {wType}' {genS}' {rType}>"); " is 122.
Long Statement,LanguageExt.CodeGen,RWSGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\RWSGenerator.cs,GenerateAsync,The length of the statement  "                var resultTypeS = SyntaxFactory.ParseTypeName($"LanguageExt.RWSResult<{monoidWType}' {rType}' {wType}' {genS}' {sType}>"); " is 122.
Long Statement,LanguageExt.CodeGen,RWSGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\RWSGenerator.cs,GenerateAsync,The length of the statement  "                var resultTypeUnit = SyntaxFactory.ParseTypeName($"LanguageExt.RWSResult<{monoidWType}' {rType}' {wType}' {genS}' LanguageExt.Unit>"); " is 134.
Long Statement,LanguageExt.CodeGen,RWSGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\RWSGenerator.cs,GenerateAsync,The length of the statement  "                    CodeGenUtil.ReportError($"Type can't be made into a RWS monad.  It must be a partial struct with one or more generic parameters."' "RWS Code-Gen"' context.ProcessingNode' progress); " is 181.
Long Statement,LanguageExt.CodeGen,RWSGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\RWSGenerator.cs,GenerateAsync,The length of the statement  "                    CodeGenUtil.ReportError($"Type can't be made into a RWS monad.  It must be a partial struct with two or more generic parameters' the first generic parameter being the state' the second being the bound value type."' "RWS Code-Gen"' context.ProcessingNode' progress); " is 265.
Long Statement,LanguageExt.CodeGen,UnionGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\UnionGenerator.cs,GenerateAsync,The length of the statement  "                var staticCtorClass = MakeStaticConstructorClass(applyTo.Identifier' applyTo.Members' applyTo.TypeParameterList' applyTo.ConstraintClauses); " is 140.
Long Statement,LanguageExt.CodeGen,UnionGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\UnionGenerator.cs,GenerateAsync,The length of the statement  "                    CodeGenUtil.ReportError($"Type can't be made into a union.  It must be an abstract partial class or an interface"' "Union Code-Gen"' context.ProcessingNode' progress); " is 167.
Long Statement,LanguageExt.CodeGen,UnionGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\UnionGenerator.cs,GenerateAsync,The length of the statement  "                    CodeGenUtil.ReportError($"Type can't be made into a union.  It must be an abstract partial class or an interface"' "Union Code-Gen"' context.ProcessingNode' progress); " is 167.
Long Statement,LanguageExt.CodeGen,UnionGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\UnionGenerator.cs,GenerateAsync,The length of the statement  "                if (!AllMembersReturnInterface(applyToClass.Identifier' applyToClass.Members' applyToClass.TypeParameterList' context' progress)) " is 129.
Long Statement,LanguageExt.CodeGen,UnionGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\UnionGenerator.cs,GenerateAsync,The length of the statement  "                var staticCtorClass = MakeStaticConstructorClass(applyToClass.Identifier' applyToClass.Members' applyToClass.TypeParameterList' applyToClass.ConstraintClauses); " is 160.
Long Statement,LanguageExt.CodeGen,UnionGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\UnionGenerator.cs,GenerateAsync,The length of the statement  "                CodeGenUtil.ReportError($"Type can't be made into a union.  It must be an interface/abstract class"' "Union Code-Gen"' context.ProcessingNode' progress); " is 153.
Long Statement,LanguageExt.CodeGen,UnionGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\UnionGenerator.cs,AllMembersReturnInterface,The length of the statement  "                CodeGenUtil.ReportError($"Type can't contain anything other than methods if you want to make it into a union type."' "Union Code-Gen"' nonMethod' progress); " is 156.
Long Statement,LanguageExt.CodeGen,UnionGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\UnionGenerator.cs,AllMembersReturnInterface,The length of the statement  "                    CodeGenUtil.ReportError($"Methods in union types must return the same type as the interface/abstract class they're defined in. ({method.ReturnType} != {returnType})"' "Union Code-Gen"' method' progress); " is 203.
Long Statement,LanguageExt.CodeGen,UnionGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\UnionGenerator.cs,MakeStaticConstructorClass,The length of the statement  "                                TokenList(new[] { Token(SyntaxKind.PublicKeyword)' Token(SyntaxKind.StaticKeyword)' Token(SyntaxKind.PartialKeyword) })); " is 121.
Complex Conditional,LanguageExt.CodeGen,CodeGenUtil,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\CodeGenUtil.cs,AddMembersToPrelude,The conditional expression  "method.MethodKind == MethodKind.Ordinary &&                              method.ReturnType.Name != "Void" &&                              !method.IsStatic &&                              method.Name != "GetHashCode" &&                              method.Name != "Equals" &&                              method.Name != "CompareTo" &&                              method.Name != "ToString" &&                              method.Name != "this" &&                              method.Name != "GetEnumerator""  is complex.
Complex Conditional,LanguageExt.CodeGen,RWSGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\RWSGenerator.cs,GenerateAsync,The conditional expression  "context.ProcessingNode is StructDeclarationSyntax applyToStruct &&                   ((fixedState == false && applyToStruct.TypeParameterList.Parameters.Count >= 2) ||                   (fixedState == true && applyToStruct.TypeParameterList.Parameters.Count >= 1))"  is complex.
Magic Number,LanguageExt.CodeGen,CodeGenUtil,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\CodeGenUtil.cs,Report,The following statement contains a magic number: progress.Report(Diagnostic.Create(                  new DiagnosticDescriptor(                      $"CG{Math.Abs(message.GetHashCode()>>16)}"'                      message'                      message'                      codeGenCategory'                      severity'                      true'                      message)'                  node.GetLocation()));
Magic Number,LanguageExt.CodeGen,CodeGenUtil,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\CodeGenUtil.cs,AddMembersToPrelude,The following statement contains a magic number: switch (member.Kind)                  {                      case SymbolKind.Field:                          var field = (IFieldSymbol)member;                          if (applyToStruct.TypeParameterList.Parameters.Count < 2 && !field.IsStatic)                          {                              var fdecl = CreateFieldOrProperty(applyToStruct' getter' field.Name' field.Type);                              prelude = prelude.AddMembers(fdecl);                          }                          break;                        case SymbolKind.Property:                          var prop = (IPropertySymbol)member;                          if (applyToStruct.TypeParameterList.Parameters.Count < 2 && !prop.IsStatic && prop.Name != "this[]")                          {                              var fdecl = CreateFieldOrProperty(applyToStruct' getter' prop.Name' prop.Type);                              prelude = prelude.AddMembers(fdecl);                          }                          break;                        case SymbolKind.Method:                          var method = (IMethodSymbol)member;                            if (method.MethodKind == MethodKind.Ordinary &&                              method.ReturnType.Name != "Void" &&                              !method.IsStatic &&                              method.Name != "GetHashCode" &&                              method.Name != "Equals" &&                              method.Name != "CompareTo" &&                              method.Name != "ToString" &&                              method.Name != "this" &&                              method.Name != "GetEnumerator"                              )                          {                              // Method generics                              var generics = TypeParameterList(SeparatedList<TypeParameterSyntax>(method.TypeParameters.Select(a => TypeParameter(a.Name))));                                var sparams = applyToStruct.TypeParameterList.Parameters.Count > 0                                  ? applyToStruct.TypeParameterList.Parameters.Take(applyToStruct.TypeParameterList.Parameters.Count - 1).ToList()                                  : applyToStruct.TypeParameterList.Parameters.ToList();                                sparams.AddRange(generics.Parameters);                                // Method args                              var args = ParameterList(SeparatedList<ParameterSyntax>(                                              method.Parameters.Select(a => Parameter(Identifier(a.Name)).WithType(ParseTypeName(a.Type.ToString())))));                                // Return type                              var returnType = MakeGenericStruct(applyToStruct' method.ReturnType.ToString());                                // Invocation                              var invoke = generics.Parameters.Count == 0                                  ? MemberAccessExpression(                                        SyntaxKind.SimpleMemberAccessExpression'                                        IdentifierName("__env")'                                        IdentifierName(method.Name))                                  : MemberAccessExpression(                                        SyntaxKind.SimpleMemberAccessExpression'                                        IdentifierName("__env")'                                            GenericName(Identifier(method.Name))                                                .WithTypeArgumentList(                                                    TypeArgumentList(SeparatedList<TypeSyntax>(method.TypeParameters.Select(a => IdentifierName(a.Name))))));                                var decl = MethodDeclaration(returnType' method.Name)                                             .WithModifiers(TokenList(new[] { Token(SyntaxKind.PublicKeyword)' Token(SyntaxKind.StaticKeyword) }))                                             .WithParameterList(args)                                             .WithExpressionBody(                                                  ArrowExpressionClause(                                                      InvocationExpression(ask)                                                      .WithArgumentList(                                                          ArgumentList(                                                              SingletonSeparatedList<ArgumentSyntax>(                                                                  Argument(                                                                      SimpleLambdaExpression(                                                                          Parameter(Identifier("__env"))'                                                                          InvocationExpression(invoke)                                                                          .WithArgumentList(                                                                              ArgumentList(                                                                                  SeparatedList<ArgumentSyntax>(                                                                                      method.Parameters.Select(a => Argument(IdentifierName(a.Name)))))))))))))                                              .WithSemicolonToken(                                                  Token(SyntaxKind.SemicolonToken));                                decl = sparams.Count == 0                                  ? decl                                  : decl.WithTypeParameterList(TypeParameterList(SeparatedList<TypeParameterSyntax>(sparams)));                                prelude = prelude.AddMembers(decl);                          }                            break;                  }
Magic Number,LanguageExt.CodeGen,CodeGenUtil,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\CodeGenUtil.cs,AddMembersToPrelude,The following statement contains a magic number: switch (member.Kind)                  {                      case SymbolKind.Field:                          var field = (IFieldSymbol)member;                          if (applyToStruct.TypeParameterList.Parameters.Count < 2 && !field.IsStatic)                          {                              var fdecl = CreateFieldOrProperty(applyToStruct' getter' field.Name' field.Type);                              prelude = prelude.AddMembers(fdecl);                          }                          break;                        case SymbolKind.Property:                          var prop = (IPropertySymbol)member;                          if (applyToStruct.TypeParameterList.Parameters.Count < 2 && !prop.IsStatic && prop.Name != "this[]")                          {                              var fdecl = CreateFieldOrProperty(applyToStruct' getter' prop.Name' prop.Type);                              prelude = prelude.AddMembers(fdecl);                          }                          break;                        case SymbolKind.Method:                          var method = (IMethodSymbol)member;                            if (method.MethodKind == MethodKind.Ordinary &&                              method.ReturnType.Name != "Void" &&                              !method.IsStatic &&                              method.Name != "GetHashCode" &&                              method.Name != "Equals" &&                              method.Name != "CompareTo" &&                              method.Name != "ToString" &&                              method.Name != "this" &&                              method.Name != "GetEnumerator"                              )                          {                              // Method generics                              var generics = TypeParameterList(SeparatedList<TypeParameterSyntax>(method.TypeParameters.Select(a => TypeParameter(a.Name))));                                var sparams = applyToStruct.TypeParameterList.Parameters.Count > 0                                  ? applyToStruct.TypeParameterList.Parameters.Take(applyToStruct.TypeParameterList.Parameters.Count - 1).ToList()                                  : applyToStruct.TypeParameterList.Parameters.ToList();                                sparams.AddRange(generics.Parameters);                                // Method args                              var args = ParameterList(SeparatedList<ParameterSyntax>(                                              method.Parameters.Select(a => Parameter(Identifier(a.Name)).WithType(ParseTypeName(a.Type.ToString())))));                                // Return type                              var returnType = MakeGenericStruct(applyToStruct' method.ReturnType.ToString());                                // Invocation                              var invoke = generics.Parameters.Count == 0                                  ? MemberAccessExpression(                                        SyntaxKind.SimpleMemberAccessExpression'                                        IdentifierName("__env")'                                        IdentifierName(method.Name))                                  : MemberAccessExpression(                                        SyntaxKind.SimpleMemberAccessExpression'                                        IdentifierName("__env")'                                            GenericName(Identifier(method.Name))                                                .WithTypeArgumentList(                                                    TypeArgumentList(SeparatedList<TypeSyntax>(method.TypeParameters.Select(a => IdentifierName(a.Name))))));                                var decl = MethodDeclaration(returnType' method.Name)                                             .WithModifiers(TokenList(new[] { Token(SyntaxKind.PublicKeyword)' Token(SyntaxKind.StaticKeyword) }))                                             .WithParameterList(args)                                             .WithExpressionBody(                                                  ArrowExpressionClause(                                                      InvocationExpression(ask)                                                      .WithArgumentList(                                                          ArgumentList(                                                              SingletonSeparatedList<ArgumentSyntax>(                                                                  Argument(                                                                      SimpleLambdaExpression(                                                                          Parameter(Identifier("__env"))'                                                                          InvocationExpression(invoke)                                                                          .WithArgumentList(                                                                              ArgumentList(                                                                                  SeparatedList<ArgumentSyntax>(                                                                                      method.Parameters.Select(a => Argument(IdentifierName(a.Name)))))))))))))                                              .WithSemicolonToken(                                                  Token(SyntaxKind.SemicolonToken));                                decl = sparams.Count == 0                                  ? decl                                  : decl.WithTypeParameterList(TypeParameterList(SeparatedList<TypeParameterSyntax>(sparams)));                                prelude = prelude.AddMembers(decl);                          }                            break;                  }
Magic Number,LanguageExt.CodeGen,CodeGenUtil,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\CodeGenUtil.cs,Interleave,The following statement contains a magic number: var nxs = new A[xs.Length * 2 - 1];
Magic Number,LanguageExt.CodeGen,CodeGenUtil,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\CodeGenUtil.cs,Interleave,The following statement contains a magic number: nxs[i] = i % 2 == 0                      ? xs[i >> 1]                      : sep;
Magic Number,LanguageExt.CodeGen,ReaderGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\ReaderGenerator.cs,ReaderGenerator,The following statement contains a magic number: failName = attributeData.ConstructorArguments[2].Value?.ToString() ?? "Fail";
Magic Number,LanguageExt.CodeGen,RWSGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\RWSGenerator.cs,RWSGenerator,The following statement contains a magic number: ctorName = attributeData.ConstructorArguments[2].Value?.ToString() ?? "Return";
Magic Number,LanguageExt.CodeGen,RWSGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\RWSGenerator.cs,RWSGenerator,The following statement contains a magic number: failName = attributeData.ConstructorArguments[3].Value?.ToString() ?? "Fail";
Magic Number,LanguageExt.CodeGen,RWSGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\RWSGenerator.cs,RWSGenerator,The following statement contains a magic number: attributeData.ConstructorArguments.Length == 4
Magic Number,LanguageExt.CodeGen,RWSGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\RWSGenerator.cs,GenerateAsync,The following statement contains a magic number: var genS = fixedState ? sType : applyToStruct.TypeParameterList.Parameters[applyToStruct.TypeParameterList.Parameters.Count - 2].ToString();
Magic Number,LanguageExt.CodeGen,RWSGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\RWSGenerator.cs,GenerateAsync,The following statement contains a magic number: context.ProcessingNode is StructDeclarationSyntax applyToStruct &&                   ((fixedState == false && applyToStruct.TypeParameterList.Parameters.Count >= 2) ||                   (fixedState == true && applyToStruct.TypeParameterList.Parameters.Count >= 1))
Duplicate Code,LanguageExt.CodeGen,CodeGenUtil,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\CodeGenUtil.cs,MakeEqualityMembers,The method contains a code clone-set at the following line numbers (starting from the method definition): ((84' 103)' (125' 144))
Duplicate Code,LanguageExt.CodeGen,CodeGenUtil,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\CodeGenUtil.cs,MakeClassOperatorMembers,The method contains a code clone-set at the following line numbers (starting from the method definition): ((6' 25)' (61' 80)' (95' 114)' (168' 187)' (240' 259)' (328' 347))
Duplicate Code,LanguageExt.CodeGen,CodeGenUtil,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\CodeGenUtil.cs,MakeClassOperatorMembers,The method contains a code clone-set at the following line numbers (starting from the method definition): ((6' 26)' (95' 115)' (240' 260)' (168' 188)' (328' 348))
Duplicate Code,LanguageExt.CodeGen,CodeGenUtil,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\CodeGenUtil.cs,MakeClassOperatorMembers,The method contains a code clone-set at the following line numbers (starting from the method definition): ((6' 40)' (168' 202)' (328' 362))
Duplicate Code,LanguageExt.CodeGen,CodeGenUtil,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\CodeGenUtil.cs,MakeClassOperatorMembers,The method contains a code clone-set at the following line numbers (starting from the method definition): ((95' 116)' (240' 261))
Duplicate Code,LanguageExt.CodeGen,CodeGenUtil,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\CodeGenUtil.cs,MakeClassOperatorMembers,The method contains a code clone-set at the following line numbers (starting from the method definition): ((275' 306)' (361' 392))
Duplicate Code,LanguageExt.CodeGen,CodeGenUtil,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\CodeGenUtil.cs,MakeSerialisationMembers,The method contains a code clone-set at the following line numbers (starting from the method definition): ((53' 81)' (88' 116))
Duplicate Code,LanguageExt.CodeGen,ReaderGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\ReaderGenerator.cs,GenerateAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((118' 141)' (158' 181))
Duplicate Code,LanguageExt.CodeGen,ReaderGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\ReaderGenerator.cs,GenerateAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((118' 139)' (209' 230)' (158' 179))
Duplicate Code,LanguageExt.CodeGen,ReaderGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\ReaderGenerator.cs,GenerateAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((491' 520)' (558' 587)' (622' 651))
Duplicate Code,LanguageExt.CodeGen,ReaderGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\ReaderGenerator.cs,GenerateAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((547' 576)' (611' 640))
Duplicate Code,LanguageExt.CodeGen,RWSGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\RWSGenerator.cs,GenerateAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((93' 113)' (186' 206)' (249' 269)' (317' 337)' (372' 392)' (1472' 1492)' (1633' 1653))
Duplicate Code,LanguageExt.CodeGen,RWSGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\RWSGenerator.cs,GenerateAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((186' 221)' (249' 284))
Duplicate Code,LanguageExt.CodeGen,RWSGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\RWSGenerator.cs,GenerateAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((186' 219)' (372' 405)' (249' 282))
Duplicate Code,LanguageExt.CodeGen,RWSGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\RWSGenerator.cs,GenerateAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((186' 207)' (1472' 1493)' (1633' 1654)' (249' 270)' (372' 393))
Duplicate Code,LanguageExt.CodeGen,RWSGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\RWSGenerator.cs,GenerateAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((1472' 1498)' (1633' 1659))
Duplicate Code,LanguageExt.CodeGen,RWSGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\RWSGenerator.cs,GenerateAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((902' 928)' (979' 1005)' (1053' 1079))
Duplicate Code,LanguageExt.CodeGen,RWSGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\RWSGenerator.cs,GenerateAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((968' 997)' (1042' 1071))
Duplicate Code,LanguageExt.CodeGen,RWSGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\RWSGenerator.cs,GenerateAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((1007' 1038)' (1081' 1112))
Duplicate Code,LanguageExt.CodeGen,RWSGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\RWSGenerator.cs,GenerateAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((1471' 1490)' (1632' 1651))
Duplicate Code,LanguageExt.CodeGen,UnionGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\UnionGenerator.cs,MakeAbstractClass,The method contains a code clone-set at the following line numbers (starting from the method definition): ((74' 94)' (91' 111))
Duplicate Code,LanguageExt.CodeGen,UnionGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\UnionGenerator.cs,MakeAbstractClass,The method contains a code clone-set at the following line numbers (starting from the method definition): ((163' 182)' (217' 236)' (250' 269)' (322' 341)' (409' 428)' (480' 499))
Duplicate Code,LanguageExt.CodeGen,UnionGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\UnionGenerator.cs,MakeAbstractClass,The method contains a code clone-set at the following line numbers (starting from the method definition): ((163' 183)' (250' 270)' (322' 342)' (409' 429)' (480' 500))
Duplicate Code,LanguageExt.CodeGen,UnionGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\UnionGenerator.cs,MakeAbstractClass,The method contains a code clone-set at the following line numbers (starting from the method definition): ((163' 197)' (409' 443)' (480' 514))
Duplicate Code,LanguageExt.CodeGen,UnionGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\UnionGenerator.cs,MakeAbstractClass,The method contains a code clone-set at the following line numbers (starting from the method definition): ((250' 271)' (322' 343))
Duplicate Code,LanguageExt.CodeGen,UnionGenerator,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\UnionGenerator.cs,MakeAbstractClass,The method contains a code clone-set at the following line numbers (starting from the method definition): ((357' 388)' (513' 544))
Missing Default,LanguageExt.CodeGen,CodeGenUtil,D:\research\architectureSmells\repos\louthy_language-ext\LanguageExt.CodeGen\CodeGenUtil.cs,AddMembersToPrelude,The following switch statement is missing a default case: switch (member.Kind)                  {                      case SymbolKind.Field:                          var field = (IFieldSymbol)member;                          if (applyToStruct.TypeParameterList.Parameters.Count < 2 && !field.IsStatic)                          {                              var fdecl = CreateFieldOrProperty(applyToStruct' getter' field.Name' field.Type);                              prelude = prelude.AddMembers(fdecl);                          }                          break;                        case SymbolKind.Property:                          var prop = (IPropertySymbol)member;                          if (applyToStruct.TypeParameterList.Parameters.Count < 2 && !prop.IsStatic && prop.Name != "this[]")                          {                              var fdecl = CreateFieldOrProperty(applyToStruct' getter' prop.Name' prop.Type);                              prelude = prelude.AddMembers(fdecl);                          }                          break;                        case SymbolKind.Method:                          var method = (IMethodSymbol)member;                            if (method.MethodKind == MethodKind.Ordinary &&                              method.ReturnType.Name != "Void" &&                              !method.IsStatic &&                              method.Name != "GetHashCode" &&                              method.Name != "Equals" &&                              method.Name != "CompareTo" &&                              method.Name != "ToString" &&                              method.Name != "this" &&                              method.Name != "GetEnumerator"                              )                          {                              // Method generics                              var generics = TypeParameterList(SeparatedList<TypeParameterSyntax>(method.TypeParameters.Select(a => TypeParameter(a.Name))));                                var sparams = applyToStruct.TypeParameterList.Parameters.Count > 0                                  ? applyToStruct.TypeParameterList.Parameters.Take(applyToStruct.TypeParameterList.Parameters.Count - 1).ToList()                                  : applyToStruct.TypeParameterList.Parameters.ToList();                                sparams.AddRange(generics.Parameters);                                // Method args                              var args = ParameterList(SeparatedList<ParameterSyntax>(                                              method.Parameters.Select(a => Parameter(Identifier(a.Name)).WithType(ParseTypeName(a.Type.ToString())))));                                // Return type                              var returnType = MakeGenericStruct(applyToStruct' method.ReturnType.ToString());                                // Invocation                              var invoke = generics.Parameters.Count == 0                                  ? MemberAccessExpression(                                        SyntaxKind.SimpleMemberAccessExpression'                                        IdentifierName("__env")'                                        IdentifierName(method.Name))                                  : MemberAccessExpression(                                        SyntaxKind.SimpleMemberAccessExpression'                                        IdentifierName("__env")'                                            GenericName(Identifier(method.Name))                                                .WithTypeArgumentList(                                                    TypeArgumentList(SeparatedList<TypeSyntax>(method.TypeParameters.Select(a => IdentifierName(a.Name))))));                                var decl = MethodDeclaration(returnType' method.Name)                                             .WithModifiers(TokenList(new[] { Token(SyntaxKind.PublicKeyword)' Token(SyntaxKind.StaticKeyword) }))                                             .WithParameterList(args)                                             .WithExpressionBody(                                                  ArrowExpressionClause(                                                      InvocationExpression(ask)                                                      .WithArgumentList(                                                          ArgumentList(                                                              SingletonSeparatedList<ArgumentSyntax>(                                                                  Argument(                                                                      SimpleLambdaExpression(                                                                          Parameter(Identifier("__env"))'                                                                          InvocationExpression(invoke)                                                                          .WithArgumentList(                                                                              ArgumentList(                                                                                  SeparatedList<ArgumentSyntax>(                                                                                      method.Parameters.Select(a => Argument(IdentifierName(a.Name)))))))))))))                                              .WithSemicolonToken(                                                  Token(SyntaxKind.SemicolonToken));                                decl = sparams.Count == 0                                  ? decl                                  : decl.WithTypeParameterList(TypeParameterList(SeparatedList<TypeParameterSyntax>(sparams)));                                prelude = prelude.AddMembers(decl);                          }                            break;                  }
