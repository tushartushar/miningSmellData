Implementation smell,Namespace,Class,File,Method,Description
Long Method,VimAddin,IdeViMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\IdeViMode.cs,RunExCommand,The method has 66 lines of code.
Long Method,VimAddin,ViActionMaps,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActionMaps.cs,GetDirectionKeyAction,The method has 64 lines of code.
Long Method,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,RunExCommand,The method has 90 lines of code.
Long Method,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The method has 745 lines of code.
Long Method,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,ApplyActionToSelection,The method has 73 lines of code.
Complex Method,VimAddin,IdeViMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\IdeViMode.cs,RunExCommand,Cyclomatic complexity of the method is 31
Complex Method,VimAddin,ViActionMaps,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActionMaps.cs,GetEditObjectCharAction,Cyclomatic complexity of the method is 9
Complex Method,VimAddin,ViActionMaps,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActionMaps.cs,GetNavCharAction,Cyclomatic complexity of the method is 22
Complex Method,VimAddin,ViActionMaps,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActionMaps.cs,GetDirectionKeyAction,Cyclomatic complexity of the method is 31
Complex Method,VimAddin,ViActionMaps,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActionMaps.cs,GetInsertKeyAction,Cyclomatic complexity of the method is 15
Complex Method,VimAddin,ViActions,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActions.cs,ToggleCase,Cyclomatic complexity of the method is 9
Complex Method,VimAddin,ViBuilderContext,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViBuilderContext.cs,InsertChar,Cyclomatic complexity of the method is 8
Complex Method,VimAddin,ViEditor,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViEditor.cs,SetMode,Cyclomatic complexity of the method is 11
Complex Method,VimAddin,ViEditor,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViEditor.cs,OnCaretPositionChanged,Cyclomatic complexity of the method is 9
Complex Method,VimAddin,ViEditor,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViEditor.cs,GetRegisterContents,Cyclomatic complexity of the method is 16
Complex Method,VimAddin,ViEditor,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViEditor.cs,SetRegisterContents,Cyclomatic complexity of the method is 26
Complex Method,VimAddin,ViKeyNotation,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViKeyNotation.cs,AppendToString,Cyclomatic complexity of the method is 8
Complex Method,VimAddin,ViKeyNotation,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViKeyNotation.cs,ParseKeySequence,Cyclomatic complexity of the method is 18
Complex Method,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,FormatSelection,Cyclomatic complexity of the method is 8
Complex Method,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,RunExCommand,Cyclomatic complexity of the method is 20
Complex Method,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,Cyclomatic complexity of the method is 338
Complex Method,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,RegexReplace,Cyclomatic complexity of the method is 8
Complex Method,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,ApplyActionToSelection,Cyclomatic complexity of the method is 51
Complex Method,VimAddin,ViStatusArea,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViStatusArea.cs,OnExposeEvent,Cyclomatic complexity of the method is 7
Long Parameter List,VimAddin,ViActions,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActions.cs,ParseForChar,The method has 6 parameters.
Long Parameter List,VimAddin,ViActions,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActions.cs,TryFindInnerQuote,The method has 4 parameters.
Long Parameter List,VimAddin,ViActions,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActions.cs,ParseForQuote,The method has 4 parameters.
Long Statement,VimAddin,ViActions,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActions.cs,TryFindSymbolBlock,The length of the statement  "	var matchingStartBrace = endTokenOffset.HasValue ? data.Document.GetMatchingBracketOffset (endTokenOffset.GetValueOrDefault ()) : -1; " is 133.
Long Statement,VimAddin,ViActions,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActions.cs,TryFindSymbolBlock,The length of the statement  "	if (matchingStartBrace >= 0 && (!startTokenOffset.HasValue || matchingStartBrace != startTokenOffset.GetValueOrDefault ())) " is 123.
Long Statement,VimAddin,ViActions,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActions.cs,TryFindSymbolBlock,The length of the statement  "	var matchingEndBrace = startTokenOffset.HasValue && data.GetCharAt (offset) != end ? data.Document.GetMatchingBracketOffset (startTokenOffset.GetValueOrDefault ()) : -1; " is 169.
Long Statement,VimAddin,ViActions,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActions.cs,RetreatFromLineEnd,The length of the statement  "		while (DocumentLocation.MinColumn < data.Caret.Column && (data.Caret.Offset >= data.Document.TextLength || IsEol (data.Document.GetCharAt (data.Caret.Offset)))) { " is 162.
Long Statement,VimAddin,ViActions,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActions.cs,VisualSelectionFromMoveAction,The length of the statement  "		//Console.WriteLine ("oc{0}:{1} oa{2}:{3} ol{4}:{5}"' oldCaret.Line' oldCaret.Column' oldAnchor.Line' oldAnchor.Column' oldLead.Line' oldLead.Column); " is 150.
Long Statement,VimAddin,ViActions,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActions.cs,VisualSelectionFromMoveAction,The length of the statement  "		//Console.WriteLine ("nc{0}:{1} na{2}:{3} nl{4}:{5}"' newCaret.Line' newCaret.Line' newAnchor.Line' newAnchor.Column' newLead.Line' newLead.Column); " is 148.
Long Statement,VimAddin,ViActions,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActions.cs,VisualSelectionFromMoveAction,The length of the statement  "			if (oldAnchor < oldLead && newAnchor > newLead && ((newLead.Line == newAnchor.Line && oldLead.Line == oldAnchor.Line + 1) || (newLead.Line == newAnchor.Line - 1 && oldLead.Line == oldAnchor.Line))) " is 197.
Long Statement,VimAddin,ViActions,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActions.cs,VisualSelectionFromMoveAction,The length of the statement  "			else if (oldAnchor > oldLead && newAnchor < newLead && ((newLead.Line == newAnchor.Line && oldLead.Line == oldAnchor.Line - 1) || (newLead.Line == newAnchor.Line + 1 && oldLead.Line == oldAnchor.Line))) " is 202.
Long Statement,VimAddin,ViBuilderContext,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViBuilderContext.cs,InsertChar,The length of the statement  "				data.MainSelection = data.MainSelection.WithRange (new DocumentLocation (data.MainSelection.Anchor.Line' caret.Column + 1)' new DocumentLocation (data.MainSelection.Lead.Line' caret.Column + 1)); " is 195.
Long Statement,VimAddin,ViEditor,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViEditor.cs,GetRegisterContents,The length of the statement  "		if (((int)'a' <= regInt && regInt <= (int)'z') || ((int)'A' <= regInt && regInt <= (int)'Z') || ((int)'0' <= regInt && regInt <= (int)'9')) " is 139.
Long Statement,VimAddin,ViEditor,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViEditor.cs,IsValidRegister,The length of the statement  "	return (((int)'a' <= regInt && regInt <= (int)'z') || ((int)'A' <= regInt && regInt <= (int)'Z') || ((int)'0' <= regInt && regInt <= (int)'9') || validRegisters.Contains (c)); " is 175.
Long Statement,VimAddin,ViEditor,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViEditor.cs,IsValidSetRegister,The length of the statement  "	return (((int)'a' <= regInt && regInt <= (int)'z') || ((int)'A' <= regInt && regInt <= (int)'Z') || ((int)'0' <= regInt && regInt <= (int)'9') || validSetRegisters.Contains (c)); " is 178.
Long Statement,VimAddin,ViEditor,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViEditor.cs,IsValidGetRegister,The length of the statement  "	return (((int)'a' <= regInt && regInt <= (int)'z') || ((int)'A' <= regInt && regInt <= (int)'Z') || ((int)'0' <= regInt && regInt <= (int)'9') || validGetRegisters.Contains (c)); " is 178.
Long Statement,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,RunExCommand,The length of the statement  "			return string.Format ("s:{0} {1}; ({2}'{3}) ({4}) ({5})"' selection.Offset' selection.Length' LastSelectionRange.Item1' LastSelectionRange.Item2' linesAhead' Data.Document.TextLength); " is 184.
Long Statement,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The length of the statement  "		} else if (((modifier & (Gdk.ModifierType.ShiftMask | Gdk.ModifierType.ControlMask)) == 0 && (unicodeKey == 'd' || unicodeKey == 'j' || unicodeKey == 'k'))) { " is 158.
Long Statement,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The length of the statement  "		} else if (((modifier & (Gdk.ModifierType.ShiftMask | Gdk.ModifierType.ControlMask)) == 0 && (unicodeKey == 'y' || unicodeKey == 'j' || unicodeKey == 'k'))) { " is 158.
Long Statement,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,PasteAfter,The length of the statement  "		Gtk.Clipboard.Get (ClipboardActions.CopyOperation.CLIPBOARD_ATOM).RequestText (delegate (Gtk.Clipboard cb' string contents) { " is 125.
Long Statement,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,PasteBefore,The length of the statement  "		Gtk.Clipboard.Get (ClipboardActions.CopyOperation.CLIPBOARD_ATOM).RequestText (delegate (Gtk.Clipboard cb' string contents) { " is 125.
Long Statement,VimAddin,ViWordFindStrategy,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViWordFindStrategy.cs,FindNextSubwordOffset,The length of the statement  "	for (c = doc.GetCharAt (myoffset); char.IsWhiteSpace (c) && 0 <= myoffset && doc.TextLength - 1 > myoffset; c = doc.GetCharAt (++myoffset)) " is 139.
Long Statement,VimAddin,ViWordFindStrategy,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViWordFindStrategy.cs,FindNextWordOffset,The length of the statement  "	for (char c = doc.GetCharAt (myoffset); !char.IsWhiteSpace (c) && 0 <= myoffset && doc.TextLength - 1 > myoffset; c = doc.GetCharAt (++myoffset)) " is 145.
Long Statement,VimAddin,ViWordFindStrategy,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViWordFindStrategy.cs,FindNextWordOffset,The length of the statement  "	for (char c = doc.GetCharAt (myoffset); char.IsWhiteSpace (c) && 0 <= myoffset && doc.TextLength - 1 > myoffset; c = doc.GetCharAt (++myoffset)) " is 144.
Long Statement,VimAddin,ViWordFindStrategy,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViWordFindStrategy.cs,FindPrevSubwordOffset,The length of the statement  "	for (c = doc.GetCharAt (myoffset); char.IsWhiteSpace (c) && 0 <= myoffset && doc.TextLength - 1 > myoffset; c = doc.GetCharAt (--myoffset)) " is 139.
Long Statement,VimAddin,ViWordFindStrategy,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViWordFindStrategy.cs,FindPrevSubwordOffset,The length of the statement  "	for (; GetCharacterClass (c) == initialClass && 0 <= myoffset && doc.TextLength - 1 > myoffset; c = doc.GetCharAt (--myoffset)) " is 127.
Long Statement,VimAddin,ViWordFindStrategy,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViWordFindStrategy.cs,FindPrevWordOffset,The length of the statement  "	for (char c = doc.GetCharAt (offset); char.IsWhiteSpace (c) && 0 < offset && doc.TextLength > offset; c = doc.GetCharAt (--offset)) " is 131.
Long Statement,VimAddin,ViWordFindStrategy,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViWordFindStrategy.cs,FindPrevWordOffset,The length of the statement  "	for (char c = doc.GetCharAt (offset); !char.IsWhiteSpace (c) && 0 < offset && doc.TextLength > offset; c = doc.GetCharAt (--offset)) " is 132.
Complex Conditional,VimAddin,ViActions,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActions.cs,ParseForQuote,The conditional expression  "text [i] == charToFind && (i < 1 || text [i - 1] != '\\') && (i < 2 || text [i - 2] != '\\')"  is complex.
Complex Conditional,VimAddin,ViActions,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActions.cs,VisualSelectionFromMoveAction,The conditional expression  "oldAnchor < oldLead && newAnchor > newLead && ((newLead.Line == newAnchor.Line && oldLead.Line == oldAnchor.Line + 1) || (newLead.Line == newAnchor.Line - 1 && oldLead.Line == oldAnchor.Line))"  is complex.
Complex Conditional,VimAddin,ViActions,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActions.cs,VisualSelectionFromMoveAction,The conditional expression  "oldAnchor > oldLead && newAnchor < newLead && ((newLead.Line == newAnchor.Line && oldLead.Line == oldAnchor.Line - 1) || (newLead.Line == newAnchor.Line + 1 && oldLead.Line == oldAnchor.Line))"  is complex.
Complex Conditional,VimAddin,ViBuilders,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViBuilders.cs,InsertBuilder,The conditional expression  "(noModifiers && l.Key == Key.Escape) || (l.Char == 'c' && (l.Modifiers & ModifierType.ControlMask) != 0)"  is complex.
Complex Conditional,VimAddin,ViEditor,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViEditor.cs,GetRegisterContents,The conditional expression  "((int)'a' <= regInt && regInt <= (int)'z') || ((int)'A' <= regInt && regInt <= (int)'Z') || ((int)'0' <= regInt && regInt <= (int)'9')"  is complex.
Complex Conditional,VimAddin,ViEditor,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViEditor.cs,SetRegisterContents,The conditional expression  "((int)'a' <= regInt && regInt <= (int)'z') || ((int)'A' <= regInt && regInt <= (int)'Z')"  is complex.
Complex Conditional,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The conditional expression  "((modifier & (Gdk.ModifierType.ShiftMask | Gdk.ModifierType.ControlMask)) == 0 && (unicodeKey == 'd' || unicodeKey == 'j' || unicodeKey == 'k'))"  is complex.
Complex Conditional,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The conditional expression  "((modifier & (Gdk.ModifierType.ShiftMask | Gdk.ModifierType.ControlMask)) == 0 && (unicodeKey == 'y' || unicodeKey == 'j' || unicodeKey == 'k'))"  is complex.
Virtual Method Call from Constructor,VimAddin,VimAddinOptionsPanelWidget,D:\newReposJune17\alextsui05_VimAddin\VimAddin\VimAddinOptionsPanelWidget.cs,VimAddinOptionsPanelWidget,The constructor "VimAddinOptionsPanelWidget" calls a virtual method "Build".
Magic Number,VimAddin,IdeViMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\IdeViMode.cs,RunExCommand,The following statement contains a magic number: if (':' != command [0] || 2 > command.Length)  	return base.RunExCommand (command);  
Magic Number,VimAddin,IdeViMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\IdeViMode.cs,RunExCommand,The following statement contains a magic number: switch (command [1]) {  case 'w':  	if (2 < command.Length) {  		switch (command [2]) {  		case 'q':  			// :wq  			saveableDocument.Save ();  			saveableDocument.Close ();  			return "Saved and closed file.";  		case '!':  			// :w!  			saveableDocument.Save ();  			break;  		default:  			return base.RunExCommand (command);  		}  	} else  		saveableDocument.Save ();  	return "Saved file.";  case 'q':  	bool force = false;  	if (2 < command.Length) {  		switch (command [2]) {  		case '!':  			// :q!  			force = true;  			break;  		default:  			return base.RunExCommand (command);  		}  	}  	saveableDocument.Close ();  	return force ? "Closed file without saving." : "Closed file.";  case 'm':  	if (!Regex.IsMatch (command' "^:mak[e!]"' RegexOptions.Compiled))  		break;  	//MonoDevelop.Projects.Project proj = editor.View.Project;  	MonoDevelop.Projects.Project proj = editor.Project;  	if (proj != null) {  		IdeApp.ProjectOperations.Build (proj);  		return string.Format ("Building project {0}"' proj.Name);  	}  	return "File is not part of a project";  case 'c':  	// Error manipulation  	if (3 == command.Length) {  		switch (command [2]) {  		case 'n':  			// :cn - jump to next error  			IdeApp.CommandService.DispatchCommand (MonoDevelop.Ide.Commands.ViewCommands.ShowNext);  			return string.Empty;  		case 'N':  		case 'p':  			// :c[pN] - jump to previous error  			IdeApp.CommandService.DispatchCommand (MonoDevelop.Ide.Commands.ViewCommands.ShowPrevious);  			return string.Empty;  		}  	}  	break;  }  
Magic Number,VimAddin,IdeViMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\IdeViMode.cs,RunExCommand,The following statement contains a magic number: switch (command [1]) {  case 'w':  	if (2 < command.Length) {  		switch (command [2]) {  		case 'q':  			// :wq  			saveableDocument.Save ();  			saveableDocument.Close ();  			return "Saved and closed file.";  		case '!':  			// :w!  			saveableDocument.Save ();  			break;  		default:  			return base.RunExCommand (command);  		}  	} else  		saveableDocument.Save ();  	return "Saved file.";  case 'q':  	bool force = false;  	if (2 < command.Length) {  		switch (command [2]) {  		case '!':  			// :q!  			force = true;  			break;  		default:  			return base.RunExCommand (command);  		}  	}  	saveableDocument.Close ();  	return force ? "Closed file without saving." : "Closed file.";  case 'm':  	if (!Regex.IsMatch (command' "^:mak[e!]"' RegexOptions.Compiled))  		break;  	//MonoDevelop.Projects.Project proj = editor.View.Project;  	MonoDevelop.Projects.Project proj = editor.Project;  	if (proj != null) {  		IdeApp.ProjectOperations.Build (proj);  		return string.Format ("Building project {0}"' proj.Name);  	}  	return "File is not part of a project";  case 'c':  	// Error manipulation  	if (3 == command.Length) {  		switch (command [2]) {  		case 'n':  			// :cn - jump to next error  			IdeApp.CommandService.DispatchCommand (MonoDevelop.Ide.Commands.ViewCommands.ShowNext);  			return string.Empty;  		case 'N':  		case 'p':  			// :c[pN] - jump to previous error  			IdeApp.CommandService.DispatchCommand (MonoDevelop.Ide.Commands.ViewCommands.ShowPrevious);  			return string.Empty;  		}  	}  	break;  }  
Magic Number,VimAddin,IdeViMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\IdeViMode.cs,RunExCommand,The following statement contains a magic number: switch (command [1]) {  case 'w':  	if (2 < command.Length) {  		switch (command [2]) {  		case 'q':  			// :wq  			saveableDocument.Save ();  			saveableDocument.Close ();  			return "Saved and closed file.";  		case '!':  			// :w!  			saveableDocument.Save ();  			break;  		default:  			return base.RunExCommand (command);  		}  	} else  		saveableDocument.Save ();  	return "Saved file.";  case 'q':  	bool force = false;  	if (2 < command.Length) {  		switch (command [2]) {  		case '!':  			// :q!  			force = true;  			break;  		default:  			return base.RunExCommand (command);  		}  	}  	saveableDocument.Close ();  	return force ? "Closed file without saving." : "Closed file.";  case 'm':  	if (!Regex.IsMatch (command' "^:mak[e!]"' RegexOptions.Compiled))  		break;  	//MonoDevelop.Projects.Project proj = editor.View.Project;  	MonoDevelop.Projects.Project proj = editor.Project;  	if (proj != null) {  		IdeApp.ProjectOperations.Build (proj);  		return string.Format ("Building project {0}"' proj.Name);  	}  	return "File is not part of a project";  case 'c':  	// Error manipulation  	if (3 == command.Length) {  		switch (command [2]) {  		case 'n':  			// :cn - jump to next error  			IdeApp.CommandService.DispatchCommand (MonoDevelop.Ide.Commands.ViewCommands.ShowNext);  			return string.Empty;  		case 'N':  		case 'p':  			// :c[pN] - jump to previous error  			IdeApp.CommandService.DispatchCommand (MonoDevelop.Ide.Commands.ViewCommands.ShowPrevious);  			return string.Empty;  		}  	}  	break;  }  
Magic Number,VimAddin,IdeViMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\IdeViMode.cs,RunExCommand,The following statement contains a magic number: switch (command [1]) {  case 'w':  	if (2 < command.Length) {  		switch (command [2]) {  		case 'q':  			// :wq  			saveableDocument.Save ();  			saveableDocument.Close ();  			return "Saved and closed file.";  		case '!':  			// :w!  			saveableDocument.Save ();  			break;  		default:  			return base.RunExCommand (command);  		}  	} else  		saveableDocument.Save ();  	return "Saved file.";  case 'q':  	bool force = false;  	if (2 < command.Length) {  		switch (command [2]) {  		case '!':  			// :q!  			force = true;  			break;  		default:  			return base.RunExCommand (command);  		}  	}  	saveableDocument.Close ();  	return force ? "Closed file without saving." : "Closed file.";  case 'm':  	if (!Regex.IsMatch (command' "^:mak[e!]"' RegexOptions.Compiled))  		break;  	//MonoDevelop.Projects.Project proj = editor.View.Project;  	MonoDevelop.Projects.Project proj = editor.Project;  	if (proj != null) {  		IdeApp.ProjectOperations.Build (proj);  		return string.Format ("Building project {0}"' proj.Name);  	}  	return "File is not part of a project";  case 'c':  	// Error manipulation  	if (3 == command.Length) {  		switch (command [2]) {  		case 'n':  			// :cn - jump to next error  			IdeApp.CommandService.DispatchCommand (MonoDevelop.Ide.Commands.ViewCommands.ShowNext);  			return string.Empty;  		case 'N':  		case 'p':  			// :c[pN] - jump to previous error  			IdeApp.CommandService.DispatchCommand (MonoDevelop.Ide.Commands.ViewCommands.ShowPrevious);  			return string.Empty;  		}  	}  	break;  }  
Magic Number,VimAddin,IdeViMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\IdeViMode.cs,RunExCommand,The following statement contains a magic number: switch (command [1]) {  case 'w':  	if (2 < command.Length) {  		switch (command [2]) {  		case 'q':  			// :wq  			saveableDocument.Save ();  			saveableDocument.Close ();  			return "Saved and closed file.";  		case '!':  			// :w!  			saveableDocument.Save ();  			break;  		default:  			return base.RunExCommand (command);  		}  	} else  		saveableDocument.Save ();  	return "Saved file.";  case 'q':  	bool force = false;  	if (2 < command.Length) {  		switch (command [2]) {  		case '!':  			// :q!  			force = true;  			break;  		default:  			return base.RunExCommand (command);  		}  	}  	saveableDocument.Close ();  	return force ? "Closed file without saving." : "Closed file.";  case 'm':  	if (!Regex.IsMatch (command' "^:mak[e!]"' RegexOptions.Compiled))  		break;  	//MonoDevelop.Projects.Project proj = editor.View.Project;  	MonoDevelop.Projects.Project proj = editor.Project;  	if (proj != null) {  		IdeApp.ProjectOperations.Build (proj);  		return string.Format ("Building project {0}"' proj.Name);  	}  	return "File is not part of a project";  case 'c':  	// Error manipulation  	if (3 == command.Length) {  		switch (command [2]) {  		case 'n':  			// :cn - jump to next error  			IdeApp.CommandService.DispatchCommand (MonoDevelop.Ide.Commands.ViewCommands.ShowNext);  			return string.Empty;  		case 'N':  		case 'p':  			// :c[pN] - jump to previous error  			IdeApp.CommandService.DispatchCommand (MonoDevelop.Ide.Commands.ViewCommands.ShowPrevious);  			return string.Empty;  		}  	}  	break;  }  
Magic Number,VimAddin,IdeViMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\IdeViMode.cs,RunExCommand,The following statement contains a magic number: switch (command [1]) {  case 'w':  	if (2 < command.Length) {  		switch (command [2]) {  		case 'q':  			// :wq  			saveableDocument.Save ();  			saveableDocument.Close ();  			return "Saved and closed file.";  		case '!':  			// :w!  			saveableDocument.Save ();  			break;  		default:  			return base.RunExCommand (command);  		}  	} else  		saveableDocument.Save ();  	return "Saved file.";  case 'q':  	bool force = false;  	if (2 < command.Length) {  		switch (command [2]) {  		case '!':  			// :q!  			force = true;  			break;  		default:  			return base.RunExCommand (command);  		}  	}  	saveableDocument.Close ();  	return force ? "Closed file without saving." : "Closed file.";  case 'm':  	if (!Regex.IsMatch (command' "^:mak[e!]"' RegexOptions.Compiled))  		break;  	//MonoDevelop.Projects.Project proj = editor.View.Project;  	MonoDevelop.Projects.Project proj = editor.Project;  	if (proj != null) {  		IdeApp.ProjectOperations.Build (proj);  		return string.Format ("Building project {0}"' proj.Name);  	}  	return "File is not part of a project";  case 'c':  	// Error manipulation  	if (3 == command.Length) {  		switch (command [2]) {  		case 'n':  			// :cn - jump to next error  			IdeApp.CommandService.DispatchCommand (MonoDevelop.Ide.Commands.ViewCommands.ShowNext);  			return string.Empty;  		case 'N':  		case 'p':  			// :c[pN] - jump to previous error  			IdeApp.CommandService.DispatchCommand (MonoDevelop.Ide.Commands.ViewCommands.ShowPrevious);  			return string.Empty;  		}  	}  	break;  }  
Magic Number,VimAddin,IdeViMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\IdeViMode.cs,RunExCommand,The following statement contains a magic number: if (2 < command.Length) {  	switch (command [2]) {  	case 'q':  		// :wq  		saveableDocument.Save ();  		saveableDocument.Close ();  		return "Saved and closed file.";  	case '!':  		// :w!  		saveableDocument.Save ();  		break;  	default:  		return base.RunExCommand (command);  	}  } else  	saveableDocument.Save ();  
Magic Number,VimAddin,IdeViMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\IdeViMode.cs,RunExCommand,The following statement contains a magic number: if (2 < command.Length) {  	switch (command [2]) {  	case 'q':  		// :wq  		saveableDocument.Save ();  		saveableDocument.Close ();  		return "Saved and closed file.";  	case '!':  		// :w!  		saveableDocument.Save ();  		break;  	default:  		return base.RunExCommand (command);  	}  } else  	saveableDocument.Save ();  
Magic Number,VimAddin,IdeViMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\IdeViMode.cs,RunExCommand,The following statement contains a magic number: switch (command [2]) {  case 'q':  	// :wq  	saveableDocument.Save ();  	saveableDocument.Close ();  	return "Saved and closed file.";  case '!':  	// :w!  	saveableDocument.Save ();  	break;  default:  	return base.RunExCommand (command);  }  
Magic Number,VimAddin,IdeViMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\IdeViMode.cs,RunExCommand,The following statement contains a magic number: if (2 < command.Length) {  	switch (command [2]) {  	case '!':  		// :q!  		force = true;  		break;  	default:  		return base.RunExCommand (command);  	}  }  
Magic Number,VimAddin,IdeViMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\IdeViMode.cs,RunExCommand,The following statement contains a magic number: if (2 < command.Length) {  	switch (command [2]) {  	case '!':  		// :q!  		force = true;  		break;  	default:  		return base.RunExCommand (command);  	}  }  
Magic Number,VimAddin,IdeViMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\IdeViMode.cs,RunExCommand,The following statement contains a magic number: switch (command [2]) {  case '!':  	// :q!  	force = true;  	break;  default:  	return base.RunExCommand (command);  }  
Magic Number,VimAddin,IdeViMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\IdeViMode.cs,RunExCommand,The following statement contains a magic number: if (3 == command.Length) {  	switch (command [2]) {  	case 'n':  		// :cn - jump to next error  		IdeApp.CommandService.DispatchCommand (MonoDevelop.Ide.Commands.ViewCommands.ShowNext);  		return string.Empty;  	case 'N':  	case 'p':  		// :c[pN] - jump to previous error  		IdeApp.CommandService.DispatchCommand (MonoDevelop.Ide.Commands.ViewCommands.ShowPrevious);  		return string.Empty;  	}  }  
Magic Number,VimAddin,IdeViMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\IdeViMode.cs,RunExCommand,The following statement contains a magic number: if (3 == command.Length) {  	switch (command [2]) {  	case 'n':  		// :cn - jump to next error  		IdeApp.CommandService.DispatchCommand (MonoDevelop.Ide.Commands.ViewCommands.ShowNext);  		return string.Empty;  	case 'N':  	case 'p':  		// :c[pN] - jump to previous error  		IdeApp.CommandService.DispatchCommand (MonoDevelop.Ide.Commands.ViewCommands.ShowPrevious);  		return string.Empty;  	}  }  
Magic Number,VimAddin,IdeViMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\IdeViMode.cs,RunExCommand,The following statement contains a magic number: switch (command [2]) {  case 'n':  	// :cn - jump to next error  	IdeApp.CommandService.DispatchCommand (MonoDevelop.Ide.Commands.ViewCommands.ShowNext);  	return string.Empty;  case 'N':  case 'p':  	// :c[pN] - jump to previous error  	IdeApp.CommandService.DispatchCommand (MonoDevelop.Ide.Commands.ViewCommands.ShowPrevious);  	return string.Empty;  }  
Magic Number,VimAddin,ViActions,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActions.cs,OuterQuote,The following statement contains a magic number: return data => {  	int beginOffset' length;  	if (TryFindInnerQuote (data' c' out beginOffset' out length)) {  		beginOffset--;  		length += 2;  		data.SelectionRange = new TextSegment (beginOffset' length);  	}  };  
Magic Number,VimAddin,ViActions,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActions.cs,OuterQuote,The following statement contains a magic number: if (TryFindInnerQuote (data' c' out beginOffset' out length)) {  	beginOffset--;  	length += 2;  	data.SelectionRange = new TextSegment (beginOffset' length);  }  
Magic Number,VimAddin,ViActions,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActions.cs,OuterQuote,The following statement contains a magic number: length += 2;  
Magic Number,VimAddin,ViActions,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActions.cs,ParseForQuote,The following statement contains a magic number: for (int i = start; forward && i < text.Length || !forward && i >= 0; i += increment) {  	if (text [i] == charToFind && (i < 1 || text [i - 1] != '\\') && (i < 2 || text [i - 2] != '\\'))  		return i;  }  
Magic Number,VimAddin,ViActions,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActions.cs,ParseForQuote,The following statement contains a magic number: for (int i = start; forward && i < text.Length || !forward && i >= 0; i += increment) {  	if (text [i] == charToFind && (i < 1 || text [i - 1] != '\\') && (i < 2 || text [i - 2] != '\\'))  		return i;  }  
Magic Number,VimAddin,ViActions,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActions.cs,ParseForQuote,The following statement contains a magic number: if (text [i] == charToFind && (i < 1 || text [i - 1] != '\\') && (i < 2 || text [i - 2] != '\\'))  	return i;  
Magic Number,VimAddin,ViActions,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActions.cs,ParseForQuote,The following statement contains a magic number: if (text [i] == charToFind && (i < 1 || text [i - 1] != '\\') && (i < 2 || text [i - 2] != '\\'))  	return i;  
Magic Number,VimAddin,ViBuilderContext,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViBuilderContext.cs,RunAction,The following statement contains a magic number: if (Multiplier > 1) {  	for (int i = 0; i < System.Math.Min (100' Multiplier); i++)  		action (editor);  } else {  	action (editor);  }  
Magic Number,VimAddin,ViBuilderContext,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViBuilderContext.cs,RunAction,The following statement contains a magic number: for (int i = 0; i < System.Math.Min (100' Multiplier); i++)  	action (editor);  
Magic Number,VimAddin,ViBuilders,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViBuilders.cs,StartMultiplierBuilder,The following statement contains a magic number: ctx.Builder = (ViBuilderContext x) => {  	int c = (int)x.LastKey.Char;  	if (c >= (int)'0' && c <= (int)'9') {  		//don't eat '0' if not preceded by non-zero digit  		//pass on to interpret as goto line start  		if (c == (int)'0' && factor == 1) {  			ctx.Multiplier *= multiplier;  			ctx.Builder = nextBuilder;  			return ctx.Builder (ctx);  		}  		int d = c - (int)'0';  		multiplier = multiplier * factor + d;  		factor *= 10;  		return true;  	} else {  		ctx.Multiplier *= multiplier;  		ctx.Builder = nextBuilder;  		return ctx.Builder (ctx);  	}  };  
Magic Number,VimAddin,ViBuilders,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViBuilders.cs,StartMultiplierBuilder,The following statement contains a magic number: if (c >= (int)'0' && c <= (int)'9') {  	//don't eat '0' if not preceded by non-zero digit  	//pass on to interpret as goto line start  	if (c == (int)'0' && factor == 1) {  		ctx.Multiplier *= multiplier;  		ctx.Builder = nextBuilder;  		return ctx.Builder (ctx);  	}  	int d = c - (int)'0';  	multiplier = multiplier * factor + d;  	factor *= 10;  	return true;  } else {  	ctx.Multiplier *= multiplier;  	ctx.Builder = nextBuilder;  	return ctx.Builder (ctx);  }  
Magic Number,VimAddin,ViBuilders,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViBuilders.cs,StartMultiplierBuilder,The following statement contains a magic number: factor *= 10;  
Magic Number,VimAddin,ViKeyNotation,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViKeyNotation.cs,Parse,The following statement contains a magic number: for (int i = 0; i < command.Length; i++) {  	if (command [i] == '<') {  		int j = command.IndexOf ('>'' i);  		if (j < i + 2)  			throw new FormatException ("Could not find matching > at index " + i.ToString ());  		string seq = command.Substring (i + 1' j - i - 1);  		list.Add (ParseKeySequence (seq));  		i = j;  	} else {  		list.Add (command [i]);  	}  }  
Magic Number,VimAddin,ViKeyNotation,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViKeyNotation.cs,Parse,The following statement contains a magic number: if (command [i] == '<') {  	int j = command.IndexOf ('>'' i);  	if (j < i + 2)  		throw new FormatException ("Could not find matching > at index " + i.ToString ());  	string seq = command.Substring (i + 1' j - i - 1);  	list.Add (ParseKeySequence (seq));  	i = j;  } else {  	list.Add (command [i]);  }  
Magic Number,VimAddin,ViKeyNotation,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViKeyNotation.cs,Parse,The following statement contains a magic number: if (j < i + 2)  	throw new FormatException ("Could not find matching > at index " + i.ToString ());  
Magic Number,VimAddin,ViKeyNotation,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViKeyNotation.cs,ParseKeySequence,The following statement contains a magic number: while (seq.Length > 2 && seq [1] == '-') {  	switch (seq [0]) {  	case 'S':  		modifiers |= ModifierType.ShiftMask;  		break;  	case 'C':  		modifiers |= ModifierType.ControlMask;  		break;  	case 'M':  	case 'A':  		modifiers |= ModifierType.Mod1Mask;  		break;  	case 'D':  		modifiers |= ModifierType.MetaMask;  		//HACK: Mac command key  		break;  	default:  		throw new FormatException ("Unknown modifier " + seq [0].ToString ());  	}  	seq = seq.Substring (2);  }  
Magic Number,VimAddin,ViKeyNotation,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViKeyNotation.cs,ParseKeySequence,The following statement contains a magic number: while (seq.Length > 2 && seq [1] == '-') {  	switch (seq [0]) {  	case 'S':  		modifiers |= ModifierType.ShiftMask;  		break;  	case 'C':  		modifiers |= ModifierType.ControlMask;  		break;  	case 'M':  	case 'A':  		modifiers |= ModifierType.Mod1Mask;  		break;  	case 'D':  		modifiers |= ModifierType.MetaMask;  		//HACK: Mac command key  		break;  	default:  		throw new FormatException ("Unknown modifier " + seq [0].ToString ());  	}  	seq = seq.Substring (2);  }  
Magic Number,VimAddin,ViKeyNotation,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViKeyNotation.cs,ParseKeySequence,The following statement contains a magic number: seq = seq.Substring (2);  
Magic Number,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,RunExCommand,The following statement contains a magic number: switch (command [0]) {  case ':':  	if (2 > command.Length)  		break;  	int line;  	if (int.TryParse (command.Substring (1)' out line)) {  		if (line < DocumentLocation.MinLine || line > Data.Document.LineCount) {  			return "Invalid line number.";  		} else if (line == 0) {  			RunAction (CaretMoveActions.ToDocumentStart);  			return "Jumped to beginning of document.";  		}  		Data.Caret.Line = line;  		Editor.ScrollToCaret ();  		return string.Format ("Jumped to line {0}."' line);  	}  	switch (command [1]) {  	case 's':  		if (2 == command.Length) {  			if (null == lastPattern || null == lastReplacement)  				return "No stored pattern.";  			// Perform replacement with stored stuff  			command = string.Format (":s/{0}/{1}/"' lastPattern' lastReplacement);  		}  		var match = Regex.Match (command' substMatch' RegexOptions.Compiled);  		if (!(match.Success && match.Groups ["pattern"].Success && match.Groups ["replacement"].Success))  			break;  		return RegexReplace (match);  	case '$':  		if (command.Length == 2) {  			//RunAction (CaretMoveActions.ToDocumentEnd);  			RunAction (ToDocumentEnd);  			return "Jumped to end of document.";  		}  		break;  	}  	if (command.Substring (1) == "test") {  		CurState = State.Confirm;  		var selection = Data.SelectionRange;  		int lineStart' lineEnd;  		int lookaheadOffset = Math.Min (Caret.Offset + 1000' Data.Document.TextLength);  		MiscActions.GetSelectedLines (Data' out lineStart' out lineEnd);  		int roffset = Data.SelectionRange.Offset;  		int linesAhead = Math.Min (LastSelectionRange.Item1' Document.LineCount - Caret.Line);  		//					CaretMoveActions.LineStart(Data);  		SelectionActions.StartSelection (Data);  		if (linesAhead > 1) {  			for (int i = 0; i < linesAhead; ++i) {  				ViActions.Down (Data);  			}  			CaretMoveActions.LineStart (Data);  		}  		DocumentLine lastLine = Document.GetLineByOffset (Caret.Offset);  		int lastLineOffset = Math.Min (LastSelectionRange.Item2' lastLine.EndOffset);  		for (int i = 0; i < lastLineOffset; ++i) {  			ViActions.Right (Data);  		}  		SelectionActions.EndSelection (Data);  		//					SelectionActions.StartSelection (Data);  		//					CaretMoveActions.LineFirstNonWhitespace (Data);  		//					ViActions.Down (Data);  		//					ViActions.Right (Data);  		//					ViActions.Right (Data);  		//					ViActions.Right (Data);  		//					ViActions.Right (Data);  		//					ViActions.Right (Data);  		//					SelectionActions.EndSelection (Data);  		//return string.Format("line range: {0} {1}"' lineStart' lineEnd);  		return string.Format ("s:{0} {1}; ({2}'{3}) ({4}) ({5})"' selection.Offset' selection.Length' LastSelectionRange.Item1' LastSelectionRange.Item2' linesAhead' Data.Document.TextLength);  	}  	break;  // case ':'  case '?':  case '/':  	searchBackward = ('?' == command [0]);  	if (1 < command.Length) {  		Editor.HighlightSearchPattern = true;  		Editor.SearchEngine = new RegexSearchEngine ();  		var pattern = command.Substring (1);  		Editor.SearchPattern = pattern;  		var caseSensitive = pattern.ToCharArray ().Any (c => char.IsUpper (c));  		Editor.SearchEngine.SearchRequest.CaseSensitive = caseSensitive;  	}  	return Search ();  }  
Magic Number,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,RunExCommand,The following statement contains a magic number: switch (command [0]) {  case ':':  	if (2 > command.Length)  		break;  	int line;  	if (int.TryParse (command.Substring (1)' out line)) {  		if (line < DocumentLocation.MinLine || line > Data.Document.LineCount) {  			return "Invalid line number.";  		} else if (line == 0) {  			RunAction (CaretMoveActions.ToDocumentStart);  			return "Jumped to beginning of document.";  		}  		Data.Caret.Line = line;  		Editor.ScrollToCaret ();  		return string.Format ("Jumped to line {0}."' line);  	}  	switch (command [1]) {  	case 's':  		if (2 == command.Length) {  			if (null == lastPattern || null == lastReplacement)  				return "No stored pattern.";  			// Perform replacement with stored stuff  			command = string.Format (":s/{0}/{1}/"' lastPattern' lastReplacement);  		}  		var match = Regex.Match (command' substMatch' RegexOptions.Compiled);  		if (!(match.Success && match.Groups ["pattern"].Success && match.Groups ["replacement"].Success))  			break;  		return RegexReplace (match);  	case '$':  		if (command.Length == 2) {  			//RunAction (CaretMoveActions.ToDocumentEnd);  			RunAction (ToDocumentEnd);  			return "Jumped to end of document.";  		}  		break;  	}  	if (command.Substring (1) == "test") {  		CurState = State.Confirm;  		var selection = Data.SelectionRange;  		int lineStart' lineEnd;  		int lookaheadOffset = Math.Min (Caret.Offset + 1000' Data.Document.TextLength);  		MiscActions.GetSelectedLines (Data' out lineStart' out lineEnd);  		int roffset = Data.SelectionRange.Offset;  		int linesAhead = Math.Min (LastSelectionRange.Item1' Document.LineCount - Caret.Line);  		//					CaretMoveActions.LineStart(Data);  		SelectionActions.StartSelection (Data);  		if (linesAhead > 1) {  			for (int i = 0; i < linesAhead; ++i) {  				ViActions.Down (Data);  			}  			CaretMoveActions.LineStart (Data);  		}  		DocumentLine lastLine = Document.GetLineByOffset (Caret.Offset);  		int lastLineOffset = Math.Min (LastSelectionRange.Item2' lastLine.EndOffset);  		for (int i = 0; i < lastLineOffset; ++i) {  			ViActions.Right (Data);  		}  		SelectionActions.EndSelection (Data);  		//					SelectionActions.StartSelection (Data);  		//					CaretMoveActions.LineFirstNonWhitespace (Data);  		//					ViActions.Down (Data);  		//					ViActions.Right (Data);  		//					ViActions.Right (Data);  		//					ViActions.Right (Data);  		//					ViActions.Right (Data);  		//					ViActions.Right (Data);  		//					SelectionActions.EndSelection (Data);  		//return string.Format("line range: {0} {1}"' lineStart' lineEnd);  		return string.Format ("s:{0} {1}; ({2}'{3}) ({4}) ({5})"' selection.Offset' selection.Length' LastSelectionRange.Item1' LastSelectionRange.Item2' linesAhead' Data.Document.TextLength);  	}  	break;  // case ':'  case '?':  case '/':  	searchBackward = ('?' == command [0]);  	if (1 < command.Length) {  		Editor.HighlightSearchPattern = true;  		Editor.SearchEngine = new RegexSearchEngine ();  		var pattern = command.Substring (1);  		Editor.SearchPattern = pattern;  		var caseSensitive = pattern.ToCharArray ().Any (c => char.IsUpper (c));  		Editor.SearchEngine.SearchRequest.CaseSensitive = caseSensitive;  	}  	return Search ();  }  
Magic Number,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,RunExCommand,The following statement contains a magic number: switch (command [0]) {  case ':':  	if (2 > command.Length)  		break;  	int line;  	if (int.TryParse (command.Substring (1)' out line)) {  		if (line < DocumentLocation.MinLine || line > Data.Document.LineCount) {  			return "Invalid line number.";  		} else if (line == 0) {  			RunAction (CaretMoveActions.ToDocumentStart);  			return "Jumped to beginning of document.";  		}  		Data.Caret.Line = line;  		Editor.ScrollToCaret ();  		return string.Format ("Jumped to line {0}."' line);  	}  	switch (command [1]) {  	case 's':  		if (2 == command.Length) {  			if (null == lastPattern || null == lastReplacement)  				return "No stored pattern.";  			// Perform replacement with stored stuff  			command = string.Format (":s/{0}/{1}/"' lastPattern' lastReplacement);  		}  		var match = Regex.Match (command' substMatch' RegexOptions.Compiled);  		if (!(match.Success && match.Groups ["pattern"].Success && match.Groups ["replacement"].Success))  			break;  		return RegexReplace (match);  	case '$':  		if (command.Length == 2) {  			//RunAction (CaretMoveActions.ToDocumentEnd);  			RunAction (ToDocumentEnd);  			return "Jumped to end of document.";  		}  		break;  	}  	if (command.Substring (1) == "test") {  		CurState = State.Confirm;  		var selection = Data.SelectionRange;  		int lineStart' lineEnd;  		int lookaheadOffset = Math.Min (Caret.Offset + 1000' Data.Document.TextLength);  		MiscActions.GetSelectedLines (Data' out lineStart' out lineEnd);  		int roffset = Data.SelectionRange.Offset;  		int linesAhead = Math.Min (LastSelectionRange.Item1' Document.LineCount - Caret.Line);  		//					CaretMoveActions.LineStart(Data);  		SelectionActions.StartSelection (Data);  		if (linesAhead > 1) {  			for (int i = 0; i < linesAhead; ++i) {  				ViActions.Down (Data);  			}  			CaretMoveActions.LineStart (Data);  		}  		DocumentLine lastLine = Document.GetLineByOffset (Caret.Offset);  		int lastLineOffset = Math.Min (LastSelectionRange.Item2' lastLine.EndOffset);  		for (int i = 0; i < lastLineOffset; ++i) {  			ViActions.Right (Data);  		}  		SelectionActions.EndSelection (Data);  		//					SelectionActions.StartSelection (Data);  		//					CaretMoveActions.LineFirstNonWhitespace (Data);  		//					ViActions.Down (Data);  		//					ViActions.Right (Data);  		//					ViActions.Right (Data);  		//					ViActions.Right (Data);  		//					ViActions.Right (Data);  		//					ViActions.Right (Data);  		//					SelectionActions.EndSelection (Data);  		//return string.Format("line range: {0} {1}"' lineStart' lineEnd);  		return string.Format ("s:{0} {1}; ({2}'{3}) ({4}) ({5})"' selection.Offset' selection.Length' LastSelectionRange.Item1' LastSelectionRange.Item2' linesAhead' Data.Document.TextLength);  	}  	break;  // case ':'  case '?':  case '/':  	searchBackward = ('?' == command [0]);  	if (1 < command.Length) {  		Editor.HighlightSearchPattern = true;  		Editor.SearchEngine = new RegexSearchEngine ();  		var pattern = command.Substring (1);  		Editor.SearchPattern = pattern;  		var caseSensitive = pattern.ToCharArray ().Any (c => char.IsUpper (c));  		Editor.SearchEngine.SearchRequest.CaseSensitive = caseSensitive;  	}  	return Search ();  }  
Magic Number,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,RunExCommand,The following statement contains a magic number: switch (command [0]) {  case ':':  	if (2 > command.Length)  		break;  	int line;  	if (int.TryParse (command.Substring (1)' out line)) {  		if (line < DocumentLocation.MinLine || line > Data.Document.LineCount) {  			return "Invalid line number.";  		} else if (line == 0) {  			RunAction (CaretMoveActions.ToDocumentStart);  			return "Jumped to beginning of document.";  		}  		Data.Caret.Line = line;  		Editor.ScrollToCaret ();  		return string.Format ("Jumped to line {0}."' line);  	}  	switch (command [1]) {  	case 's':  		if (2 == command.Length) {  			if (null == lastPattern || null == lastReplacement)  				return "No stored pattern.";  			// Perform replacement with stored stuff  			command = string.Format (":s/{0}/{1}/"' lastPattern' lastReplacement);  		}  		var match = Regex.Match (command' substMatch' RegexOptions.Compiled);  		if (!(match.Success && match.Groups ["pattern"].Success && match.Groups ["replacement"].Success))  			break;  		return RegexReplace (match);  	case '$':  		if (command.Length == 2) {  			//RunAction (CaretMoveActions.ToDocumentEnd);  			RunAction (ToDocumentEnd);  			return "Jumped to end of document.";  		}  		break;  	}  	if (command.Substring (1) == "test") {  		CurState = State.Confirm;  		var selection = Data.SelectionRange;  		int lineStart' lineEnd;  		int lookaheadOffset = Math.Min (Caret.Offset + 1000' Data.Document.TextLength);  		MiscActions.GetSelectedLines (Data' out lineStart' out lineEnd);  		int roffset = Data.SelectionRange.Offset;  		int linesAhead = Math.Min (LastSelectionRange.Item1' Document.LineCount - Caret.Line);  		//					CaretMoveActions.LineStart(Data);  		SelectionActions.StartSelection (Data);  		if (linesAhead > 1) {  			for (int i = 0; i < linesAhead; ++i) {  				ViActions.Down (Data);  			}  			CaretMoveActions.LineStart (Data);  		}  		DocumentLine lastLine = Document.GetLineByOffset (Caret.Offset);  		int lastLineOffset = Math.Min (LastSelectionRange.Item2' lastLine.EndOffset);  		for (int i = 0; i < lastLineOffset; ++i) {  			ViActions.Right (Data);  		}  		SelectionActions.EndSelection (Data);  		//					SelectionActions.StartSelection (Data);  		//					CaretMoveActions.LineFirstNonWhitespace (Data);  		//					ViActions.Down (Data);  		//					ViActions.Right (Data);  		//					ViActions.Right (Data);  		//					ViActions.Right (Data);  		//					ViActions.Right (Data);  		//					ViActions.Right (Data);  		//					SelectionActions.EndSelection (Data);  		//return string.Format("line range: {0} {1}"' lineStart' lineEnd);  		return string.Format ("s:{0} {1}; ({2}'{3}) ({4}) ({5})"' selection.Offset' selection.Length' LastSelectionRange.Item1' LastSelectionRange.Item2' linesAhead' Data.Document.TextLength);  	}  	break;  // case ':'  case '?':  case '/':  	searchBackward = ('?' == command [0]);  	if (1 < command.Length) {  		Editor.HighlightSearchPattern = true;  		Editor.SearchEngine = new RegexSearchEngine ();  		var pattern = command.Substring (1);  		Editor.SearchPattern = pattern;  		var caseSensitive = pattern.ToCharArray ().Any (c => char.IsUpper (c));  		Editor.SearchEngine.SearchRequest.CaseSensitive = caseSensitive;  	}  	return Search ();  }  
Magic Number,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,RunExCommand,The following statement contains a magic number: if (2 > command.Length)  	break;  
Magic Number,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,RunExCommand,The following statement contains a magic number: switch (command [1]) {  case 's':  	if (2 == command.Length) {  		if (null == lastPattern || null == lastReplacement)  			return "No stored pattern.";  		// Perform replacement with stored stuff  		command = string.Format (":s/{0}/{1}/"' lastPattern' lastReplacement);  	}  	var match = Regex.Match (command' substMatch' RegexOptions.Compiled);  	if (!(match.Success && match.Groups ["pattern"].Success && match.Groups ["replacement"].Success))  		break;  	return RegexReplace (match);  case '$':  	if (command.Length == 2) {  		//RunAction (CaretMoveActions.ToDocumentEnd);  		RunAction (ToDocumentEnd);  		return "Jumped to end of document.";  	}  	break;  }  
Magic Number,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,RunExCommand,The following statement contains a magic number: switch (command [1]) {  case 's':  	if (2 == command.Length) {  		if (null == lastPattern || null == lastReplacement)  			return "No stored pattern.";  		// Perform replacement with stored stuff  		command = string.Format (":s/{0}/{1}/"' lastPattern' lastReplacement);  	}  	var match = Regex.Match (command' substMatch' RegexOptions.Compiled);  	if (!(match.Success && match.Groups ["pattern"].Success && match.Groups ["replacement"].Success))  		break;  	return RegexReplace (match);  case '$':  	if (command.Length == 2) {  		//RunAction (CaretMoveActions.ToDocumentEnd);  		RunAction (ToDocumentEnd);  		return "Jumped to end of document.";  	}  	break;  }  
Magic Number,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,RunExCommand,The following statement contains a magic number: if (2 == command.Length) {  	if (null == lastPattern || null == lastReplacement)  		return "No stored pattern.";  	// Perform replacement with stored stuff  	command = string.Format (":s/{0}/{1}/"' lastPattern' lastReplacement);  }  
Magic Number,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,RunExCommand,The following statement contains a magic number: if (command.Length == 2) {  	//RunAction (CaretMoveActions.ToDocumentEnd);  	RunAction (ToDocumentEnd);  	return "Jumped to end of document.";  }  
Magic Number,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,RunExCommand,The following statement contains a magic number: if (command.Substring (1) == "test") {  	CurState = State.Confirm;  	var selection = Data.SelectionRange;  	int lineStart' lineEnd;  	int lookaheadOffset = Math.Min (Caret.Offset + 1000' Data.Document.TextLength);  	MiscActions.GetSelectedLines (Data' out lineStart' out lineEnd);  	int roffset = Data.SelectionRange.Offset;  	int linesAhead = Math.Min (LastSelectionRange.Item1' Document.LineCount - Caret.Line);  	//					CaretMoveActions.LineStart(Data);  	SelectionActions.StartSelection (Data);  	if (linesAhead > 1) {  		for (int i = 0; i < linesAhead; ++i) {  			ViActions.Down (Data);  		}  		CaretMoveActions.LineStart (Data);  	}  	DocumentLine lastLine = Document.GetLineByOffset (Caret.Offset);  	int lastLineOffset = Math.Min (LastSelectionRange.Item2' lastLine.EndOffset);  	for (int i = 0; i < lastLineOffset; ++i) {  		ViActions.Right (Data);  	}  	SelectionActions.EndSelection (Data);  	//					SelectionActions.StartSelection (Data);  	//					CaretMoveActions.LineFirstNonWhitespace (Data);  	//					ViActions.Down (Data);  	//					ViActions.Right (Data);  	//					ViActions.Right (Data);  	//					ViActions.Right (Data);  	//					ViActions.Right (Data);  	//					ViActions.Right (Data);  	//					SelectionActions.EndSelection (Data);  	//return string.Format("line range: {0} {1}"' lineStart' lineEnd);  	return string.Format ("s:{0} {1}; ({2}'{3}) ({4}) ({5})"' selection.Offset' selection.Length' LastSelectionRange.Item1' LastSelectionRange.Item2' linesAhead' Data.Document.TextLength);  }  
Magic Number,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The following statement contains a magic number: switch (CurState) {  case State.Unknown:  	Reset (string.Empty);  	goto case State.Normal;  case State.Normal:  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0)) {  		if (key == Gdk.Key.Delete)  			unicodeKey = 'x';  		switch ((char)unicodeKey) {  		case '?':  		case '/':  		case ':':  			CurState = State.Command;  			commandBuffer.Append ((char)unicodeKey);  			Status = commandBuffer.ToString ();  			return;  		case 'A':  			StartNewLastAction (CaretMoveActions.LineEnd);  			RunAction (CaretMoveActions.LineEnd);  			goto case 'i';  		case 'I':  			StartNewLastAction (CaretMoveActions.LineFirstNonWhitespace);  			RunAction (CaretMoveActions.LineFirstNonWhitespace);  			goto case 'i';  		case 'a':  			StartNewLastAction (CaretMoveActions.Right);  			//use CaretMoveActions so that we can move past last character on line end  			RunAction (CaretMoveActions.Right);  			goto case 'i';  		case 'i':  			Caret.Mode = CaretMode.Insert;  			Status = "-- INSERT --";  			CurState = State.Insert;  			return;  		case 'R':  			Caret.Mode = CaretMode.Underscore;  			Status = "-- REPLACE --";  			CurState = State.Replace;  			return;  		case 'V':  			Status = "-- VISUAL LINE --";  			Data.SetSelectLines (Caret.Line' Caret.Line);  			CurState = State.VisualLine;  			return;  		case 'v':  			Status = "-- VISUAL --";  			CurState = State.Visual;  			RunAction (ViActions.VisualSelectionFromMoveAction (ViActions.Right));  			return;  		case 'd':  			Status = "d";  			CurState = State.Delete;  			return;  		case 'y':  			Status = "y";  			CurState = State.Yank;  			return;  		case 'Y':  			CurState = State.Yank;  			HandleKeypress (Gdk.Key.y' (int)'y'' Gdk.ModifierType.None);  			return;  		case 'O':  			StartNewLastAction (ViActions.NewLineAbove);  			RunAction (ViActions.NewLineAbove);  			goto case 'i';  		case 'o':  			StartNewLastAction (ViActions.NewLineBelow);  			RunAction (ViActions.NewLineBelow);  			goto case 'i';  		case 'r':  			Caret.Mode = CaretMode.Underscore;  			Status = "-- REPLACE --";  			CurState = State.WriteChar;  			return;  		case 'c':  			Caret.Mode = CaretMode.Insert;  			Status = "c";  			CurState = State.Change;  			return;  		case 'x':  			if (Data.Caret.Column == Data.Document.GetLine (Data.Caret.Line).Length + 1)  				return;  			Status = string.Empty;  			if (!Data.IsSomethingSelected)  				RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Right)' ClipboardActions.Cut);  			else  				RunAction (ClipboardActions.Cut);  			ViActions.RetreatFromLineEnd (Data);  			return;  		case 'X':  			if (Data.Caret.Column == DocumentLocation.MinColumn)  				return;  			Status = string.Empty;  			if (!Data.IsSomethingSelected && 0 < Caret.Offset)  				RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Left)' ClipboardActions.Cut);  			else  				RunAction (ClipboardActions.Cut);  			return;  		case 'D':  			RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  			return;  		case 'C':  			RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  			goto case 'i';  		case '>':  			Status = ">";  			CurState = State.Indent;  			return;  		case '<':  			Status = "<";  			CurState = State.Unindent;  			return;  		case 'n':  			Search ();  			return;  		case 'N':  			searchBackward = !searchBackward;  			Search ();  			searchBackward = !searchBackward;  			return;  		case 'p':  			PasteAfter (false);  			return;  		case 'P':  			PasteBefore (false);  			return;  		case 's':  			if (!Data.IsSomethingSelected)  				RunAction (SelectionActions.FromMoveAction (CaretMoveActions.Right));  			RunAction (ClipboardActions.Cut);  			goto case 'i';  		case 'S':  			if (!Data.IsSomethingSelected)  				RunAction (SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd));  			else  				Data.SetSelectLines (Data.MainSelection.Anchor.Line' Data.Caret.Line);  			RunAction (ClipboardActions.Cut);  			goto case 'i';  		case 'g':  			Status = "g";  			CurState = State.G;  			return;  		case 'G':  			RunAction (marks ['`'].SaveMark);  			if (repeatCount > 1) {  				Caret.Line = repeatCount;  			} else {  				//RunAction (CaretMoveActions.ToDocumentEnd);  				RunAction (ToDocumentEnd);  			}  			Reset (string.Empty);  			return;  		case 'H':  			Caret.Line = System.Math.Max (DocumentLocation.MinLine' Editor.PointToLocation (0' Editor.LineHeight - 1).Line);  			return;  		case 'J':  			RunAction (ViActions.Join);  			return;  		case 'L':  			int line = Editor.PointToLocation (0' Editor.Allocation.Height - Editor.LineHeight * 2 - 2).Line;  			if (line < DocumentLocation.MinLine)  				line = Document.LineCount;  			Caret.Line = line;  			return;  		case 'M':  			line = Editor.PointToLocation (0' Editor.Allocation.Height / 2).Line;  			if (line < DocumentLocation.MinLine)  				line = Document.LineCount;  			Caret.Line = line;  			return;  		case '~':  			RunAction (ViActions.ToggleCase);  			return;  		case 'z':  			Status = "z";  			CurState = State.Fold;  			return;  		case 'm':  			Status = "m";  			CurState = State.Mark;  			return;  		case '`':  			Status = "`";  			CurState = State.GoToMark;  			return;  		case '@':  			Status = "@";  			CurState = State.PlayMacro;  			return;  		case 'q':  			if (currentMacro == null) {  				Status = "q";  				CurState = State.NameMacro;  				return;  			}  			currentMacro = null;  			Reset ("Macro Recorded");  			return;  		case '*':  			SearchWordAtCaret (backward: false);  			return;  		case '#':  			SearchWordAtCaret (backward: true);  			return;  		case '.':  			RepeatLastAction ();  			return;  		}  	}  	//				if (Data == null)  	//					Console.WriteLine ("ViMode.HandleKeypress: after State.Normal block' Data is null");  	action = GetNavCharAction ((char)unicodeKey' true);  	if (action == null) {  		action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	}  	if (action == null) {  		action = ViActionMaps.GetCommandCharAction ((char)unicodeKey);  	}  	if (action != null) {  		RunRepeatableAction (action);  	}  	//				if (Data == null)  	//					Console.WriteLine ("ViMode.HandleKeypress: right before CheckVisualMode' Data is null");  	//undo/redo may leave MD with a selection mode without activating visual mode  	CheckVisualMode ();  	return;  case State.Delete:  	if (IsInnerOrOuterMotionKey (unicodeKey' ref motion))  		return;  	int offsetz = Caret.Offset;  	if (motion != Motion.None) {  		action = ViActionMaps.GetEditObjectCharAction ((char)unicodeKey' motion);  	} else if (((modifier & (Gdk.ModifierType.ShiftMask | Gdk.ModifierType.ControlMask)) == 0 && (unicodeKey == 'd' || unicodeKey == 'j' || unicodeKey == 'k'))) {  		if (unicodeKey == 'k') {  			action = CaretMoveActions.Up;  		} else {  			action = CaretMoveActions.Down;  		}  		if (unicodeKey == 'j') {  			repeatCount += 1;  		}  		//get one extra line for yj  		lineAction = true;  	} else {  		action = GetNavCharAction ((char)unicodeKey' false);  		if (action == null)  			action = ViActionMaps.GetDirectionKeyAction (key' modifier);  		if (action != null)  			action = SelectionActions.FromMoveAction (action);  	}  	if (action != null) {  		if (lineAction) {  			RunAction (CaretMoveActions.LineStart);  			SelectionActions.StartSelection (Data);  			for (int i = 0; i < repeatCount; i++) {  				RunAction (action);  			}  			SelectionActions.EndSelection (Data);  			numericPrefix = "";  		} else {  			RunRepeatableAction (action);  		}  		if (Data.IsSomethingSelected && !lineAction)  			offsetz = Data.SelectionRange.Offset;  		RunAction (ClipboardActions.Cut);  		Reset (string.Empty);  	} else {  		Reset ("Unrecognised motion");  	}  	Caret.Offset = offsetz;  	return;  case State.Yank:  	if (IsInnerOrOuterMotionKey (unicodeKey' ref motion))  		return;  	int offset = Caret.Offset;  	if (motion != Motion.None) {  		action = ViActionMaps.GetEditObjectCharAction ((char)unicodeKey' motion);  	} else if (((modifier & (Gdk.ModifierType.ShiftMask | Gdk.ModifierType.ControlMask)) == 0 && (unicodeKey == 'y' || unicodeKey == 'j' || unicodeKey == 'k'))) {  		if (unicodeKey == 'k') {  			action = CaretMoveActions.Up;  		} else {  			action = CaretMoveActions.Down;  		}  		if (unicodeKey == 'j') {  			repeatCount += 1;  		}  		//get one extra line for yj  		lineAction = true;  	} else {  		action = GetNavCharAction ((char)unicodeKey' false);  		if (action == null)  			action = ViActionMaps.GetDirectionKeyAction (key' modifier);  		if (action != null)  			action = SelectionActions.FromMoveAction (action);  	}  	if (action != null) {  		if (lineAction) {  			RunAction (CaretMoveActions.LineStart);  			SelectionActions.StartSelection (Data);  			for (int i = 0; i < repeatCount; i++) {  				RunAction (action);  			}  			SelectionActions.EndSelection (Data);  			numericPrefix = "";  		} else {  			RunRepeatableAction (action);  		}  		if (Data.IsSomethingSelected && !lineAction)  			offset = Data.SelectionRange.Offset;  		RunAction (ClipboardActions.Copy);  		Reset (string.Empty);  	} else {  		Reset ("Unrecognised motion");  	}  	Caret.Offset = offset;  	return;  case State.Change:  	if (IsInnerOrOuterMotionKey (unicodeKey' ref motion))  		return;  	lastActionStarted = true;  	LastAction.Clear ();  	if (motion != Motion.None) {  		action = ViActionMaps.GetEditObjectCharAction ((char)unicodeKey' motion);  	} //copied from delete action  	else if (((modifier & (Gdk.ModifierType.ShiftMask | Gdk.ModifierType.ControlMask)) == 0 && unicodeKey == 'c')) {  		action = SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd);  		lineAction = true;  	} else {  		action = ViActionMaps.GetEditObjectCharAction ((char)unicodeKey);  		if (action == null)  			action = ViActionMaps.GetDirectionKeyAction (key' modifier);  		if (action != null)  			action = SelectionActions.FromMoveAction (action);  	}  	if (action != null) {  		List<Action<TextEditorData>> actions;  		if (lineAction) {  			//cd or cj  -- delete lines moving downward  			actions = GenerateRepeatedActionList (action' ClipboardActions.Cut' CaretMoveActions.LineFirstNonWhitespace);  			actions.Add (ViActions.NewLineAbove);  		} else if (unicodeKey == 'j') {  			//cj -- delete current line and line below  			repeatCount += 1;  			action = SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd);  			actions = GenerateRepeatedActionList (action' ClipboardActions.Cut' CaretMoveActions.LineFirstNonWhitespace);  			actions.Add (ViActions.NewLineAbove);  		} else if (unicodeKey == 'k') {  			//ck -- delete current line and line above  			repeatCount += 1;  			actions = GenerateRepeatedActionList (CaretMoveActions.LineFirstNonWhitespace' ClipboardActions.Cut' action);  			actions.Add (ViActions.NewLineBelow);  		} else {  			actions = GenerateRepeatedActionList (action);  			actions.Add (ClipboardActions.Cut);  		}  		RunActions (actions.ToArray ());  		LastAction.AddRange (actions);  		Status = "-- INSERT --";  		PrevState = State.Change;  		CurState = State.Insert;  		Caret.Mode = CaretMode.Insert;  	} else {  		Reset ("Unrecognised motion");  	}  	return;  case State.Insert:  case State.Replace:  	action = ViActionMaps.GetInsertKeyAction (key' modifier);  	// Record InsertKeyActions  	if (action != null) {  		RunAction (action);  		InsertBuffer.Add (new Keystroke (key' unicodeKey' modifier));  		return;  	}  	// Clear InsertBuffer if DirectionKeyAction  	action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	if (action != null) {  		RunAction (action);  		InsertBuffer.Clear ();  		return;  	}  	if (unicodeKey != 0) {  		InsertCharacter (unicodeKey);  		InsertBuffer.Add (new Keystroke (key' unicodeKey' modifier));  	}  	return;  case State.VisualLine:  	if (key == Gdk.Key.Delete)  		unicodeKey = 'x';  	switch ((char)unicodeKey) {  	case 'p':  		PasteAfter (true);  		return;  	case 'P':  		PasteBefore (true);  		return;  	}  	action = GetNavCharAction ((char)unicodeKey' false);  	if (action == null) {  		action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	}  	if (action == null) {  		action = ViActionMaps.GetCommandCharAction ((char)unicodeKey);  	}  	if (action != null) {  		RunAction (SelectionActions.LineActionFromMoveAction (action));  		return;  	}  	ApplyActionToSelection (modifier' unicodeKey);  	return;  case State.Visual:  	if (IsInnerOrOuterMotionKey (unicodeKey' ref motion))  		return;  	if (motion != Motion.None) {  		action = ViActionMaps.GetEditObjectCharAction ((char)unicodeKey' motion);  		if (action != null) {  			RunAction (action);  			return;  		}  	}  	if (key == Gdk.Key.Delete)  		unicodeKey = 'x';  	switch ((char)unicodeKey) {  	case 'p':  		PasteAfter (false);  		return;  	case 'P':  		PasteBefore (false);  		return;  	}  	action = GetNavCharAction ((char)unicodeKey' false);  	if (action == null) {  		action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	}  	if (action == null) {  		action = ViActionMaps.GetCommandCharAction ((char)unicodeKey);  	}  	if (action != null) {  		RunAction (ViActions.VisualSelectionFromMoveAction (action));  		return;  	}  	ApplyActionToSelection (modifier' unicodeKey);  	return;  case State.Command:  	switch (key) {  	case Gdk.Key.Return:  	case Gdk.Key.KP_Enter:  		Status = RunExCommand (commandBuffer.ToString ());  		commandBuffer.Length = 0;  		//CurState = State.Normal;  		break;  	case Gdk.Key.BackSpace:  	case Gdk.Key.Delete:  	case Gdk.Key.KP_Delete:  		if (0 < commandBuffer.Length) {  			commandBuffer.Remove (commandBuffer.Length - 1' 1);  			Status = commandBuffer.ToString ();  			if (0 == commandBuffer.Length)  				Reset (Status);  		}  		break;  	default:  		if (unicodeKey != 0) {  			commandBuffer.Append ((char)unicodeKey);  			Status = commandBuffer.ToString ();  		}  		break;  	}  	return;  case State.WriteChar:  	if (unicodeKey != 0) {  		RunAction (SelectionActions.StartSelection);  		int roffset = Data.SelectionRange.Offset;  		InsertCharacter ((char)unicodeKey);  		Reset (string.Empty);  		Caret.Offset = roffset;  	} else {  		Reset ("Keystroke was not a character");  	}  	return;  case State.Indent:  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0 && unicodeKey == '>')) {  		//select current line to indent  		Action<TextEditorData> indentAction = MakeIndentAction (repeatCount);  		StartNewLastAction (indentAction);  		RunAction (indentAction);  		return;  	}  	action = GetNavCharAction ((char)unicodeKey' false);  	if (action == null)  		action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	if (action != null) {  		// TODO: Stuff this into a delegate and go   		var linesToIndent = repeatCount;  		Action<TextEditorData> indentAction = delegate (TextEditorData data) {  			List<Action<TextEditorData>> actions = new List<Action<TextEditorData>> ();  			//get away from LineBegin  			RunAction (CaretMoveActions.LineFirstNonWhitespace);  			int roffset = Data.SelectionRange.Offset;  			actions.Add (ViActions.Right);  			for (int i = 0; i < linesToIndent; i++) {  				actions.Add (SelectionActions.FromMoveAction (action));  			}  			actions.Add (MiscActions.IndentSelection);  			RunActions (actions.ToArray ());  			//set cursor to start of first line indented  			Caret.Offset = roffset;  			RunAction (CaretMoveActions.LineFirstNonWhitespace);  			Reset ("");  		};  		StartNewLastAction (indentAction);  		RunAction (indentAction);  	} else {  		Reset ("Unrecognised motion");  	}  	return;  case State.Unindent:  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0 && ((char)unicodeKey) == '<')) {  		//select current line to indent  		// TODO: Stuff this into a delegate and go  		Action<TextEditorData> unindentAction = MakeUnindentAction (repeatCount);  		StartNewLastAction (unindentAction);  		RunAction (unindentAction);  		return;  	}  	action = GetNavCharAction ((char)unicodeKey' false);  	if (action == null)  		action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	if (action != null) {  		// TODO: Stuff this into a delegate and go  		var linesToUnindent = repeatCount;  		Action<TextEditorData> unindentAction = delegate (TextEditorData data) {  			List<Action<TextEditorData>> actions = new List<Action<TextEditorData>> ();  			RunAction (CaretMoveActions.LineFirstNonWhitespace);  			int roffset = Data.SelectionRange.Offset;  			//get away from LineBegin  			actions.Add (ViActions.Right);  			for (int i = 0; i < linesToUnindent; i++) {  				actions.Add (SelectionActions.FromMoveAction (action));  			}  			actions.Add (MiscActions.RemoveIndentSelection);  			RunActions (actions.ToArray ());  			//set cursor to start of first line indented  			Caret.Offset = roffset;  			RunAction (CaretMoveActions.LineFirstNonWhitespace);  			Reset ("");  		};  		StartNewLastAction (unindentAction);  		RunAction (unindentAction);  	} else {  		Reset ("Unrecognised motion");  	}  	return;  case State.G:  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0)) {  		switch ((char)unicodeKey) {  		case 'g':  			RunAction (marks ['`'].SaveMark);  			Caret.Offset = 0;  			Reset ("");  			return;  		}  	}  	Reset ("Unknown command");  	return;  case State.Mark: {  	char k = (char)unicodeKey;  	ViMark mark = null;  	if (!char.IsLetterOrDigit (k) && !SpecialMarks.Contains (k)) {  		Reset ("Invalid Mark");  		return;  	}  	if (marks.ContainsKey (k)) {  		mark = marks [k];  	} else {  		mark = new ViMark (k);  		marks [k] = mark;  	}  	RunAction (mark.SaveMark);  	Reset ("");  	return;  }  case State.NameMacro: {  	char k = (char)unicodeKey;  	if (!char.IsLetterOrDigit (k)) {  		Reset ("Invalid Macro Name");  		return;  	}  	currentMacro = new ViMacro (k);  	currentMacro.KeysPressed = new Queue<ViMacro.KeySet> ();  	macros [k] = currentMacro;  	Reset ("");  	return;  }  case State.PlayMacro: {  	char k = (char)unicodeKey;  	if (k == '@')  		k = macros_lastplayed;  	if (macros.ContainsKey (k)) {  		int playCount = repeatCount;  		//store repeat count in case macro changes it  		Reset ("");  		macros_lastplayed = k;  		// FIXME play nice when playing macros from inside macros?  		ViMacro macroToPlay = macros [k];  		for (int i = 0; i < playCount; i++) {  			foreach (ViMacro.KeySet keySet in macroToPlay.KeysPressed) {  				HandleKeypress (keySet.Key' keySet.UnicodeKey' keySet.Modifiers);  				// FIXME stop on errors? essential with multipliers and nowrapscan  			}  		}  		/* Once all the keys have been played back' quickly exit. */return;  	} else {  		Reset ("Invalid Macro Name '" + k + "'");  		return;  	}  }  case State.GoToMark: {  	char k = (char)unicodeKey;  	if (marks.ContainsKey (k)) {  		if (k != '`') {  			RunAction (marks ['`'].SaveMark);  		}  		RunAction (marks [k].LoadMark);  		Reset ("");  	} else {  		Reset ("Unknown Mark");  	}  	return;  }  case State.Fold: {  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0)) {  		switch ((char)unicodeKey) {  		case 'A':  			// Recursive fold toggle  			action = FoldActions.ToggleFoldRecursive;  			break;  		case 'C':  			// Recursive fold close  			action = FoldActions.CloseFoldRecursive;  			break;  		case 'M':  			// Close all folds  			action = FoldActions.CloseAllFolds;  			break;  		case 'O':  			// Recursive fold open  			action = FoldActions.OpenFoldRecursive;  			break;  		case 'R':  			// Expand all folds  			action = FoldActions.OpenAllFolds;  			break;  		case 'a':  			// Fold toggle  			action = FoldActions.ToggleFold;  			break;  		case 'c':  			// Fold close  			action = FoldActions.CloseFold;  			break;  		case 'o':  			// Fold open  			action = FoldActions.OpenFold;  			break;  		default:  			Reset ("Unknown command");  			break;  		}  		if (null != action) {  			RunAction (action);  			Reset (string.Empty);  		}  	}  	return;  }  case State.Confirm:  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0)) {  		switch ((char)unicodeKey) {  		case 'y':  			Reset ("Yes");  			break;  		case 'n':  			Reset ("No");  			break;  		}  	}  	return;  }  
Magic Number,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The following statement contains a magic number: switch (CurState) {  case State.Unknown:  	Reset (string.Empty);  	goto case State.Normal;  case State.Normal:  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0)) {  		if (key == Gdk.Key.Delete)  			unicodeKey = 'x';  		switch ((char)unicodeKey) {  		case '?':  		case '/':  		case ':':  			CurState = State.Command;  			commandBuffer.Append ((char)unicodeKey);  			Status = commandBuffer.ToString ();  			return;  		case 'A':  			StartNewLastAction (CaretMoveActions.LineEnd);  			RunAction (CaretMoveActions.LineEnd);  			goto case 'i';  		case 'I':  			StartNewLastAction (CaretMoveActions.LineFirstNonWhitespace);  			RunAction (CaretMoveActions.LineFirstNonWhitespace);  			goto case 'i';  		case 'a':  			StartNewLastAction (CaretMoveActions.Right);  			//use CaretMoveActions so that we can move past last character on line end  			RunAction (CaretMoveActions.Right);  			goto case 'i';  		case 'i':  			Caret.Mode = CaretMode.Insert;  			Status = "-- INSERT --";  			CurState = State.Insert;  			return;  		case 'R':  			Caret.Mode = CaretMode.Underscore;  			Status = "-- REPLACE --";  			CurState = State.Replace;  			return;  		case 'V':  			Status = "-- VISUAL LINE --";  			Data.SetSelectLines (Caret.Line' Caret.Line);  			CurState = State.VisualLine;  			return;  		case 'v':  			Status = "-- VISUAL --";  			CurState = State.Visual;  			RunAction (ViActions.VisualSelectionFromMoveAction (ViActions.Right));  			return;  		case 'd':  			Status = "d";  			CurState = State.Delete;  			return;  		case 'y':  			Status = "y";  			CurState = State.Yank;  			return;  		case 'Y':  			CurState = State.Yank;  			HandleKeypress (Gdk.Key.y' (int)'y'' Gdk.ModifierType.None);  			return;  		case 'O':  			StartNewLastAction (ViActions.NewLineAbove);  			RunAction (ViActions.NewLineAbove);  			goto case 'i';  		case 'o':  			StartNewLastAction (ViActions.NewLineBelow);  			RunAction (ViActions.NewLineBelow);  			goto case 'i';  		case 'r':  			Caret.Mode = CaretMode.Underscore;  			Status = "-- REPLACE --";  			CurState = State.WriteChar;  			return;  		case 'c':  			Caret.Mode = CaretMode.Insert;  			Status = "c";  			CurState = State.Change;  			return;  		case 'x':  			if (Data.Caret.Column == Data.Document.GetLine (Data.Caret.Line).Length + 1)  				return;  			Status = string.Empty;  			if (!Data.IsSomethingSelected)  				RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Right)' ClipboardActions.Cut);  			else  				RunAction (ClipboardActions.Cut);  			ViActions.RetreatFromLineEnd (Data);  			return;  		case 'X':  			if (Data.Caret.Column == DocumentLocation.MinColumn)  				return;  			Status = string.Empty;  			if (!Data.IsSomethingSelected && 0 < Caret.Offset)  				RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Left)' ClipboardActions.Cut);  			else  				RunAction (ClipboardActions.Cut);  			return;  		case 'D':  			RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  			return;  		case 'C':  			RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  			goto case 'i';  		case '>':  			Status = ">";  			CurState = State.Indent;  			return;  		case '<':  			Status = "<";  			CurState = State.Unindent;  			return;  		case 'n':  			Search ();  			return;  		case 'N':  			searchBackward = !searchBackward;  			Search ();  			searchBackward = !searchBackward;  			return;  		case 'p':  			PasteAfter (false);  			return;  		case 'P':  			PasteBefore (false);  			return;  		case 's':  			if (!Data.IsSomethingSelected)  				RunAction (SelectionActions.FromMoveAction (CaretMoveActions.Right));  			RunAction (ClipboardActions.Cut);  			goto case 'i';  		case 'S':  			if (!Data.IsSomethingSelected)  				RunAction (SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd));  			else  				Data.SetSelectLines (Data.MainSelection.Anchor.Line' Data.Caret.Line);  			RunAction (ClipboardActions.Cut);  			goto case 'i';  		case 'g':  			Status = "g";  			CurState = State.G;  			return;  		case 'G':  			RunAction (marks ['`'].SaveMark);  			if (repeatCount > 1) {  				Caret.Line = repeatCount;  			} else {  				//RunAction (CaretMoveActions.ToDocumentEnd);  				RunAction (ToDocumentEnd);  			}  			Reset (string.Empty);  			return;  		case 'H':  			Caret.Line = System.Math.Max (DocumentLocation.MinLine' Editor.PointToLocation (0' Editor.LineHeight - 1).Line);  			return;  		case 'J':  			RunAction (ViActions.Join);  			return;  		case 'L':  			int line = Editor.PointToLocation (0' Editor.Allocation.Height - Editor.LineHeight * 2 - 2).Line;  			if (line < DocumentLocation.MinLine)  				line = Document.LineCount;  			Caret.Line = line;  			return;  		case 'M':  			line = Editor.PointToLocation (0' Editor.Allocation.Height / 2).Line;  			if (line < DocumentLocation.MinLine)  				line = Document.LineCount;  			Caret.Line = line;  			return;  		case '~':  			RunAction (ViActions.ToggleCase);  			return;  		case 'z':  			Status = "z";  			CurState = State.Fold;  			return;  		case 'm':  			Status = "m";  			CurState = State.Mark;  			return;  		case '`':  			Status = "`";  			CurState = State.GoToMark;  			return;  		case '@':  			Status = "@";  			CurState = State.PlayMacro;  			return;  		case 'q':  			if (currentMacro == null) {  				Status = "q";  				CurState = State.NameMacro;  				return;  			}  			currentMacro = null;  			Reset ("Macro Recorded");  			return;  		case '*':  			SearchWordAtCaret (backward: false);  			return;  		case '#':  			SearchWordAtCaret (backward: true);  			return;  		case '.':  			RepeatLastAction ();  			return;  		}  	}  	//				if (Data == null)  	//					Console.WriteLine ("ViMode.HandleKeypress: after State.Normal block' Data is null");  	action = GetNavCharAction ((char)unicodeKey' true);  	if (action == null) {  		action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	}  	if (action == null) {  		action = ViActionMaps.GetCommandCharAction ((char)unicodeKey);  	}  	if (action != null) {  		RunRepeatableAction (action);  	}  	//				if (Data == null)  	//					Console.WriteLine ("ViMode.HandleKeypress: right before CheckVisualMode' Data is null");  	//undo/redo may leave MD with a selection mode without activating visual mode  	CheckVisualMode ();  	return;  case State.Delete:  	if (IsInnerOrOuterMotionKey (unicodeKey' ref motion))  		return;  	int offsetz = Caret.Offset;  	if (motion != Motion.None) {  		action = ViActionMaps.GetEditObjectCharAction ((char)unicodeKey' motion);  	} else if (((modifier & (Gdk.ModifierType.ShiftMask | Gdk.ModifierType.ControlMask)) == 0 && (unicodeKey == 'd' || unicodeKey == 'j' || unicodeKey == 'k'))) {  		if (unicodeKey == 'k') {  			action = CaretMoveActions.Up;  		} else {  			action = CaretMoveActions.Down;  		}  		if (unicodeKey == 'j') {  			repeatCount += 1;  		}  		//get one extra line for yj  		lineAction = true;  	} else {  		action = GetNavCharAction ((char)unicodeKey' false);  		if (action == null)  			action = ViActionMaps.GetDirectionKeyAction (key' modifier);  		if (action != null)  			action = SelectionActions.FromMoveAction (action);  	}  	if (action != null) {  		if (lineAction) {  			RunAction (CaretMoveActions.LineStart);  			SelectionActions.StartSelection (Data);  			for (int i = 0; i < repeatCount; i++) {  				RunAction (action);  			}  			SelectionActions.EndSelection (Data);  			numericPrefix = "";  		} else {  			RunRepeatableAction (action);  		}  		if (Data.IsSomethingSelected && !lineAction)  			offsetz = Data.SelectionRange.Offset;  		RunAction (ClipboardActions.Cut);  		Reset (string.Empty);  	} else {  		Reset ("Unrecognised motion");  	}  	Caret.Offset = offsetz;  	return;  case State.Yank:  	if (IsInnerOrOuterMotionKey (unicodeKey' ref motion))  		return;  	int offset = Caret.Offset;  	if (motion != Motion.None) {  		action = ViActionMaps.GetEditObjectCharAction ((char)unicodeKey' motion);  	} else if (((modifier & (Gdk.ModifierType.ShiftMask | Gdk.ModifierType.ControlMask)) == 0 && (unicodeKey == 'y' || unicodeKey == 'j' || unicodeKey == 'k'))) {  		if (unicodeKey == 'k') {  			action = CaretMoveActions.Up;  		} else {  			action = CaretMoveActions.Down;  		}  		if (unicodeKey == 'j') {  			repeatCount += 1;  		}  		//get one extra line for yj  		lineAction = true;  	} else {  		action = GetNavCharAction ((char)unicodeKey' false);  		if (action == null)  			action = ViActionMaps.GetDirectionKeyAction (key' modifier);  		if (action != null)  			action = SelectionActions.FromMoveAction (action);  	}  	if (action != null) {  		if (lineAction) {  			RunAction (CaretMoveActions.LineStart);  			SelectionActions.StartSelection (Data);  			for (int i = 0; i < repeatCount; i++) {  				RunAction (action);  			}  			SelectionActions.EndSelection (Data);  			numericPrefix = "";  		} else {  			RunRepeatableAction (action);  		}  		if (Data.IsSomethingSelected && !lineAction)  			offset = Data.SelectionRange.Offset;  		RunAction (ClipboardActions.Copy);  		Reset (string.Empty);  	} else {  		Reset ("Unrecognised motion");  	}  	Caret.Offset = offset;  	return;  case State.Change:  	if (IsInnerOrOuterMotionKey (unicodeKey' ref motion))  		return;  	lastActionStarted = true;  	LastAction.Clear ();  	if (motion != Motion.None) {  		action = ViActionMaps.GetEditObjectCharAction ((char)unicodeKey' motion);  	} //copied from delete action  	else if (((modifier & (Gdk.ModifierType.ShiftMask | Gdk.ModifierType.ControlMask)) == 0 && unicodeKey == 'c')) {  		action = SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd);  		lineAction = true;  	} else {  		action = ViActionMaps.GetEditObjectCharAction ((char)unicodeKey);  		if (action == null)  			action = ViActionMaps.GetDirectionKeyAction (key' modifier);  		if (action != null)  			action = SelectionActions.FromMoveAction (action);  	}  	if (action != null) {  		List<Action<TextEditorData>> actions;  		if (lineAction) {  			//cd or cj  -- delete lines moving downward  			actions = GenerateRepeatedActionList (action' ClipboardActions.Cut' CaretMoveActions.LineFirstNonWhitespace);  			actions.Add (ViActions.NewLineAbove);  		} else if (unicodeKey == 'j') {  			//cj -- delete current line and line below  			repeatCount += 1;  			action = SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd);  			actions = GenerateRepeatedActionList (action' ClipboardActions.Cut' CaretMoveActions.LineFirstNonWhitespace);  			actions.Add (ViActions.NewLineAbove);  		} else if (unicodeKey == 'k') {  			//ck -- delete current line and line above  			repeatCount += 1;  			actions = GenerateRepeatedActionList (CaretMoveActions.LineFirstNonWhitespace' ClipboardActions.Cut' action);  			actions.Add (ViActions.NewLineBelow);  		} else {  			actions = GenerateRepeatedActionList (action);  			actions.Add (ClipboardActions.Cut);  		}  		RunActions (actions.ToArray ());  		LastAction.AddRange (actions);  		Status = "-- INSERT --";  		PrevState = State.Change;  		CurState = State.Insert;  		Caret.Mode = CaretMode.Insert;  	} else {  		Reset ("Unrecognised motion");  	}  	return;  case State.Insert:  case State.Replace:  	action = ViActionMaps.GetInsertKeyAction (key' modifier);  	// Record InsertKeyActions  	if (action != null) {  		RunAction (action);  		InsertBuffer.Add (new Keystroke (key' unicodeKey' modifier));  		return;  	}  	// Clear InsertBuffer if DirectionKeyAction  	action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	if (action != null) {  		RunAction (action);  		InsertBuffer.Clear ();  		return;  	}  	if (unicodeKey != 0) {  		InsertCharacter (unicodeKey);  		InsertBuffer.Add (new Keystroke (key' unicodeKey' modifier));  	}  	return;  case State.VisualLine:  	if (key == Gdk.Key.Delete)  		unicodeKey = 'x';  	switch ((char)unicodeKey) {  	case 'p':  		PasteAfter (true);  		return;  	case 'P':  		PasteBefore (true);  		return;  	}  	action = GetNavCharAction ((char)unicodeKey' false);  	if (action == null) {  		action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	}  	if (action == null) {  		action = ViActionMaps.GetCommandCharAction ((char)unicodeKey);  	}  	if (action != null) {  		RunAction (SelectionActions.LineActionFromMoveAction (action));  		return;  	}  	ApplyActionToSelection (modifier' unicodeKey);  	return;  case State.Visual:  	if (IsInnerOrOuterMotionKey (unicodeKey' ref motion))  		return;  	if (motion != Motion.None) {  		action = ViActionMaps.GetEditObjectCharAction ((char)unicodeKey' motion);  		if (action != null) {  			RunAction (action);  			return;  		}  	}  	if (key == Gdk.Key.Delete)  		unicodeKey = 'x';  	switch ((char)unicodeKey) {  	case 'p':  		PasteAfter (false);  		return;  	case 'P':  		PasteBefore (false);  		return;  	}  	action = GetNavCharAction ((char)unicodeKey' false);  	if (action == null) {  		action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	}  	if (action == null) {  		action = ViActionMaps.GetCommandCharAction ((char)unicodeKey);  	}  	if (action != null) {  		RunAction (ViActions.VisualSelectionFromMoveAction (action));  		return;  	}  	ApplyActionToSelection (modifier' unicodeKey);  	return;  case State.Command:  	switch (key) {  	case Gdk.Key.Return:  	case Gdk.Key.KP_Enter:  		Status = RunExCommand (commandBuffer.ToString ());  		commandBuffer.Length = 0;  		//CurState = State.Normal;  		break;  	case Gdk.Key.BackSpace:  	case Gdk.Key.Delete:  	case Gdk.Key.KP_Delete:  		if (0 < commandBuffer.Length) {  			commandBuffer.Remove (commandBuffer.Length - 1' 1);  			Status = commandBuffer.ToString ();  			if (0 == commandBuffer.Length)  				Reset (Status);  		}  		break;  	default:  		if (unicodeKey != 0) {  			commandBuffer.Append ((char)unicodeKey);  			Status = commandBuffer.ToString ();  		}  		break;  	}  	return;  case State.WriteChar:  	if (unicodeKey != 0) {  		RunAction (SelectionActions.StartSelection);  		int roffset = Data.SelectionRange.Offset;  		InsertCharacter ((char)unicodeKey);  		Reset (string.Empty);  		Caret.Offset = roffset;  	} else {  		Reset ("Keystroke was not a character");  	}  	return;  case State.Indent:  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0 && unicodeKey == '>')) {  		//select current line to indent  		Action<TextEditorData> indentAction = MakeIndentAction (repeatCount);  		StartNewLastAction (indentAction);  		RunAction (indentAction);  		return;  	}  	action = GetNavCharAction ((char)unicodeKey' false);  	if (action == null)  		action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	if (action != null) {  		// TODO: Stuff this into a delegate and go   		var linesToIndent = repeatCount;  		Action<TextEditorData> indentAction = delegate (TextEditorData data) {  			List<Action<TextEditorData>> actions = new List<Action<TextEditorData>> ();  			//get away from LineBegin  			RunAction (CaretMoveActions.LineFirstNonWhitespace);  			int roffset = Data.SelectionRange.Offset;  			actions.Add (ViActions.Right);  			for (int i = 0; i < linesToIndent; i++) {  				actions.Add (SelectionActions.FromMoveAction (action));  			}  			actions.Add (MiscActions.IndentSelection);  			RunActions (actions.ToArray ());  			//set cursor to start of first line indented  			Caret.Offset = roffset;  			RunAction (CaretMoveActions.LineFirstNonWhitespace);  			Reset ("");  		};  		StartNewLastAction (indentAction);  		RunAction (indentAction);  	} else {  		Reset ("Unrecognised motion");  	}  	return;  case State.Unindent:  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0 && ((char)unicodeKey) == '<')) {  		//select current line to indent  		// TODO: Stuff this into a delegate and go  		Action<TextEditorData> unindentAction = MakeUnindentAction (repeatCount);  		StartNewLastAction (unindentAction);  		RunAction (unindentAction);  		return;  	}  	action = GetNavCharAction ((char)unicodeKey' false);  	if (action == null)  		action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	if (action != null) {  		// TODO: Stuff this into a delegate and go  		var linesToUnindent = repeatCount;  		Action<TextEditorData> unindentAction = delegate (TextEditorData data) {  			List<Action<TextEditorData>> actions = new List<Action<TextEditorData>> ();  			RunAction (CaretMoveActions.LineFirstNonWhitespace);  			int roffset = Data.SelectionRange.Offset;  			//get away from LineBegin  			actions.Add (ViActions.Right);  			for (int i = 0; i < linesToUnindent; i++) {  				actions.Add (SelectionActions.FromMoveAction (action));  			}  			actions.Add (MiscActions.RemoveIndentSelection);  			RunActions (actions.ToArray ());  			//set cursor to start of first line indented  			Caret.Offset = roffset;  			RunAction (CaretMoveActions.LineFirstNonWhitespace);  			Reset ("");  		};  		StartNewLastAction (unindentAction);  		RunAction (unindentAction);  	} else {  		Reset ("Unrecognised motion");  	}  	return;  case State.G:  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0)) {  		switch ((char)unicodeKey) {  		case 'g':  			RunAction (marks ['`'].SaveMark);  			Caret.Offset = 0;  			Reset ("");  			return;  		}  	}  	Reset ("Unknown command");  	return;  case State.Mark: {  	char k = (char)unicodeKey;  	ViMark mark = null;  	if (!char.IsLetterOrDigit (k) && !SpecialMarks.Contains (k)) {  		Reset ("Invalid Mark");  		return;  	}  	if (marks.ContainsKey (k)) {  		mark = marks [k];  	} else {  		mark = new ViMark (k);  		marks [k] = mark;  	}  	RunAction (mark.SaveMark);  	Reset ("");  	return;  }  case State.NameMacro: {  	char k = (char)unicodeKey;  	if (!char.IsLetterOrDigit (k)) {  		Reset ("Invalid Macro Name");  		return;  	}  	currentMacro = new ViMacro (k);  	currentMacro.KeysPressed = new Queue<ViMacro.KeySet> ();  	macros [k] = currentMacro;  	Reset ("");  	return;  }  case State.PlayMacro: {  	char k = (char)unicodeKey;  	if (k == '@')  		k = macros_lastplayed;  	if (macros.ContainsKey (k)) {  		int playCount = repeatCount;  		//store repeat count in case macro changes it  		Reset ("");  		macros_lastplayed = k;  		// FIXME play nice when playing macros from inside macros?  		ViMacro macroToPlay = macros [k];  		for (int i = 0; i < playCount; i++) {  			foreach (ViMacro.KeySet keySet in macroToPlay.KeysPressed) {  				HandleKeypress (keySet.Key' keySet.UnicodeKey' keySet.Modifiers);  				// FIXME stop on errors? essential with multipliers and nowrapscan  			}  		}  		/* Once all the keys have been played back' quickly exit. */return;  	} else {  		Reset ("Invalid Macro Name '" + k + "'");  		return;  	}  }  case State.GoToMark: {  	char k = (char)unicodeKey;  	if (marks.ContainsKey (k)) {  		if (k != '`') {  			RunAction (marks ['`'].SaveMark);  		}  		RunAction (marks [k].LoadMark);  		Reset ("");  	} else {  		Reset ("Unknown Mark");  	}  	return;  }  case State.Fold: {  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0)) {  		switch ((char)unicodeKey) {  		case 'A':  			// Recursive fold toggle  			action = FoldActions.ToggleFoldRecursive;  			break;  		case 'C':  			// Recursive fold close  			action = FoldActions.CloseFoldRecursive;  			break;  		case 'M':  			// Close all folds  			action = FoldActions.CloseAllFolds;  			break;  		case 'O':  			// Recursive fold open  			action = FoldActions.OpenFoldRecursive;  			break;  		case 'R':  			// Expand all folds  			action = FoldActions.OpenAllFolds;  			break;  		case 'a':  			// Fold toggle  			action = FoldActions.ToggleFold;  			break;  		case 'c':  			// Fold close  			action = FoldActions.CloseFold;  			break;  		case 'o':  			// Fold open  			action = FoldActions.OpenFold;  			break;  		default:  			Reset ("Unknown command");  			break;  		}  		if (null != action) {  			RunAction (action);  			Reset (string.Empty);  		}  	}  	return;  }  case State.Confirm:  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0)) {  		switch ((char)unicodeKey) {  		case 'y':  			Reset ("Yes");  			break;  		case 'n':  			Reset ("No");  			break;  		}  	}  	return;  }  
Magic Number,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The following statement contains a magic number: switch (CurState) {  case State.Unknown:  	Reset (string.Empty);  	goto case State.Normal;  case State.Normal:  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0)) {  		if (key == Gdk.Key.Delete)  			unicodeKey = 'x';  		switch ((char)unicodeKey) {  		case '?':  		case '/':  		case ':':  			CurState = State.Command;  			commandBuffer.Append ((char)unicodeKey);  			Status = commandBuffer.ToString ();  			return;  		case 'A':  			StartNewLastAction (CaretMoveActions.LineEnd);  			RunAction (CaretMoveActions.LineEnd);  			goto case 'i';  		case 'I':  			StartNewLastAction (CaretMoveActions.LineFirstNonWhitespace);  			RunAction (CaretMoveActions.LineFirstNonWhitespace);  			goto case 'i';  		case 'a':  			StartNewLastAction (CaretMoveActions.Right);  			//use CaretMoveActions so that we can move past last character on line end  			RunAction (CaretMoveActions.Right);  			goto case 'i';  		case 'i':  			Caret.Mode = CaretMode.Insert;  			Status = "-- INSERT --";  			CurState = State.Insert;  			return;  		case 'R':  			Caret.Mode = CaretMode.Underscore;  			Status = "-- REPLACE --";  			CurState = State.Replace;  			return;  		case 'V':  			Status = "-- VISUAL LINE --";  			Data.SetSelectLines (Caret.Line' Caret.Line);  			CurState = State.VisualLine;  			return;  		case 'v':  			Status = "-- VISUAL --";  			CurState = State.Visual;  			RunAction (ViActions.VisualSelectionFromMoveAction (ViActions.Right));  			return;  		case 'd':  			Status = "d";  			CurState = State.Delete;  			return;  		case 'y':  			Status = "y";  			CurState = State.Yank;  			return;  		case 'Y':  			CurState = State.Yank;  			HandleKeypress (Gdk.Key.y' (int)'y'' Gdk.ModifierType.None);  			return;  		case 'O':  			StartNewLastAction (ViActions.NewLineAbove);  			RunAction (ViActions.NewLineAbove);  			goto case 'i';  		case 'o':  			StartNewLastAction (ViActions.NewLineBelow);  			RunAction (ViActions.NewLineBelow);  			goto case 'i';  		case 'r':  			Caret.Mode = CaretMode.Underscore;  			Status = "-- REPLACE --";  			CurState = State.WriteChar;  			return;  		case 'c':  			Caret.Mode = CaretMode.Insert;  			Status = "c";  			CurState = State.Change;  			return;  		case 'x':  			if (Data.Caret.Column == Data.Document.GetLine (Data.Caret.Line).Length + 1)  				return;  			Status = string.Empty;  			if (!Data.IsSomethingSelected)  				RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Right)' ClipboardActions.Cut);  			else  				RunAction (ClipboardActions.Cut);  			ViActions.RetreatFromLineEnd (Data);  			return;  		case 'X':  			if (Data.Caret.Column == DocumentLocation.MinColumn)  				return;  			Status = string.Empty;  			if (!Data.IsSomethingSelected && 0 < Caret.Offset)  				RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Left)' ClipboardActions.Cut);  			else  				RunAction (ClipboardActions.Cut);  			return;  		case 'D':  			RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  			return;  		case 'C':  			RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  			goto case 'i';  		case '>':  			Status = ">";  			CurState = State.Indent;  			return;  		case '<':  			Status = "<";  			CurState = State.Unindent;  			return;  		case 'n':  			Search ();  			return;  		case 'N':  			searchBackward = !searchBackward;  			Search ();  			searchBackward = !searchBackward;  			return;  		case 'p':  			PasteAfter (false);  			return;  		case 'P':  			PasteBefore (false);  			return;  		case 's':  			if (!Data.IsSomethingSelected)  				RunAction (SelectionActions.FromMoveAction (CaretMoveActions.Right));  			RunAction (ClipboardActions.Cut);  			goto case 'i';  		case 'S':  			if (!Data.IsSomethingSelected)  				RunAction (SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd));  			else  				Data.SetSelectLines (Data.MainSelection.Anchor.Line' Data.Caret.Line);  			RunAction (ClipboardActions.Cut);  			goto case 'i';  		case 'g':  			Status = "g";  			CurState = State.G;  			return;  		case 'G':  			RunAction (marks ['`'].SaveMark);  			if (repeatCount > 1) {  				Caret.Line = repeatCount;  			} else {  				//RunAction (CaretMoveActions.ToDocumentEnd);  				RunAction (ToDocumentEnd);  			}  			Reset (string.Empty);  			return;  		case 'H':  			Caret.Line = System.Math.Max (DocumentLocation.MinLine' Editor.PointToLocation (0' Editor.LineHeight - 1).Line);  			return;  		case 'J':  			RunAction (ViActions.Join);  			return;  		case 'L':  			int line = Editor.PointToLocation (0' Editor.Allocation.Height - Editor.LineHeight * 2 - 2).Line;  			if (line < DocumentLocation.MinLine)  				line = Document.LineCount;  			Caret.Line = line;  			return;  		case 'M':  			line = Editor.PointToLocation (0' Editor.Allocation.Height / 2).Line;  			if (line < DocumentLocation.MinLine)  				line = Document.LineCount;  			Caret.Line = line;  			return;  		case '~':  			RunAction (ViActions.ToggleCase);  			return;  		case 'z':  			Status = "z";  			CurState = State.Fold;  			return;  		case 'm':  			Status = "m";  			CurState = State.Mark;  			return;  		case '`':  			Status = "`";  			CurState = State.GoToMark;  			return;  		case '@':  			Status = "@";  			CurState = State.PlayMacro;  			return;  		case 'q':  			if (currentMacro == null) {  				Status = "q";  				CurState = State.NameMacro;  				return;  			}  			currentMacro = null;  			Reset ("Macro Recorded");  			return;  		case '*':  			SearchWordAtCaret (backward: false);  			return;  		case '#':  			SearchWordAtCaret (backward: true);  			return;  		case '.':  			RepeatLastAction ();  			return;  		}  	}  	//				if (Data == null)  	//					Console.WriteLine ("ViMode.HandleKeypress: after State.Normal block' Data is null");  	action = GetNavCharAction ((char)unicodeKey' true);  	if (action == null) {  		action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	}  	if (action == null) {  		action = ViActionMaps.GetCommandCharAction ((char)unicodeKey);  	}  	if (action != null) {  		RunRepeatableAction (action);  	}  	//				if (Data == null)  	//					Console.WriteLine ("ViMode.HandleKeypress: right before CheckVisualMode' Data is null");  	//undo/redo may leave MD with a selection mode without activating visual mode  	CheckVisualMode ();  	return;  case State.Delete:  	if (IsInnerOrOuterMotionKey (unicodeKey' ref motion))  		return;  	int offsetz = Caret.Offset;  	if (motion != Motion.None) {  		action = ViActionMaps.GetEditObjectCharAction ((char)unicodeKey' motion);  	} else if (((modifier & (Gdk.ModifierType.ShiftMask | Gdk.ModifierType.ControlMask)) == 0 && (unicodeKey == 'd' || unicodeKey == 'j' || unicodeKey == 'k'))) {  		if (unicodeKey == 'k') {  			action = CaretMoveActions.Up;  		} else {  			action = CaretMoveActions.Down;  		}  		if (unicodeKey == 'j') {  			repeatCount += 1;  		}  		//get one extra line for yj  		lineAction = true;  	} else {  		action = GetNavCharAction ((char)unicodeKey' false);  		if (action == null)  			action = ViActionMaps.GetDirectionKeyAction (key' modifier);  		if (action != null)  			action = SelectionActions.FromMoveAction (action);  	}  	if (action != null) {  		if (lineAction) {  			RunAction (CaretMoveActions.LineStart);  			SelectionActions.StartSelection (Data);  			for (int i = 0; i < repeatCount; i++) {  				RunAction (action);  			}  			SelectionActions.EndSelection (Data);  			numericPrefix = "";  		} else {  			RunRepeatableAction (action);  		}  		if (Data.IsSomethingSelected && !lineAction)  			offsetz = Data.SelectionRange.Offset;  		RunAction (ClipboardActions.Cut);  		Reset (string.Empty);  	} else {  		Reset ("Unrecognised motion");  	}  	Caret.Offset = offsetz;  	return;  case State.Yank:  	if (IsInnerOrOuterMotionKey (unicodeKey' ref motion))  		return;  	int offset = Caret.Offset;  	if (motion != Motion.None) {  		action = ViActionMaps.GetEditObjectCharAction ((char)unicodeKey' motion);  	} else if (((modifier & (Gdk.ModifierType.ShiftMask | Gdk.ModifierType.ControlMask)) == 0 && (unicodeKey == 'y' || unicodeKey == 'j' || unicodeKey == 'k'))) {  		if (unicodeKey == 'k') {  			action = CaretMoveActions.Up;  		} else {  			action = CaretMoveActions.Down;  		}  		if (unicodeKey == 'j') {  			repeatCount += 1;  		}  		//get one extra line for yj  		lineAction = true;  	} else {  		action = GetNavCharAction ((char)unicodeKey' false);  		if (action == null)  			action = ViActionMaps.GetDirectionKeyAction (key' modifier);  		if (action != null)  			action = SelectionActions.FromMoveAction (action);  	}  	if (action != null) {  		if (lineAction) {  			RunAction (CaretMoveActions.LineStart);  			SelectionActions.StartSelection (Data);  			for (int i = 0; i < repeatCount; i++) {  				RunAction (action);  			}  			SelectionActions.EndSelection (Data);  			numericPrefix = "";  		} else {  			RunRepeatableAction (action);  		}  		if (Data.IsSomethingSelected && !lineAction)  			offset = Data.SelectionRange.Offset;  		RunAction (ClipboardActions.Copy);  		Reset (string.Empty);  	} else {  		Reset ("Unrecognised motion");  	}  	Caret.Offset = offset;  	return;  case State.Change:  	if (IsInnerOrOuterMotionKey (unicodeKey' ref motion))  		return;  	lastActionStarted = true;  	LastAction.Clear ();  	if (motion != Motion.None) {  		action = ViActionMaps.GetEditObjectCharAction ((char)unicodeKey' motion);  	} //copied from delete action  	else if (((modifier & (Gdk.ModifierType.ShiftMask | Gdk.ModifierType.ControlMask)) == 0 && unicodeKey == 'c')) {  		action = SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd);  		lineAction = true;  	} else {  		action = ViActionMaps.GetEditObjectCharAction ((char)unicodeKey);  		if (action == null)  			action = ViActionMaps.GetDirectionKeyAction (key' modifier);  		if (action != null)  			action = SelectionActions.FromMoveAction (action);  	}  	if (action != null) {  		List<Action<TextEditorData>> actions;  		if (lineAction) {  			//cd or cj  -- delete lines moving downward  			actions = GenerateRepeatedActionList (action' ClipboardActions.Cut' CaretMoveActions.LineFirstNonWhitespace);  			actions.Add (ViActions.NewLineAbove);  		} else if (unicodeKey == 'j') {  			//cj -- delete current line and line below  			repeatCount += 1;  			action = SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd);  			actions = GenerateRepeatedActionList (action' ClipboardActions.Cut' CaretMoveActions.LineFirstNonWhitespace);  			actions.Add (ViActions.NewLineAbove);  		} else if (unicodeKey == 'k') {  			//ck -- delete current line and line above  			repeatCount += 1;  			actions = GenerateRepeatedActionList (CaretMoveActions.LineFirstNonWhitespace' ClipboardActions.Cut' action);  			actions.Add (ViActions.NewLineBelow);  		} else {  			actions = GenerateRepeatedActionList (action);  			actions.Add (ClipboardActions.Cut);  		}  		RunActions (actions.ToArray ());  		LastAction.AddRange (actions);  		Status = "-- INSERT --";  		PrevState = State.Change;  		CurState = State.Insert;  		Caret.Mode = CaretMode.Insert;  	} else {  		Reset ("Unrecognised motion");  	}  	return;  case State.Insert:  case State.Replace:  	action = ViActionMaps.GetInsertKeyAction (key' modifier);  	// Record InsertKeyActions  	if (action != null) {  		RunAction (action);  		InsertBuffer.Add (new Keystroke (key' unicodeKey' modifier));  		return;  	}  	// Clear InsertBuffer if DirectionKeyAction  	action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	if (action != null) {  		RunAction (action);  		InsertBuffer.Clear ();  		return;  	}  	if (unicodeKey != 0) {  		InsertCharacter (unicodeKey);  		InsertBuffer.Add (new Keystroke (key' unicodeKey' modifier));  	}  	return;  case State.VisualLine:  	if (key == Gdk.Key.Delete)  		unicodeKey = 'x';  	switch ((char)unicodeKey) {  	case 'p':  		PasteAfter (true);  		return;  	case 'P':  		PasteBefore (true);  		return;  	}  	action = GetNavCharAction ((char)unicodeKey' false);  	if (action == null) {  		action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	}  	if (action == null) {  		action = ViActionMaps.GetCommandCharAction ((char)unicodeKey);  	}  	if (action != null) {  		RunAction (SelectionActions.LineActionFromMoveAction (action));  		return;  	}  	ApplyActionToSelection (modifier' unicodeKey);  	return;  case State.Visual:  	if (IsInnerOrOuterMotionKey (unicodeKey' ref motion))  		return;  	if (motion != Motion.None) {  		action = ViActionMaps.GetEditObjectCharAction ((char)unicodeKey' motion);  		if (action != null) {  			RunAction (action);  			return;  		}  	}  	if (key == Gdk.Key.Delete)  		unicodeKey = 'x';  	switch ((char)unicodeKey) {  	case 'p':  		PasteAfter (false);  		return;  	case 'P':  		PasteBefore (false);  		return;  	}  	action = GetNavCharAction ((char)unicodeKey' false);  	if (action == null) {  		action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	}  	if (action == null) {  		action = ViActionMaps.GetCommandCharAction ((char)unicodeKey);  	}  	if (action != null) {  		RunAction (ViActions.VisualSelectionFromMoveAction (action));  		return;  	}  	ApplyActionToSelection (modifier' unicodeKey);  	return;  case State.Command:  	switch (key) {  	case Gdk.Key.Return:  	case Gdk.Key.KP_Enter:  		Status = RunExCommand (commandBuffer.ToString ());  		commandBuffer.Length = 0;  		//CurState = State.Normal;  		break;  	case Gdk.Key.BackSpace:  	case Gdk.Key.Delete:  	case Gdk.Key.KP_Delete:  		if (0 < commandBuffer.Length) {  			commandBuffer.Remove (commandBuffer.Length - 1' 1);  			Status = commandBuffer.ToString ();  			if (0 == commandBuffer.Length)  				Reset (Status);  		}  		break;  	default:  		if (unicodeKey != 0) {  			commandBuffer.Append ((char)unicodeKey);  			Status = commandBuffer.ToString ();  		}  		break;  	}  	return;  case State.WriteChar:  	if (unicodeKey != 0) {  		RunAction (SelectionActions.StartSelection);  		int roffset = Data.SelectionRange.Offset;  		InsertCharacter ((char)unicodeKey);  		Reset (string.Empty);  		Caret.Offset = roffset;  	} else {  		Reset ("Keystroke was not a character");  	}  	return;  case State.Indent:  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0 && unicodeKey == '>')) {  		//select current line to indent  		Action<TextEditorData> indentAction = MakeIndentAction (repeatCount);  		StartNewLastAction (indentAction);  		RunAction (indentAction);  		return;  	}  	action = GetNavCharAction ((char)unicodeKey' false);  	if (action == null)  		action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	if (action != null) {  		// TODO: Stuff this into a delegate and go   		var linesToIndent = repeatCount;  		Action<TextEditorData> indentAction = delegate (TextEditorData data) {  			List<Action<TextEditorData>> actions = new List<Action<TextEditorData>> ();  			//get away from LineBegin  			RunAction (CaretMoveActions.LineFirstNonWhitespace);  			int roffset = Data.SelectionRange.Offset;  			actions.Add (ViActions.Right);  			for (int i = 0; i < linesToIndent; i++) {  				actions.Add (SelectionActions.FromMoveAction (action));  			}  			actions.Add (MiscActions.IndentSelection);  			RunActions (actions.ToArray ());  			//set cursor to start of first line indented  			Caret.Offset = roffset;  			RunAction (CaretMoveActions.LineFirstNonWhitespace);  			Reset ("");  		};  		StartNewLastAction (indentAction);  		RunAction (indentAction);  	} else {  		Reset ("Unrecognised motion");  	}  	return;  case State.Unindent:  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0 && ((char)unicodeKey) == '<')) {  		//select current line to indent  		// TODO: Stuff this into a delegate and go  		Action<TextEditorData> unindentAction = MakeUnindentAction (repeatCount);  		StartNewLastAction (unindentAction);  		RunAction (unindentAction);  		return;  	}  	action = GetNavCharAction ((char)unicodeKey' false);  	if (action == null)  		action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	if (action != null) {  		// TODO: Stuff this into a delegate and go  		var linesToUnindent = repeatCount;  		Action<TextEditorData> unindentAction = delegate (TextEditorData data) {  			List<Action<TextEditorData>> actions = new List<Action<TextEditorData>> ();  			RunAction (CaretMoveActions.LineFirstNonWhitespace);  			int roffset = Data.SelectionRange.Offset;  			//get away from LineBegin  			actions.Add (ViActions.Right);  			for (int i = 0; i < linesToUnindent; i++) {  				actions.Add (SelectionActions.FromMoveAction (action));  			}  			actions.Add (MiscActions.RemoveIndentSelection);  			RunActions (actions.ToArray ());  			//set cursor to start of first line indented  			Caret.Offset = roffset;  			RunAction (CaretMoveActions.LineFirstNonWhitespace);  			Reset ("");  		};  		StartNewLastAction (unindentAction);  		RunAction (unindentAction);  	} else {  		Reset ("Unrecognised motion");  	}  	return;  case State.G:  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0)) {  		switch ((char)unicodeKey) {  		case 'g':  			RunAction (marks ['`'].SaveMark);  			Caret.Offset = 0;  			Reset ("");  			return;  		}  	}  	Reset ("Unknown command");  	return;  case State.Mark: {  	char k = (char)unicodeKey;  	ViMark mark = null;  	if (!char.IsLetterOrDigit (k) && !SpecialMarks.Contains (k)) {  		Reset ("Invalid Mark");  		return;  	}  	if (marks.ContainsKey (k)) {  		mark = marks [k];  	} else {  		mark = new ViMark (k);  		marks [k] = mark;  	}  	RunAction (mark.SaveMark);  	Reset ("");  	return;  }  case State.NameMacro: {  	char k = (char)unicodeKey;  	if (!char.IsLetterOrDigit (k)) {  		Reset ("Invalid Macro Name");  		return;  	}  	currentMacro = new ViMacro (k);  	currentMacro.KeysPressed = new Queue<ViMacro.KeySet> ();  	macros [k] = currentMacro;  	Reset ("");  	return;  }  case State.PlayMacro: {  	char k = (char)unicodeKey;  	if (k == '@')  		k = macros_lastplayed;  	if (macros.ContainsKey (k)) {  		int playCount = repeatCount;  		//store repeat count in case macro changes it  		Reset ("");  		macros_lastplayed = k;  		// FIXME play nice when playing macros from inside macros?  		ViMacro macroToPlay = macros [k];  		for (int i = 0; i < playCount; i++) {  			foreach (ViMacro.KeySet keySet in macroToPlay.KeysPressed) {  				HandleKeypress (keySet.Key' keySet.UnicodeKey' keySet.Modifiers);  				// FIXME stop on errors? essential with multipliers and nowrapscan  			}  		}  		/* Once all the keys have been played back' quickly exit. */return;  	} else {  		Reset ("Invalid Macro Name '" + k + "'");  		return;  	}  }  case State.GoToMark: {  	char k = (char)unicodeKey;  	if (marks.ContainsKey (k)) {  		if (k != '`') {  			RunAction (marks ['`'].SaveMark);  		}  		RunAction (marks [k].LoadMark);  		Reset ("");  	} else {  		Reset ("Unknown Mark");  	}  	return;  }  case State.Fold: {  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0)) {  		switch ((char)unicodeKey) {  		case 'A':  			// Recursive fold toggle  			action = FoldActions.ToggleFoldRecursive;  			break;  		case 'C':  			// Recursive fold close  			action = FoldActions.CloseFoldRecursive;  			break;  		case 'M':  			// Close all folds  			action = FoldActions.CloseAllFolds;  			break;  		case 'O':  			// Recursive fold open  			action = FoldActions.OpenFoldRecursive;  			break;  		case 'R':  			// Expand all folds  			action = FoldActions.OpenAllFolds;  			break;  		case 'a':  			// Fold toggle  			action = FoldActions.ToggleFold;  			break;  		case 'c':  			// Fold close  			action = FoldActions.CloseFold;  			break;  		case 'o':  			// Fold open  			action = FoldActions.OpenFold;  			break;  		default:  			Reset ("Unknown command");  			break;  		}  		if (null != action) {  			RunAction (action);  			Reset (string.Empty);  		}  	}  	return;  }  case State.Confirm:  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0)) {  		switch ((char)unicodeKey) {  		case 'y':  			Reset ("Yes");  			break;  		case 'n':  			Reset ("No");  			break;  		}  	}  	return;  }  
Magic Number,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The following statement contains a magic number: if (((modifier & (Gdk.ModifierType.ControlMask)) == 0)) {  	if (key == Gdk.Key.Delete)  		unicodeKey = 'x';  	switch ((char)unicodeKey) {  	case '?':  	case '/':  	case ':':  		CurState = State.Command;  		commandBuffer.Append ((char)unicodeKey);  		Status = commandBuffer.ToString ();  		return;  	case 'A':  		StartNewLastAction (CaretMoveActions.LineEnd);  		RunAction (CaretMoveActions.LineEnd);  		goto case 'i';  	case 'I':  		StartNewLastAction (CaretMoveActions.LineFirstNonWhitespace);  		RunAction (CaretMoveActions.LineFirstNonWhitespace);  		goto case 'i';  	case 'a':  		StartNewLastAction (CaretMoveActions.Right);  		//use CaretMoveActions so that we can move past last character on line end  		RunAction (CaretMoveActions.Right);  		goto case 'i';  	case 'i':  		Caret.Mode = CaretMode.Insert;  		Status = "-- INSERT --";  		CurState = State.Insert;  		return;  	case 'R':  		Caret.Mode = CaretMode.Underscore;  		Status = "-- REPLACE --";  		CurState = State.Replace;  		return;  	case 'V':  		Status = "-- VISUAL LINE --";  		Data.SetSelectLines (Caret.Line' Caret.Line);  		CurState = State.VisualLine;  		return;  	case 'v':  		Status = "-- VISUAL --";  		CurState = State.Visual;  		RunAction (ViActions.VisualSelectionFromMoveAction (ViActions.Right));  		return;  	case 'd':  		Status = "d";  		CurState = State.Delete;  		return;  	case 'y':  		Status = "y";  		CurState = State.Yank;  		return;  	case 'Y':  		CurState = State.Yank;  		HandleKeypress (Gdk.Key.y' (int)'y'' Gdk.ModifierType.None);  		return;  	case 'O':  		StartNewLastAction (ViActions.NewLineAbove);  		RunAction (ViActions.NewLineAbove);  		goto case 'i';  	case 'o':  		StartNewLastAction (ViActions.NewLineBelow);  		RunAction (ViActions.NewLineBelow);  		goto case 'i';  	case 'r':  		Caret.Mode = CaretMode.Underscore;  		Status = "-- REPLACE --";  		CurState = State.WriteChar;  		return;  	case 'c':  		Caret.Mode = CaretMode.Insert;  		Status = "c";  		CurState = State.Change;  		return;  	case 'x':  		if (Data.Caret.Column == Data.Document.GetLine (Data.Caret.Line).Length + 1)  			return;  		Status = string.Empty;  		if (!Data.IsSomethingSelected)  			RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Right)' ClipboardActions.Cut);  		else  			RunAction (ClipboardActions.Cut);  		ViActions.RetreatFromLineEnd (Data);  		return;  	case 'X':  		if (Data.Caret.Column == DocumentLocation.MinColumn)  			return;  		Status = string.Empty;  		if (!Data.IsSomethingSelected && 0 < Caret.Offset)  			RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Left)' ClipboardActions.Cut);  		else  			RunAction (ClipboardActions.Cut);  		return;  	case 'D':  		RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  		return;  	case 'C':  		RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  		goto case 'i';  	case '>':  		Status = ">";  		CurState = State.Indent;  		return;  	case '<':  		Status = "<";  		CurState = State.Unindent;  		return;  	case 'n':  		Search ();  		return;  	case 'N':  		searchBackward = !searchBackward;  		Search ();  		searchBackward = !searchBackward;  		return;  	case 'p':  		PasteAfter (false);  		return;  	case 'P':  		PasteBefore (false);  		return;  	case 's':  		if (!Data.IsSomethingSelected)  			RunAction (SelectionActions.FromMoveAction (CaretMoveActions.Right));  		RunAction (ClipboardActions.Cut);  		goto case 'i';  	case 'S':  		if (!Data.IsSomethingSelected)  			RunAction (SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd));  		else  			Data.SetSelectLines (Data.MainSelection.Anchor.Line' Data.Caret.Line);  		RunAction (ClipboardActions.Cut);  		goto case 'i';  	case 'g':  		Status = "g";  		CurState = State.G;  		return;  	case 'G':  		RunAction (marks ['`'].SaveMark);  		if (repeatCount > 1) {  			Caret.Line = repeatCount;  		} else {  			//RunAction (CaretMoveActions.ToDocumentEnd);  			RunAction (ToDocumentEnd);  		}  		Reset (string.Empty);  		return;  	case 'H':  		Caret.Line = System.Math.Max (DocumentLocation.MinLine' Editor.PointToLocation (0' Editor.LineHeight - 1).Line);  		return;  	case 'J':  		RunAction (ViActions.Join);  		return;  	case 'L':  		int line = Editor.PointToLocation (0' Editor.Allocation.Height - Editor.LineHeight * 2 - 2).Line;  		if (line < DocumentLocation.MinLine)  			line = Document.LineCount;  		Caret.Line = line;  		return;  	case 'M':  		line = Editor.PointToLocation (0' Editor.Allocation.Height / 2).Line;  		if (line < DocumentLocation.MinLine)  			line = Document.LineCount;  		Caret.Line = line;  		return;  	case '~':  		RunAction (ViActions.ToggleCase);  		return;  	case 'z':  		Status = "z";  		CurState = State.Fold;  		return;  	case 'm':  		Status = "m";  		CurState = State.Mark;  		return;  	case '`':  		Status = "`";  		CurState = State.GoToMark;  		return;  	case '@':  		Status = "@";  		CurState = State.PlayMacro;  		return;  	case 'q':  		if (currentMacro == null) {  			Status = "q";  			CurState = State.NameMacro;  			return;  		}  		currentMacro = null;  		Reset ("Macro Recorded");  		return;  	case '*':  		SearchWordAtCaret (backward: false);  		return;  	case '#':  		SearchWordAtCaret (backward: true);  		return;  	case '.':  		RepeatLastAction ();  		return;  	}  }  
Magic Number,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The following statement contains a magic number: if (((modifier & (Gdk.ModifierType.ControlMask)) == 0)) {  	if (key == Gdk.Key.Delete)  		unicodeKey = 'x';  	switch ((char)unicodeKey) {  	case '?':  	case '/':  	case ':':  		CurState = State.Command;  		commandBuffer.Append ((char)unicodeKey);  		Status = commandBuffer.ToString ();  		return;  	case 'A':  		StartNewLastAction (CaretMoveActions.LineEnd);  		RunAction (CaretMoveActions.LineEnd);  		goto case 'i';  	case 'I':  		StartNewLastAction (CaretMoveActions.LineFirstNonWhitespace);  		RunAction (CaretMoveActions.LineFirstNonWhitespace);  		goto case 'i';  	case 'a':  		StartNewLastAction (CaretMoveActions.Right);  		//use CaretMoveActions so that we can move past last character on line end  		RunAction (CaretMoveActions.Right);  		goto case 'i';  	case 'i':  		Caret.Mode = CaretMode.Insert;  		Status = "-- INSERT --";  		CurState = State.Insert;  		return;  	case 'R':  		Caret.Mode = CaretMode.Underscore;  		Status = "-- REPLACE --";  		CurState = State.Replace;  		return;  	case 'V':  		Status = "-- VISUAL LINE --";  		Data.SetSelectLines (Caret.Line' Caret.Line);  		CurState = State.VisualLine;  		return;  	case 'v':  		Status = "-- VISUAL --";  		CurState = State.Visual;  		RunAction (ViActions.VisualSelectionFromMoveAction (ViActions.Right));  		return;  	case 'd':  		Status = "d";  		CurState = State.Delete;  		return;  	case 'y':  		Status = "y";  		CurState = State.Yank;  		return;  	case 'Y':  		CurState = State.Yank;  		HandleKeypress (Gdk.Key.y' (int)'y'' Gdk.ModifierType.None);  		return;  	case 'O':  		StartNewLastAction (ViActions.NewLineAbove);  		RunAction (ViActions.NewLineAbove);  		goto case 'i';  	case 'o':  		StartNewLastAction (ViActions.NewLineBelow);  		RunAction (ViActions.NewLineBelow);  		goto case 'i';  	case 'r':  		Caret.Mode = CaretMode.Underscore;  		Status = "-- REPLACE --";  		CurState = State.WriteChar;  		return;  	case 'c':  		Caret.Mode = CaretMode.Insert;  		Status = "c";  		CurState = State.Change;  		return;  	case 'x':  		if (Data.Caret.Column == Data.Document.GetLine (Data.Caret.Line).Length + 1)  			return;  		Status = string.Empty;  		if (!Data.IsSomethingSelected)  			RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Right)' ClipboardActions.Cut);  		else  			RunAction (ClipboardActions.Cut);  		ViActions.RetreatFromLineEnd (Data);  		return;  	case 'X':  		if (Data.Caret.Column == DocumentLocation.MinColumn)  			return;  		Status = string.Empty;  		if (!Data.IsSomethingSelected && 0 < Caret.Offset)  			RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Left)' ClipboardActions.Cut);  		else  			RunAction (ClipboardActions.Cut);  		return;  	case 'D':  		RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  		return;  	case 'C':  		RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  		goto case 'i';  	case '>':  		Status = ">";  		CurState = State.Indent;  		return;  	case '<':  		Status = "<";  		CurState = State.Unindent;  		return;  	case 'n':  		Search ();  		return;  	case 'N':  		searchBackward = !searchBackward;  		Search ();  		searchBackward = !searchBackward;  		return;  	case 'p':  		PasteAfter (false);  		return;  	case 'P':  		PasteBefore (false);  		return;  	case 's':  		if (!Data.IsSomethingSelected)  			RunAction (SelectionActions.FromMoveAction (CaretMoveActions.Right));  		RunAction (ClipboardActions.Cut);  		goto case 'i';  	case 'S':  		if (!Data.IsSomethingSelected)  			RunAction (SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd));  		else  			Data.SetSelectLines (Data.MainSelection.Anchor.Line' Data.Caret.Line);  		RunAction (ClipboardActions.Cut);  		goto case 'i';  	case 'g':  		Status = "g";  		CurState = State.G;  		return;  	case 'G':  		RunAction (marks ['`'].SaveMark);  		if (repeatCount > 1) {  			Caret.Line = repeatCount;  		} else {  			//RunAction (CaretMoveActions.ToDocumentEnd);  			RunAction (ToDocumentEnd);  		}  		Reset (string.Empty);  		return;  	case 'H':  		Caret.Line = System.Math.Max (DocumentLocation.MinLine' Editor.PointToLocation (0' Editor.LineHeight - 1).Line);  		return;  	case 'J':  		RunAction (ViActions.Join);  		return;  	case 'L':  		int line = Editor.PointToLocation (0' Editor.Allocation.Height - Editor.LineHeight * 2 - 2).Line;  		if (line < DocumentLocation.MinLine)  			line = Document.LineCount;  		Caret.Line = line;  		return;  	case 'M':  		line = Editor.PointToLocation (0' Editor.Allocation.Height / 2).Line;  		if (line < DocumentLocation.MinLine)  			line = Document.LineCount;  		Caret.Line = line;  		return;  	case '~':  		RunAction (ViActions.ToggleCase);  		return;  	case 'z':  		Status = "z";  		CurState = State.Fold;  		return;  	case 'm':  		Status = "m";  		CurState = State.Mark;  		return;  	case '`':  		Status = "`";  		CurState = State.GoToMark;  		return;  	case '@':  		Status = "@";  		CurState = State.PlayMacro;  		return;  	case 'q':  		if (currentMacro == null) {  			Status = "q";  			CurState = State.NameMacro;  			return;  		}  		currentMacro = null;  		Reset ("Macro Recorded");  		return;  	case '*':  		SearchWordAtCaret (backward: false);  		return;  	case '#':  		SearchWordAtCaret (backward: true);  		return;  	case '.':  		RepeatLastAction ();  		return;  	}  }  
Magic Number,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The following statement contains a magic number: if (((modifier & (Gdk.ModifierType.ControlMask)) == 0)) {  	if (key == Gdk.Key.Delete)  		unicodeKey = 'x';  	switch ((char)unicodeKey) {  	case '?':  	case '/':  	case ':':  		CurState = State.Command;  		commandBuffer.Append ((char)unicodeKey);  		Status = commandBuffer.ToString ();  		return;  	case 'A':  		StartNewLastAction (CaretMoveActions.LineEnd);  		RunAction (CaretMoveActions.LineEnd);  		goto case 'i';  	case 'I':  		StartNewLastAction (CaretMoveActions.LineFirstNonWhitespace);  		RunAction (CaretMoveActions.LineFirstNonWhitespace);  		goto case 'i';  	case 'a':  		StartNewLastAction (CaretMoveActions.Right);  		//use CaretMoveActions so that we can move past last character on line end  		RunAction (CaretMoveActions.Right);  		goto case 'i';  	case 'i':  		Caret.Mode = CaretMode.Insert;  		Status = "-- INSERT --";  		CurState = State.Insert;  		return;  	case 'R':  		Caret.Mode = CaretMode.Underscore;  		Status = "-- REPLACE --";  		CurState = State.Replace;  		return;  	case 'V':  		Status = "-- VISUAL LINE --";  		Data.SetSelectLines (Caret.Line' Caret.Line);  		CurState = State.VisualLine;  		return;  	case 'v':  		Status = "-- VISUAL --";  		CurState = State.Visual;  		RunAction (ViActions.VisualSelectionFromMoveAction (ViActions.Right));  		return;  	case 'd':  		Status = "d";  		CurState = State.Delete;  		return;  	case 'y':  		Status = "y";  		CurState = State.Yank;  		return;  	case 'Y':  		CurState = State.Yank;  		HandleKeypress (Gdk.Key.y' (int)'y'' Gdk.ModifierType.None);  		return;  	case 'O':  		StartNewLastAction (ViActions.NewLineAbove);  		RunAction (ViActions.NewLineAbove);  		goto case 'i';  	case 'o':  		StartNewLastAction (ViActions.NewLineBelow);  		RunAction (ViActions.NewLineBelow);  		goto case 'i';  	case 'r':  		Caret.Mode = CaretMode.Underscore;  		Status = "-- REPLACE --";  		CurState = State.WriteChar;  		return;  	case 'c':  		Caret.Mode = CaretMode.Insert;  		Status = "c";  		CurState = State.Change;  		return;  	case 'x':  		if (Data.Caret.Column == Data.Document.GetLine (Data.Caret.Line).Length + 1)  			return;  		Status = string.Empty;  		if (!Data.IsSomethingSelected)  			RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Right)' ClipboardActions.Cut);  		else  			RunAction (ClipboardActions.Cut);  		ViActions.RetreatFromLineEnd (Data);  		return;  	case 'X':  		if (Data.Caret.Column == DocumentLocation.MinColumn)  			return;  		Status = string.Empty;  		if (!Data.IsSomethingSelected && 0 < Caret.Offset)  			RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Left)' ClipboardActions.Cut);  		else  			RunAction (ClipboardActions.Cut);  		return;  	case 'D':  		RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  		return;  	case 'C':  		RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  		goto case 'i';  	case '>':  		Status = ">";  		CurState = State.Indent;  		return;  	case '<':  		Status = "<";  		CurState = State.Unindent;  		return;  	case 'n':  		Search ();  		return;  	case 'N':  		searchBackward = !searchBackward;  		Search ();  		searchBackward = !searchBackward;  		return;  	case 'p':  		PasteAfter (false);  		return;  	case 'P':  		PasteBefore (false);  		return;  	case 's':  		if (!Data.IsSomethingSelected)  			RunAction (SelectionActions.FromMoveAction (CaretMoveActions.Right));  		RunAction (ClipboardActions.Cut);  		goto case 'i';  	case 'S':  		if (!Data.IsSomethingSelected)  			RunAction (SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd));  		else  			Data.SetSelectLines (Data.MainSelection.Anchor.Line' Data.Caret.Line);  		RunAction (ClipboardActions.Cut);  		goto case 'i';  	case 'g':  		Status = "g";  		CurState = State.G;  		return;  	case 'G':  		RunAction (marks ['`'].SaveMark);  		if (repeatCount > 1) {  			Caret.Line = repeatCount;  		} else {  			//RunAction (CaretMoveActions.ToDocumentEnd);  			RunAction (ToDocumentEnd);  		}  		Reset (string.Empty);  		return;  	case 'H':  		Caret.Line = System.Math.Max (DocumentLocation.MinLine' Editor.PointToLocation (0' Editor.LineHeight - 1).Line);  		return;  	case 'J':  		RunAction (ViActions.Join);  		return;  	case 'L':  		int line = Editor.PointToLocation (0' Editor.Allocation.Height - Editor.LineHeight * 2 - 2).Line;  		if (line < DocumentLocation.MinLine)  			line = Document.LineCount;  		Caret.Line = line;  		return;  	case 'M':  		line = Editor.PointToLocation (0' Editor.Allocation.Height / 2).Line;  		if (line < DocumentLocation.MinLine)  			line = Document.LineCount;  		Caret.Line = line;  		return;  	case '~':  		RunAction (ViActions.ToggleCase);  		return;  	case 'z':  		Status = "z";  		CurState = State.Fold;  		return;  	case 'm':  		Status = "m";  		CurState = State.Mark;  		return;  	case '`':  		Status = "`";  		CurState = State.GoToMark;  		return;  	case '@':  		Status = "@";  		CurState = State.PlayMacro;  		return;  	case 'q':  		if (currentMacro == null) {  			Status = "q";  			CurState = State.NameMacro;  			return;  		}  		currentMacro = null;  		Reset ("Macro Recorded");  		return;  	case '*':  		SearchWordAtCaret (backward: false);  		return;  	case '#':  		SearchWordAtCaret (backward: true);  		return;  	case '.':  		RepeatLastAction ();  		return;  	}  }  
Magic Number,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The following statement contains a magic number: switch ((char)unicodeKey) {  case '?':  case '/':  case ':':  	CurState = State.Command;  	commandBuffer.Append ((char)unicodeKey);  	Status = commandBuffer.ToString ();  	return;  case 'A':  	StartNewLastAction (CaretMoveActions.LineEnd);  	RunAction (CaretMoveActions.LineEnd);  	goto case 'i';  case 'I':  	StartNewLastAction (CaretMoveActions.LineFirstNonWhitespace);  	RunAction (CaretMoveActions.LineFirstNonWhitespace);  	goto case 'i';  case 'a':  	StartNewLastAction (CaretMoveActions.Right);  	//use CaretMoveActions so that we can move past last character on line end  	RunAction (CaretMoveActions.Right);  	goto case 'i';  case 'i':  	Caret.Mode = CaretMode.Insert;  	Status = "-- INSERT --";  	CurState = State.Insert;  	return;  case 'R':  	Caret.Mode = CaretMode.Underscore;  	Status = "-- REPLACE --";  	CurState = State.Replace;  	return;  case 'V':  	Status = "-- VISUAL LINE --";  	Data.SetSelectLines (Caret.Line' Caret.Line);  	CurState = State.VisualLine;  	return;  case 'v':  	Status = "-- VISUAL --";  	CurState = State.Visual;  	RunAction (ViActions.VisualSelectionFromMoveAction (ViActions.Right));  	return;  case 'd':  	Status = "d";  	CurState = State.Delete;  	return;  case 'y':  	Status = "y";  	CurState = State.Yank;  	return;  case 'Y':  	CurState = State.Yank;  	HandleKeypress (Gdk.Key.y' (int)'y'' Gdk.ModifierType.None);  	return;  case 'O':  	StartNewLastAction (ViActions.NewLineAbove);  	RunAction (ViActions.NewLineAbove);  	goto case 'i';  case 'o':  	StartNewLastAction (ViActions.NewLineBelow);  	RunAction (ViActions.NewLineBelow);  	goto case 'i';  case 'r':  	Caret.Mode = CaretMode.Underscore;  	Status = "-- REPLACE --";  	CurState = State.WriteChar;  	return;  case 'c':  	Caret.Mode = CaretMode.Insert;  	Status = "c";  	CurState = State.Change;  	return;  case 'x':  	if (Data.Caret.Column == Data.Document.GetLine (Data.Caret.Line).Length + 1)  		return;  	Status = string.Empty;  	if (!Data.IsSomethingSelected)  		RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Right)' ClipboardActions.Cut);  	else  		RunAction (ClipboardActions.Cut);  	ViActions.RetreatFromLineEnd (Data);  	return;  case 'X':  	if (Data.Caret.Column == DocumentLocation.MinColumn)  		return;  	Status = string.Empty;  	if (!Data.IsSomethingSelected && 0 < Caret.Offset)  		RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Left)' ClipboardActions.Cut);  	else  		RunAction (ClipboardActions.Cut);  	return;  case 'D':  	RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  	return;  case 'C':  	RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  	goto case 'i';  case '>':  	Status = ">";  	CurState = State.Indent;  	return;  case '<':  	Status = "<";  	CurState = State.Unindent;  	return;  case 'n':  	Search ();  	return;  case 'N':  	searchBackward = !searchBackward;  	Search ();  	searchBackward = !searchBackward;  	return;  case 'p':  	PasteAfter (false);  	return;  case 'P':  	PasteBefore (false);  	return;  case 's':  	if (!Data.IsSomethingSelected)  		RunAction (SelectionActions.FromMoveAction (CaretMoveActions.Right));  	RunAction (ClipboardActions.Cut);  	goto case 'i';  case 'S':  	if (!Data.IsSomethingSelected)  		RunAction (SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd));  	else  		Data.SetSelectLines (Data.MainSelection.Anchor.Line' Data.Caret.Line);  	RunAction (ClipboardActions.Cut);  	goto case 'i';  case 'g':  	Status = "g";  	CurState = State.G;  	return;  case 'G':  	RunAction (marks ['`'].SaveMark);  	if (repeatCount > 1) {  		Caret.Line = repeatCount;  	} else {  		//RunAction (CaretMoveActions.ToDocumentEnd);  		RunAction (ToDocumentEnd);  	}  	Reset (string.Empty);  	return;  case 'H':  	Caret.Line = System.Math.Max (DocumentLocation.MinLine' Editor.PointToLocation (0' Editor.LineHeight - 1).Line);  	return;  case 'J':  	RunAction (ViActions.Join);  	return;  case 'L':  	int line = Editor.PointToLocation (0' Editor.Allocation.Height - Editor.LineHeight * 2 - 2).Line;  	if (line < DocumentLocation.MinLine)  		line = Document.LineCount;  	Caret.Line = line;  	return;  case 'M':  	line = Editor.PointToLocation (0' Editor.Allocation.Height / 2).Line;  	if (line < DocumentLocation.MinLine)  		line = Document.LineCount;  	Caret.Line = line;  	return;  case '~':  	RunAction (ViActions.ToggleCase);  	return;  case 'z':  	Status = "z";  	CurState = State.Fold;  	return;  case 'm':  	Status = "m";  	CurState = State.Mark;  	return;  case '`':  	Status = "`";  	CurState = State.GoToMark;  	return;  case '@':  	Status = "@";  	CurState = State.PlayMacro;  	return;  case 'q':  	if (currentMacro == null) {  		Status = "q";  		CurState = State.NameMacro;  		return;  	}  	currentMacro = null;  	Reset ("Macro Recorded");  	return;  case '*':  	SearchWordAtCaret (backward: false);  	return;  case '#':  	SearchWordAtCaret (backward: true);  	return;  case '.':  	RepeatLastAction ();  	return;  }  
Magic Number,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The following statement contains a magic number: switch ((char)unicodeKey) {  case '?':  case '/':  case ':':  	CurState = State.Command;  	commandBuffer.Append ((char)unicodeKey);  	Status = commandBuffer.ToString ();  	return;  case 'A':  	StartNewLastAction (CaretMoveActions.LineEnd);  	RunAction (CaretMoveActions.LineEnd);  	goto case 'i';  case 'I':  	StartNewLastAction (CaretMoveActions.LineFirstNonWhitespace);  	RunAction (CaretMoveActions.LineFirstNonWhitespace);  	goto case 'i';  case 'a':  	StartNewLastAction (CaretMoveActions.Right);  	//use CaretMoveActions so that we can move past last character on line end  	RunAction (CaretMoveActions.Right);  	goto case 'i';  case 'i':  	Caret.Mode = CaretMode.Insert;  	Status = "-- INSERT --";  	CurState = State.Insert;  	return;  case 'R':  	Caret.Mode = CaretMode.Underscore;  	Status = "-- REPLACE --";  	CurState = State.Replace;  	return;  case 'V':  	Status = "-- VISUAL LINE --";  	Data.SetSelectLines (Caret.Line' Caret.Line);  	CurState = State.VisualLine;  	return;  case 'v':  	Status = "-- VISUAL --";  	CurState = State.Visual;  	RunAction (ViActions.VisualSelectionFromMoveAction (ViActions.Right));  	return;  case 'd':  	Status = "d";  	CurState = State.Delete;  	return;  case 'y':  	Status = "y";  	CurState = State.Yank;  	return;  case 'Y':  	CurState = State.Yank;  	HandleKeypress (Gdk.Key.y' (int)'y'' Gdk.ModifierType.None);  	return;  case 'O':  	StartNewLastAction (ViActions.NewLineAbove);  	RunAction (ViActions.NewLineAbove);  	goto case 'i';  case 'o':  	StartNewLastAction (ViActions.NewLineBelow);  	RunAction (ViActions.NewLineBelow);  	goto case 'i';  case 'r':  	Caret.Mode = CaretMode.Underscore;  	Status = "-- REPLACE --";  	CurState = State.WriteChar;  	return;  case 'c':  	Caret.Mode = CaretMode.Insert;  	Status = "c";  	CurState = State.Change;  	return;  case 'x':  	if (Data.Caret.Column == Data.Document.GetLine (Data.Caret.Line).Length + 1)  		return;  	Status = string.Empty;  	if (!Data.IsSomethingSelected)  		RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Right)' ClipboardActions.Cut);  	else  		RunAction (ClipboardActions.Cut);  	ViActions.RetreatFromLineEnd (Data);  	return;  case 'X':  	if (Data.Caret.Column == DocumentLocation.MinColumn)  		return;  	Status = string.Empty;  	if (!Data.IsSomethingSelected && 0 < Caret.Offset)  		RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Left)' ClipboardActions.Cut);  	else  		RunAction (ClipboardActions.Cut);  	return;  case 'D':  	RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  	return;  case 'C':  	RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  	goto case 'i';  case '>':  	Status = ">";  	CurState = State.Indent;  	return;  case '<':  	Status = "<";  	CurState = State.Unindent;  	return;  case 'n':  	Search ();  	return;  case 'N':  	searchBackward = !searchBackward;  	Search ();  	searchBackward = !searchBackward;  	return;  case 'p':  	PasteAfter (false);  	return;  case 'P':  	PasteBefore (false);  	return;  case 's':  	if (!Data.IsSomethingSelected)  		RunAction (SelectionActions.FromMoveAction (CaretMoveActions.Right));  	RunAction (ClipboardActions.Cut);  	goto case 'i';  case 'S':  	if (!Data.IsSomethingSelected)  		RunAction (SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd));  	else  		Data.SetSelectLines (Data.MainSelection.Anchor.Line' Data.Caret.Line);  	RunAction (ClipboardActions.Cut);  	goto case 'i';  case 'g':  	Status = "g";  	CurState = State.G;  	return;  case 'G':  	RunAction (marks ['`'].SaveMark);  	if (repeatCount > 1) {  		Caret.Line = repeatCount;  	} else {  		//RunAction (CaretMoveActions.ToDocumentEnd);  		RunAction (ToDocumentEnd);  	}  	Reset (string.Empty);  	return;  case 'H':  	Caret.Line = System.Math.Max (DocumentLocation.MinLine' Editor.PointToLocation (0' Editor.LineHeight - 1).Line);  	return;  case 'J':  	RunAction (ViActions.Join);  	return;  case 'L':  	int line = Editor.PointToLocation (0' Editor.Allocation.Height - Editor.LineHeight * 2 - 2).Line;  	if (line < DocumentLocation.MinLine)  		line = Document.LineCount;  	Caret.Line = line;  	return;  case 'M':  	line = Editor.PointToLocation (0' Editor.Allocation.Height / 2).Line;  	if (line < DocumentLocation.MinLine)  		line = Document.LineCount;  	Caret.Line = line;  	return;  case '~':  	RunAction (ViActions.ToggleCase);  	return;  case 'z':  	Status = "z";  	CurState = State.Fold;  	return;  case 'm':  	Status = "m";  	CurState = State.Mark;  	return;  case '`':  	Status = "`";  	CurState = State.GoToMark;  	return;  case '@':  	Status = "@";  	CurState = State.PlayMacro;  	return;  case 'q':  	if (currentMacro == null) {  		Status = "q";  		CurState = State.NameMacro;  		return;  	}  	currentMacro = null;  	Reset ("Macro Recorded");  	return;  case '*':  	SearchWordAtCaret (backward: false);  	return;  case '#':  	SearchWordAtCaret (backward: true);  	return;  case '.':  	RepeatLastAction ();  	return;  }  
Magic Number,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The following statement contains a magic number: switch ((char)unicodeKey) {  case '?':  case '/':  case ':':  	CurState = State.Command;  	commandBuffer.Append ((char)unicodeKey);  	Status = commandBuffer.ToString ();  	return;  case 'A':  	StartNewLastAction (CaretMoveActions.LineEnd);  	RunAction (CaretMoveActions.LineEnd);  	goto case 'i';  case 'I':  	StartNewLastAction (CaretMoveActions.LineFirstNonWhitespace);  	RunAction (CaretMoveActions.LineFirstNonWhitespace);  	goto case 'i';  case 'a':  	StartNewLastAction (CaretMoveActions.Right);  	//use CaretMoveActions so that we can move past last character on line end  	RunAction (CaretMoveActions.Right);  	goto case 'i';  case 'i':  	Caret.Mode = CaretMode.Insert;  	Status = "-- INSERT --";  	CurState = State.Insert;  	return;  case 'R':  	Caret.Mode = CaretMode.Underscore;  	Status = "-- REPLACE --";  	CurState = State.Replace;  	return;  case 'V':  	Status = "-- VISUAL LINE --";  	Data.SetSelectLines (Caret.Line' Caret.Line);  	CurState = State.VisualLine;  	return;  case 'v':  	Status = "-- VISUAL --";  	CurState = State.Visual;  	RunAction (ViActions.VisualSelectionFromMoveAction (ViActions.Right));  	return;  case 'd':  	Status = "d";  	CurState = State.Delete;  	return;  case 'y':  	Status = "y";  	CurState = State.Yank;  	return;  case 'Y':  	CurState = State.Yank;  	HandleKeypress (Gdk.Key.y' (int)'y'' Gdk.ModifierType.None);  	return;  case 'O':  	StartNewLastAction (ViActions.NewLineAbove);  	RunAction (ViActions.NewLineAbove);  	goto case 'i';  case 'o':  	StartNewLastAction (ViActions.NewLineBelow);  	RunAction (ViActions.NewLineBelow);  	goto case 'i';  case 'r':  	Caret.Mode = CaretMode.Underscore;  	Status = "-- REPLACE --";  	CurState = State.WriteChar;  	return;  case 'c':  	Caret.Mode = CaretMode.Insert;  	Status = "c";  	CurState = State.Change;  	return;  case 'x':  	if (Data.Caret.Column == Data.Document.GetLine (Data.Caret.Line).Length + 1)  		return;  	Status = string.Empty;  	if (!Data.IsSomethingSelected)  		RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Right)' ClipboardActions.Cut);  	else  		RunAction (ClipboardActions.Cut);  	ViActions.RetreatFromLineEnd (Data);  	return;  case 'X':  	if (Data.Caret.Column == DocumentLocation.MinColumn)  		return;  	Status = string.Empty;  	if (!Data.IsSomethingSelected && 0 < Caret.Offset)  		RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Left)' ClipboardActions.Cut);  	else  		RunAction (ClipboardActions.Cut);  	return;  case 'D':  	RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  	return;  case 'C':  	RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  	goto case 'i';  case '>':  	Status = ">";  	CurState = State.Indent;  	return;  case '<':  	Status = "<";  	CurState = State.Unindent;  	return;  case 'n':  	Search ();  	return;  case 'N':  	searchBackward = !searchBackward;  	Search ();  	searchBackward = !searchBackward;  	return;  case 'p':  	PasteAfter (false);  	return;  case 'P':  	PasteBefore (false);  	return;  case 's':  	if (!Data.IsSomethingSelected)  		RunAction (SelectionActions.FromMoveAction (CaretMoveActions.Right));  	RunAction (ClipboardActions.Cut);  	goto case 'i';  case 'S':  	if (!Data.IsSomethingSelected)  		RunAction (SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd));  	else  		Data.SetSelectLines (Data.MainSelection.Anchor.Line' Data.Caret.Line);  	RunAction (ClipboardActions.Cut);  	goto case 'i';  case 'g':  	Status = "g";  	CurState = State.G;  	return;  case 'G':  	RunAction (marks ['`'].SaveMark);  	if (repeatCount > 1) {  		Caret.Line = repeatCount;  	} else {  		//RunAction (CaretMoveActions.ToDocumentEnd);  		RunAction (ToDocumentEnd);  	}  	Reset (string.Empty);  	return;  case 'H':  	Caret.Line = System.Math.Max (DocumentLocation.MinLine' Editor.PointToLocation (0' Editor.LineHeight - 1).Line);  	return;  case 'J':  	RunAction (ViActions.Join);  	return;  case 'L':  	int line = Editor.PointToLocation (0' Editor.Allocation.Height - Editor.LineHeight * 2 - 2).Line;  	if (line < DocumentLocation.MinLine)  		line = Document.LineCount;  	Caret.Line = line;  	return;  case 'M':  	line = Editor.PointToLocation (0' Editor.Allocation.Height / 2).Line;  	if (line < DocumentLocation.MinLine)  		line = Document.LineCount;  	Caret.Line = line;  	return;  case '~':  	RunAction (ViActions.ToggleCase);  	return;  case 'z':  	Status = "z";  	CurState = State.Fold;  	return;  case 'm':  	Status = "m";  	CurState = State.Mark;  	return;  case '`':  	Status = "`";  	CurState = State.GoToMark;  	return;  case '@':  	Status = "@";  	CurState = State.PlayMacro;  	return;  case 'q':  	if (currentMacro == null) {  		Status = "q";  		CurState = State.NameMacro;  		return;  	}  	currentMacro = null;  	Reset ("Macro Recorded");  	return;  case '*':  	SearchWordAtCaret (backward: false);  	return;  case '#':  	SearchWordAtCaret (backward: true);  	return;  case '.':  	RepeatLastAction ();  	return;  }  
Magic Number,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The following statement contains a magic number: line = Editor.PointToLocation (0' Editor.Allocation.Height / 2).Line;  
Magic Number,VimAddin,ViStatusArea,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViStatusArea.cs,OnExposeEvent,The following statement contains a magic number: using (Cairo.Context cr = Gdk.CairoHelper.Create (evnt.Window)) {  	cr.Rectangle (evnt.Region.Clipbox.X' evnt.Region.Clipbox.Y' evnt.Region.Clipbox.Width' evnt.Region.Clipbox.Height);  	cr.SetSourceColor (editor.ColorStyle.PlainText.Background);  	cr.Fill ();  	using (var layout = PangoUtil.CreateLayout (editor)) {  		layout.FontDescription = editor.Options.Font;  		layout.SetText ("000'00-00");  		int minstatusw' minstatush;  		layout.GetPixelSize (out minstatusw' out minstatush);  		var line = editor.GetLine (editor.Caret.Line);  		var visColumn = line.GetVisualColumn (editor.GetTextEditorData ()' editor.Caret.Column);  		if (visColumn != editor.Caret.Column) {  			layout.SetText (editor.Caret.Line + "'" + editor.Caret.Column + "-" + visColumn);  		} else {  			layout.SetText (editor.Caret.Line + "'" + editor.Caret.Column);  		}  		int statusw' statush;  		layout.GetPixelSize (out statusw' out statush);  		statusw = System.Math.Max (statusw' minstatusw);  		statusw += 8;  		cr.MoveTo (Allocation.Width - statusw' 0);  		statusw += 8;  		cr.SetSourceColor (editor.ColorStyle.PlainText.Foreground);  		cr.ShowLayout (layout);  		layout.SetText (statusText ?? "");  		int w' h;  		layout.GetPixelSize (out w' out h);  		var x = System.Math.Min (0' -w + Allocation.Width - editor.TextViewMargin.CharWidth - statusw);  		cr.MoveTo (x' 0);  		cr.SetSourceColor (editor.ColorStyle.PlainText.Foreground);  		cr.ShowLayout (layout);  		if (ShowCaret) {  			#if false  									if (editor.TextViewMargin.caretBlink) { 							cr.Rectangle (w + x' 0' (int)editor.TextViewMargin.CharWidth' (int)editor.LineHeight); 							cr.Fill (); 						} 						#endif  		}  	}  }  
Magic Number,VimAddin,ViStatusArea,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViStatusArea.cs,OnExposeEvent,The following statement contains a magic number: using (Cairo.Context cr = Gdk.CairoHelper.Create (evnt.Window)) {  	cr.Rectangle (evnt.Region.Clipbox.X' evnt.Region.Clipbox.Y' evnt.Region.Clipbox.Width' evnt.Region.Clipbox.Height);  	cr.SetSourceColor (editor.ColorStyle.PlainText.Background);  	cr.Fill ();  	using (var layout = PangoUtil.CreateLayout (editor)) {  		layout.FontDescription = editor.Options.Font;  		layout.SetText ("000'00-00");  		int minstatusw' minstatush;  		layout.GetPixelSize (out minstatusw' out minstatush);  		var line = editor.GetLine (editor.Caret.Line);  		var visColumn = line.GetVisualColumn (editor.GetTextEditorData ()' editor.Caret.Column);  		if (visColumn != editor.Caret.Column) {  			layout.SetText (editor.Caret.Line + "'" + editor.Caret.Column + "-" + visColumn);  		} else {  			layout.SetText (editor.Caret.Line + "'" + editor.Caret.Column);  		}  		int statusw' statush;  		layout.GetPixelSize (out statusw' out statush);  		statusw = System.Math.Max (statusw' minstatusw);  		statusw += 8;  		cr.MoveTo (Allocation.Width - statusw' 0);  		statusw += 8;  		cr.SetSourceColor (editor.ColorStyle.PlainText.Foreground);  		cr.ShowLayout (layout);  		layout.SetText (statusText ?? "");  		int w' h;  		layout.GetPixelSize (out w' out h);  		var x = System.Math.Min (0' -w + Allocation.Width - editor.TextViewMargin.CharWidth - statusw);  		cr.MoveTo (x' 0);  		cr.SetSourceColor (editor.ColorStyle.PlainText.Foreground);  		cr.ShowLayout (layout);  		if (ShowCaret) {  			#if false  									if (editor.TextViewMargin.caretBlink) { 							cr.Rectangle (w + x' 0' (int)editor.TextViewMargin.CharWidth' (int)editor.LineHeight); 							cr.Fill (); 						} 						#endif  		}  	}  }  
Magic Number,VimAddin,ViStatusArea,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViStatusArea.cs,OnExposeEvent,The following statement contains a magic number: using (var layout = PangoUtil.CreateLayout (editor)) {  	layout.FontDescription = editor.Options.Font;  	layout.SetText ("000'00-00");  	int minstatusw' minstatush;  	layout.GetPixelSize (out minstatusw' out minstatush);  	var line = editor.GetLine (editor.Caret.Line);  	var visColumn = line.GetVisualColumn (editor.GetTextEditorData ()' editor.Caret.Column);  	if (visColumn != editor.Caret.Column) {  		layout.SetText (editor.Caret.Line + "'" + editor.Caret.Column + "-" + visColumn);  	} else {  		layout.SetText (editor.Caret.Line + "'" + editor.Caret.Column);  	}  	int statusw' statush;  	layout.GetPixelSize (out statusw' out statush);  	statusw = System.Math.Max (statusw' minstatusw);  	statusw += 8;  	cr.MoveTo (Allocation.Width - statusw' 0);  	statusw += 8;  	cr.SetSourceColor (editor.ColorStyle.PlainText.Foreground);  	cr.ShowLayout (layout);  	layout.SetText (statusText ?? "");  	int w' h;  	layout.GetPixelSize (out w' out h);  	var x = System.Math.Min (0' -w + Allocation.Width - editor.TextViewMargin.CharWidth - statusw);  	cr.MoveTo (x' 0);  	cr.SetSourceColor (editor.ColorStyle.PlainText.Foreground);  	cr.ShowLayout (layout);  	if (ShowCaret) {  		#if false  								if (editor.TextViewMargin.caretBlink) { 							cr.Rectangle (w + x' 0' (int)editor.TextViewMargin.CharWidth' (int)editor.LineHeight); 							cr.Fill (); 						} 						#endif  	}  }  
Magic Number,VimAddin,ViStatusArea,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViStatusArea.cs,OnExposeEvent,The following statement contains a magic number: using (var layout = PangoUtil.CreateLayout (editor)) {  	layout.FontDescription = editor.Options.Font;  	layout.SetText ("000'00-00");  	int minstatusw' minstatush;  	layout.GetPixelSize (out minstatusw' out minstatush);  	var line = editor.GetLine (editor.Caret.Line);  	var visColumn = line.GetVisualColumn (editor.GetTextEditorData ()' editor.Caret.Column);  	if (visColumn != editor.Caret.Column) {  		layout.SetText (editor.Caret.Line + "'" + editor.Caret.Column + "-" + visColumn);  	} else {  		layout.SetText (editor.Caret.Line + "'" + editor.Caret.Column);  	}  	int statusw' statush;  	layout.GetPixelSize (out statusw' out statush);  	statusw = System.Math.Max (statusw' minstatusw);  	statusw += 8;  	cr.MoveTo (Allocation.Width - statusw' 0);  	statusw += 8;  	cr.SetSourceColor (editor.ColorStyle.PlainText.Foreground);  	cr.ShowLayout (layout);  	layout.SetText (statusText ?? "");  	int w' h;  	layout.GetPixelSize (out w' out h);  	var x = System.Math.Min (0' -w + Allocation.Width - editor.TextViewMargin.CharWidth - statusw);  	cr.MoveTo (x' 0);  	cr.SetSourceColor (editor.ColorStyle.PlainText.Foreground);  	cr.ShowLayout (layout);  	if (ShowCaret) {  		#if false  								if (editor.TextViewMargin.caretBlink) { 							cr.Rectangle (w + x' 0' (int)editor.TextViewMargin.CharWidth' (int)editor.LineHeight); 							cr.Fill (); 						} 						#endif  	}  }  
Magic Number,VimAddin,ViStatusArea,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViStatusArea.cs,OnExposeEvent,The following statement contains a magic number: statusw += 8;  
Magic Number,VimAddin,ViStatusArea,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViStatusArea.cs,OnExposeEvent,The following statement contains a magic number: statusw += 8;  
Magic Number,VimAddin,VimAddinOptionsPanelWidget,D:\newReposJune17\alextsui05_VimAddin\VimAddin\VimAddinOptionsPanelWidget.cs,Build,The following statement contains a magic number: w1.X = 14;  
Magic Number,VimAddin,VimAddinOptionsPanelWidget,D:\newReposJune17\alextsui05_VimAddin\VimAddin\VimAddinOptionsPanelWidget.cs,Build,The following statement contains a magic number: w1.Y = 41;  
Magic Number,VimAddin,VimAddinOptionsPanelWidget,D:\newReposJune17\alextsui05_VimAddin\VimAddin\VimAddinOptionsPanelWidget.cs,Build,The following statement contains a magic number: w2.X = 13;  
Magic Number,VimAddin,VimAddinOptionsPanelWidget,D:\newReposJune17\alextsui05_VimAddin\VimAddin\VimAddinOptionsPanelWidget.cs,Build,The following statement contains a magic number: w2.Y = 10;  
Duplicate Code,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The method contains a code clone-set at the following line numbers (starting from the method definition): ((289' 318)' (334' 363))
Missing Default,VimAddin,IdeViMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\IdeViMode.cs,GetInsertAction,The following switch statement is missing a default case: switch (key) {  case Gdk.Key.BackSpace:  	return EditActions.AdvancedBackspace;  case Gdk.Key.Tab:  	return tabAction.Action;  }  
Missing Default,VimAddin,IdeViMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\IdeViMode.cs,RunExCommand,The following switch statement is missing a default case: switch (command [2]) {  case 'n':  	// :cn - jump to next error  	IdeApp.CommandService.DispatchCommand (MonoDevelop.Ide.Commands.ViewCommands.ShowNext);  	return string.Empty;  case 'N':  case 'p':  	// :c[pN] - jump to previous error  	IdeApp.CommandService.DispatchCommand (MonoDevelop.Ide.Commands.ViewCommands.ShowPrevious);  	return string.Empty;  }  
Missing Default,VimAddin,IdeViMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\IdeViMode.cs,HandleKeypress,The following switch statement is missing a default case: switch (key) {  case Gdk.Key.bracketright:  	// ctrl-] => Go to declaration	  	// HACK: since the SourceEditor can't link the Refactoring addin the command is provided as string.  	IdeApp.CommandService.DispatchCommand ("MonoDevelop.Refactoring.RefactoryCommands.GotoDeclaration");  	return;  }  
Missing Default,VimAddin,ViActionMaps,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActionMaps.cs,GetEditObjectCharAction,The following switch statement is missing a default case: switch (c) {  case 'W':  case 'w':  	return ViActions.WordEnd;  case 'B':  case 'b':  	return ViActions.WordStart;  }  
Missing Default,VimAddin,ViActionMaps,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActionMaps.cs,GetNavCharAction,The following switch statement is missing a default case: switch (c) {  case 'h':  	return ViActions.Left;  case 'b':  	return CaretMoveActions.PreviousSubword;  case 'B':  	return CaretMoveActions.PreviousWord;  case 'l':  	return ViActions.Right;  case 'e':  	if (isCommand) {  		return ViActions.NextSubwordEnd;  	} else {  		return ViActions.NextSubwordEndPlus1;  	}  case 'E':  	if (isCommand) {  		return ViActions.NextWordEnd;  	} else {  		return ViActions.NextWordEndPlus1;  	}  case 'w':  	return CaretMoveActions.NextSubword;  case 'W':  	return CaretMoveActions.NextWord;  case 'k':  	return ViActions.Up;  case 'j':  	return ViActions.Down;  case '%':  	return MiscActions.GotoMatchingBracket;  case '0':  	return CaretMoveActions.LineStart;  case '^':  case '_':  	return CaretMoveActions.LineFirstNonWhitespace;  case '$':  	return ViActions.LineEnd;  case 'G':  	return CaretMoveActions.ToDocumentEnd;  case '{':  	return ViActions.MoveToPreviousEmptyLine;  case '}':  	return ViActions.MoveToNextEmptyLine;  }  
Missing Default,VimAddin,ViActionMaps,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActionMaps.cs,GetDirectionKeyAction,The following switch statement is missing a default case: switch (key) {  case Gdk.Key.Left:  case Gdk.Key.KP_Left:  	return ViActions.Left;  case Gdk.Key.Right:  case Gdk.Key.KP_Right:  	return ViActions.Right;  case Gdk.Key.Up:  case Gdk.Key.KP_Up:  	return ViActions.Up;  case Gdk.Key.Down:  case Gdk.Key.KP_Down:  	return ViActions.Down;  //not strictly vi' but more useful IMO  case Gdk.Key.KP_Home:  case Gdk.Key.Home:  	return CaretMoveActions.LineHome;  case Gdk.Key.KP_End:  case Gdk.Key.End:  	return ViActions.LineEnd;  case Gdk.Key.Page_Up:  case Gdk.Key.KP_Page_Up:  	return CaretMoveActions.PageUp;  case Gdk.Key.Page_Down:  case Gdk.Key.KP_Page_Down:  	return CaretMoveActions.PageDown;  }  
Missing Default,VimAddin,ViActionMaps,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActionMaps.cs,GetDirectionKeyAction,The following switch statement is missing a default case: switch (key) {  case Gdk.Key.Left:  case Gdk.Key.KP_Left:  	return CaretMoveActions.PreviousWord;  case Gdk.Key.Right:  case Gdk.Key.KP_Right:  	return CaretMoveActions.NextWord;  case Gdk.Key.Up:  case Gdk.Key.KP_Up:  	return ScrollActions.Up;  // usually bound at IDE level  case Gdk.Key.u:  	return CaretMoveActions.PageUp;  case Gdk.Key.Down:  case Gdk.Key.KP_Down:  	return ScrollActions.Down;  case Gdk.Key.d:  	return CaretMoveActions.PageDown;  case Gdk.Key.KP_Home:  case Gdk.Key.Home:  	return CaretMoveActions.ToDocumentStart;  case Gdk.Key.KP_End:  case Gdk.Key.End:  	return CaretMoveActions.ToDocumentEnd;  }  
Missing Default,VimAddin,ViActionMaps,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActionMaps.cs,GetInsertKeyAction,The following switch statement is missing a default case: switch (key) {  case Gdk.Key.Tab:  	return MiscActions.InsertTab;  case Gdk.Key.Return:  case Gdk.Key.KP_Enter:  	return MiscActions.InsertNewLine;  case Gdk.Key.BackSpace:  	return DeleteActions.Backspace;  case Gdk.Key.Delete:  case Gdk.Key.KP_Delete:  	return DeleteActions.Delete;  case Gdk.Key.Insert:  	return MiscActions.SwitchCaretMode;  }  
Missing Default,VimAddin,ViActionMaps,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActionMaps.cs,GetInsertKeyAction,The following switch statement is missing a default case: switch (key) {  case Gdk.Key.BackSpace:  	return DeleteActions.PreviousWord;  case Gdk.Key.Delete:  case Gdk.Key.KP_Delete:  	return DeleteActions.NextWord;  }  
Missing Default,VimAddin,ViActionMaps,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActionMaps.cs,GetInsertKeyAction,The following switch statement is missing a default case: switch (key) {  case Gdk.Key.Tab:  	return MiscActions.RemoveTab;  case Gdk.Key.BackSpace:  	return DeleteActions.Backspace;  case Gdk.Key.Return:  case Gdk.Key.KP_Enter:  	return MiscActions.InsertNewLine;  }  
Missing Default,VimAddin,ViActionMaps,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViActionMaps.cs,GetCommandCharAction,The following switch statement is missing a default case: switch (c) {  case 'u':  	return MiscActions.Undo;  }  
Missing Default,VimAddin,ViEditor,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViEditor.cs,SetMode,The following switch statement is missing a default case: switch (mode) {  case ViEditorMode.Insert:  	Message = "-- INSERT --";  	editMode.SetCaretMode (CaretMode.Insert);  	break;  case ViEditorMode.Normal:  	editMode.SetCaretMode (CaretMode.Block);  	break;  case ViEditorMode.Replace:  	Message = "-- REPLACE --";  	editMode.SetCaretMode (CaretMode.Underscore);  	break;  }  
Missing Default,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,RunExCommand,The following switch statement is missing a default case: switch (command [0]) {  case ':':  	if (2 > command.Length)  		break;  	int line;  	if (int.TryParse (command.Substring (1)' out line)) {  		if (line < DocumentLocation.MinLine || line > Data.Document.LineCount) {  			return "Invalid line number.";  		} else if (line == 0) {  			RunAction (CaretMoveActions.ToDocumentStart);  			return "Jumped to beginning of document.";  		}  		Data.Caret.Line = line;  		Editor.ScrollToCaret ();  		return string.Format ("Jumped to line {0}."' line);  	}  	switch (command [1]) {  	case 's':  		if (2 == command.Length) {  			if (null == lastPattern || null == lastReplacement)  				return "No stored pattern.";  			// Perform replacement with stored stuff  			command = string.Format (":s/{0}/{1}/"' lastPattern' lastReplacement);  		}  		var match = Regex.Match (command' substMatch' RegexOptions.Compiled);  		if (!(match.Success && match.Groups ["pattern"].Success && match.Groups ["replacement"].Success))  			break;  		return RegexReplace (match);  	case '$':  		if (command.Length == 2) {  			//RunAction (CaretMoveActions.ToDocumentEnd);  			RunAction (ToDocumentEnd);  			return "Jumped to end of document.";  		}  		break;  	}  	if (command.Substring (1) == "test") {  		CurState = State.Confirm;  		var selection = Data.SelectionRange;  		int lineStart' lineEnd;  		int lookaheadOffset = Math.Min (Caret.Offset + 1000' Data.Document.TextLength);  		MiscActions.GetSelectedLines (Data' out lineStart' out lineEnd);  		int roffset = Data.SelectionRange.Offset;  		int linesAhead = Math.Min (LastSelectionRange.Item1' Document.LineCount - Caret.Line);  		//					CaretMoveActions.LineStart(Data);  		SelectionActions.StartSelection (Data);  		if (linesAhead > 1) {  			for (int i = 0; i < linesAhead; ++i) {  				ViActions.Down (Data);  			}  			CaretMoveActions.LineStart (Data);  		}  		DocumentLine lastLine = Document.GetLineByOffset (Caret.Offset);  		int lastLineOffset = Math.Min (LastSelectionRange.Item2' lastLine.EndOffset);  		for (int i = 0; i < lastLineOffset; ++i) {  			ViActions.Right (Data);  		}  		SelectionActions.EndSelection (Data);  		//					SelectionActions.StartSelection (Data);  		//					CaretMoveActions.LineFirstNonWhitespace (Data);  		//					ViActions.Down (Data);  		//					ViActions.Right (Data);  		//					ViActions.Right (Data);  		//					ViActions.Right (Data);  		//					ViActions.Right (Data);  		//					ViActions.Right (Data);  		//					SelectionActions.EndSelection (Data);  		//return string.Format("line range: {0} {1}"' lineStart' lineEnd);  		return string.Format ("s:{0} {1}; ({2}'{3}) ({4}) ({5})"' selection.Offset' selection.Length' LastSelectionRange.Item1' LastSelectionRange.Item2' linesAhead' Data.Document.TextLength);  	}  	break;  // case ':'  case '?':  case '/':  	searchBackward = ('?' == command [0]);  	if (1 < command.Length) {  		Editor.HighlightSearchPattern = true;  		Editor.SearchEngine = new RegexSearchEngine ();  		var pattern = command.Substring (1);  		Editor.SearchPattern = pattern;  		var caseSensitive = pattern.ToCharArray ().Any (c => char.IsUpper (c));  		Editor.SearchEngine.SearchRequest.CaseSensitive = caseSensitive;  	}  	return Search ();  }  
Missing Default,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,RunExCommand,The following switch statement is missing a default case: switch (command [1]) {  case 's':  	if (2 == command.Length) {  		if (null == lastPattern || null == lastReplacement)  			return "No stored pattern.";  		// Perform replacement with stored stuff  		command = string.Format (":s/{0}/{1}/"' lastPattern' lastReplacement);  	}  	var match = Regex.Match (command' substMatch' RegexOptions.Compiled);  	if (!(match.Success && match.Groups ["pattern"].Success && match.Groups ["replacement"].Success))  		break;  	return RegexReplace (match);  case '$':  	if (command.Length == 2) {  		//RunAction (CaretMoveActions.ToDocumentEnd);  		RunAction (ToDocumentEnd);  		return "Jumped to end of document.";  	}  	break;  }  
Missing Default,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The following switch statement is missing a default case: switch ((char)unicodeKey) {  case '?':  case '/':  case ':':  	CurState = State.Command;  	commandBuffer.Append ((char)unicodeKey);  	Status = commandBuffer.ToString ();  	return;  case 'A':  	StartNewLastAction (CaretMoveActions.LineEnd);  	RunAction (CaretMoveActions.LineEnd);  	goto case 'i';  case 'I':  	StartNewLastAction (CaretMoveActions.LineFirstNonWhitespace);  	RunAction (CaretMoveActions.LineFirstNonWhitespace);  	goto case 'i';  case 'a':  	StartNewLastAction (CaretMoveActions.Right);  	//use CaretMoveActions so that we can move past last character on line end  	RunAction (CaretMoveActions.Right);  	goto case 'i';  case 'i':  	Caret.Mode = CaretMode.Insert;  	Status = "-- INSERT --";  	CurState = State.Insert;  	return;  case 'R':  	Caret.Mode = CaretMode.Underscore;  	Status = "-- REPLACE --";  	CurState = State.Replace;  	return;  case 'V':  	Status = "-- VISUAL LINE --";  	Data.SetSelectLines (Caret.Line' Caret.Line);  	CurState = State.VisualLine;  	return;  case 'v':  	Status = "-- VISUAL --";  	CurState = State.Visual;  	RunAction (ViActions.VisualSelectionFromMoveAction (ViActions.Right));  	return;  case 'd':  	Status = "d";  	CurState = State.Delete;  	return;  case 'y':  	Status = "y";  	CurState = State.Yank;  	return;  case 'Y':  	CurState = State.Yank;  	HandleKeypress (Gdk.Key.y' (int)'y'' Gdk.ModifierType.None);  	return;  case 'O':  	StartNewLastAction (ViActions.NewLineAbove);  	RunAction (ViActions.NewLineAbove);  	goto case 'i';  case 'o':  	StartNewLastAction (ViActions.NewLineBelow);  	RunAction (ViActions.NewLineBelow);  	goto case 'i';  case 'r':  	Caret.Mode = CaretMode.Underscore;  	Status = "-- REPLACE --";  	CurState = State.WriteChar;  	return;  case 'c':  	Caret.Mode = CaretMode.Insert;  	Status = "c";  	CurState = State.Change;  	return;  case 'x':  	if (Data.Caret.Column == Data.Document.GetLine (Data.Caret.Line).Length + 1)  		return;  	Status = string.Empty;  	if (!Data.IsSomethingSelected)  		RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Right)' ClipboardActions.Cut);  	else  		RunAction (ClipboardActions.Cut);  	ViActions.RetreatFromLineEnd (Data);  	return;  case 'X':  	if (Data.Caret.Column == DocumentLocation.MinColumn)  		return;  	Status = string.Empty;  	if (!Data.IsSomethingSelected && 0 < Caret.Offset)  		RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Left)' ClipboardActions.Cut);  	else  		RunAction (ClipboardActions.Cut);  	return;  case 'D':  	RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  	return;  case 'C':  	RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  	goto case 'i';  case '>':  	Status = ">";  	CurState = State.Indent;  	return;  case '<':  	Status = "<";  	CurState = State.Unindent;  	return;  case 'n':  	Search ();  	return;  case 'N':  	searchBackward = !searchBackward;  	Search ();  	searchBackward = !searchBackward;  	return;  case 'p':  	PasteAfter (false);  	return;  case 'P':  	PasteBefore (false);  	return;  case 's':  	if (!Data.IsSomethingSelected)  		RunAction (SelectionActions.FromMoveAction (CaretMoveActions.Right));  	RunAction (ClipboardActions.Cut);  	goto case 'i';  case 'S':  	if (!Data.IsSomethingSelected)  		RunAction (SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd));  	else  		Data.SetSelectLines (Data.MainSelection.Anchor.Line' Data.Caret.Line);  	RunAction (ClipboardActions.Cut);  	goto case 'i';  case 'g':  	Status = "g";  	CurState = State.G;  	return;  case 'G':  	RunAction (marks ['`'].SaveMark);  	if (repeatCount > 1) {  		Caret.Line = repeatCount;  	} else {  		//RunAction (CaretMoveActions.ToDocumentEnd);  		RunAction (ToDocumentEnd);  	}  	Reset (string.Empty);  	return;  case 'H':  	Caret.Line = System.Math.Max (DocumentLocation.MinLine' Editor.PointToLocation (0' Editor.LineHeight - 1).Line);  	return;  case 'J':  	RunAction (ViActions.Join);  	return;  case 'L':  	int line = Editor.PointToLocation (0' Editor.Allocation.Height - Editor.LineHeight * 2 - 2).Line;  	if (line < DocumentLocation.MinLine)  		line = Document.LineCount;  	Caret.Line = line;  	return;  case 'M':  	line = Editor.PointToLocation (0' Editor.Allocation.Height / 2).Line;  	if (line < DocumentLocation.MinLine)  		line = Document.LineCount;  	Caret.Line = line;  	return;  case '~':  	RunAction (ViActions.ToggleCase);  	return;  case 'z':  	Status = "z";  	CurState = State.Fold;  	return;  case 'm':  	Status = "m";  	CurState = State.Mark;  	return;  case '`':  	Status = "`";  	CurState = State.GoToMark;  	return;  case '@':  	Status = "@";  	CurState = State.PlayMacro;  	return;  case 'q':  	if (currentMacro == null) {  		Status = "q";  		CurState = State.NameMacro;  		return;  	}  	currentMacro = null;  	Reset ("Macro Recorded");  	return;  case '*':  	SearchWordAtCaret (backward: false);  	return;  case '#':  	SearchWordAtCaret (backward: true);  	return;  case '.':  	RepeatLastAction ();  	return;  }  
Missing Default,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The following switch statement is missing a default case: switch ((char)unicodeKey) {  case 'p':  	PasteAfter (true);  	return;  case 'P':  	PasteBefore (true);  	return;  }  
Missing Default,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The following switch statement is missing a default case: switch ((char)unicodeKey) {  case 'p':  	PasteAfter (false);  	return;  case 'P':  	PasteBefore (false);  	return;  }  
Missing Default,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The following switch statement is missing a default case: switch ((char)unicodeKey) {  case 'g':  	RunAction (marks ['`'].SaveMark);  	Caret.Offset = 0;  	Reset ("");  	return;  }  
Missing Default,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The following switch statement is missing a default case: switch ((char)unicodeKey) {  case 'y':  	Reset ("Yes");  	break;  case 'n':  	Reset ("No");  	break;  }  
Missing Default,VimAddin,ViEditMode,D:\newReposJune17\alextsui05_VimAddin\VimAddin\Mono.TextEditor.Vi\ViMode.cs,ApplyActionToSelection,The following switch statement is missing a default case: switch ((char)unicodeKey) {  case 'x':  case 'd':  	StartNewLastAction (MakeActionToApplyToLastSelection (ClipboardActions.Cut));  	RunAction (ClipboardActions.Cut);  	Reset ("Deleted selection");  	return;  case 'y':  	int offset = Data.SelectionRange.Offset;  	RunAction (ClipboardActions.Copy);  	Reset ("Yanked selection");  	Caret.Offset = offset;  	return;  case 's':  case 'c':  	StartNewLastAction (MakeActionToApplyToLastSelection (ClipboardActions.Cut));  	RunAction (ClipboardActions.Cut);  	Caret.Mode = CaretMode.Insert;  	CurState = State.Insert;  	Status = "-- INSERT --";  	return;  case 'S':  	Data.SetSelectLines (Data.MainSelection.Anchor.Line' Data.Caret.Line);  	goto case 'c';  case '>':  	int roffset = Data.SelectionRange.Offset;  	if (true) {  		int lineStart' lineEnd;  		MiscActions.GetSelectedLines (Data' out lineStart' out lineEnd);  		int lines = lineEnd - lineStart + 1;  		StartNewLastAction (MakeIndentAction (lines));  	}  	RunAction (MiscActions.IndentSelection);  	Caret.Offset = roffset;  	Reset ("");  	return;  case '<':  	roffset = Data.SelectionRange.Offset;  	if (true) {  		int lineStart' lineEnd;  		MiscActions.GetSelectedLines (Data' out lineStart' out lineEnd);  		int lines = lineEnd - lineStart + 1;  		StartNewLastAction (MakeUnindentAction (lines));  	}  	RunAction (MiscActions.RemoveIndentSelection);  	Caret.Offset = roffset;  	Reset ("");  	return;  case ':':  	commandBuffer.Append (":");  	Status = commandBuffer.ToString ();  	CurState = State.Command;  	break;  case 'J':  	StartNewLastAction (MakeActionToApplyToLastSelection (ViActions.Join));  	RunAction (ViActions.Join);  	Reset ("");  	return;  case '~':  	StartNewLastAction (MakeActionToApplyToLastSelection (ViActions.ToggleCase));  	RunAction (ViActions.ToggleCase);  	Reset ("");  	return;  case '=':  	FormatSelection ();  	Reset ("");  	return;  }  
