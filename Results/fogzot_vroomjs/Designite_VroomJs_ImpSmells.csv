Implementation smell,Namespace,Class,File,Method,Description
Complex Method,VroomJs,JsConvert,D:\research\architectureSmells\repos\fogzot_vroomjs\VroomJs\VroomJs\JsConvert.cs,FromJsValue,Cyclomatic complexity of the method is 17
Complex Method,VroomJs,JsConvert,D:\research\architectureSmells\repos\fogzot_vroomjs\VroomJs\VroomJs\JsConvert.cs,ToJsValue,Cyclomatic complexity of the method is 19
Magic Number,VroomJs,JsConvert,D:\research\architectureSmells\repos\fogzot_vroomjs\VroomJs\VroomJs\JsConvert.cs,FromJsValue,The following statement contains a magic number: switch (v.Type)               {                  case JsValueType.Null:                      return null;                    case JsValueType.Boolean:                      return v.I32 != 0;                    case JsValueType.Integer:                      return v.I32;                    case JsValueType.Number:                      return v.Num;                    case JsValueType.String:                      return Marshal.PtrToStringUni(v.Ptr);                    case JsValueType.Date:                      // The formula (v.num * 10000) + 621355968000000000L was taken from a StackOverflow                      // question and should be OK. Then why do we need to compensate by -26748000000000L                      // (a value determined from the failing tests)?!                      return new DateTime((long)(v.Num * 10000) + 621355968000000000L - 26748000000000L);                    case JsValueType.Array: {                      var r = new object[v.Length];                      for (int i=0 ; i < v.Length ; i++) {                          var vi =(JsValue)Marshal.PtrToStructure((v.Ptr + 16*i)' typeof(JsValue));                          r[i] = FromJsValue(vi);                      }                      return r;                  }                    case JsValueType.UnknownError:                      if (v.Ptr != IntPtr.Zero)                          return new JsException(Marshal.PtrToStringUni(v.Ptr));                      return new JsInteropException("unknown error without reason");                    case JsValueType.Error:                      return new JsException(Marshal.PtrToStringUni(v.Ptr));                    case JsValueType.Managed:                      return _engine.KeepAliveGet(v.Index);                    case JsValueType.ManagedError:                      string msg = null;                      if (v.Ptr != IntPtr.Zero)                          msg = Marshal.PtrToStringUni(v.Ptr);                      return new JsException(msg' _engine.KeepAliveGet(v.Index) as Exception);                    case JsValueType.Wrapped:                      return new JsObject(_engine' v.Ptr);                    case JsValueType.WrappedError:                      return new JsException(new JsObject(_engine' v.Ptr));                    default:                      throw new InvalidOperationException("unknown type code: " + v.Type);              }
Magic Number,VroomJs,JsConvert,D:\research\architectureSmells\repos\fogzot_vroomjs\VroomJs\VroomJs\JsConvert.cs,FromJsValue,The following statement contains a magic number: switch (v.Type)               {                  case JsValueType.Null:                      return null;                    case JsValueType.Boolean:                      return v.I32 != 0;                    case JsValueType.Integer:                      return v.I32;                    case JsValueType.Number:                      return v.Num;                    case JsValueType.String:                      return Marshal.PtrToStringUni(v.Ptr);                    case JsValueType.Date:                      // The formula (v.num * 10000) + 621355968000000000L was taken from a StackOverflow                      // question and should be OK. Then why do we need to compensate by -26748000000000L                      // (a value determined from the failing tests)?!                      return new DateTime((long)(v.Num * 10000) + 621355968000000000L - 26748000000000L);                    case JsValueType.Array: {                      var r = new object[v.Length];                      for (int i=0 ; i < v.Length ; i++) {                          var vi =(JsValue)Marshal.PtrToStructure((v.Ptr + 16*i)' typeof(JsValue));                          r[i] = FromJsValue(vi);                      }                      return r;                  }                    case JsValueType.UnknownError:                      if (v.Ptr != IntPtr.Zero)                          return new JsException(Marshal.PtrToStringUni(v.Ptr));                      return new JsInteropException("unknown error without reason");                    case JsValueType.Error:                      return new JsException(Marshal.PtrToStringUni(v.Ptr));                    case JsValueType.Managed:                      return _engine.KeepAliveGet(v.Index);                    case JsValueType.ManagedError:                      string msg = null;                      if (v.Ptr != IntPtr.Zero)                          msg = Marshal.PtrToStringUni(v.Ptr);                      return new JsException(msg' _engine.KeepAliveGet(v.Index) as Exception);                    case JsValueType.Wrapped:                      return new JsObject(_engine' v.Ptr);                    case JsValueType.WrappedError:                      return new JsException(new JsObject(_engine' v.Ptr));                    default:                      throw new InvalidOperationException("unknown type code: " + v.Type);              }
Magic Number,VroomJs,JsConvert,D:\research\architectureSmells\repos\fogzot_vroomjs\VroomJs\VroomJs\JsConvert.cs,FromJsValue,The following statement contains a magic number: switch (v.Type)               {                  case JsValueType.Null:                      return null;                    case JsValueType.Boolean:                      return v.I32 != 0;                    case JsValueType.Integer:                      return v.I32;                    case JsValueType.Number:                      return v.Num;                    case JsValueType.String:                      return Marshal.PtrToStringUni(v.Ptr);                    case JsValueType.Date:                      // The formula (v.num * 10000) + 621355968000000000L was taken from a StackOverflow                      // question and should be OK. Then why do we need to compensate by -26748000000000L                      // (a value determined from the failing tests)?!                      return new DateTime((long)(v.Num * 10000) + 621355968000000000L - 26748000000000L);                    case JsValueType.Array: {                      var r = new object[v.Length];                      for (int i=0 ; i < v.Length ; i++) {                          var vi =(JsValue)Marshal.PtrToStructure((v.Ptr + 16*i)' typeof(JsValue));                          r[i] = FromJsValue(vi);                      }                      return r;                  }                    case JsValueType.UnknownError:                      if (v.Ptr != IntPtr.Zero)                          return new JsException(Marshal.PtrToStringUni(v.Ptr));                      return new JsInteropException("unknown error without reason");                    case JsValueType.Error:                      return new JsException(Marshal.PtrToStringUni(v.Ptr));                    case JsValueType.Managed:                      return _engine.KeepAliveGet(v.Index);                    case JsValueType.ManagedError:                      string msg = null;                      if (v.Ptr != IntPtr.Zero)                          msg = Marshal.PtrToStringUni(v.Ptr);                      return new JsException(msg' _engine.KeepAliveGet(v.Index) as Exception);                    case JsValueType.Wrapped:                      return new JsObject(_engine' v.Ptr);                    case JsValueType.WrappedError:                      return new JsException(new JsObject(_engine' v.Ptr));                    default:                      throw new InvalidOperationException("unknown type code: " + v.Type);              }
Magic Number,VroomJs,JsConvert,D:\research\architectureSmells\repos\fogzot_vroomjs\VroomJs\VroomJs\JsConvert.cs,FromJsValue,The following statement contains a magic number: switch (v.Type)               {                  case JsValueType.Null:                      return null;                    case JsValueType.Boolean:                      return v.I32 != 0;                    case JsValueType.Integer:                      return v.I32;                    case JsValueType.Number:                      return v.Num;                    case JsValueType.String:                      return Marshal.PtrToStringUni(v.Ptr);                    case JsValueType.Date:                      // The formula (v.num * 10000) + 621355968000000000L was taken from a StackOverflow                      // question and should be OK. Then why do we need to compensate by -26748000000000L                      // (a value determined from the failing tests)?!                      return new DateTime((long)(v.Num * 10000) + 621355968000000000L - 26748000000000L);                    case JsValueType.Array: {                      var r = new object[v.Length];                      for (int i=0 ; i < v.Length ; i++) {                          var vi =(JsValue)Marshal.PtrToStructure((v.Ptr + 16*i)' typeof(JsValue));                          r[i] = FromJsValue(vi);                      }                      return r;                  }                    case JsValueType.UnknownError:                      if (v.Ptr != IntPtr.Zero)                          return new JsException(Marshal.PtrToStringUni(v.Ptr));                      return new JsInteropException("unknown error without reason");                    case JsValueType.Error:                      return new JsException(Marshal.PtrToStringUni(v.Ptr));                    case JsValueType.Managed:                      return _engine.KeepAliveGet(v.Index);                    case JsValueType.ManagedError:                      string msg = null;                      if (v.Ptr != IntPtr.Zero)                          msg = Marshal.PtrToStringUni(v.Ptr);                      return new JsException(msg' _engine.KeepAliveGet(v.Index) as Exception);                    case JsValueType.Wrapped:                      return new JsObject(_engine' v.Ptr);                    case JsValueType.WrappedError:                      return new JsException(new JsObject(_engine' v.Ptr));                    default:                      throw new InvalidOperationException("unknown type code: " + v.Type);              }
Magic Number,VroomJs,JsConvert,D:\research\architectureSmells\repos\fogzot_vroomjs\VroomJs\VroomJs\JsConvert.cs,ToJsValue,The following statement contains a magic number: return new JsValue {                   Type = JsValueType.Date'                   Num = (((DateTime)obj).Ticks - 621355968000000000.0 + 26748000000000.0)/10000.0               };
Magic Number,VroomJs,JsConvert,D:\research\architectureSmells\repos\fogzot_vroomjs\VroomJs\VroomJs\JsConvert.cs,ToJsValue,The following statement contains a magic number: return new JsValue {                   Type = JsValueType.Date'                   Num = (((DateTime)obj).Ticks - 621355968000000000.0 + 26748000000000.0)/10000.0               };
Magic Number,VroomJs,JsConvert,D:\research\architectureSmells\repos\fogzot_vroomjs\VroomJs\VroomJs\JsConvert.cs,ToJsValue,The following statement contains a magic number: return new JsValue {                   Type = JsValueType.Date'                   Num = (((DateTime)obj).Ticks - 621355968000000000.0 + 26748000000000.0)/10000.0               };
Magic Number,VroomJs,JsConvert,D:\research\architectureSmells\repos\fogzot_vroomjs\VroomJs\VroomJs\JsConvert.cs,ToJsValue,The following statement contains a magic number: Marshal.StructureToPtr(ToJsValue(array[i])' (v.Ptr + 16*i)' false);
