Implementation smell,Namespace,Class,File,Method,Description
Long Method,NBitcoin,PSBTInput,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTInput.cs,PSBTInput,The method has 113 lines of code.
Long Method,NBitcoin,PSBTInput,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTInput.cs,Serialize,The method has 110 lines of code.
Long Method,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,VerifyScript,The method has 108 lines of code.
Long Method,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,EvalScript,The method has 755 lines of code.
Long Method,NBitcoin,Op,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptReader.cs,GetOpName,The method has 239 lines of code.
Long Method,NBitcoin,Transaction,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,GetSignatureHash,The method has 103 lines of code.
Long Method,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The method has 384 lines of code.
Long Method,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The method has 125 lines of code.
Long Method,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The method has 193 lines of code.
Long Method,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BigInteger,The method has 154 lines of code.
Long Method,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,Divide,The method has 106 lines of code.
Long Method,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToString,The method has 118 lines of code.
Long Method,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Point,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Point.cs,Add,The method has 117 lines of code.
Long Method,NBitcoin.BouncyCastle.Math.EC,FpPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECPoint.cs,Add,The method has 221 lines of code.
Long Method,NBitcoin.BouncyCastle.Math.EC,FpPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECPoint.cs,Twice,The method has 126 lines of code.
Long Method,NBitcoin.BouncyCastle.Math.EC,F2mPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECPoint.cs,Add,The method has 183 lines of code.
Long Method,NBitcoin.BouncyCastle.Math.EC,F2mPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECPoint.cs,Twice,The method has 106 lines of code.
Long Method,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyLD,The method has 133 lines of code.
Long Method,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiply,The method has 133 lines of code.
Long Method,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyAlt,The method has 221 lines of code.
Long Method,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Multiply,The method has 135 lines of code.
Long Method,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModInverse,The method has 112 lines of code.
Long Method,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,Precompute,The method has 115 lines of code.
Long Method,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The method has 162 lines of code.
Long Method,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The method has 162 lines of code.
Long Method,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The method has 103 lines of code.
Long Method,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The method has 232 lines of code.
Long Method,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,ReadWrite,The method has 148 lines of code.
Long Method,NBitcoin.Protocol,NodeConnection,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,BeginListen,The method has 122 lines of code.
Long Method,NBitcoin.Scripting,ScriptExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptExtensions.cs,ToTokens,The method has 145 lines of code.
Complex Method,NBitcoin,GolombRiceFilter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\GolombRiceFilter.cs,MatchAny,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin,PSBT,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PartiallySignedTransaction.cs,PSBT,Cyclomatic complexity of the method is 19
Complex Method,NBitcoin,PSBT,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PartiallySignedTransaction.cs,AddCoins,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin,PSBT,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PartiallySignedTransaction.cs,AddTransactions,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin,PSBT,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PartiallySignedTransaction.cs,ToString,Cyclomatic complexity of the method is 9
Complex Method,NBitcoin,PSBT,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PartiallySignedTransaction.cs,AddScripts,Cyclomatic complexity of the method is 11
Complex Method,NBitcoin,PSBT,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PartiallySignedTransaction.cs,AddKeyPath,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin,PSBT,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PartiallySignedTransaction.cs,RebaseKeyPaths,Cyclomatic complexity of the method is 9
Complex Method,NBitcoin,PSBTCoin,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTCoin.cs,GetSignableCoin,Cyclomatic complexity of the method is 12
Complex Method,NBitcoin,PSBTCoin,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTCoin.cs,HDKeysFor,Cyclomatic complexity of the method is 14
Complex Method,NBitcoin,PSBTInput,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTInput.cs,PSBTInput,Cyclomatic complexity of the method is 31
Complex Method,NBitcoin,PSBTInput,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTInput.cs,UpdateFromCoin,Cyclomatic complexity of the method is 18
Complex Method,NBitcoin,PSBTInput,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTInput.cs,Combine,Cyclomatic complexity of the method is 13
Complex Method,NBitcoin,PSBTInput,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTInput.cs,CheckSanity,Cyclomatic complexity of the method is 22
Complex Method,NBitcoin,PSBTInput,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTInput.cs,Serialize,Cyclomatic complexity of the method is 12
Complex Method,NBitcoin,PSBTInput,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTInput.cs,Write,Cyclomatic complexity of the method is 11
Complex Method,NBitcoin,PSBTInput,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTInput.cs,GetName,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin,PSBTInput,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTInput.cs,TryFinalizeInput,Cyclomatic complexity of the method is 9
Complex Method,NBitcoin,PSBTOutput,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTOutput.cs,PSBTOutput,Cyclomatic complexity of the method is 13
Complex Method,NBitcoin,Wordlist,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP39\Wordlist.cs,GetLanguageFileName,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin,Wordlist,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP39\Wordlist.cs,AutoDetectLanguage,Cyclomatic complexity of the method is 18
Complex Method,NBitcoin,BitcoinStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BitcoinStream.cs,ReadWriteArray,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin,BloomFilter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BloomFilter.cs,IsRelevantAndUpdate,Cyclomatic complexity of the method is 16
Complex Method,NBitcoin,ChainedBlock,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ChainedBlock.cs,GetWorkRequired,Cyclomatic complexity of the method is 13
Complex Method,NBitcoin,ScriptCoin,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Coin.cs,IsCoherent,Cyclomatic complexity of the method is 10
Complex Method,NBitcoin,ConcurrentChain,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ConcurrentChain.cs,EnumerateThisToFork,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,GetGroup,Cyclomatic complexity of the method is 10
Complex Method,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,Register,Cyclomatic complexity of the method is 10
Complex Method,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,Parse,Cyclomatic complexity of the method is 11
Complex Method,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,CreateBase58Data,Cyclomatic complexity of the method is 13
Complex Method,NBitcoin,NetworkSetBase,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\NetworkSet.cs,RegisterDefaultCookiePath,Cyclomatic complexity of the method is 10
Complex Method,NBitcoin,Script,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Script.cs,IsScriptType,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin,Script,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Script.cs,CombineSignatures,Cyclomatic complexity of the method is 9
Complex Method,NBitcoin,Script,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Script.cs,CombineMultisig,Cyclomatic complexity of the method is 14
Complex Method,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,VerifyScript,Cyclomatic complexity of the method is 26
Complex Method,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,VerifyWitnessProgram,Cyclomatic complexity of the method is 15
Complex Method,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,EvalScript,Cyclomatic complexity of the method is 151
Complex Method,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,CompareBigEndian,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,IsValidSignatureEncoding,Cyclomatic complexity of the method is 14
Complex Method,NBitcoin,Op,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptReader.cs,GetOpName,Cyclomatic complexity of the method is 113
Complex Method,NBitcoin,Op,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptReader.cs,GetPushOp,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin,Op,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptReader.cs,PushDataToStream,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin,Op,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptReader.cs,ReadData,Cyclomatic complexity of the method is 12
Complex Method,NBitcoin,ScriptReader,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptReader.cs,TryReadOpCode,Cyclomatic complexity of the method is 9
Complex Method,NBitcoin,SlimChain,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\SlimChain.cs,TrySetTipNoLock,Cyclomatic complexity of the method is 14
Complex Method,NBitcoin,PayToMultiSigTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,CheckScriptPubKeyCore,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin,PayToMultiSigTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,CheckScriptSigCore,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin,OutPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,TryParse,Cyclomatic complexity of the method is 9
Complex Method,NBitcoin,Transaction,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,ReadWrite,Cyclomatic complexity of the method is 11
Complex Method,NBitcoin,Transaction,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,Check,Cyclomatic complexity of the method is 14
Complex Method,NBitcoin,Transaction,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,GetSignatureHash,Cyclomatic complexity of the method is 16
Complex Method,NBitcoin,DefaultCoinSelector,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\TransactionBuilder.cs,Select,Cyclomatic complexity of the method is 13
Complex Method,NBitcoin,TransactionBuilder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\TransactionBuilder.cs,BuildTransaction,Cyclomatic complexity of the method is 10
Complex Method,NBitcoin,TransactionBuilder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\TransactionBuilder.cs,BuildTransaction,Cyclomatic complexity of the method is 16
Complex Method,NBitcoin,TransactionBuilder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\TransactionBuilder.cs,FindSignableCoin,Cyclomatic complexity of the method is 11
Complex Method,NBitcoin,TransactionBuilder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\TransactionBuilder.cs,EstimateScriptSigSize,Cyclomatic complexity of the method is 11
Complex Method,NBitcoin,TransactionBuilder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\TransactionBuilder.cs,Sign,Cyclomatic complexity of the method is 15
Complex Method,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,GetByte,Cyclomatic complexity of the method is 9
Complex Method,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,Comparison,Cyclomatic complexity of the method is 20
Complex Method,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,Comparison,Cyclomatic complexity of the method is 14
Complex Method,NBitcoin,Extensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ReadEx,Cyclomatic complexity of the method is 10
Complex Method,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,TryParseEndpoint,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin.BouncyCastle.Asn1,Asn1InputStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\Asn1InputStream.cs,ReadLength,Cyclomatic complexity of the method is 9
Complex Method,NBitcoin.BouncyCastle.Asn1,DerObjectIdentifier,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\DerObjectIdentifier.cs,MakeOidStringFromBytes,Cyclomatic complexity of the method is 10
Complex Method,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,Cyclomatic complexity of the method is 12
Complex Method,NBitcoin.BouncyCastle.Crypto.Signers,ECDsaSigner,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\signers\ECDsaSigner.cs,VerifySignature,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BigInteger,Cyclomatic complexity of the method is 16
Complex Method,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,MakeMagnitude,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BigInteger,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,Divide,Cyclomatic complexity of the method is 18
Complex Method,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ModPow,Cyclomatic complexity of the method is 9
Complex Method,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ModPowMonty,Cyclomatic complexity of the method is 12
Complex Method,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,Pow,Cyclomatic complexity of the method is 9
Complex Method,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,Remainder,Cyclomatic complexity of the method is 17
Complex Method,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,Remainder,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToByteArray,Cyclomatic complexity of the method is 10
Complex Method,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToString,Cyclomatic complexity of the method is 19
Complex Method,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,Or,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,Xor,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin.BouncyCastle.Math.EC.Abc,Tnaf,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\abc\Tnaf.cs,Round,Cyclomatic complexity of the method is 11
Complex Method,NBitcoin.BouncyCastle.Math.EC.Abc,Tnaf,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\abc\Tnaf.cs,TauAdicWNaf,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Point,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Point.cs,Add,Cyclomatic complexity of the method is 10
Complex Method,NBitcoin.BouncyCastle.Math.EC,ECAlgorithms,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECAlgorithms.cs,ImplSumOfMultiplies,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin.BouncyCastle.Math.EC,ECCurve,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECCurve.cs,DecodePoint,Cyclomatic complexity of the method is 12
Complex Method,NBitcoin.BouncyCastle.Math.EC,FpFieldElement,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECFieldElement.cs,ModReduce,Cyclomatic complexity of the method is 9
Complex Method,NBitcoin.BouncyCastle.Math.EC,ECPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECPoint.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin.BouncyCastle.Math.EC,FpPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECPoint.cs,Add,Cyclomatic complexity of the method is 23
Complex Method,NBitcoin.BouncyCastle.Math.EC,FpPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECPoint.cs,Twice,Cyclomatic complexity of the method is 13
Complex Method,NBitcoin.BouncyCastle.Math.EC,FpPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECPoint.cs,TwicePlus,Cyclomatic complexity of the method is 10
Complex Method,NBitcoin.BouncyCastle.Math.EC,FpPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECPoint.cs,TimesPow2,Cyclomatic complexity of the method is 15
Complex Method,NBitcoin.BouncyCastle.Math.EC,AbstractF2mPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECPoint.cs,SatisfiesCurveEquation,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin.BouncyCastle.Math.EC,F2mPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECPoint.cs,Add,Cyclomatic complexity of the method is 23
Complex Method,NBitcoin.BouncyCastle.Math.EC,F2mPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECPoint.cs,Twice,Cyclomatic complexity of the method is 11
Complex Method,NBitcoin.BouncyCastle.Math.EC,F2mPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECPoint.cs,TwicePlus,Cyclomatic complexity of the method is 9
Complex Method,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,LongArray,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyLD,Cyclomatic complexity of the method is 13
Complex Method,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiply,Cyclomatic complexity of the method is 12
Complex Method,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyAlt,Cyclomatic complexity of the method is 13
Complex Method,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Multiply,Cyclomatic complexity of the method is 12
Complex Method,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModInverse,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,GenerateCompactWindowNaf,Cyclomatic complexity of the method is 10
Complex Method,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,GenerateJsf,Cyclomatic complexity of the method is 10
Complex Method,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,GenerateWindowNaf,Cyclomatic complexity of the method is 9
Complex Method,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,Precompute,Cyclomatic complexity of the method is 14
Complex Method,NBitcoin.BouncyCastle.Math.Raw,Mod,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Mod.cs,Invert,Cyclomatic complexity of the method is 10
Complex Method,NBitcoin.Crypto,ECKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\ECKey.cs,RecoverFromSignature,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin.DataEncoders,Base58Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Base58Encoder.cs,DecodeData,Cyclomatic complexity of the method is 13
Complex Method,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,locate_errors,Cyclomatic complexity of the method is 13
Complex Method,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,DecodeDataCore,Cyclomatic complexity of the method is 9
Complex Method,NBitcoin.OpenAsset,ColoredTransaction,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColoredTransaction.cs,FetchColorsAsync,Cyclomatic complexity of the method is 18
Complex Method,NBitcoin.OpenAsset,ColoredTransaction,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColoredTransaction.cs,ColoredTransaction,Cyclomatic complexity of the method is 19
Complex Method,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,ReadLEB128,Cyclomatic complexity of the method is 11
Complex Method,NBitcoin.Payment,BitcoinUrlBuilder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\BitcoinUrlBuilder.cs,BitcoinUrlBuilder,Cyclomatic complexity of the method is 12
Complex Method,NBitcoin.Payment,PaymentDetails,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentRequest.cs,Load,Cyclomatic complexity of the method is 10
Complex Method,NBitcoin.Payment,PaymentDetails,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentRequest.cs,WriteTo,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin.Payment,PaymentRequest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentRequest.cs,Load,Cyclomatic complexity of the method is 9
Complex Method,System.Web.NBitcoin,HttpUtility,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\HttpUtility.cs,UrlDecode,Cyclomatic complexity of the method is 10
Complex Method,NBitcoin.Policy,MinerTransactionPolicy,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Policy\MinerTransactionPolicy.cs,Check,Cyclomatic complexity of the method is 11
Complex Method,NBitcoin.Policy,StandardTransactionPolicy,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Policy\StandardTransactionPolicy.cs,Check,Cyclomatic complexity of the method is 30
Complex Method,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,ReadWrite,Cyclomatic complexity of the method is 25
Complex Method,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Add_,Cyclomatic complexity of the method is 14
Complex Method,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Check_,Cyclomatic complexity of the method is 29
Complex Method,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Select_,Cyclomatic complexity of the method is 9
Complex Method,NBitcoin.Protocol,Message,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Message.cs,ReadWrite,Cyclomatic complexity of the method is 10
Complex Method,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,Connect,Cyclomatic complexity of the method is 9
Complex Method,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,GetHeadersFromFork,Cyclomatic complexity of the method is 16
Complex Method,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,SynchronizeSlimChain,Cyclomatic complexity of the method is 13
Complex Method,NBitcoin.Protocol,CmpctBlockPayload,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Payloads\CmpctBlockPayload.cs,ReadWriteCore,Cyclomatic complexity of the method is 13
Complex Method,NBitcoin.Protocol,GetBlockTxnPayload,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Payloads\GetBlockTxnPayload.cs,ReadWriteCore,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin.Protocol.Behaviors,BroadcastHubBehavior,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Behaviors\BroadcastTransactionBehavior.cs,AttachedNode_MessageReceived,Cyclomatic complexity of the method is 14
Complex Method,NBitcoin.Protocol.Behaviors,ChainBehavior,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Behaviors\ChainBehavior.cs,Intercept,Cyclomatic complexity of the method is 20
Complex Method,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,RPCClient,Cyclomatic complexity of the method is 9
Complex Method,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,SendBatchAsyncCore,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,SendCommandAsyncCore,Cyclomatic complexity of the method is 10
Complex Method,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,SignRawTransactionWithKeyAsync,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,WalletCreateFundedPSBTAsync,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin.RPC,RPCException,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCException.cs,FindMessage,Cyclomatic complexity of the method is 12
Complex Method,NBitcoin.RPC,SatoshiFormatter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\SatoshiFormatter.cs,WriteTransaction,Cyclomatic complexity of the method is 9
Complex Method,NBitcoin.Scripting,ParserUtil,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ParserUtil.cs,SafeSplit,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin.Scripting,ScriptExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptExtensions.cs,ToTokens,Cyclomatic complexity of the method is 46
Complex Method,NBitcoin.Scripting,ScriptToken,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptToken.cs,ToString,Cyclomatic complexity of the method is 29
Complex Method,NBitcoin.Scripting,ScriptToken,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptToken.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin.Socks,SocksException,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksException.cs,GetMessageForCode,Cyclomatic complexity of the method is 10
Complex Method,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,CreateConnectMessage,Cyclomatic complexity of the method is 8
Complex Method,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,Handshake,Cyclomatic complexity of the method is 16
Complex Method,NBitcoin.Stealth,StealthPayment,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Stealth\StealthPayment.cs,GetPayments,Cyclomatic complexity of the method is 10
Long Parameter List,NBitcoin,GolombRiceFilter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\GolombRiceFilter.cs,ConstructHashedSet,The method has 6 parameters. Parameters: P' n' m' key' data' dataCount
Long Parameter List,NBitcoin,ExtKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP32\ExtKey.cs,ExtKey,The method has 5 parameters. Parameters: key' chainCode' depth' fingerprint' child
Long Parameter List,NBitcoin,ExtKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP32\ExtKey.cs,ExtKey,The method has 5 parameters. Parameters: key' chainCode' depth' fingerprint' child
Long Parameter List,NBitcoin,ExtPubKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP32\ExtPubKey.cs,ExtPubKey,The method has 5 parameters. Parameters: pubkey' chainCode' depth' fingerprint' child
Long Parameter List,NBitcoin,ScriptCoin,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Coin.cs,ScriptCoin,The method has 5 parameters. Parameters: txHash' outputIndex' amount' scriptPubKey' redeem
Long Parameter List,NBitcoin,StealthCoin,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Coin.cs,StealthCoin,The method has 5 parameters. Parameters: outpoint' txOut' redeem' stealthMetadata' address
Long Parameter List,NBitcoin,BitcoinSerializableExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IBitcoinSerializable.cs,ReadWrite,The method has 5 parameters. Parameters: serializable' stream' serializing' network' version
Long Parameter List,NBitcoin,BitcoinSerializableExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IBitcoinSerializable.cs,ReadWrite,The method has 5 parameters. Parameters: serializable' stream' serializing' consensusFactory' version
Long Parameter List,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,CreateGenesisBlock,The method has 5 parameters. Parameters: nTime' nNonce' nBits' nVersion' genesisReward
Long Parameter List,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,CreateGenesisBlock,The method has 7 parameters. Parameters: pszTimestamp' genesisOutputScript' nTime' nNonce' nBits' nVersion' genesisReward
Long Parameter List,NBitcoin,Script,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Script.cs,VerifyScript,The method has 6 parameters. Parameters: scriptSig' scriptPubKey' tx' i' scriptVerify' sigHash
Long Parameter List,NBitcoin,Script,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Script.cs,VerifyScript,The method has 7 parameters. Parameters: scriptSig' scriptPubKey' tx' i' value' scriptVerify' sigHash
Long Parameter List,NBitcoin,Script,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Script.cs,VerifyScript,The method has 6 parameters. Parameters: scriptSig' tx' i' spentOutput' scriptVerify' sigHash
Long Parameter List,NBitcoin,Script,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Script.cs,VerifyScript,The method has 6 parameters. Parameters: scriptSig' scriptPubKey' tx' i' value' error
Long Parameter List,NBitcoin,Script,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Script.cs,VerifyScript,The method has 5 parameters. Parameters: scriptSig' tx' i' spentOutput' error
Long Parameter List,NBitcoin,Script,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Script.cs,VerifyScript,The method has 6 parameters. Parameters: scriptPubKey' tx' i' value' scriptVerify' sigHash
Long Parameter List,NBitcoin,Script,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Script.cs,VerifyScript,The method has 5 parameters. Parameters: tx' i' spentOutput' scriptVerify' sigHash
Long Parameter List,NBitcoin,Script,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Script.cs,VerifyScript,The method has 5 parameters. Parameters: scriptPubKey' tx' i' value' error
Long Parameter List,NBitcoin,Script,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Script.cs,VerifyScript,The method has 7 parameters. Parameters: scriptPubKey' tx' i' value' scriptVerify' sigHash' error
Long Parameter List,NBitcoin,Script,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Script.cs,VerifyScript,The method has 6 parameters. Parameters: tx' i' spentOutput' scriptVerify' sigHash' error
Long Parameter List,NBitcoin,Script,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Script.cs,VerifyScript,The method has 8 parameters. Parameters: scriptSig' scriptPubKey' tx' i' value' scriptVerify' sigHash' error
Long Parameter List,NBitcoin,Script,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Script.cs,VerifyScript,The method has 7 parameters. Parameters: scriptSig' tx' i' spentOutput' scriptVerify' sigHash' error
Long Parameter List,NBitcoin,Script,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Script.cs,VerifyScriptConsensus,The method has 7 parameters. Parameters: scriptPubKey' scriptPubKeyLen' txTo' txToLen' nIn' flags' err
Long Parameter List,NBitcoin,Script,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Script.cs,VerifyScriptConsensusWithAmount,The method has 8 parameters. Parameters: scriptPubKey' scriptPubKeyLen' amount' txTo' txToLen' nIn' flags' err
Long Parameter List,NBitcoin,Script,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Script.cs,VerifyScriptConsensus,The method has 5 parameters. Parameters: scriptPubKey' tx' nIn' amount' flags
Long Parameter List,NBitcoin,Script,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Script.cs,VerifyScriptConsensus,The method has 5 parameters. Parameters: scriptPubKey' tx' nIn' flags' err
Long Parameter List,NBitcoin,Script,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Script.cs,VerifyScriptConsensus,The method has 6 parameters. Parameters: scriptPubKey' tx' nIn' amount' flags' err
Long Parameter List,NBitcoin,Script,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Script.cs,CombineSignatures,The method has 5 parameters. Parameters: scriptPubKey' transaction' n' scriptSig1' scriptSig2
Long Parameter List,NBitcoin,Script,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Script.cs,CombineSignatures,The method has 5 parameters. Parameters: scriptPubKey' checker' sigs1' sigs2' hashVersion
Long Parameter List,NBitcoin,Script,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Script.cs,CombineMultisig,The method has 5 parameters. Parameters: scriptPubKey' checker' sigs1' sigs2' hashVersion
Long Parameter List,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,VerifyScript,The method has 5 parameters. Parameters: scriptSig' scriptPubKey' txTo' nIn' value
Long Parameter List,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,CompareBigEndian,The method has 5 parameters. Parameters: c1' ic1' c1len' c2' c2len
Long Parameter List,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,CheckSig,The method has 5 parameters. Parameters: signature' pubKey' scriptPubKey' txTo' nIn
Long Parameter List,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,CheckSig,The method has 5 parameters. Parameters: signature' pubKey' scriptPubKey' checker' hashVersion
Long Parameter List,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,CheckSig,The method has 5 parameters. Parameters: vchSig' vchPubKey' scriptCode' txTo' nIn
Long Parameter List,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,CheckSig,The method has 7 parameters. Parameters: vchSig' vchPubKey' scriptCode' txTo' nIn' sigVersion' spentOutput
Long Parameter List,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,CheckSig,The method has 5 parameters. Parameters: vchSig' vchPubKey' scriptCode' checker' sigversion
Long Parameter List,NBitcoin,Transaction,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,GetSignatureHash,The method has 6 parameters. Parameters: scriptCode' nIn' nHashType' spentOutput' sigversion' precomputedTransactionData
Long Parameter List,NBitcoin,Transaction,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,GetSignatureHash,The method has 5 parameters. Parameters: scriptCode' nIn' nHashType' spentOutput' sigversion
Long Parameter List,NBitcoin,DefaultCoinSelector,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\TransactionBuilder.cs,ApproximateBestSubset,The method has 5 parameters. Parameters: groups' nTotalLower' nTargetValue' vfBest' nBest
Long Parameter List,NBitcoin,TransactionBuilder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\TransactionBuilder.cs,BuildTransaction,The method has 5 parameters. Parameters: ctx' group' builders' coins' zero
Long Parameter List,NBitcoin,TransactionSignature,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\TransactionSignature.cs,Check,The method has 5 parameters. Parameters: pubKey' scriptPubKey' tx' nIndex' verify
Long Parameter List,NBitcoin,Extensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ReadEx,The method has 5 parameters. Parameters: stream' buffer' offset' count' cancellation
Long Parameter List,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ArrayEqual,The method has 5 parameters. Parameters: a' startA' b' startB' length
Long Parameter List,NBitcoin.BouncyCastle.Asn1.X9,X9ECParameters,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\x9\X9ECParameters.cs,X9ECParameters,The method has 5 parameters. Parameters: curve' g' n' h' seed
Long Parameter List,NBitcoin.BouncyCastle.Asn1.X9,X9ECParameters,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\x9\X9ECParameters.cs,X9ECParameters,The method has 5 parameters. Parameters: curve' g' n' h' seed
Long Parameter List,NBitcoin.BouncyCastle.Asn1.X9,X9FieldElement,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\x9\X9FieldElement.cs,X9FieldElement,The method has 5 parameters. Parameters: m' k1' k2' k3' s
Long Parameter List,NBitcoin.BouncyCastle.Crypto,BufferedBlockCipher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\BufferedBlockCipher.cs,ProcessBytes,The method has 5 parameters. Parameters: input' inOff' length' output' outOff
Long Parameter List,NBitcoin.BouncyCastle.Crypto,BufferedCipherBase,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\BufferedCipherBase.cs,ProcessBytes,The method has 5 parameters. Parameters: input' inOff' length' output' outOff
Long Parameter List,NBitcoin.BouncyCastle.Crypto,BufferedCipherBase,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\BufferedCipherBase.cs,DoFinal,The method has 5 parameters. Parameters: input' inOff' length' output' outOff
Long Parameter List,NBitcoin.BouncyCastle.Crypto,IBufferedCipher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\IBufferedCipher.cs,ProcessBytes,The method has 5 parameters. Parameters: input' inOff' length' output' outOff
Long Parameter List,NBitcoin.BouncyCastle.Crypto,IBufferedCipher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\IBufferedCipher.cs,DoFinal,The method has 5 parameters. Parameters: input' inOff' length' output' outOff
Long Parameter List,NBitcoin.BouncyCastle.Crypto.Paddings,PaddedBufferedBlockCipher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\paddings\PaddedBufferedBlockCipher.cs,ProcessBytes,The method has 5 parameters. Parameters: input' inOff' length' output' outOff
Long Parameter List,NBitcoin.BouncyCastle.Crypto.Parameters,ECDomainParameters,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\parameters\ECDomainParameters.cs,ECDomainParameters,The method has 5 parameters. Parameters: curve' g' n' h' seed
Long Parameter List,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,LE_To_UInt32,The method has 5 parameters. Parameters: bs' bOff' ns' nOff' count
Long Parameter List,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,MultiplyMonty,The method has 6 parameters. Parameters: a' x' y' m' mDash' smallMontyModulus
Long Parameter List,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,SquareMonty,The method has 5 parameters. Parameters: a' x' m' mDash' smallMontyModulus
Long Parameter List,NBitcoin.BouncyCastle.Math.EC.Abc,Tnaf,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\abc\Tnaf.cs,ApproximateDivisionByN,The method has 6 parameters. Parameters: k' s' vm' a' m' c
Long Parameter List,NBitcoin.BouncyCastle.Math.EC.Abc,Tnaf,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\abc\Tnaf.cs,PartModReduction,The method has 6 parameters. Parameters: k' m' a' s' mu' c
Long Parameter List,NBitcoin.BouncyCastle.Math.EC.Abc,Tnaf,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\abc\Tnaf.cs,TauAdicWNaf,The method has 6 parameters. Parameters: mu' lambda' width' pow2w' tw' alpha
Long Parameter List,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Point,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Point.cs,SecP256K1Point,The method has 5 parameters. Parameters: curve' x' y' zs' withCompression
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,ECAlgorithms,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECAlgorithms.cs,ImplShamirsTrickWNaf,The method has 6 parameters. Parameters: preCompP' preCompNegP' wnafP' preCompQ' preCompNegQ' wnafQ
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,FpCurve,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECCurve.cs,FpCurve,The method has 5 parameters. Parameters: q' a' b' order' cofactor
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,FpCurve,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECCurve.cs,FpCurve,The method has 6 parameters. Parameters: q' r' a' b' order' cofactor
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,F2mCurve,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECCurve.cs,F2mCurve,The method has 6 parameters. Parameters: m' k' a' b' order' cofactor
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,F2mCurve,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECCurve.cs,F2mCurve,The method has 6 parameters. Parameters: m' k1' k2' k3' a' b
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,F2mCurve,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECCurve.cs,F2mCurve,The method has 8 parameters. Parameters: m' k1' k2' k3' a' b' order' cofactor
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,F2mCurve,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECCurve.cs,F2mCurve,The method has 8 parameters. Parameters: m' k1' k2' k3' a' b' order' cofactor
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,F2mFieldElement,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECFieldElement.cs,F2mFieldElement,The method has 5 parameters. Parameters: m' k1' k2' k3' x
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,ECPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECPoint.cs,ECPoint,The method has 5 parameters. Parameters: curve' x' y' zs' withCompression
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,ECPointBase,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECPoint.cs,ECPointBase,The method has 5 parameters. Parameters: curve' x' y' zs' withCompression
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,AbstractFpPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECPoint.cs,AbstractFpPoint,The method has 5 parameters. Parameters: curve' x' y' zs' withCompression
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,FpPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECPoint.cs,FpPoint,The method has 5 parameters. Parameters: curve' x' y' zs' withCompression
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,AbstractF2mPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECPoint.cs,AbstractF2mPoint,The method has 5 parameters. Parameters: curve' x' y' zs' withCompression
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,F2mPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECPoint.cs,F2mPoint,The method has 5 parameters. Parameters: curve' x' y' zs' withCompression
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ShiftUp,The method has 6 parameters. Parameters: x' xOff' z' zOff' count' shift
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,AddShiftedUp,The method has 6 parameters. Parameters: x' xOff' y' yOff' count' shift
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,AddShiftedDown,The method has 6 parameters. Parameters: x' xOff' y' yOff' count' shift
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Add,The method has 5 parameters. Parameters: x' xOff' y' yOff' count
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Add,The method has 7 parameters. Parameters: x' xOff' y' yOff' z' zOff' count
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,AddBoth,The method has 7 parameters. Parameters: x' xOff' y1' y1Off' y2' y2Off' count
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Distribute,The method has 5 parameters. Parameters: x' src' dst1' dst2' count
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,MultiplyWord,The method has 5 parameters. Parameters: a' b' bLen' c' cOff
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ReduceResult,The method has 5 parameters. Parameters: buf' off' len' m' ks
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ReduceInPlace,The method has 5 parameters. Parameters: buf' off' len' m' ks
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ReduceBitWise,The method has 5 parameters. Parameters: buf' off' BitLength' m' ks
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ReduceBit,The method has 5 parameters. Parameters: buf' off' bit' m' ks
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ReduceWordWise,The method has 6 parameters. Parameters: buf' off' len' toBit' m' ks
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ReduceWord,The method has 6 parameters. Parameters: buf' off' bit' word' m' ks
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ReduceVectorWise,The method has 6 parameters. Parameters: buf' off' len' words' m' ks
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,FlipVector,The method has 6 parameters. Parameters: x' xOff' y' yOff' yLen' bits
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave,The method has 6 parameters. Parameters: x' xOff' z' zOff' count' width
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave3,The method has 5 parameters. Parameters: x' xOff' z' zOff' count
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave5,The method has 5 parameters. Parameters: x' xOff' z' zOff' count
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave7,The method has 5 parameters. Parameters: x' xOff' z' zOff' count
Long Parameter List,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave2_n,The method has 6 parameters. Parameters: x' xOff' z' zOff' count' rounds
Long Parameter List,NBitcoin.BouncyCastle.Math.EC.Endo,GlvTypeBParameters,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\endo\GlvTypeBParameters.cs,GlvTypeBParameters,The method has 7 parameters. Parameters: beta' lambda' v1' v2' g1' g2' bits
Long Parameter List,NBitcoin.BouncyCastle.Math.EC.Multiplier,WTauNafMultiplier,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WTauNafMultiplier.cs,MultiplyWTnaf,The method has 5 parameters. Parameters: p' lambda' preCompInfo' a' mu
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Mod,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Mod.cs,InversionStep,The method has 5 parameters. Parameters: p' u' uLen' x' xc
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Add33At,The method has 5 parameters. Parameters: len' x' z' zOff' zPos
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,AddBothTo,The method has 7 parameters. Parameters: len' x' xOff' y' yOff' z' zOff
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,AddDWordAt,The method has 5 parameters. Parameters: len' x' z' zOff' zPos
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,AddTo,The method has 5 parameters. Parameters: len' x' xOff' z' zOff
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,AddWordAt,The method has 5 parameters. Parameters: len' x' z' zOff' zPos
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Mul,The method has 7 parameters. Parameters: len' x' xOff' y' yOff' zz' zzOff
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Mul31BothAdd,The method has 7 parameters. Parameters: len' a' x' b' y' z' zOff
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,MulWord,The method has 6 parameters. Parameters: len' x' y' yOff' z' zOff
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,MulWordAddTo,The method has 6 parameters. Parameters: len' x' y' yOff' z' zOff
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,MulWordDwordAddAt,The method has 5 parameters. Parameters: len' x' y' z' zPos
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftDownBit,The method has 6 parameters. Parameters: len' x' xOff' c' z' zOff
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftDownBits,The method has 5 parameters. Parameters: len' z' zOff' bits' c
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftDownBits,The method has 5 parameters. Parameters: len' x' bits' c' z
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftDownBits,The method has 7 parameters. Parameters: len' x' xOff' bits' c' z' zOff
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftUpBit,The method has 6 parameters. Parameters: len' x' xOff' c' z' zOff
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftUpBit64,The method has 6 parameters. Parameters: len' x' xOff' c' z' zOff
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftUpBits,The method has 5 parameters. Parameters: len' z' zOff' bits' c
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftUpBits64,The method has 5 parameters. Parameters: len' z' zOff' bits' c
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftUpBits,The method has 5 parameters. Parameters: len' x' bits' c' z
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftUpBits,The method has 7 parameters. Parameters: len' x' xOff' bits' c' z' zOff
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftUpBits64,The method has 7 parameters. Parameters: len' x' xOff' bits' c' z' zOff
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Square,The method has 5 parameters. Parameters: len' x' xOff' zz' zzOff
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SquareWordAdd,The method has 5 parameters. Parameters: x' xOff' xPos' z' zOff
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Sub,The method has 7 parameters. Parameters: len' x' xOff' y' yOff' z' zOff
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Sub33At,The method has 5 parameters. Parameters: len' x' z' zOff' zPos
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SubBothFrom,The method has 7 parameters. Parameters: len' x' xOff' y' yOff' z' zOff
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SubDWordAt,The method has 5 parameters. Parameters: len' x' z' zOff' zPos
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SubFrom,The method has 5 parameters. Parameters: len' x' xOff' z' zOff
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SubWordAt,The method has 5 parameters. Parameters: len' x' z' zOff' zPos
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The method has 6 parameters. Parameters: x' xOff' y' yOff' z' zOff
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The method has 6 parameters. Parameters: x' xOff' y' yOff' z' zOff
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The method has 5 parameters. Parameters: x' xOff' z' zOff' cIn
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Diff,The method has 6 parameters. Parameters: x' xOff' y' yOff' z' zOff
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The method has 6 parameters. Parameters: x' xOff' y' yOff' zz' zzOff
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The method has 6 parameters. Parameters: x' xOff' y' yOff' zz' zzOff
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33Add,The method has 7 parameters. Parameters: w' x' xOff' y' yOff' z' zOff
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordAddTo,The method has 5 parameters. Parameters: x' y' yOff' z' zOff
Long Parameter List,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The method has 6 parameters. Parameters: x' xOff' y' yOff' z' zOff
Long Parameter List,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The method has 5 parameters. Parameters: rounds' input' inputOffset' output' outputOffset
Long Parameter List,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,ComputeDerivedKey,The method has 7 parameters. Parameters: key' salt' cost' blockSize' parallel' maxThreads' derivedKeyLength
Long Parameter List,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,GetEffectivePbkdf2Salt,The method has 6 parameters. Parameters: key' salt' cost' blockSize' parallel' maxThreads
Long Parameter List,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,GetStream,The method has 6 parameters. Parameters: key' salt' cost' blockSize' parallel' maxThreads
Long Parameter List,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,MFcrypt,The method has 6 parameters. Parameters: P' S' cost' blockSize' parallel' maxThreads
Long Parameter List,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,ThreadSMixCalls,The method has 6 parameters. Parameters: B0' MFLen' cost' blockSize' parallel' maxThreads
Long Parameter List,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,SMix,The method has 6 parameters. Parameters: B' Boffset' Bp' Bpoffset' N' r
Long Parameter List,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,BlockMix,The method has 8 parameters. Parameters: B' Boffset' Bp' Bpoffset' x' y' scratch' r
Long Parameter List,NBitcoin.DataEncoders,Base32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Base32Encoder.cs,ConvertBits,The method has 7 parameters. Parameters: outfn' val' valOffset' valCount' frombits' tobits' pad
Long Parameter List,NBitcoin.Logging,NullLogger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Logging\Logs.cs,Log,The method has 5 parameters. Parameters: logLevel' eventId' state' exception' formatter
Long Parameter List,NBitcoin.Protocol,Message,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Message.cs,ReadNext,The method has 5 parameters. Parameters: socket' network' version' cancellationToken' counter
Long Parameter List,NBitcoin.Protocol,Message,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Message.cs,ReadNext,The method has 6 parameters. Parameters: socket' network' version' cancellationToken' buffer' counter
Long Parameter List,NBitcoin.Protocol,Message,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Message.cs,ReadNext,The method has 5 parameters. Parameters: stream' network' version' cancellationToken' counter
Long Parameter List,NBitcoin.Protocol,Message,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Message.cs,ReadNext,The method has 6 parameters. Parameters: stream' network' version' cancellationToken' buffer' counter
Long Parameter List,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,Connect,The method has 5 parameters. Parameters: network' endpoint' myVersion' isRelay' cancellation
Long Parameter List,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,Connect,The method has 5 parameters. Parameters: network' endpoint' myVersion' isRelay' cancellation
Long Parameter List,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,Node,The method has 5 parameters. Parameters: peer' network' parameters' socket' peerVersion
Long Parameter List,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,SendToAddress,The method has 6 parameters. Parameters: address' amount' commentTx' commentDest' subtractFeeFromAmount' replaceable
Long Parameter List,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,SendToAddress,The method has 6 parameters. Parameters: scriptPubKey' amount' commentTx' commentDest' subtractFeeFromAmount' replaceable
Long Parameter List,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,SendToAddressAsync,The method has 6 parameters. Parameters: scriptPubKey' amount' commentTx' commentDest' subtractFeeFromAmount' replaceable
Long Parameter List,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,SendToAddressAsync,The method has 6 parameters. Parameters: address' amount' commentTx' commentDest' subtractFeeFromAmount' replaceable
Long Parameter List,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,WalletCreateFundedPSBT,The method has 5 parameters. Parameters: inputs' outputs' locktime' options' bip32derivs
Long Parameter List,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,WalletCreateFundedPSBTAsync,The method has 5 parameters. Parameters: inputs' outputs' locktime' options' bip32derivs
Long Parameter List,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,WalletCreateFundedPSBT,The method has 5 parameters. Parameters: inputs' outputs' locktime' options' bip32derivs
Long Parameter List,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,WalletCreateFundedPSBT,The method has 5 parameters. Parameters: inputs' outputs' locktime' options' bip32derivs
Long Parameter List,NBitcoin.Scripting.Parser,Parse,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\Parser\Parse.Char.cs,ChainOperatorRest,The method has 5 parameters. Parameters: firstOperand' op' operand' apply' or
Long Parameter List,NBitcoin.Scripting.Parser,Parse,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\Parser\Parse.Char.cs,ChainRightOperatorRest,The method has 5 parameters. Parameters: lastOperand' op' operand' apply' or
Long Parameter List,NBitcoin.Stealth,BitcoinStealthAddress,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Stealth\BitcoinStealthAddress.cs,BitcoinStealthAddress,The method has 5 parameters. Parameters: scanKey' pubKeys' signatureCount' bitfield' network
Long Identifier,NBitcoin,PSBT,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PartiallySignedTransaction.cs,Clone,The length of the parameter keepOriginalTransactionInformation is 34.
Long Identifier,NBitcoin,Consensus,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,,The length of the parameter _RuleChangeActivationThreshold is 30.
Long Identifier,NBitcoin,Consensus,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,,The length of the parameter _NeverNeedPreviousTxForSigning is 30.
Long Identifier,NBitcoin,Sequence,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Sequence.cs,,The length of the parameter SEQUENCE_LOCKTIME_DISABLE_FLAG is 30.
Long Identifier,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,,The length of the parameter BITCOIN_SIGNED_MESSAGE_HEADER_BYTES is 35.
Long Identifier,NBitcoin.BouncyCastle.Asn1.X9,X9ObjectIdentifiers,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\x9\X9ObjectIdentifiers.cs,,The length of the parameter DHSinglePassStdDHSha1KdfScheme is 30.
Long Identifier,NBitcoin.BouncyCastle.Asn1.X9,X9ObjectIdentifiers,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\x9\X9ObjectIdentifiers.cs,,The length of the parameter DHSinglePassCofactorDHSha1KdfScheme is 35.
Long Identifier,NBitcoin.Payment,PaymentRequest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentRequest.cs,,The length of the parameter _DefaultCertificateServiceProvider is 34.
Long Identifier,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,,The length of the parameter ADDRMAN_TRIED_BUCKETS_PER_GROUP is 31.
Long Identifier,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,,The length of the parameter ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP is 36.
Long Identifier,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,,The length of the parameter ADDRMAN_NEW_BUCKETS_PER_ADDRESS is 31.
Long Identifier,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,,The length of the parameter SelectionMessageNoAuthenticationRequired is 40.
Long Identifier,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,,The length of the parameter SelectionMessageUsernamePassword is 32.
Long Statement,NBitcoin,PSBT,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PartiallySignedTransaction.cs,AddTransactions,The length of the statement  "					if (output.ScriptPubKey.IsScriptType(ScriptType.Witness) || input.RedeemScript?.IsScriptType(ScriptType.Witness) is true)" is 121.
Long Statement,NBitcoin,PSBT,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PartiallySignedTransaction.cs,CoinsFor,The length of the statement  "			return Inputs.CoinsFor(accountHDScriptPubKey' accountKey' accountKeyPath).OfType<PSBTCoin>().Concat(Outputs.CoinsFor(accountHDScriptPubKey' accountKey' accountKeyPath).OfType<PSBTCoin>());" is 188.
Long Statement,NBitcoin,PSBT,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PartiallySignedTransaction.cs,HDKeysFor,The length of the statement  "			return Inputs.HDKeysFor(accountHDScriptPubKey' accountKey' accountKeyPath).OfType<PSBTHDKeyMatch>().Concat(Outputs.HDKeysFor(accountHDScriptPubKey' accountKey' accountKeyPath));" is 177.
Long Statement,NBitcoin,PSBT,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PartiallySignedTransaction.cs,HDKeysFor,The length of the statement  "			return Inputs.HDKeysFor(accountKey' accountKeyPath).OfType<PSBTHDKeyMatch>().Concat(Outputs.HDKeysFor(accountKey' accountKeyPath));" is 131.
Long Statement,NBitcoin,PSBT,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PartiallySignedTransaction.cs,AddKeyPath,The length of the statement  "					((o.GetSignableCoin() ?? coin.TryToScriptCoin(pubkey)) is Coin c && txBuilder.IsCompatibleKeyFromScriptCode(pubkey' c.GetScriptCode())) ||" is 138.
Long Statement,NBitcoin,PSBTCoin,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTCoin.cs,HDKeysFor,The length of the statement  "					if (!hdKey.Value.KeyPath.IsHardenedPath || (accountKey.CanDeriveHardenedPath() && (accountHDScriptPubKey == null || accountHDScriptPubKey.CanDeriveHardenedPath())))" is 164.
Long Statement,NBitcoin,PSBTCoin,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTCoin.cs,HDKeysFor,The length of the statement  "							if (accountHDScriptPubKey == null || accountHDScriptPubKey.Derive(hdKey.Value.KeyPath).ScriptPubKey == coinScriptPubKey)" is 120.
Long Statement,NBitcoin,PSBTCoin,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTCoin.cs,HDKeysFor,The length of the statement  "					// in some cases addresses are generated on a hardened path below the account key (eg. 49'/0'/0'/0'/1') in which case we" is 120.
Long Statement,NBitcoin,PSBTCoin,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTCoin.cs,HDKeysFor,The length of the statement  "					else if (accountKey.CanDeriveHardenedPath() && (accountHDScriptPubKey == null || accountHDScriptPubKey.CanDeriveHardenedPath())) // We can only do this if we can derive hardened paths" is 183.
Long Statement,NBitcoin,PSBTInput,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTInput.cs,UpdateFromCoin,The length of the statement  "						var redeemScript = PayToScriptHashTemplate.Instance.ExtractScriptSigParameters(originalScriptSig' coin.TxOut.ScriptPubKey)?.RedeemScript;" is 137.
Long Statement,NBitcoin,PSBTInput,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTInput.cs,CheckSanity,The length of the statement  "					errors.Add(new PSBTError(Index' "non_witness_utxo does not match the transaction id referenced by the global transaction sign"));" is 129.
Long Statement,NBitcoin,PSBTInput,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTInput.cs,TryFinalizeInput,The length of the statement  "			var coin = this.GetSignableCoin(out var getSignableCoinError) ?? this.GetCoin(); // GetCoin can't be null at this stage." is 120.
Long Statement,NBitcoin,PSBTInput,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTInput.cs,TryFinalizeInput,The length of the statement  "				errors = new List<PSBTError>() { new PSBTError(Index' $"Error while finalizing the input \"{getSignableCoinError ?? ex.Message}\"") };" is 134.
Long Statement,NBitcoin,PSBTInput,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTInput.cs,TryFinalizeInput,The length of the statement  "				errors = new List<PSBTError>() { new PSBTError(Index' $"The finalized input script does not properly validate \"{error}\"") };" is 126.
Long Statement,NBitcoin,PSBTUtils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTUtils.cs,WriteBIP32Derivations,The length of the statement  "				jsonWriter.WritePropertyValue("master_fingerprint"' Encoders.Hex.EncodeData(keypath.Value.MasterFingerprint.ToBytes()));" is 120.
Long Statement,NBitcoin,BitcoinExtKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP32\BitcoinExtKey.cs,Derive,The length of the statement  "				throw new ArgumentException(paramName: nameof(rootedKeyPath)' message: "The rootedKeyPath's fingerprint does not match this ExtKey"); " is 133.
Long Statement,NBitcoin,ExtKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP32\ExtKey.cs,Derive,The length of the statement  "				throw new ArgumentException(paramName: nameof(rootedKeyPath)' message: "The rootedKeyPath's fingerprint does not match this ExtKey"); " is 133.
Long Statement,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptSeed,The length of the statement  "			//AES256Encrypt((encryptedpart1[8...15] + seedb[16...23]) xor derivedhalf1[16...31]' derivedhalf2)' call the 16-byte result encryptedpart2. The "+" operator is concatenation. " is 174.
Long Statement,NBitcoin,BitcoinPassphraseCode,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinPassphraseCode.cs,GenerateEncryptedSecret,The length of the statement  "				return new BitcoinConfirmationCode(Network.NetworkStringParser.GetBase58CheckEncoder().EncodeData(confirmBytes)' Network); " is 122.
Long Statement,NBitcoin,Mnemonic,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP39\Mnemonic.cs,ToInt,The length of the statement  "			//literally picture this loop as going from the most significant bit across to the least in the 11 bits' dividing by 2 for each bit as per binary/base 2 " is 152.
Long Statement,NBitcoin,Mnemonic,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP39\Mnemonic.cs,SupportOsNormalization,The length of the statement  "						_SupportOSNormalization = notNormalized.Normalize(NormalizationForm.FormKD).Equals(normalized' StringComparison.Ordinal); " is 121.
Long Statement,NBitcoin,Mnemonic,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP39\Mnemonic.cs,Concat,The length of the statement  "			//Most efficient way to merge two arrays this according to http://stackoverflow.com/questions/415291/best-way-to-combine-two-or-more-byte-arrays-in-c-sharp " is 155.
Long Statement,NBitcoin,Wordlist,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP39\Wordlist.cs,ToIndices,The length of the statement  "					throw new FormatException("Word " + words[i] + " is not in the wordlist for this language' cannot continue to rebuild entropy from wordlist"); " is 142.
Long Statement,NBitcoin,ChainedBlock,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ChainedBlock.cs,GetWorkRequired,The length of the statement  "						while (pindex.Previous != null && (pindex.Height % consensus.DifficultyAdjustmentInterval) != 0 && pindex.Header.Bits == nProofOfWorkLimit) " is 139.
Long Statement,NBitcoin,StealthCoin,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Coin.cs,Find,The length of the statement  "			return new StealthCoin(new OutPoint(txId' tx.Outputs.IndexOf(txout))' txout' payment.Redeem' payment.Metadata' address); " is 120.
Long Statement,NBitcoin,ChainSerializationFormat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ConcurrentChain.cs,AssertCoherent,The length of the statement  "					throw new InvalidOperationException("The ChainSerializationFormat is invalid' SerializePrecomputedBlockHash or SerializeBlockHeader should be true"); " is 149.
Long Statement,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,Derivate,The length of the statement  "				throw new InvalidOperationException("You won a prize ! this should happen very rarely. Take a screenshot' and roll the dice again."); " is 133.
Long Statement,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,Derivate,The length of the statement  "				throw new InvalidOperationException("You won the big prize ! this has probability lower than 1 in 2^127. Take a screenshot' and roll the dice again."); " is 151.
Long Statement,NBitcoin,MerkleNode,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\MerkleNode.cs,GetRoot,The length of the statement  "				throw new ArgumentOutOfRangeException("leafCount"' "To prevent DDOS attacks' NBitcoin does not support more than 1024*1024 transactions for the creation of a MerkleNode' if this case is legitimate' contact us."); " is 212.
Long Statement,NBitcoin,CharExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Money.cs,IsDigit,The length of the statement  "			return c == '0' || c == '1' || c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9'; " is 124.
Long Statement,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,Bech32NotSupported,The length of the statement  "			return new NotSupportedException("The network " + this + " does not have any prefix for bech32 " + Enum.GetName(typeof(Bech32Type)' type)); " is 139.
Long Statement,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,Base58NotSupported,The length of the statement  "			return new NotSupportedException("The network " + this + " does not have any prefix for base58 " + Enum.GetName(typeof(Base58Type)' type)); " is 139.
Long Statement,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,Register,The length of the statement  "				var defaultAlias = network._NetworkSet.CryptoCode.ToLowerInvariant() + "-" + network.NetworkType.ToString().ToLowerInvariant(); " is 127.
Long Statement,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitMain,The length of the statement  "			assert(consensus.HashGenesisBlock == uint256.Parse("0x000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f")); " is 122.
Long Statement,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitTest,The length of the statement  "			assert(consensus.HashGenesisBlock == uint256.Parse("0x000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943")); " is 122.
Long Statement,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitReg,The length of the statement  "			consensus.BIP9Deployments[BIP9Deployments.Segwit] = new BIP9DeploymentsParameters(1' BIP9DeploymentsParameters.AlwaysActive' 999999999); " is 136.
Long Statement,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitReg,The length of the statement  "			assert(consensus.HashGenesisBlock == uint256.Parse("0x0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206")); " is 122.
Long Statement,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,CreateGenesisBlock,The length of the statement  "			Script genesisOutputScript = new Script(Op.GetPushOp(Encoders.Hex.DecodeData("04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f"))' OpcodeType.OP_CHECKSIG); " is 237.
Long Statement,NBitcoin,NoSqlRepository,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\NoSqlRepository.cs,PutBatch,The length of the statement  "			return PutBytesBatch(values.Select(s => new Tuple<string' byte[]>(s.Item1' s.Item2 == null ? null : s.Item2.ToBytes()))); " is 121.
Long Statement,NBitcoin,BitcoinColoredAddress,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\BitcoinColoredAddress.cs,Build,The length of the statement  "				var data = address.Network.NetworkStringParser.GetBase58CheckEncoder().DecodeData(b58.ToString()).Skip(version.Length).ToArray(); " is 129.
Long Statement,NBitcoin,PubKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\PubKey.cs,Derivate,The length of the statement  "				throw new InvalidOperationException("You won a prize ! this should happen very rarely. Take a screenshot' and roll the dice again."); " is 133.
Long Statement,NBitcoin,PubKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\PubKey.cs,Derivate,The length of the statement  "				throw new InvalidOperationException("You won the big prize ! this would happen only 1 in 2^127. Take a screenshot' and roll the dice again."); " is 142.
Long Statement,NBitcoin,Script,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Script.cs,ExtractScriptCode,The length of the statement  "				if (separatorIndex >= codeSeparatorIndex && !(separatorIndex == codeSeparatorIndex && op.Code == OpcodeType.OP_CODESEPARATOR)) " is 126.
Long Statement,NBitcoin,Script,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Script.cs,VerifyScriptConsensus,The length of the statement  "			var valid = VerifyScriptConsensus(scriptPubKeyBytes' (uint)scriptPubKeyBytes.Length' txToBytes' (uint)txToBytes.Length' nIn' flags' ref err); " is 141.
Long Statement,NBitcoin,Script,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Script.cs,VerifyScriptConsensus,The length of the statement  "			int valid = VerifyScriptConsensusWithAmount(scriptPubKeyBytes' (uint)scriptPubKeyBytes.Length' amount.Satoshi' txToBytes' (uint)txToBytes.Length' 0' flags & ScriptVerify.Consensus' ref err); " is 190.
Long Statement,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,EvalScript,The length of the statement  "									byte[] vchHash = null; //((opcode == OpcodeType.OP_RIPEMD160 || opcode == OpcodeType.OP_SHA1 || opcode == OpcodeType.OP_HASH160) ? 20 : 32); " is 140.
Long Statement,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,CheckSequence,The length of the statement  "				(txToSequenceMasked < Sequence.SEQUENCE_LOCKTIME_TYPE_FLAG && nSequenceMasked < Sequence.SEQUENCE_LOCKTIME_TYPE_FLAG) || " is 120.
Long Statement,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,CheckSignatureEncoding,The length of the statement  "			if ((ScriptVerify & (ScriptVerify.DerSig | ScriptVerify.LowS | ScriptVerify.StrictEnc)) != 0 && !IsValidSignatureEncoding(vchSig)) " is 130.
Long Statement,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,CheckPubKeyEncoding,The length of the statement  "			if ((ScriptVerify & ScriptVerify.WitnessPubkeyType) != 0 && sigversion == (int)HashVersion.Witness && !IsCompressedPubKey(vchPubKey)) " is 133.
Long Statement,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,CheckSig,The length of the statement  "			uint256 sighash = checker.Transaction.GetSignatureHash(scriptCode' checker.Index' scriptSig.SigHash' checker.SpentOutput' (HashVersion)sigversion' checker.PrecomputedTransactionData); " is 183.
Long Statement,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,CheckSig,The length of the statement  "				//Replicate OpenSSL bug on 23b397edccd3740a74adb603c9756370fafcde9bcc4483eb271ecad09a94dd63 (http://r6.ca/blog/20111119T211504Z.html) " is 133.
Long Statement,NBitcoin,SlimChain,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\SlimChain.cs,TrySetTipNoLock,The length of the statement  "					throw new ArgumentException(message: "newTip is already inserted with a different previous block' this should never happen");" is 125.
Long Statement,NBitcoin,SlimChain,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\SlimChain.cs,TrySetTipNoLock,The length of the statement  "					throw new ArgumentException(message: "newTip is already inserted with a different previous block' this should never happen");" is 125.
Long Statement,NBitcoin,SlimChain,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\SlimChain.cs,CreateSlimBlock,The length of the statement  "			return new SlimChainedBlock(_BlockHashesByHeight[height]' height == 0 ? null : _BlockHashesByHeight[height - 1]' height);" is 121.
Long Statement,NBitcoin,TxNullDataTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,GenerateScriptPubKey,The length of the statement  "				throw new ArgumentOutOfRangeException("data"' "Data in OP_RETURN should have a maximum size of " + MaxScriptSizeLimit + " bytes"); " is 130.
Long Statement,NBitcoin,PayToScriptHashSigParameters,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,GetMultisigSignatures,The length of the statement  "			return PayToMultiSigTemplate.Instance.ExtractScriptSigParameters(new Script(Pushes.Select(p => Op.GetPushOp(p)).ToArray())); " is 124.
Long Statement,NBitcoin,ScriptTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,CheckScriptSig,The length of the statement  "				result &= CheckScriptSigCore(scriptSig' scriptSig.ToOps().ToArray()' scriptPubKey' scriptPubKey == null ? null : scriptPubKey.ToOps().ToArray()); " is 145.
Long Statement,NBitcoin,Transaction,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,GetIndexedInput,The length of the statement  "			return Inputs.FindIndexedInput(coin.Outpoint) ?? throw new ArgumentException("The coin is not being spent by this transaction"' nameof(coin)); " is 142.
Long Statement,NBitcoin,Transaction,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,CalculateSequenceLocks,The length of the statement  "				throw new ArgumentException("The number of element in prevHeights should be equal to the number of inputs"' "prevHeights"); " is 123.
Long Statement,NBitcoin,Transaction,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,CalculateSequenceLocks,The length of the statement  "					long nCoinTime = (long)Utils.DateTimeToUnixTimeLong(block.GetAncestor(Math.Max(nCoinHeight - 1' 0)).GetMedianTimePast()); " is 121.
Long Statement,NBitcoin,Transaction,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,CalculateSequenceLocks,The length of the statement  "					nMinTime = Math.Max(nMinTime' nCoinTime + (long)((txin.Sequence & Sequence.SEQUENCE_LOCKTIME_MASK) << Sequence.SEQUENCE_LOCKTIME_GRANULARITY) - 1); " is 147.
Long Statement,NBitcoin,Transaction,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,GetSignatureHash,The length of the statement  "				if ((nHashType & SigHash.AnyoneCanPay) == 0 && ((uint)nHashType & 0x1f) != (uint)SigHash.Single && ((uint)nHashType & 0x1f) != (uint)SigHash.None) " is 146.
Long Statement,NBitcoin,TransactionBuilder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\TransactionBuilder.cs,SetChange,The length of the statement  "				throw new InvalidOperationException($"You should not call {nameof(SetChange)} after {nameof(SendAllRemaining)}' maybe you should call {nameof(SendAllRemainingToChange)} instead of {nameof(SendAllRemaining)}"); " is 209.
Long Statement,NBitcoin,TransactionBuilder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\TransactionBuilder.cs,BuildTransaction,The length of the statement  "							   .Select(o => o.Count() == 1 ? o.First() : ctx.Transaction.Outputs.CreateNewTxOut(o.Select(txout => txout.Value).Sum()' o.Key)) " is 126.
Long Statement,NBitcoin,TransactionBuilder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\TransactionBuilder.cs,Sign,The length of the statement  "				var spendKeys = stealthCoin.Address.SpendPubKeys.Select(p => ctx.FindKey(p.ScriptPubKey)).Where(p => p != null).ToArray(); " is 122.
Long Statement,NBitcoin,KnownSignatureSigner,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\TransactionBuilder.cs,FindKey,The length of the statement  "				foreach (var tv in _KnownSignatures.Where(tv => signingContext.Builder.IsCompatibleKeyFromScriptCode(tv.Item1' scriptPubKey))) " is 126.
Long Statement,NBitcoin,TransactionBuildingContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\TransactionBuilder.cs,EnsureMarkerInserted,The length of the statement  "				var dummy = Transaction.Inputs.Add(new OutPoint(new uint256(1)' 0)); //Since a transaction without input will be considered without marker' insert a dummy " is 154.
Long Statement,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,CompareTo,The length of the statement  "				   obj is null ? CompareTo(null as uint256) : throw new ArgumentException($"Object is not an instance of uint256"' nameof(obj)); " is 125.
Long Statement,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,CompareTo,The length of the statement  "				   obj is null ? CompareTo(null as uint160) : throw new ArgumentException($"Object is not an instance of uint160"' nameof(obj)); " is 125.
Long Statement,NBitcoin,Extensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ReadEx,The length of the statement  "					//A potential fix is to use the ReadAsync API. Another fix is to register a callback with BeginRead that calls EndRead in all cases. " is 132.
Long Statement,NBitcoin.BouncyCastle.Asn1.Sec,Secp384r1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The length of the statement  "				BigInteger p = FromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF"); " is 123.
Long Statement,NBitcoin.BouncyCastle.Asn1.Sec,Secp384r1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The length of the statement  "				BigInteger a = FromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC"); " is 123.
Long Statement,NBitcoin.BouncyCastle.Asn1.Sec,Secp384r1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The length of the statement  "				BigInteger b = FromHex("B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF"); " is 123.
Long Statement,NBitcoin.BouncyCastle.Asn1.Sec,Secp384r1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The length of the statement  "				BigInteger n = FromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973"); " is 123.
Long Statement,NBitcoin.BouncyCastle.Asn1.Sec,Secp521r1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The length of the statement  "				BigInteger p = FromHex("01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"); " is 159.
Long Statement,NBitcoin.BouncyCastle.Asn1.Sec,Secp521r1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The length of the statement  "				BigInteger a = FromHex("01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC"); " is 159.
Long Statement,NBitcoin.BouncyCastle.Asn1.Sec,Secp521r1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The length of the statement  "				BigInteger b = FromHex("0051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00"); " is 159.
Long Statement,NBitcoin.BouncyCastle.Asn1.Sec,Secp521r1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The length of the statement  "				BigInteger n = FromHex("01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409"); " is 159.
Long Statement,NBitcoin.BouncyCastle.Asn1.Sec,Secp521r1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The length of the statement  "					+ "00C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66" " is 136.
Long Statement,NBitcoin.BouncyCastle.Asn1.Sec,Secp521r1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The length of the statement  "					+ "011839296A789A3BC0045C8A5FB42C7D1BD998F54449579B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C7086A272C24088BE94769FD16650")); " is 139.
Long Statement,NBitcoin.BouncyCastle.Asn1.Sec,Sect409k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The length of the statement  "				BigInteger n = FromHex("7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE5F83B2D4EA20400EC4557D5ED3E3E7CA5B4B5C83B8E01E5FCF"); " is 129.
Long Statement,NBitcoin.BouncyCastle.Asn1.Sec,Sect409r1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The length of the statement  "				BigInteger b = FromHex("0021A5C2C8EE9FEB5C4B9A753B7B476B7FD6422EF1F3DD674761FA99D6AC27C8A9A197B272822F6CD57A55AA4F50AE317B13545F"); " is 131.
Long Statement,NBitcoin.BouncyCastle.Asn1.Sec,Sect409r1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The length of the statement  "				BigInteger n = FromHex("010000000000000000000000000000000000000000000000000001E2AAD6A612F33307BE5FA47C3C9E052F838164CD37D9A21173"); " is 131.
Long Statement,NBitcoin.BouncyCastle.Asn1.Sec,Sect571k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The length of the statement  "				BigInteger n = FromHex("020000000000000000000000000000000000000000000000000000000000000000000000131850E1F19A63E4B391A8DB917F4138B630D84BE5D639381E91DEB45CFE778F637C1001"); " is 171.
Long Statement,NBitcoin.BouncyCastle.Asn1.Sec,Sect571k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The length of the statement  "					+ "026EB7A859923FBC82189631F8103FE4AC9CA2970012D5D46024804801841CA44370958493B205E647DA304DB4CEB08CBBD1BA39494776FB988B47174DCA88C7E2945283A01C8972" " is 148.
Long Statement,NBitcoin.BouncyCastle.Asn1.Sec,Sect571k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The length of the statement  "					+ "0349DC807F4FBF374F4AEADE3BCA95314DD58CEC9F307A54FFC61EFC006D8A2C9D4979C0AC44AEA74FBEBBB9F772AEDCB620B01A7BA7AF1B320430C8591984F601CD4C143EF1C7A3")); " is 151.
Long Statement,NBitcoin.BouncyCastle.Asn1.Sec,Sect571r1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The length of the statement  "				BigInteger b = FromHex("02F40E7E2221F295DE297117B7F3D62F5C6A97FFCB8CEFF1CD6BA8CE4A9A18AD84FFABBD8EFA59332BE7AD6756A66E294AFD185A78FF12AA520E4DE739BACA0C7FFEFF7F2955727A"); " is 171.
Long Statement,NBitcoin.BouncyCastle.Asn1.Sec,Sect571r1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The length of the statement  "				BigInteger n = FromHex("03FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE661CE18FF55987308059B186823851EC7DD9CA1161DE93D5174D66E8382E9BB2FE84E47"); " is 171.
Long Statement,NBitcoin.BouncyCastle.Asn1.Sec,Sect571r1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The length of the statement  "					+ "0303001D34B856296C16C0D40D3CD7750A93D1D2955FA80AA5F40FC8DB7B2ABDBDE53950F4C0D293CDD711A35B67FB1499AE60038614F1394ABFA3B4C850D927E1E7769C8EEC2D19" " is 148.
Long Statement,NBitcoin.BouncyCastle.Asn1.Sec,Sect571r1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The length of the statement  "					+ "037BF27342DA639B6DCCFFFEB73D69D78C6C27A6009CBBCA1980F8533921E8A684423E43BAB08A576291AF8F461BB2A8B3531D2F0485C19B16E2F1516E23DD3C1A4827AF1B8AC15B")); " is 151.
Long Statement,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The length of the statement  "			this.C0 = (uint)S[r0 & 255] ^ (((uint)S[(r1 >> 8) & 255]) << 8) ^ (((uint)S[(r2 >> 16) & 255]) << 16) ^ (((uint)S[r3 >> 24]) << 24) ^ kw[0];" is 140.
Long Statement,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The length of the statement  "			this.C1 = (uint)S[r1 & 255] ^ (((uint)S[(r2 >> 8) & 255]) << 8) ^ (((uint)S[(r3 >> 16) & 255]) << 16) ^ (((uint)S[r0 >> 24]) << 24) ^ kw[1];" is 140.
Long Statement,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The length of the statement  "			this.C2 = (uint)S[r2 & 255] ^ (((uint)S[(r3 >> 8) & 255]) << 8) ^ (((uint)S[(r0 >> 16) & 255]) << 16) ^ (((uint)S[r1 >> 24]) << 24) ^ kw[2];" is 140.
Long Statement,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The length of the statement  "			this.C3 = (uint)S[r3 & 255] ^ (((uint)S[(r0 >> 8) & 255]) << 8) ^ (((uint)S[(r1 >> 16) & 255]) << 16) ^ (((uint)S[r2 >> 24]) << 24) ^ kw[3];" is 140.
Long Statement,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The length of the statement  "			this.C0 = (uint)Si[r0 & 255] ^ (((uint)Si[(r3 >> 8) & 255]) << 8) ^ (((uint)Si[(r2 >> 16) & 255]) << 16) ^ (((uint)Si[r1 >> 24]) << 24) ^ kw[0];" is 144.
Long Statement,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The length of the statement  "			this.C1 = (uint)Si[r1 & 255] ^ (((uint)Si[(r0 >> 8) & 255]) << 8) ^ (((uint)Si[(r3 >> 16) & 255]) << 16) ^ (((uint)Si[r2 >> 24]) << 24) ^ kw[1];" is 144.
Long Statement,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The length of the statement  "			this.C2 = (uint)Si[r2 & 255] ^ (((uint)Si[(r1 >> 8) & 255]) << 8) ^ (((uint)Si[(r0 >> 16) & 255]) << 16) ^ (((uint)Si[r3 >> 24]) << 24) ^ kw[2];" is 144.
Long Statement,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The length of the statement  "			this.C3 = (uint)Si[r3 & 255] ^ (((uint)Si[(r2 >> 8) & 255]) << 8) ^ (((uint)Si[(r1 >> 16) & 255]) << 16) ^ (((uint)Si[r0 >> 24]) << 24) ^ kw[3];" is 144.
Long Statement,NBitcoin.BouncyCastle.Math.EC,ECAlgorithms,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECAlgorithms.cs,ImplShamirsTrickWNaf,The length of the statement  "			int width = System.Math.Max(2' System.Math.Min(16' WNafUtilities.GetWindowSize(System.Math.Max(k.BitLength' l.BitLength))));" is 124.
Long Statement,NBitcoin.BouncyCastle.Math.EC,ECAlgorithms,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECAlgorithms.cs,ImplSumOfMultiplies,The length of the statement  "				int width = System.Math.Max(2' System.Math.Min(16' WNafUtilities.GetWindowSize(System.Math.Max(kj0.BitLength' kj1.BitLength))));" is 128.
Long Statement,NBitcoin.BouncyCastle.Math.EC,ECCurve,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECCurve.cs,ImportPoint,The length of the statement  "			// TODO Default behaviour could be improved if the two curves have the same coordinate system by copying any Z coordinates." is 123.
Long Statement,NBitcoin.BuilderExtensions,P2MultiSigBuilderExtension,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BuilderExtensions\P2MultiSigBuilderExtension.cs,EstimateScriptSigSize,The length of the statement  "			return PayToMultiSigTemplate.Instance.GenerateScriptSig(Enumerable.Range(0' p2mk.SignatureCount).Select(o => DummySignature).ToArray()).Length; " is 143.
Long Statement,NBitcoin.Crypto,ECKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\ECKey.cs,GetPubKey,The length of the statement  "			//Pub key (q) is composed into X and Y' the compressed form only include X' which can derive Y along with 02 or 03 prepent depending on whether Y in even or odd. " is 161.
Long Statement,NBitcoin.Crypto,SchnorrSigner,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\SchnorrSignature.cs,Verify,The length of the statement  "			var e = new BigInteger(1' Hashes.SHA256(Utils.BigIntegerToBytes(sig.R' 32).Concat(pubkey.ToBytes()' m.ToBytes(false)))).Mod(Secp256k1.N);" is 137.
Long Statement,NBitcoin.Crypto,SchnorrSigner,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\SchnorrSignature.cs,BatchVerify,The length of the statement  "				var e = new BigInteger(1' Hashes.SHA256(Utils.BigIntegerToBytes(sig.R' 32).Concat(pubkeys[i].ToBytes()' m[i].ToBytes(false)))).Mod(Secp256k1.N);" is 144.
Long Statement,NBitcoin.JsonConverters,BitcoinStringJsonConverter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\JsonConverters\BitcoinStringJsonConverter.cs,CanConvert,The length of the statement  "				(typeof(IDestination).GetTypeInfo().IsAssignableFrom(objectType.GetTypeInfo()) && objectType.GetTypeInfo().AssemblyQualifiedName.Contains("NBitcoin"));" is 151.
Long Statement,NBitcoin.JsonConverters,BitcoinStringJsonConverter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\JsonConverters\BitcoinStringJsonConverter.cs,ReadJson,The length of the statement  "					throw new JsonObjectException("Invalid BitcoinString type expected " + objectType.Name + "' actual " + result.GetType().Name' reader);" is 134.
Long Statement,NBitcoin.JsonConverters,CoinJson,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\JsonConverters\CoinJsonConverter.cs,ToCoin,The length of the statement  "				var coin = RedeemScript == null ? new Coin(new OutPoint(TransactionId' index)' new TxOut(Value' ScriptPubKey)) : new ScriptCoin(new OutPoint(TransactionId' index)' new TxOut(Value' ScriptPubKey)' RedeemScript);" is 210.
Long Statement,NBitcoin.JsonConverters,JsonConverterUtils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\JsonConverters\JsonConverterUtils.cs,AssertJsonType,The length of the statement  "				throw new JsonObjectException($"Unexpected json token type' expected is {expectedType} and actual is {reader.TokenType}"' reader);" is 130.
Long Statement,NBitcoin.JsonConverters,JsonConverterUtils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\JsonConverters\JsonConverterUtils.cs,AssertJsonType,The length of the statement  "				throw new JsonObjectException($"Unexpected json token type' expected are {string.Join("' "' anyExpectedTypes)} and actual is {reader.TokenType}"' reader);" is 154.
Long Statement,NBitcoin.JsonConverters,KeyPathJsonConverter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\JsonConverters\KeyPathJsonConverter.cs,CanConvert,The length of the statement  "			return typeof(KeyPath).GetTypeInfo().IsAssignableFrom(objectType.GetTypeInfo()) || typeof(RootedKeyPath).GetTypeInfo().IsAssignableFrom(objectType.GetTypeInfo());" is 162.
Long Statement,NBitcoin.JsonConverters,NetworkJsonConverter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\JsonConverters\NetworkJsonConverter.cs,ReadJson,The length of the statement  "			if (network.Equals("MainNet"' StringComparison.OrdinalIgnoreCase) || network.Equals("main"' StringComparison.OrdinalIgnoreCase))" is 128.
Long Statement,NBitcoin.JsonConverters,NetworkJsonConverter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\JsonConverters\NetworkJsonConverter.cs,ReadJson,The length of the statement  "			if (network.Equals("TestNet"' StringComparison.OrdinalIgnoreCase) || network.Equals("test"' StringComparison.OrdinalIgnoreCase))" is 128.
Long Statement,NBitcoin.JsonConverters,NetworkJsonConverter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\JsonConverters\NetworkJsonConverter.cs,ReadJson,The length of the statement  "			if (network.Equals("RegTest"' StringComparison.OrdinalIgnoreCase) || network.Equals("reg"' StringComparison.OrdinalIgnoreCase))" is 127.
Long Statement,NBitcoin.JsonConverters,ScriptJsonConverter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\JsonConverters\ScriptJsonConverter.cs,CanConvert,The length of the statement  "			return typeof(Script).GetTypeInfo().IsAssignableFrom(objectType.GetTypeInfo()) || typeof(WitScript).GetTypeInfo().IsAssignableFrom(objectType.GetTypeInfo());" is 157.
Long Statement,NBitcoin.OpenAsset,ColoredTransaction,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColoredTransaction.cs,FetchColorsAsync,The length of the statement  "			//The following code is to prevent recursion of FetchColors that would fire a StackOverflow if the origin of traded asset were deep in the transaction dependency tree " is 166.
Long Statement,NBitcoin.OpenAsset,ColoredTransaction,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColoredTransaction.cs,FetchColorsAsync,The length of the statement  "				colored = frame.PreviousTransactions != null ? null : await repo.GetAsync(frame.TransactionId).ConfigureAwait(false); //Already known " is 133.
Long Statement,NBitcoin.OpenAsset,ColoredTransaction,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColoredTransaction.cs,FetchColorsAsync,The length of the statement  "					throw new TransactionNotFoundException("Transaction " + frame.TransactionId + " not found in transaction repository"' frame.TransactionId); " is 139.
Long Statement,NBitcoin.OpenAsset,ColoredTransaction,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColoredTransaction.cs,FetchColorsAsync,The length of the statement  "						throw new TransactionNotFoundException("An open asset transaction is issuing assets' but it needs a parent transaction in the TransactionRepository to know the address of the issued asset (missing : " + txIn.PrevOut.Hash + ")"' txIn.PrevOut.Hash); " is 247.
Long Statement,NBitcoin.OpenAsset,ColoredTransaction,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColoredTransaction.cs,BulkLoadIfCached,The length of the statement  "			repo = new NoDuplicateColoredTransactionRepository(repo); //prevent from having concurrent request to the same transaction id " is 125.
Long Statement,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,HasValidColorMarker,The length of the statement  "			//If there are more items in the  asset quantity list  than the number of colorable outputs' the transaction is deemed invalid' and all outputs are uncolored. " is 158.
Long Statement,NBitcoin.Payment,BitcoinUrlBuilder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\BitcoinUrlBuilder.cs,GetPaymentRequestAsync,The length of the statement  "				if (result.Content.Headers.ContentType == null || !result.Content.Headers.ContentType.MediaType.Equals(PaymentRequest.MediaType' StringComparison.OrdinalIgnoreCase)) " is 165.
Long Statement,NBitcoin.Payment,BitcoinUrlBuilder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\BitcoinUrlBuilder.cs,GetPaymentRequestAsync,The length of the statement  "					throw new WebException("Invalid contenttype received' expecting " + PaymentRequest.MediaType + "' but got " + result.Content.Headers.ContentType); " is 146.
Long Statement,NBitcoin.Payment,PaymentACK,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentACK.cs,Load,The length of the statement  "				throw new ArgumentOutOfRangeException("PaymentACK messages larger than " + MaxLength + " bytes should be rejected"' "source"); " is 126.
Long Statement,NBitcoin.Payment,PaymentMessage,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentACK.cs,Load,The length of the statement  "				throw new ArgumentException("Payment messages larger than " + MaxLength + " bytes should be rejected by the merchant's server"' "source"); " is 138.
Long Statement,NBitcoin.Payment,PaymentMessage,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentACK.cs,SubmitPaymentAsync,The length of the statement  "				if (result.Content.Headers.ContentType == null || !result.Content.Headers.ContentType.MediaType.Equals(PaymentACK.MediaType' StringComparison.OrdinalIgnoreCase)) " is 161.
Long Statement,NBitcoin.Payment,PaymentMessage,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentACK.cs,SubmitPaymentAsync,The length of the statement  "					throw new WebException("Invalid contenttype received' expecting " + PaymentACK.MediaType + "' but got " + result.Content.Headers.ContentType); " is 142.
Long Statement,NBitcoin.Payment,PaymentRequest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentRequest.cs,GetCertificateProvider,The length of the statement  "				throw new InvalidOperationException("DefaultCertificateServiceProvider or CertificateServiceProvider must be set before calling this method."); " is 143.
Long Statement,NBitcoin.Payment,WindowsHashChecker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\WindowsCertificateServiceProvider.cs,VerifySignature,The length of the statement  "					return new X509Certificate2(certificate).GetRSAPublicKey().VerifyHash(hash' signature' new HashAlgorithmName(hashOID.ToUpperInvariant())' RSASignaturePadding.Pkcs1); " is 165.
Long Statement,NBitcoin.Payment,WindowsHashChecker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\WindowsCertificateServiceProvider.cs,VerifySignature,The length of the statement  "					return ((RSACryptoServiceProvider)new X509Certificate2(certificate).PublicKey.Key).VerifyHash(hash' hashOID' signature); " is 120.
Long Statement,NBitcoin.Payment,WindowsChainChecker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\WindowsCertificateServiceProvider.cs,VerifyChain,The length of the statement  "				return VerifyChain(out chain' new X509Certificate2(certificate)' additionalCertificates.Select(c => new X509Certificate2(c)).ToArray()); " is 136.
Long Statement,System.Web.Util,HttpEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\HttpEncoder.cs,NotEncoded,The length of the statement  "			//query strings are allowed to contain both ? and / characters' see section 3.4 of http://www.ietf.org/rfc/rfc3986.txt' which is basically the spec written by Tim Berners-Lee and friends governing how the web should operate. " is 224.
Long Statement,System.Web.Util,HttpEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\HttpEncoder.cs,NotEncoded,The length of the statement  "			return (c == '!' || c == '(' || c == ')' || c == '*' || c == '-' || c == '.' || c == '_' || c == '?' || c == '/' || c == ':' " is 124.
Long Statement,NBitcoin.Policy,StandardTransactionPolicy,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Policy\StandardTransactionPolicy.cs,Check,The length of the statement  "					errors.Add(new InputPolicyError("Max scriptSig length exceeded actual is " + txin.ScriptSig.Length + "' max is " + MaxScriptSigLength' input)); " is 143.
Long Statement,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,ReadWrite,The length of the statement  "								if (nVersion == 1 && nUBuckets == ADDRMAN_NEW_BUCKET_COUNT && vvNew[bucket' nUBucketPos] == -1 && info.nRefCount < ADDRMAN_NEW_BUCKETS_PER_ADDRESS) " is 147.
Long Statement,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,assert,The length of the statement  "				throw new InvalidOperationException("Bug in AddressManager' should never happen' contact NBitcoin developers if you see this exception"); " is 137.
Long Statement,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,DiscoverPeers,The length of the statement  "					CancellationToken loopCancel = CancellationTokenSource.CreateLinkedTokenSource(peerTableFull.Token' parameters.ConnectCancellation).Token; " is 138.
Long Statement,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,PopulateTableWithDNSNodes,The length of the statement  "						return (await dns.GetAddressNodesAsync(network.DefaultPort).ConfigureAwait(false)).Select(o => new NetworkAddress(o)).ToArray(); " is 128.
Long Statement,NBitcoin.Protocol,AddressInfo,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,GetTriedBucket,The length of the statement  "				UInt64 hash2 = Cheap(Hashes.Hash256(nKey.ToBytes().Concat(Address.Endpoint.Address.GetGroup()).Concat(Utils.ToBytes(hash1 % AddressManager.ADDRMAN_TRIED_BUCKETS_PER_GROUP' true)).ToArray())); " is 191.
Long Statement,NBitcoin.Protocol,AddressInfo,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,_IsTerrible,The length of the statement  "				if (Address.ntime == 0 || now - Address.Time > TimeSpan.FromSeconds(ADDRMAN_HORIZON_DAYS * 24 * 60 * 60)) // not seen in recent history " is 135.
Long Statement,NBitcoin.Protocol,AddressInfo,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,_IsTerrible,The length of the statement  "				if (now - LastSuccess > TimeSpan.FromSeconds(ADDRMAN_MIN_FAIL_DAYS * 24 * 60 * 60) && nAttempts >= AddressManager.ADDRMAN_MAX_FAILURES) // N successive failures in the last week " is 177.
Long Statement,NBitcoin.Protocol,AddressInfo,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,GetChance,The length of the statement  "				// deprioritize 66% after each failed attempt' but at most 1/28th to avoid the search taking forever or overly penalizing outages. " is 130.
Long Statement,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,FireFilters,The length of the statement  "					Logs.NodeServer.LogError(default' ex.InnerException' "Unhandled exception raised by a node filter (OnReceivingMessage)"); " is 121.
Long Statement,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,Connect,The length of the statement  "			var addrmanBehavior = parameters.TemplateBehaviors.FindOrCreate(() => new AddressManagerBehavior(new AddressManager())); " is 120.
Long Statement,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,ConnectAsync,The length of the statement  "				await parameters.EndpointConnector.ConnectSocket(socket' endpoint' parameters' parameters.ConnectCancellation).ConfigureAwait(false); " is 133.
Long Statement,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,ConnectAsync,The length of the statement  "				var expectedPeerEndpoint = (endpoint as IPEndPoint) ?? endpoint.AsOnionCatIPEndpoint() ?? (socket.RemoteEndPoint as IPEndPoint); " is 128.
Long Statement,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,ConnectAsync,The length of the statement  "					throw new ArgumentException("The peer's endpoint that you provided is different from the endpoint eventually connected to"); " is 124.
Long Statement,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,SendMessageAsync,The length of the statement  "			TaskCompletionSource<bool> completion = new TaskCompletionSource<bool>(TaskCreationOptions.RunContinuationsAsynchronously); " is 123.
Long Statement,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,VersionHandshake,The length of the statement  "					Logs.NodeServer.LogWarning("Different external address detected by the node {addressReceiver} instead of {addressFrom}"' version.AddressReceiver.Address' MyVersion.AddressFrom.Address); " is 185.
Long Statement,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,RespondToHandShake,The length of the statement  "			using (var list = CreateListener().Where(m => m.Message.Payload is VerAckPayload || m.Message.Payload is RejectPayload)) " is 120.
Long Statement,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,AssertNoListeningThread,The length of the statement  "				throw new InvalidOperationException("Using Disconnect on this thread would result in a deadlock' use DisconnectAsync instead"); " is 127.
Long Statement,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,GetHeadersFromFork,The length of the statement  "					//Get before last so' at the end' we should only receive 1 header equals to this one (so we will not have race problems with concurrent GetChains) " is 146.
Long Statement,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,GetHeadersFromFork,The length of the statement  "						if (headers.Headers.Count == 0 && PeerVersion.StartHeight == 0 && currentTip.HashBlock == Network.GenesisHash) //In the special case where the remote node is at height 0 as well as us' then the headers count will be 0 " is 217.
Long Statement,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,SynchronizeSlimChain,The length of the statement  "					//Get before last so' at the end' we should only receive 1 header equals to this one (so we will not have race problems with concurrent GetChains) " is 146.
Long Statement,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,SynchronizeSlimChain,The length of the statement  "					var awaited = currentTip.Previous is null ? chain.GetLocator(currentTip.Height) : chain.GetLocator(currentTip.Height - 1); " is 122.
Long Statement,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,SynchronizeSlimChain,The length of the statement  "						if (headers.Headers.Count == 0 && PeerVersion.StartHeight == 0 && currentTip.Hash == Network.GenesisHash) //In the special case where the remote node is at height 0 as well as us' then the headers count will be 0 " is 212.
Long Statement,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,GetMempoolTransactions,The length of the statement  "			using (var listener = CreateListener().Where(m => m.Message.Payload is TxPayload || m.Message.Payload is NotFoundPayload)) " is 122.
Long Statement,NBitcoin.Protocol,NodeServer,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\NodeServer.cs,ProcessMessageCore,The length of the statement  "						Logs.NodeServer.LogError(default' ex' "The remote node did not respond fast enough (10 seconds) to the handshake completion' dropping connection"); " is 147.
Long Statement,NBitcoin.Protocol,NodesGroup,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\NodesGroup.cs,StartConnecting,The length of the statement  "							Logs.NodeServer.LogInformation("Connected nodes {connectedNodeCount} / {maximumNodeCount} "' _ConnectedNodes.Count' MaximumNodeConnection); " is 139.
Long Statement,NBitcoin.Protocol,NodesGroup,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\NodesGroup.cs,StartConnecting,The length of the statement  "								node = Node.Connect(_Network' parameters' _ConnectedNodes.Select(n => n.RemoteSocketEndpoint as IPEndPoint).Where(e => e != null).ToArray()' groupSelector); " is 156.
Long Statement,NBitcoin.Protocol.Behaviors,BroadcastHub,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Behaviors\BroadcastTransactionBehavior.cs,BroadcastTransactionAsync,The length of the statement  "			TaskCompletionSource<RejectPayload> completion = new TaskCompletionSource<RejectPayload>(TaskCreationOptions.RunContinuationsAsynchronously); " is 141.
Long Statement,NBitcoin.Protocol.Behaviors,PingPongBehavior,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Behaviors\PingPongBehavior.cs,AttachCore,The length of the statement  "			if (AttachedNode.PeerVersion != null && !PingVersion()) //If not handshaked' stil attach (the callback will also check version) " is 127.
Long Statement,NBitcoin.Protocol.Connectors,DefaultEndpointConnector,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Connectors\DefaultEndpointConnector.cs,ConnectSocket,The length of the statement  "				throw new InvalidOperationException($"The Endpoint connector is configured to allow only Tor endpoints and the '{endpoint}' enpoint is not one");" is 145.
Long Statement,NBitcoin.Protocol.Connectors,DefaultEndpointConnector,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Connectors\DefaultEndpointConnector.cs,ConnectSocket,The length of the statement  "					throw new InvalidOperationException("SocksSettingsBehavior.SocksEndpoint is not set but the connection is expecting using socks proxy");" is 136.
Long Statement,NBitcoin.RPC,GetAddressInfoResponse,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\GetAddressInfoResponse.cs,LoadFromJson,The length of the statement  "			Timestamp = raw.Property("timestamp") == null ? (DateTimeOffset?)null : Utils.UnixTimeToDateTime(raw.Property("timestamp").Value.Value<ulong>());" is 145.
Long Statement,NBitcoin.RPC,GetAddressInfoResponse,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\GetAddressInfoResponse.cs,LoadFromJson,The length of the statement  "			HDMasterKeyID = raw.Property("hdmasterkeyid") == null ? null : uint160.Parse(raw.Property("hdmasterkeyid").Value.Value<string>());" is 130.
Long Statement,NBitcoin.RPC,RestClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RestClient.cs,GetBlockHeadersAsync,The length of the statement  "			var result = await SendRequestAsync("headers"' RestResponseFormat.Bin' count.ToString(CultureInfo.InvariantCulture)' blockId.ToString()).ConfigureAwait(false); " is 159.
Long Statement,NBitcoin.RPC,RestClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RestClient.cs,GetUnspentOutputsAsync,The length of the statement  "			var result = await SendRequestAsync("getutxos" + (checkMempool ? "/checkmempool" : "")' RestResponseFormat.Bin' ids.ToArray()).ConfigureAwait(false); " is 149.
Long Statement,NBitcoin.RPC,RestClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RestClient.cs,BuildHttpRequest,The length of the statement  "			uriBuilder.Path = "rest/" + resource + (hasParams ? "/" : "") + string.Join("/"' parms) + "." + format.ToString().ToLowerInvariant(); " is 133.
Long Statement,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,SetVersion,The length of the statement  "			catch (RPCException ex) when (ex.RPCCode == RPCErrorCode.RPC_METHOD_NOT_FOUND || ex.RPCCode == RPCErrorCode.RPC_METHOD_DEPRECATED) " is 130.
Long Statement,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,CheckCapabilities,The length of the statement  "			catch (RPCException ex) when (ex.RPCCode == RPCErrorCode.RPC_METHOD_NOT_FOUND || ex.RPCCode == RPCErrorCode.RPC_METHOD_DEPRECATED) " is 130.
Long Statement,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,GetDefaultCookieFilePath,The length of the statement  "				throw new ArgumentException("This network has no default cookie file path registered' use RPCClient.RegisterDefaultCookiePath to register"' "network"); " is 151.
Long Statement,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,GetNewAddressAsync,The length of the statement  "			return BitcoinAddress.Create((await SendCommandWithNamedArgsAsync(RPCOperations.getnewaddress.ToString()' p).ConfigureAwait(false)).Result.ToString()' Network); " is 160.
Long Statement,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,StartScanTxoutSetAsync,The length of the statement  "				OutPoint outpoint = OutPoint.Parse($"{unspent.Property("txid").Value.Value<string>()}-{(int)unspent.Property("vout").Value.Value<long>()}"); " is 140.
Long Statement,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,StartScanTxoutSetAsync,The length of the statement  "				var scriptPubKey = Script.FromBytesUnsafe(Encoders.Hex.DecodeData(unspent.Property("scriptPubKey").Value.Value<string>())); " is 123.
Long Statement,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,SendBatchAsync,The length of the statement  "			List<Tuple<RPCRequest' TaskCompletionSource<RPCResponse>>> requests = new List<Tuple<RPCRequest' TaskCompletionSource<RPCResponse>>>(); " is 135.
Long Statement,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,SendCommandAsyncCore,The length of the statement  "				TaskCompletionSource<RPCResponse> source = new TaskCompletionSource<RPCResponse>(TaskCreationOptions.RunContinuationsAsynchronously); " is 133.
Long Statement,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,CreateWebRequest,The length of the statement  "			webRequest.Headers.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Basic"' Encoders.Base64.EncodeData(Encoders.ASCII.DecodeData(_Authentication))); " is 170.
Long Statement,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,AddNodeAsync,The length of the statement  "			await SendCommandAsync(RPCOperations.addnode' nodeEndPoint.ToString()' onetry ? "onetry" : "add").ConfigureAwait(false); " is 120.
Long Statement,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,GetAddedNodeInfoAync,The length of the statement  "				var result = await SendCommandAsync(RPCOperations.getaddednodeinfo' detailed' nodeEndPoint.ToString()).ConfigureAwait(false); " is 125.
Long Statement,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,GetRawTransactionAsync,The length of the statement  "			var response = await SendCommandAsync(new RPCRequest(RPCOperations.getrawtransaction' args.ToArray())' throwIfNotFound).ConfigureAwait(false); " is 142.
Long Statement,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,GetRawTransactionInfoAsync,The length of the statement  "				TransactionTime = json["time"] != null ? NBitcoin.Utils.UnixTimeToDateTime(json.Value<long>("time")) : (DateTimeOffset?)null' " is 125.
Long Statement,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,GetRawTransactionInfoAsync,The length of the statement  "				BlockTime = json["blocktime"] != null ? NBitcoin.Utils.UnixTimeToDateTime(json.Value<long>("blocktime")) : (DateTimeOffset?)null " is 128.
Long Statement,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,SendRawTransactionAsync,The length of the statement  "			var result = await SendCommandAsync(RPCOperations.sendrawtransaction' Encoders.Hex.EncodeData(bytes)).ConfigureAwait(false); " is 124.
Long Statement,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,EstimateSmartFeeImplAsync,The length of the statement  "				var request = new RPCRequest(RPCOperations.estimatesmartfee.ToString()' new object[] { confirmationTarget' estimateMode.ToString().ToUpperInvariant() }); " is 153.
Long Statement,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,SendToAddress,The length of the statement  "			txid = SendToAddressAsync(address' amount' commentTx' commentDest' subtractFeeFromAmount' replaceable).GetAwaiter().GetResult(); " is 128.
Long Statement,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,SendToAddress,The length of the statement  "			return SendToAddressAsync(scriptPubKey' amount' commentTx' commentDest' subtractFeeFromAmount' replaceable).GetAwaiter().GetResult(); " is 133.
Long Statement,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,SendToAddressAsync,The length of the statement  "			return SendToAddressAsync(scriptPubKey.GetDestinationAddress(Network)' amount' commentTx' commentDest' subtractFeeFromAmount' replaceable); " is 139.
Long Statement,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,GenerateAsync,The length of the statement  "				catch (RPCException rpc) when (rpc.RPCCode == RPCErrorCode.RPC_METHOD_DEPRECATED || rpc.RPCCode == RPCErrorCode.RPC_METHOD_NOT_FOUND) " is 133.
Long Statement,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,GenerateToAddressAsync,The length of the statement  "			var result = (JArray)(await SendCommandAsync(RPCOperations.generatetoaddress' nBlocks' address.ToString()).ConfigureAwait(false)).Result; " is 137.
Long Statement,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,GetReceivedByAddressAsync,The length of the statement  "			var response = await SendCommandAsync(RPCOperations.getreceivedbyaddress' address.ToString()' confirmations).ConfigureAwait(false);" is 131.
Long Statement,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,ListUnspentAsync,The length of the statement  "			var response = await SendCommandAsync(RPCOperations.listunspent' minconf' maxconf' addr.ToArray()).ConfigureAwait(false);" is 121.
Long Statement,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,ListUnspentAsync,The length of the statement  "			var response = await SendCommandWithNamedArgsAsync(RPCOperations.listunspent.ToString()' queryOptions).ConfigureAwait(false);" is 125.
Long Statement,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,WalletProcessPSBTAsync,The length of the statement  "			var response = await SendCommandAsync(RPCOperations.walletprocesspsbt' psbt.ToBase64()' sign' SigHashToString(sighashType)' bip32derivs).ConfigureAwait(false);" is 159.
Long Statement,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,Handshake,The length of the statement  "			var selectionMessage = credentials is null ? SelectionMessageNoAuthenticationRequired : SelectionMessageUsernamePassword;" is 121.
Long Statement,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,Handshake,The length of the statement  "			await stream.WriteAsync(selectionMessage' 0' selectionMessage.Length).WithCancellation(cancellationToken).ConfigureAwait(false);" is 128.
Long Statement,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,Handshake,The length of the statement  "				await stream.WriteAsync(usernamePasswordRequest' 0' usernamePasswordRequest.Length).WithCancellation(cancellationToken).ConfigureAwait(false);" is 142.
Long Statement,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,Handshake,The length of the statement  "					throw new SocksException($"Authentication version {userNamePasswordResponse[0]} is not supported. Only version {1} is supported.");" is 131.
Long Statement,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,Handshake,The length of the statement  "			await stream.WriteAsync(connectBytes' 0' connectBytes.Length).WithCancellation(cancellationToken).ConfigureAwait(false);" is 120.
Long Statement,NBitcoin.Stealth,StealthPayment,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Stealth\StealthPayment.cs,CreatePaymentScript,The length of the statement  "			return CreatePaymentScript(address.SignatureCount' address.SpendPubKeys.Select(p => p.UncoverReceiver(scan' ephemKey)).ToArray()); " is 130.
Complex Conditional,NBitcoin,PSBT,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PartiallySignedTransaction.cs,AddKeyPath,The conditional expression  "(scriptPubKey != null && coin.ScriptPubKey == scriptPubKey) || 					((o.GetSignableCoin() ?? coin.TryToScriptCoin(pubkey)) is Coin c && txBuilder.IsCompatibleKeyFromScriptCode(pubkey' c.GetScriptCode())) || 					  txBuilder.IsCompatibleKeyFromScriptCode(pubkey' coin.ScriptPubKey)"  is complex.
Complex Conditional,NBitcoin,PSBTCoin,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTCoin.cs,HDKeysFor,The conditional expression  "!hdKey.Value.KeyPath.IsHardenedPath || (accountKey.CanDeriveHardenedPath() && (accountHDScriptPubKey == null || accountHDScriptPubKey.CanDeriveHardenedPath()))"  is complex.
Complex Conditional,NBitcoin,ConcurrentChain,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ConcurrentChain.cs,Load,The conditional expression  "!format.SerializeBlockHeader ||  								(_Tip.HashBlock == header.HashPrevBlock && !(header.IsNull && header.Nonce == 0))"  is complex.
Complex Conditional,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,GetGroup,The conditional expression  "bytes[15 - 15] == 0x20 && bytes[15 - 14] == 0x01 && bytes[15 - 13] == 0x04 && bytes[15 - 12] == 0x70"  is complex.
Complex Conditional,NBitcoin,Script,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Script.cs,GetSigOpCount,The conditional expression  "fAccurate && lastOpcode != null && lastOpcode.Code >= OpcodeType.OP_1 && lastOpcode.Code <= OpcodeType.OP_16"  is complex.
Complex Conditional,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,EvalScript,The conditional expression  "opcode.Code == OpcodeType.OP_CAT ||  						opcode.Code == OpcodeType.OP_SUBSTR ||  						opcode.Code == OpcodeType.OP_LEFT ||  						opcode.Code == OpcodeType.OP_RIGHT ||  						opcode.Code == OpcodeType.OP_INVERT ||  						opcode.Code == OpcodeType.OP_AND ||  						opcode.Code == OpcodeType.OP_OR ||  						opcode.Code == OpcodeType.OP_XOR ||  						opcode.Code == OpcodeType.OP_2MUL ||  						opcode.Code == OpcodeType.OP_2DIV ||  						opcode.Code == OpcodeType.OP_MUL ||  						opcode.Code == OpcodeType.OP_DIV ||  						opcode.Code == OpcodeType.OP_MOD ||  						opcode.Code == OpcodeType.OP_LSHIFT ||  						opcode.Code == OpcodeType.OP_RSHIFT"  is complex.
Complex Conditional,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,EvalScript,The conditional expression  "!fSuccess && (ScriptVerify & ScriptVerify.NullFail) != 0 && ikey2 == 0 && _stack.Top(-1).Length != 0"  is complex.
Complex Conditional,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,CheckSequence,The conditional expression  "!(  				(txToSequenceMasked < Sequence.SEQUENCE_LOCKTIME_TYPE_FLAG && nSequenceMasked < Sequence.SEQUENCE_LOCKTIME_TYPE_FLAG) ||  				(txToSequenceMasked >= Sequence.SEQUENCE_LOCKTIME_TYPE_FLAG && nSequenceMasked >= Sequence.SEQUENCE_LOCKTIME_TYPE_FLAG)  			)"  is complex.
Complex Conditional,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,CheckLockTime,The conditional expression  "!(  				(txTo.LockTime < LockTime.LOCKTIME_THRESHOLD && nLockTime < LockTime.LOCKTIME_THRESHOLD) ||  				(txTo.LockTime >= LockTime.LOCKTIME_THRESHOLD && nLockTime >= LockTime.LOCKTIME_THRESHOLD)  			)"  is complex.
Complex Conditional,NBitcoin,ScriptCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,GetSpecialSize,The conditional expression  "nSize == 2 || nSize == 3 || nSize == 4 || nSize == 5"  is complex.
Complex Conditional,NBitcoin,DefaultCoinSelector,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\TransactionBuilder.cs,Select,The conditional expression  "!nBest.Equals(target) && (nTotalLower.CompareTo(targetMinChange) is var v && (v == 0 || v > 0))"  is complex.
Complex Conditional,NBitcoin,DefaultCoinSelector,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\TransactionBuilder.cs,Select,The conditional expression  "lowest_larger != null &&  				((!nBest.Equals(target) && nBest.CompareTo(targetMinChange) < 0) ||  				(lowest_larger.Amount.CompareTo(nBest) is var vv && (vv == 0 || vv < 0)))"  is complex.
Complex Conditional,NBitcoin.BouncyCastle.Crypto.Signers,ECDsaSigner,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\signers\ECDsaSigner.cs,VerifySignature,The conditional expression  "r.SignValue < 1 || s.SignValue < 1 				|| r.CompareTo(n) >= 0 || s.CompareTo(n) >= 0"  is complex.
Complex Conditional,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Field,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Field.cs,Reduce32,The conditional expression  "(x != 0 && Nat256.Mul33WordAdd(PInv33' x' z' 0) != 0) 				|| (z[7] == P7 && Nat256.Gte(z' P))"  is complex.
Complex Conditional,NBitcoin.BouncyCastle.Math.EC,ECAlgorithms,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECAlgorithms.cs,SumOfMultiplies,The conditional expression  "ps == null || ks == null || ps.Length != ks.Length || ps.Length < 1"  is complex.
Complex Conditional,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,locate_errors,The conditional expression  "l_s0 != -1 && l_s1 != -1 && l_s2 != -1 && (2 * l_s1 - l_s2 - l_s0 + 2046) % 1023 == 0"  is complex.
Complex Conditional,System.Web.Util,HttpEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\HttpEncoder.cs,UrlEncodeChar,The conditional expression  "(c < '0') ||  				(c < 'A' && c > '9') ||  				(c > 'Z' && c < 'a') ||  				(c > 'z')"  is complex.
Complex Conditional,System.Web.NBitcoin,HttpUtility,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\HttpUtility.cs,UrlEncode,The conditional expression  "(c < '0') || (c < 'A' && c > '9') || (c > 'Z' && c < 'a') || (c > 'z')"  is complex.
Complex Conditional,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,ReadWrite,The conditional expression  "nVersion == 1 && nUBuckets == ADDRMAN_NEW_BUCKET_COUNT && vvNew[bucket' nUBucketPos] == -1 && info.nRefCount < ADDRMAN_NEW_BUCKETS_PER_ADDRESS"  is complex.
Complex Conditional,NBitcoin.Protocol.Behaviors,PingPongBehavior,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Behaviors\PingPongBehavior.cs,AttachedNode_MessageReceived,The conditional expression  "pong != null &&  				Mode.HasFlag(PingPongMode.SendPing) &&  				_CurrentPing != null &&  				_CurrentPing.Nonce == pong.Nonce"  is complex.
Complex Conditional,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,SendBatchAsyncCore,The conditional expression  "httpResponse.Content == null ||  								(httpResponse.Content.Headers.ContentLength == null || httpResponse.Content.Headers.ContentLength.Value == 0) ||  								!httpResponse.Content.Headers.ContentType.MediaType.Equals("application/json"' StringComparison.Ordinal)"  is complex.
Complex Conditional,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,SendCommandAsyncCore,The conditional expression  "httpResponse.Content == null ||  								(httpResponse.Content.Headers.ContentLength == null || httpResponse.Content.Headers.ContentLength.Value == 0) ||  								!httpResponse.Content.Headers.ContentType.MediaType.Equals("application/json"' StringComparison.Ordinal)"  is complex.
Virtual Method Call from Constructor,NBitcoin,PSBT,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PartiallySignedTransaction.cs,PSBT,The constructor "PSBT" calls a virtual method "CreateTransaction".
Virtual Method Call from Constructor,NBitcoin,PSBT,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PartiallySignedTransaction.cs,PSBT,The constructor "PSBT" calls a virtual method "ReadWrite".
Virtual Method Call from Constructor,NBitcoin,PSBTInput,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTInput.cs,PSBTInput,The constructor "PSBTInput" calls a virtual method "CreateTransaction".
Virtual Method Call from Constructor,NBitcoin,PSBTInput,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTInput.cs,PSBTInput,The constructor "PSBTInput" calls a virtual method "GetConsensusFactory".
Virtual Method Call from Constructor,NBitcoin,PSBTInput,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTInput.cs,PSBTInput,The constructor "PSBTInput" calls a virtual method "GetConsensusFactory".
Virtual Method Call from Constructor,NBitcoin,ExtKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP32\ExtKey.cs,ExtKey,The constructor "ExtKey" calls a virtual method "DecodeData".
Virtual Method Call from Constructor,NBitcoin,ExtPubKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP32\ExtPubKey.cs,ExtPubKey,The constructor "ExtPubKey" calls a virtual method "DecodeData".
Virtual Method Call from Constructor,NBitcoin,BitcoinScriptAddress,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BitcoinAddress.cs,BitcoinScriptAddress,The constructor "BitcoinScriptAddress" calls a virtual method "GetBase58CheckEncoder".
Virtual Method Call from Constructor,NBitcoin,BitcoinPubKeyAddress,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BitcoinPubKeyAddress.cs,BitcoinPubKeyAddress,The constructor "BitcoinPubKeyAddress" calls a virtual method "GetBase58CheckEncoder".
Virtual Method Call from Constructor,NBitcoin,BitcoinWitPubKeyAddress,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BitcoinSegwitAddress.cs,BitcoinWitPubKeyAddress,The constructor "BitcoinWitPubKeyAddress" calls a virtual method "Decode".
Virtual Method Call from Constructor,NBitcoin,BitcoinWitScriptAddress,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BitcoinSegwitAddress.cs,BitcoinWitScriptAddress,The constructor "BitcoinWitScriptAddress" calls a virtual method "Decode".
Virtual Method Call from Constructor,NBitcoin,BlockHeader,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Block.cs,BlockHeader,The constructor "BlockHeader" calls a virtual method "SetNull".
Virtual Method Call from Constructor,NBitcoin,BlockHeader,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Block.cs,BlockHeader,The constructor "BlockHeader" calls a virtual method "DecodeData".
Virtual Method Call from Constructor,NBitcoin,BlockHeader,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Block.cs,BlockHeader,The constructor "BlockHeader" calls a virtual method "ReadWrite".
Virtual Method Call from Constructor,NBitcoin,BlockHeader,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Block.cs,BlockHeader,The constructor "BlockHeader" calls a virtual method "DecodeData".
Virtual Method Call from Constructor,NBitcoin,BlockHeader,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Block.cs,BlockHeader,The constructor "BlockHeader" calls a virtual method "ReadWrite".
Virtual Method Call from Constructor,NBitcoin,Block,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Block.cs,Block,The constructor "Block" calls a virtual method "CreateBlockHeader".
Virtual Method Call from Constructor,NBitcoin,Block,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Block.cs,Block,The constructor "Block" calls a virtual method "ReadWrite".
Virtual Method Call from Constructor,NBitcoin,TxDestination,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\KeyId.cs,TxDestination,The constructor "TxDestination" calls a virtual method "DecodeData".
Virtual Method Call from Constructor,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,Network,The constructor "Network" calls a virtual method "DecodeData".
Virtual Method Call from Constructor,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,Network,The constructor "Network" calls a virtual method "DecodeData".
Virtual Method Call from Constructor,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,Network,The constructor "Network" calls a virtual method "DecodeData".
Virtual Method Call from Constructor,NBitcoin,PrecomputedTransactionData,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\PrecomputedTransactionData.cs,PrecomputedTransactionData,The constructor "PrecomputedTransactionData" calls a virtual method "GetHashOutputs".
Virtual Method Call from Constructor,NBitcoin,PrecomputedTransactionData,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\PrecomputedTransactionData.cs,PrecomputedTransactionData,The constructor "PrecomputedTransactionData" calls a virtual method "GetHashSequence".
Virtual Method Call from Constructor,NBitcoin,PrecomputedTransactionData,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\PrecomputedTransactionData.cs,PrecomputedTransactionData,The constructor "PrecomputedTransactionData" calls a virtual method "GetHashPrevouts".
Virtual Method Call from Constructor,NBitcoin,PubKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\PubKey.cs,PubKey,The constructor "PubKey" calls a virtual method "DecodeData".
Virtual Method Call from Constructor,NBitcoin.BouncyCastle.Asn1,DefiniteLengthInputStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\DefiniteLengthInputStream.cs,DefiniteLengthInputStream,The constructor "DefiniteLengthInputStream" calls a virtual method "SetParentEofDetect".
Virtual Method Call from Constructor,NBitcoin.BouncyCastle.Asn1.X9,X9Curve,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\x9\X9Curve.cs,X9Curve,The constructor "X9Curve" calls a virtual method "ToBigInteger".
Virtual Method Call from Constructor,NBitcoin.BouncyCastle.Asn1.X9,X9Curve,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\x9\X9Curve.cs,X9Curve,The constructor "X9Curve" calls a virtual method "ToBigInteger".
Virtual Method Call from Constructor,NBitcoin.BouncyCastle.Asn1.X9,X9Curve,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\x9\X9Curve.cs,X9Curve,The constructor "X9Curve" calls a virtual method "ToBigInteger".
Virtual Method Call from Constructor,NBitcoin.BouncyCastle.Asn1.X9,X9Curve,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\x9\X9Curve.cs,X9Curve,The constructor "X9Curve" calls a virtual method "ToBigInteger".
Virtual Method Call from Constructor,NBitcoin.BouncyCastle.Asn1.X9,X9ECPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\x9\X9ECPoint.cs,X9ECPoint,The constructor "X9ECPoint" calls a virtual method "Normalize".
Virtual Method Call from Constructor,NBitcoin.BouncyCastle.Asn1.X9,X9ECPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\x9\X9ECPoint.cs,X9ECPoint,The constructor "X9ECPoint" calls a virtual method "GetEncoded".
Virtual Method Call from Constructor,NBitcoin.BouncyCastle.Asn1.X9,X9ECPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\x9\X9ECPoint.cs,X9ECPoint,The constructor "X9ECPoint" calls a virtual method "GetOctets".
Virtual Method Call from Constructor,NBitcoin.BouncyCastle.Asn1.X9,X9FieldElement,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\x9\X9FieldElement.cs,X9FieldElement,The constructor "X9FieldElement" calls a virtual method "GetOctets".
Virtual Method Call from Constructor,NBitcoin.BouncyCastle.Asn1.X9,X9FieldElement,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\x9\X9FieldElement.cs,X9FieldElement,The constructor "X9FieldElement" calls a virtual method "GetOctets".
Virtual Method Call from Constructor,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,LongDigest,The constructor "LongDigest" calls a virtual method "Reset".
Virtual Method Call from Constructor,NBitcoin.BouncyCastle.Crypto.Parameters,ECDomainParameters,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\parameters\ECDomainParameters.cs,ECDomainParameters,The constructor "ECDomainParameters" calls a virtual method "Normalize".
Virtual Method Call from Constructor,NBitcoin.BouncyCastle.Crypto.Parameters,ECPublicKeyParameters,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\parameters\ECPublicKeyParameters.cs,ECPublicKeyParameters,The constructor "ECPublicKeyParameters" calls a virtual method "Normalize".
Virtual Method Call from Constructor,NBitcoin.BouncyCastle.Crypto.Signers,HMacDsaKCalculator,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\signers\HMacDsaKCalculator.cs,HMacDsaKCalculator,The constructor "HMacDsaKCalculator" calls a virtual method "GetMacSize".
Virtual Method Call from Constructor,NBitcoin.BouncyCastle.Crypto.Signers,HMacDsaKCalculator,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\signers\HMacDsaKCalculator.cs,HMacDsaKCalculator,The constructor "HMacDsaKCalculator" calls a virtual method "GetMacSize".
Virtual Method Call from Constructor,NBitcoin.BouncyCastle.Math.EC.Endo,GlvTypeBEndomorphism,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\endo\GlvTypeBEndomorphism.cs,GlvTypeBEndomorphism,The constructor "GlvTypeBEndomorphism" calls a virtual method "FromBigInteger".
Virtual Method Call from Constructor,NBitcoin.Crypto,ECKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\ECKey.cs,ECKey,The constructor "ECKey" calls a virtual method "DecodePoint".
Virtual Method Call from Constructor,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,Bech32Encoder,The constructor "Bech32Encoder" calls a virtual method "DecodeData".
Virtual Method Call from Constructor,NBitcoin.OpenAsset,AssetId,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\AssetId.cs,AssetId,The constructor "AssetId" calls a virtual method "DecodeData".
Virtual Method Call from Constructor,NBitcoin.RPC,UnspentCoin,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\UnspentCoin.cs,UnspentCoin,The constructor "UnspentCoin" calls a virtual method "DecodeData".
Virtual Method Call from Constructor,NBitcoin.RPC,UnspentCoin,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\UnspentCoin.cs,UnspentCoin,The constructor "UnspentCoin" calls a virtual method "DecodeData".
Empty Catch Block,NBitcoin,BitcoinWitPubKeyAddress,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BitcoinSegwitAddress.cs,Validate,The method has an empty catch block.
Empty Catch Block,NBitcoin,BitcoinWitScriptAddress,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BitcoinSegwitAddress.cs,Validate,The method has an empty catch block.
Empty Catch Block,NBitcoin,ConcurrentChain,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ConcurrentChain.cs,Load,The method has an empty catch block.
Empty Catch Block,NBitcoin,FileLock,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\FileLock.cs,FileLock,The method has an empty catch block.
Empty Catch Block,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,GetCandidate,The method has an empty catch block.
Empty Catch Block,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,GetCandidate,The method has an empty catch block.
Empty Catch Block,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,SafeSet,The method has an empty catch block.
Empty Catch Block,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,SafeCloseSocket,The method has an empty catch block.
Empty Catch Block,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,SafeCloseSocket,The method has an empty catch block.
Empty Catch Block,NBitcoin.JsonConverters,BitcoinSerializableJsonConverter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\JsonConverters\BitcoinSerializableJsonConverter.cs,ReadJson,The method has an empty catch block.
Empty Catch Block,NBitcoin.JsonConverters,BitcoinSerializableJsonConverter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\JsonConverters\BitcoinSerializableJsonConverter.cs,ReadJson,The method has an empty catch block.
Empty Catch Block,NBitcoin.JsonConverters,KeyJsonConverter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\JsonConverters\KeyJsonConverter.cs,ReadJson,The method has an empty catch block.
Empty Catch Block,NBitcoin.JsonConverters,KeyJsonConverter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\JsonConverters\KeyJsonConverter.cs,ReadJson,The method has an empty catch block.
Empty Catch Block,NBitcoin.JsonConverters,OutpointJsonConverter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\JsonConverters\OutpointJsonConverter.cs,ReadJson,The method has an empty catch block.
Empty Catch Block,NBitcoin.JsonConverters,PSBTJsonConverter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\JsonConverters\PSBTJsonConverter.cs,ReadJson,The method has an empty catch block.
Empty Catch Block,NBitcoin.JsonConverters,PSBTJsonConverter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\JsonConverters\PSBTJsonConverter.cs,ReadJson,The method has an empty catch block.
Empty Catch Block,NBitcoin.JsonConverters,ScriptJsonConverter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\JsonConverters\ScriptJsonConverter.cs,ReadJson,The method has an empty catch block.
Empty Catch Block,NBitcoin.JsonConverters,SignatureJsonConverter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\JsonConverters\SignatureJsonConverter.cs,ReadJson,The method has an empty catch block.
Empty Catch Block,NBitcoin.JsonConverters,TxDestinationJsonConverter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\JsonConverters\TxDestinationJsonConverter.cs,ReadJson,The method has an empty catch block.
Empty Catch Block,NBitcoin.JsonConverters,UInt160JsonConverter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\JsonConverters\UIntJsonConverter.cs,ReadJson,The method has an empty catch block.
Empty Catch Block,NBitcoin.JsonConverters,UInt160JsonConverter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\JsonConverters\UIntJsonConverter.cs,ReadJson,The method has an empty catch block.
Empty Catch Block,NBitcoin.JsonConverters,UInt256JsonConverter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\JsonConverters\UIntJsonConverter.cs,ReadJson,The method has an empty catch block.
Empty Catch Block,NBitcoin.JsonConverters,UInt256JsonConverter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\JsonConverters\UIntJsonConverter.cs,ReadJson,The method has an empty catch block.
Empty Catch Block,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,DiscoverPeers,The method has an empty catch block.
Empty Catch Block,NBitcoin.Protocol,EventLoopMessageListener<T>,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\MessageListener.cs,EventLoopMessageListener,The method has an empty catch block.
Empty Catch Block,NBitcoin.Protocol,NodeConnection,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,BeginListen,The method has an empty catch block.
Empty Catch Block,NBitcoin.Protocol,NodeConnection,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,BeginListen,The method has an empty catch block.
Empty Catch Block,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,BuildUri,The method has an empty catch block.
Empty Catch Block,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,GetPeersInfoAsync,The method has an empty catch block.
Empty Catch Block,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,GetPeersInfoAsync,The method has an empty catch block.
Magic Number,NBitcoin,BitStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\BitStream.cs,BitStream,The following statement contains a magic number: _lengthInBits = buffer.Length * 8;
Magic Number,NBitcoin,BitStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\BitStream.cs,WriteBit,The following statement contains a magic number: _buffer[_writePos / 8] |= (byte)(1 << (8 - (_writePos % 8) - 1));
Magic Number,NBitcoin,BitStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\BitStream.cs,WriteBit,The following statement contains a magic number: _buffer[_writePos / 8] |= (byte)(1 << (8 - (_writePos % 8) - 1));
Magic Number,NBitcoin,BitStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\BitStream.cs,WriteBit,The following statement contains a magic number: _buffer[_writePos / 8] |= (byte)(1 << (8 - (_writePos % 8) - 1));
Magic Number,NBitcoin,BitStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\BitStream.cs,WriteBits,The following statement contains a magic number: data <<= (64 - count);
Magic Number,NBitcoin,BitStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\BitStream.cs,WriteBits,The following statement contains a magic number: var b = (byte)(data >> (64 - 8));
Magic Number,NBitcoin,BitStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\BitStream.cs,WriteBits,The following statement contains a magic number: var b = (byte)(data >> (64 - 8));
Magic Number,NBitcoin,BitStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\BitStream.cs,WriteBits,The following statement contains a magic number: data <<= 8;
Magic Number,NBitcoin,BitStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\BitStream.cs,WriteBits,The following statement contains a magic number: count -= 8;
Magic Number,NBitcoin,BitStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\BitStream.cs,WriteBits,The following statement contains a magic number: count >= 8
Magic Number,NBitcoin,BitStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\BitStream.cs,WriteBits,The following statement contains a magic number: var bit = data >> (64 - 1);
Magic Number,NBitcoin,BitStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\BitStream.cs,WriteByte,The following statement contains a magic number: var remainCount = (_writePos % 8);
Magic Number,NBitcoin,BitStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\BitStream.cs,WriteByte,The following statement contains a magic number: var i = _writePos / 8;
Magic Number,NBitcoin,BitStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\BitStream.cs,WriteByte,The following statement contains a magic number: var written = (8 - remainCount);
Magic Number,NBitcoin,BitStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\BitStream.cs,WriteByte,The following statement contains a magic number: _buffer[i + 1] = (byte)(b << (8 - remainCount));
Magic Number,NBitcoin,BitStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\BitStream.cs,TryReadBit,The following statement contains a magic number: var mask = 1 << (8 - (_readPos % 8) - 1);
Magic Number,NBitcoin,BitStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\BitStream.cs,TryReadBit,The following statement contains a magic number: var mask = 1 << (8 - (_readPos % 8) - 1);
Magic Number,NBitcoin,BitStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\BitStream.cs,TryReadBit,The following statement contains a magic number: bit = (_buffer[_readPos / 8] & mask) == mask;
Magic Number,NBitcoin,BitStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\BitStream.cs,TryReadBits,The following statement contains a magic number: val <<= 8;
Magic Number,NBitcoin,BitStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\BitStream.cs,TryReadBits,The following statement contains a magic number: count -= 8;
Magic Number,NBitcoin,BitStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\BitStream.cs,TryReadBits,The following statement contains a magic number: count >= 8
Magic Number,NBitcoin,BitStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\BitStream.cs,TryReadByte,The following statement contains a magic number: var i = _readPos / 8;
Magic Number,NBitcoin,BitStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\BitStream.cs,TryReadByte,The following statement contains a magic number: var remainCount = _readPos % 8;
Magic Number,NBitcoin,BitStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\BitStream.cs,TryReadByte,The following statement contains a magic number: b |= (byte)(_buffer[i + 1] >> (8 - remainCount));
Magic Number,NBitcoin,BitStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\BitStream.cs,TryReadByte,The following statement contains a magic number: _readPos += 8;
Magic Number,NBitcoin,BitStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\BitStream.cs,ToByteArray,The following statement contains a magic number: var arraySize = (_writePos + 7) / 8;
Magic Number,NBitcoin,BitStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\BitStream.cs,ToByteArray,The following statement contains a magic number: var arraySize = (_writePos + 7) / 8;
Magic Number,NBitcoin,BitStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\BitStream.cs,EnsureCapacity,The following statement contains a magic number: Array.Resize(ref _buffer' _buffer.Length + (4 * 1024));
Magic Number,NBitcoin,BitStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\BitStream.cs,EnsureCapacity,The following statement contains a magic number: Array.Resize(ref _buffer' _buffer.Length + (4 * 1024));
Magic Number,NBitcoin,BitStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\BitStream.cs,EnsureCapacity,The following statement contains a magic number: _writePos / 8 == _buffer.Length
Magic Number,NBitcoin,GolombRiceFilter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\GolombRiceFilter.cs,ConstructHashedSet,The following statement contains a magic number: var nphi = modNP >> 32;
Magic Number,NBitcoin,GolombRiceFilter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\GolombRiceFilter.cs,ConstructHashedSet,The following statement contains a magic number: var k1 = BitConverter.ToUInt64(key' 8);
Magic Number,NBitcoin,GolombRiceFilter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\GolombRiceFilter.cs,FastReduction,The following statement contains a magic number: var vhi = value >> 32;
Magic Number,NBitcoin,GolombRiceFilter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\GolombRiceFilter.cs,FastReduction,The following statement contains a magic number: var carry = ((ulong)((uint)vnpmid) + (ulong)((uint)npvmid) + 			(vnplo >> 32)) >> 32;
Magic Number,NBitcoin,GolombRiceFilter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\GolombRiceFilter.cs,FastReduction,The following statement contains a magic number: var carry = ((ulong)((uint)vnpmid) + (ulong)((uint)npvmid) + 			(vnplo >> 32)) >> 32;
Magic Number,NBitcoin,GolombRiceFilter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\GolombRiceFilter.cs,FastReduction,The following statement contains a magic number: value = vnphi + (vnpmid >> 32) + (npvmid >> 32) + carry;
Magic Number,NBitcoin,GolombRiceFilter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\GolombRiceFilter.cs,FastReduction,The following statement contains a magic number: value = vnphi + (vnpmid >> 32) + (npvmid >> 32) + carry;
Magic Number,NBitcoin,GolombRiceFilterBuilder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\GolombRiceFilter.cs,SetKey,The following statement contains a magic number: _key = blockHash.ToBytes().SafeSubarray(0' 16);
Magic Number,NBitcoin,GolombRiceFilterBuilder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\GolombRiceFilter.cs,SetP,The following statement contains a magic number: p <= 0 || p > 32
Magic Number,NBitcoin,GolombRiceFilterBuilder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\GolombRiceFilter.cs,AddOutPoint,The following statement contains a magic number: MemoryStream ms = new MemoryStream(32 + 4);
Magic Number,NBitcoin,GolombRiceFilterBuilder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\GolombRiceFilter.cs,AddOutPoint,The following statement contains a magic number: MemoryStream ms = new MemoryStream(32 + 4);
Magic Number,NBitcoin,ByteArrayComparer,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\GolombRiceFilter.cs,GetHashCode,The following statement contains a magic number: b = ((b << 23) | (b >> 9)) ^ a[i];
Magic Number,NBitcoin,ByteArrayComparer,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP158\GolombRiceFilter.cs,GetHashCode,The following statement contains a magic number: b = ((b << 23) | (b >> 9)) ^ a[i];
Magic Number,NBitcoin,PSBT,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PartiallySignedTransaction.cs,PSBT,The following statement contains a magic number: switch (k[0]) 				{ 					case PSBTConstants.PSBT_GLOBAL_UNSIGNED_TX: 						if (k.Length != 1) 							throw new FormatException("Invalid PSBT. Contains illegal value in key global tx"); 						if (tx != null) 							throw new FormatException("Duplicate Key' unsigned tx already provided"); 						tx = stream.ConsensusFactory.CreateTransaction(); 						uint size = 0; 						stream.ReadWriteAsVarInt(ref size); 						var pos = stream.Counter.ReadenBytes; 						tx.ReadWrite(stream); 						if (stream.Counter.ReadenBytes - pos != size) 							throw new FormatException("Malformed global tx. Unexpected size."); 						if (tx.Inputs.Any(txin => txin.ScriptSig != Script.Empty || txin.WitScript != WitScript.Empty)) 							throw new FormatException("Malformed global tx. It should not contain any scriptsig or witness by itself"); 						txFound = true; 						break; 					case PSBTConstants.PSBT_GLOBAL_XPUB when XPubVersionBytes != null: 						if (k.Length != 1 + XPubVersionBytes.Length + 74) 							throw new FormatException("Malformed global xpub."); 						for (int ii = 0; ii < XPubVersionBytes.Length; ii++) 						{ 							if (k[1 + ii] != XPubVersionBytes[ii]) 								throw new FormatException("Malformed global xpub."); 						} 						stream.ReadWriteAsVarString(ref v); 						KeyPath path = KeyPath.FromBytes(v.Skip(4).ToArray()); 						var rootedKeyPath = new RootedKeyPath(new HDFingerprint(v.Take(4).ToArray())' path); 						GlobalXPubs.Add(new ExtPubKey(k' 1 + XPubVersionBytes.Length' 74).GetWif(Network)' rootedKeyPath); 						break; 					default: 						if (unknown.ContainsKey(k)) 							throw new FormatException("Invalid PSBTInput' duplicate key for unknown value"); 						stream.ReadWriteAsVarString(ref v); 						unknown.Add(k' v); 						break; 				}
Magic Number,NBitcoin,PSBT,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PartiallySignedTransaction.cs,PSBT,The following statement contains a magic number: switch (k[0]) 				{ 					case PSBTConstants.PSBT_GLOBAL_UNSIGNED_TX: 						if (k.Length != 1) 							throw new FormatException("Invalid PSBT. Contains illegal value in key global tx"); 						if (tx != null) 							throw new FormatException("Duplicate Key' unsigned tx already provided"); 						tx = stream.ConsensusFactory.CreateTransaction(); 						uint size = 0; 						stream.ReadWriteAsVarInt(ref size); 						var pos = stream.Counter.ReadenBytes; 						tx.ReadWrite(stream); 						if (stream.Counter.ReadenBytes - pos != size) 							throw new FormatException("Malformed global tx. Unexpected size."); 						if (tx.Inputs.Any(txin => txin.ScriptSig != Script.Empty || txin.WitScript != WitScript.Empty)) 							throw new FormatException("Malformed global tx. It should not contain any scriptsig or witness by itself"); 						txFound = true; 						break; 					case PSBTConstants.PSBT_GLOBAL_XPUB when XPubVersionBytes != null: 						if (k.Length != 1 + XPubVersionBytes.Length + 74) 							throw new FormatException("Malformed global xpub."); 						for (int ii = 0; ii < XPubVersionBytes.Length; ii++) 						{ 							if (k[1 + ii] != XPubVersionBytes[ii]) 								throw new FormatException("Malformed global xpub."); 						} 						stream.ReadWriteAsVarString(ref v); 						KeyPath path = KeyPath.FromBytes(v.Skip(4).ToArray()); 						var rootedKeyPath = new RootedKeyPath(new HDFingerprint(v.Take(4).ToArray())' path); 						GlobalXPubs.Add(new ExtPubKey(k' 1 + XPubVersionBytes.Length' 74).GetWif(Network)' rootedKeyPath); 						break; 					default: 						if (unknown.ContainsKey(k)) 							throw new FormatException("Invalid PSBTInput' duplicate key for unknown value"); 						stream.ReadWriteAsVarString(ref v); 						unknown.Add(k' v); 						break; 				}
Magic Number,NBitcoin,PSBT,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PartiallySignedTransaction.cs,PSBT,The following statement contains a magic number: switch (k[0]) 				{ 					case PSBTConstants.PSBT_GLOBAL_UNSIGNED_TX: 						if (k.Length != 1) 							throw new FormatException("Invalid PSBT. Contains illegal value in key global tx"); 						if (tx != null) 							throw new FormatException("Duplicate Key' unsigned tx already provided"); 						tx = stream.ConsensusFactory.CreateTransaction(); 						uint size = 0; 						stream.ReadWriteAsVarInt(ref size); 						var pos = stream.Counter.ReadenBytes; 						tx.ReadWrite(stream); 						if (stream.Counter.ReadenBytes - pos != size) 							throw new FormatException("Malformed global tx. Unexpected size."); 						if (tx.Inputs.Any(txin => txin.ScriptSig != Script.Empty || txin.WitScript != WitScript.Empty)) 							throw new FormatException("Malformed global tx. It should not contain any scriptsig or witness by itself"); 						txFound = true; 						break; 					case PSBTConstants.PSBT_GLOBAL_XPUB when XPubVersionBytes != null: 						if (k.Length != 1 + XPubVersionBytes.Length + 74) 							throw new FormatException("Malformed global xpub."); 						for (int ii = 0; ii < XPubVersionBytes.Length; ii++) 						{ 							if (k[1 + ii] != XPubVersionBytes[ii]) 								throw new FormatException("Malformed global xpub."); 						} 						stream.ReadWriteAsVarString(ref v); 						KeyPath path = KeyPath.FromBytes(v.Skip(4).ToArray()); 						var rootedKeyPath = new RootedKeyPath(new HDFingerprint(v.Take(4).ToArray())' path); 						GlobalXPubs.Add(new ExtPubKey(k' 1 + XPubVersionBytes.Length' 74).GetWif(Network)' rootedKeyPath); 						break; 					default: 						if (unknown.ContainsKey(k)) 							throw new FormatException("Invalid PSBTInput' duplicate key for unknown value"); 						stream.ReadWriteAsVarString(ref v); 						unknown.Add(k' v); 						break; 				}
Magic Number,NBitcoin,PSBT,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PartiallySignedTransaction.cs,PSBT,The following statement contains a magic number: switch (k[0]) 				{ 					case PSBTConstants.PSBT_GLOBAL_UNSIGNED_TX: 						if (k.Length != 1) 							throw new FormatException("Invalid PSBT. Contains illegal value in key global tx"); 						if (tx != null) 							throw new FormatException("Duplicate Key' unsigned tx already provided"); 						tx = stream.ConsensusFactory.CreateTransaction(); 						uint size = 0; 						stream.ReadWriteAsVarInt(ref size); 						var pos = stream.Counter.ReadenBytes; 						tx.ReadWrite(stream); 						if (stream.Counter.ReadenBytes - pos != size) 							throw new FormatException("Malformed global tx. Unexpected size."); 						if (tx.Inputs.Any(txin => txin.ScriptSig != Script.Empty || txin.WitScript != WitScript.Empty)) 							throw new FormatException("Malformed global tx. It should not contain any scriptsig or witness by itself"); 						txFound = true; 						break; 					case PSBTConstants.PSBT_GLOBAL_XPUB when XPubVersionBytes != null: 						if (k.Length != 1 + XPubVersionBytes.Length + 74) 							throw new FormatException("Malformed global xpub."); 						for (int ii = 0; ii < XPubVersionBytes.Length; ii++) 						{ 							if (k[1 + ii] != XPubVersionBytes[ii]) 								throw new FormatException("Malformed global xpub."); 						} 						stream.ReadWriteAsVarString(ref v); 						KeyPath path = KeyPath.FromBytes(v.Skip(4).ToArray()); 						var rootedKeyPath = new RootedKeyPath(new HDFingerprint(v.Take(4).ToArray())' path); 						GlobalXPubs.Add(new ExtPubKey(k' 1 + XPubVersionBytes.Length' 74).GetWif(Network)' rootedKeyPath); 						break; 					default: 						if (unknown.ContainsKey(k)) 							throw new FormatException("Invalid PSBTInput' duplicate key for unknown value"); 						stream.ReadWriteAsVarString(ref v); 						unknown.Add(k' v); 						break; 				}
Magic Number,NBitcoin,PSBT,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PartiallySignedTransaction.cs,Serialize,The following statement contains a magic number: var len = (uint)(1 + XPubVersionBytes.Length + 74);
Magic Number,NBitcoin,PSBTInput,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTInput.cs,PSBTInput,The following statement contains a magic number: switch (k.First()) 				{ 					case PSBTConstants.PSBT_IN_NON_WITNESS_UTXO: 						if (k.Length != 1) 							throw new FormatException("Invalid PSBTInput. Contains illegal value in key for NonWitnessUTXO"); 						if (non_witness_utxo != null) 							throw new FormatException("Invalid PSBTInput. Duplicate non_witness_utxo"); 						non_witness_utxo = this.GetConsensusFactory().CreateTransaction(); 						non_witness_utxo.FromBytes(v); 						break; 					case PSBTConstants.PSBT_IN_WITNESS_UTXO: 						if (k.Length != 1) 							throw new FormatException("Invalid PSBTInput. Contains illegal value in key for WitnessUTXO"); 						if (witness_utxo != null) 							throw new FormatException("Invalid PSBTInput. Duplicate witness_utxo"); 						if (this.GetConsensusFactory().TryCreateNew<TxOut>(out var txout)) 						{ 							witness_utxo = txout; 						} 						else 						{ 							witness_utxo = new TxOut(); 						} 						witness_utxo.FromBytes(v); 						break; 					case PSBTConstants.PSBT_IN_PARTIAL_SIG: 						var pubkey = new PubKey(k.Skip(1).ToArray()); 						if (partial_sigs.ContainsKey(pubkey)) 							throw new FormatException("Invalid PSBTInput. Duplicate key for partial_sigs"); 						partial_sigs.Add(pubkey' new TransactionSignature(v)); 						break; 					case PSBTConstants.PSBT_IN_SIGHASH: 						if (k.Length != 1) 							throw new FormatException("Invalid PSBTInput. Contains illegal value in key for SigHash type"); 						if (!(sighash_type is null)) 							throw new FormatException("Invalid PSBTInput. Duplicate key for sighash_type"); 						if (v.Length != 4) 							throw new FormatException("Invalid PSBTInput. SigHash Type is not 4 byte"); 						var value = Utils.ToUInt32(v' 0' true); 						if (!Enum.IsDefined(typeof(SigHash)' value)) 							throw new FormatException($"Invalid PSBTInput Unknown SigHash Type {value}"); 						sighash_type = (SigHash)value; 						break; 					case PSBTConstants.PSBT_IN_REDEEMSCRIPT: 						if (k.Length != 1) 							throw new FormatException("Invalid PSBTInput. Contains illegal value in key for redeem script"); 						if (redeem_script != null) 							throw new FormatException("Invalid PSBTInput. Duplicate key for redeem_script"); 						redeem_script = Script.FromBytesUnsafe(v); 						break; 					case PSBTConstants.PSBT_IN_WITNESSSCRIPT: 						if (k.Length != 1) 							throw new FormatException("Invalid PSBTInput. Contains illegal value in key for witness script"); 						if (witness_script != null) 							throw new FormatException("Invalid PSBTInput. Duplicate key for redeem_script"); 						witness_script = Script.FromBytesUnsafe(v); 						break; 					case PSBTConstants.PSBT_IN_BIP32_DERIVATION: 						var pubkey2 = new PubKey(k.Skip(1).ToArray()); 						if (hd_keypaths.ContainsKey(pubkey2)) 							throw new FormatException("Invalid PSBTInput. Duplicate key for hd_keypaths"); 						var masterFingerPrint = new HDFingerprint(v.Take(4).ToArray()); 						KeyPath path = KeyPath.FromBytes(v.Skip(4).ToArray()); 						hd_keypaths.Add(pubkey2' new RootedKeyPath(masterFingerPrint' path)); 						break; 					case PSBTConstants.PSBT_IN_SCRIPTSIG: 						if (k.Length != 1) 							throw new FormatException("Invalid PSBTInput. Contains illegal value in key for final scriptsig"); 						if (final_script_sig != null) 							throw new FormatException("Invalid PSBTInput. Duplicate key for final_script_sig"); 						final_script_sig = Script.FromBytesUnsafe(v); 						break; 					case PSBTConstants.PSBT_IN_SCRIPTWITNESS: 						if (k.Length != 1) 							throw new FormatException("Invalid PSBTInput. Contains illegal value in key for final script witness"); 						if (final_script_witness != null) 							throw new FormatException("Invalid PSBTInput. Duplicate key for final_script_witness"); 						final_script_witness = new WitScript(v); 						break; 					default: 						if (unknown.ContainsKey(k)) 							throw new FormatException("Invalid PSBTInput. Duplicate key for unknown value"); 						unknown.Add(k' v); 						break; 				}
Magic Number,NBitcoin,PSBTInput,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTInput.cs,PSBTInput,The following statement contains a magic number: switch (k.First()) 				{ 					case PSBTConstants.PSBT_IN_NON_WITNESS_UTXO: 						if (k.Length != 1) 							throw new FormatException("Invalid PSBTInput. Contains illegal value in key for NonWitnessUTXO"); 						if (non_witness_utxo != null) 							throw new FormatException("Invalid PSBTInput. Duplicate non_witness_utxo"); 						non_witness_utxo = this.GetConsensusFactory().CreateTransaction(); 						non_witness_utxo.FromBytes(v); 						break; 					case PSBTConstants.PSBT_IN_WITNESS_UTXO: 						if (k.Length != 1) 							throw new FormatException("Invalid PSBTInput. Contains illegal value in key for WitnessUTXO"); 						if (witness_utxo != null) 							throw new FormatException("Invalid PSBTInput. Duplicate witness_utxo"); 						if (this.GetConsensusFactory().TryCreateNew<TxOut>(out var txout)) 						{ 							witness_utxo = txout; 						} 						else 						{ 							witness_utxo = new TxOut(); 						} 						witness_utxo.FromBytes(v); 						break; 					case PSBTConstants.PSBT_IN_PARTIAL_SIG: 						var pubkey = new PubKey(k.Skip(1).ToArray()); 						if (partial_sigs.ContainsKey(pubkey)) 							throw new FormatException("Invalid PSBTInput. Duplicate key for partial_sigs"); 						partial_sigs.Add(pubkey' new TransactionSignature(v)); 						break; 					case PSBTConstants.PSBT_IN_SIGHASH: 						if (k.Length != 1) 							throw new FormatException("Invalid PSBTInput. Contains illegal value in key for SigHash type"); 						if (!(sighash_type is null)) 							throw new FormatException("Invalid PSBTInput. Duplicate key for sighash_type"); 						if (v.Length != 4) 							throw new FormatException("Invalid PSBTInput. SigHash Type is not 4 byte"); 						var value = Utils.ToUInt32(v' 0' true); 						if (!Enum.IsDefined(typeof(SigHash)' value)) 							throw new FormatException($"Invalid PSBTInput Unknown SigHash Type {value}"); 						sighash_type = (SigHash)value; 						break; 					case PSBTConstants.PSBT_IN_REDEEMSCRIPT: 						if (k.Length != 1) 							throw new FormatException("Invalid PSBTInput. Contains illegal value in key for redeem script"); 						if (redeem_script != null) 							throw new FormatException("Invalid PSBTInput. Duplicate key for redeem_script"); 						redeem_script = Script.FromBytesUnsafe(v); 						break; 					case PSBTConstants.PSBT_IN_WITNESSSCRIPT: 						if (k.Length != 1) 							throw new FormatException("Invalid PSBTInput. Contains illegal value in key for witness script"); 						if (witness_script != null) 							throw new FormatException("Invalid PSBTInput. Duplicate key for redeem_script"); 						witness_script = Script.FromBytesUnsafe(v); 						break; 					case PSBTConstants.PSBT_IN_BIP32_DERIVATION: 						var pubkey2 = new PubKey(k.Skip(1).ToArray()); 						if (hd_keypaths.ContainsKey(pubkey2)) 							throw new FormatException("Invalid PSBTInput. Duplicate key for hd_keypaths"); 						var masterFingerPrint = new HDFingerprint(v.Take(4).ToArray()); 						KeyPath path = KeyPath.FromBytes(v.Skip(4).ToArray()); 						hd_keypaths.Add(pubkey2' new RootedKeyPath(masterFingerPrint' path)); 						break; 					case PSBTConstants.PSBT_IN_SCRIPTSIG: 						if (k.Length != 1) 							throw new FormatException("Invalid PSBTInput. Contains illegal value in key for final scriptsig"); 						if (final_script_sig != null) 							throw new FormatException("Invalid PSBTInput. Duplicate key for final_script_sig"); 						final_script_sig = Script.FromBytesUnsafe(v); 						break; 					case PSBTConstants.PSBT_IN_SCRIPTWITNESS: 						if (k.Length != 1) 							throw new FormatException("Invalid PSBTInput. Contains illegal value in key for final script witness"); 						if (final_script_witness != null) 							throw new FormatException("Invalid PSBTInput. Duplicate key for final_script_witness"); 						final_script_witness = new WitScript(v); 						break; 					default: 						if (unknown.ContainsKey(k)) 							throw new FormatException("Invalid PSBTInput. Duplicate key for unknown value"); 						unknown.Add(k' v); 						break; 				}
Magic Number,NBitcoin,PSBTInput,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTInput.cs,PSBTInput,The following statement contains a magic number: switch (k.First()) 				{ 					case PSBTConstants.PSBT_IN_NON_WITNESS_UTXO: 						if (k.Length != 1) 							throw new FormatException("Invalid PSBTInput. Contains illegal value in key for NonWitnessUTXO"); 						if (non_witness_utxo != null) 							throw new FormatException("Invalid PSBTInput. Duplicate non_witness_utxo"); 						non_witness_utxo = this.GetConsensusFactory().CreateTransaction(); 						non_witness_utxo.FromBytes(v); 						break; 					case PSBTConstants.PSBT_IN_WITNESS_UTXO: 						if (k.Length != 1) 							throw new FormatException("Invalid PSBTInput. Contains illegal value in key for WitnessUTXO"); 						if (witness_utxo != null) 							throw new FormatException("Invalid PSBTInput. Duplicate witness_utxo"); 						if (this.GetConsensusFactory().TryCreateNew<TxOut>(out var txout)) 						{ 							witness_utxo = txout; 						} 						else 						{ 							witness_utxo = new TxOut(); 						} 						witness_utxo.FromBytes(v); 						break; 					case PSBTConstants.PSBT_IN_PARTIAL_SIG: 						var pubkey = new PubKey(k.Skip(1).ToArray()); 						if (partial_sigs.ContainsKey(pubkey)) 							throw new FormatException("Invalid PSBTInput. Duplicate key for partial_sigs"); 						partial_sigs.Add(pubkey' new TransactionSignature(v)); 						break; 					case PSBTConstants.PSBT_IN_SIGHASH: 						if (k.Length != 1) 							throw new FormatException("Invalid PSBTInput. Contains illegal value in key for SigHash type"); 						if (!(sighash_type is null)) 							throw new FormatException("Invalid PSBTInput. Duplicate key for sighash_type"); 						if (v.Length != 4) 							throw new FormatException("Invalid PSBTInput. SigHash Type is not 4 byte"); 						var value = Utils.ToUInt32(v' 0' true); 						if (!Enum.IsDefined(typeof(SigHash)' value)) 							throw new FormatException($"Invalid PSBTInput Unknown SigHash Type {value}"); 						sighash_type = (SigHash)value; 						break; 					case PSBTConstants.PSBT_IN_REDEEMSCRIPT: 						if (k.Length != 1) 							throw new FormatException("Invalid PSBTInput. Contains illegal value in key for redeem script"); 						if (redeem_script != null) 							throw new FormatException("Invalid PSBTInput. Duplicate key for redeem_script"); 						redeem_script = Script.FromBytesUnsafe(v); 						break; 					case PSBTConstants.PSBT_IN_WITNESSSCRIPT: 						if (k.Length != 1) 							throw new FormatException("Invalid PSBTInput. Contains illegal value in key for witness script"); 						if (witness_script != null) 							throw new FormatException("Invalid PSBTInput. Duplicate key for redeem_script"); 						witness_script = Script.FromBytesUnsafe(v); 						break; 					case PSBTConstants.PSBT_IN_BIP32_DERIVATION: 						var pubkey2 = new PubKey(k.Skip(1).ToArray()); 						if (hd_keypaths.ContainsKey(pubkey2)) 							throw new FormatException("Invalid PSBTInput. Duplicate key for hd_keypaths"); 						var masterFingerPrint = new HDFingerprint(v.Take(4).ToArray()); 						KeyPath path = KeyPath.FromBytes(v.Skip(4).ToArray()); 						hd_keypaths.Add(pubkey2' new RootedKeyPath(masterFingerPrint' path)); 						break; 					case PSBTConstants.PSBT_IN_SCRIPTSIG: 						if (k.Length != 1) 							throw new FormatException("Invalid PSBTInput. Contains illegal value in key for final scriptsig"); 						if (final_script_sig != null) 							throw new FormatException("Invalid PSBTInput. Duplicate key for final_script_sig"); 						final_script_sig = Script.FromBytesUnsafe(v); 						break; 					case PSBTConstants.PSBT_IN_SCRIPTWITNESS: 						if (k.Length != 1) 							throw new FormatException("Invalid PSBTInput. Contains illegal value in key for final script witness"); 						if (final_script_witness != null) 							throw new FormatException("Invalid PSBTInput. Duplicate key for final_script_witness"); 						final_script_witness = new WitScript(v); 						break; 					default: 						if (unknown.ContainsKey(k)) 							throw new FormatException("Invalid PSBTInput. Duplicate key for unknown value"); 						unknown.Add(k' v); 						break; 				}
Magic Number,NBitcoin,PSBTOutput,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTOutput.cs,PSBTOutput,The following statement contains a magic number: switch (k.First()) 				{ 					case PSBTConstants.PSBT_OUT_REDEEMSCRIPT: 						if (k.Length != 1) 							throw new FormatException("Invalid PSBTOutput. Contains illegal value in key for redeem script"); 						if (redeem_script != null) 							throw new FormatException("Invalid PSBTOutput' duplicate key for redeem_script"); 						redeem_script = Script.FromBytesUnsafe(v); 						break; 					case PSBTConstants.PSBT_OUT_WITNESSSCRIPT: 						if (k.Length != 1) 							throw new FormatException("Invalid PSBTOutput. Contains illegal value in key for witness script"); 						if (witness_script != null) 							throw new FormatException("Invalid PSBTOutput' duplicate key for redeem_script"); 						witness_script = Script.FromBytesUnsafe(v); 						break; 					case PSBTConstants.PSBT_OUT_BIP32_DERIVATION: 						var pubkey2 = new PubKey(k.Skip(1).ToArray()); 						if (hd_keypaths.ContainsKey(pubkey2)) 							throw new FormatException("Invalid PSBTOutput' duplicate key for hd_keypaths"); 						KeyPath path = KeyPath.FromBytes(v.Skip(4).ToArray()); 						hd_keypaths.Add(pubkey2' new RootedKeyPath(new HDFingerprint(v.Take(4).ToArray())' path)); 						break; 					default: 						if (unknown.ContainsKey(k)) 							throw new FormatException("Invalid PSBTInput' duplicate key for unknown value"); 						unknown.Add(k' v); 						break; 				}
Magic Number,NBitcoin,PSBTOutput,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP174\PSBTOutput.cs,PSBTOutput,The following statement contains a magic number: switch (k.First()) 				{ 					case PSBTConstants.PSBT_OUT_REDEEMSCRIPT: 						if (k.Length != 1) 							throw new FormatException("Invalid PSBTOutput. Contains illegal value in key for redeem script"); 						if (redeem_script != null) 							throw new FormatException("Invalid PSBTOutput' duplicate key for redeem_script"); 						redeem_script = Script.FromBytesUnsafe(v); 						break; 					case PSBTConstants.PSBT_OUT_WITNESSSCRIPT: 						if (k.Length != 1) 							throw new FormatException("Invalid PSBTOutput. Contains illegal value in key for witness script"); 						if (witness_script != null) 							throw new FormatException("Invalid PSBTOutput' duplicate key for redeem_script"); 						witness_script = Script.FromBytesUnsafe(v); 						break; 					case PSBTConstants.PSBT_OUT_BIP32_DERIVATION: 						var pubkey2 = new PubKey(k.Skip(1).ToArray()); 						if (hd_keypaths.ContainsKey(pubkey2)) 							throw new FormatException("Invalid PSBTOutput' duplicate key for hd_keypaths"); 						KeyPath path = KeyPath.FromBytes(v.Skip(4).ToArray()); 						hd_keypaths.Add(pubkey2' new RootedKeyPath(new HDFingerprint(v.Take(4).ToArray())' path)); 						break; 					default: 						if (unknown.ContainsKey(k)) 							throw new FormatException("Invalid PSBTInput' duplicate key for unknown value"); 						unknown.Add(k' v); 						break; 				}
Magic Number,NBitcoin,ExtKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP32\ExtKey.cs,ExtKey,The following statement contains a magic number: throw new ArgumentException(string.Format("The fingerprint must be {0} bytes."' 4)' "fingerprint");
Magic Number,NBitcoin,ExtKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP32\ExtKey.cs,ExtKey,The following statement contains a magic number: fingerprint.Length != 4
Magic Number,NBitcoin,ExtKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP32\ExtKey.cs,ExtKey,The following statement contains a magic number: byte[] seed = RandomUtils.GetBytes(64);
Magic Number,NBitcoin,ExtKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP32\ExtKey.cs,SetMaster,The following statement contains a magic number: key = new Key(hashMAC.SafeSubarray(0' 32));
Magic Number,NBitcoin,ExtKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP32\ExtKey.cs,SetMaster,The following statement contains a magic number: Buffer.BlockCopy(hashMAC' 32' vchChainCode' 0' ChainCodeLength);
Magic Number,NBitcoin,ExtKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP32\ExtKey.cs,GetParentExtKey,The following statement contains a magic number: byte[] ll = new byte[32];
Magic Number,NBitcoin,ExtKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP32\ExtKey.cs,GetParentExtKey,The following statement contains a magic number: byte[] lr = new byte[32];
Magic Number,NBitcoin,ExtKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP32\ExtKey.cs,GetParentExtKey,The following statement contains a magic number: Array.Copy(l' ll' 32);
Magic Number,NBitcoin,ExtKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP32\ExtKey.cs,GetParentExtKey,The following statement contains a magic number: Array.Copy(l' 32' lr' 0' 32);
Magic Number,NBitcoin,ExtKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP32\ExtKey.cs,GetParentExtKey,The following statement contains a magic number: Array.Copy(l' 32' lr' 0' 32);
Magic Number,NBitcoin,ExtKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP32\ExtKey.cs,GetParentExtKey,The following statement contains a magic number: keyParentBytes = new byte[32 - keyParentBytes.Length].Concat(keyParentBytes).ToArray();
Magic Number,NBitcoin,ExtKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP32\ExtKey.cs,GetParentExtKey,The following statement contains a magic number: keyParentBytes.Length < 32
Magic Number,NBitcoin,HDFingerprint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP32\HDFingerPrint.cs,HDFingerprint,The following statement contains a magic number: bytes.Length != 4
Magic Number,NBitcoin,HDFingerprint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP32\HDFingerPrint.cs,TryParse,The following statement contains a magic number: !HexEncoder.IsWellFormed(str) || str.Length != 4 * 2
Magic Number,NBitcoin,HDFingerprint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP32\HDFingerPrint.cs,TryParse,The following statement contains a magic number: !HexEncoder.IsWellFormed(str) || str.Length != 4 * 2
Magic Number,NBitcoin,HDFingerprint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP32\HDFingerPrint.cs,HDFingerprint,The following statement contains a magic number: bytes.Length != 4
Magic Number,NBitcoin,KeyPath,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP32\KeyPath.cs,TryParse,The following statement contains a magic number: var indices =  				path  				.Split(new[] { '/' }' StringSplitOptions.RemoveEmptyEntries)  				.Where(p => p != "m")  				.Select(p =>  				{  					isValid &= TryParseCore(p' out var i);  					count++;  					if (count > 255)  						isValid = false;  					return i;  				})  				.Where(_ => isValid)  				.ToArray();
Magic Number,NBitcoin,KeyPath,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP32\KeyPath.cs,KeyPath,The following statement contains a magic number: _Indexes =  				path  				.Split(new[] { '/' }' StringSplitOptions.RemoveEmptyEntries)  				.Where(p => p != "m")  				.Select(p =>  				{  					if (!TryParseCore(p' out var i))  						throw new FormatException("KeyPath uncorrectly formatted");  					count++;  					if (count > 255)  						throw new FormatException("KeyPath uncorrectly formatted");  					return i;  				})  				.ToArray();
Magic Number,NBitcoin,KeyPath,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP32\KeyPath.cs,FromBytes,The following statement contains a magic number: data.Length % 4 != 0
Magic Number,NBitcoin,KeyPath,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP32\KeyPath.cs,FromBytes,The following statement contains a magic number: var depth = data.Length / 4;
Magic Number,NBitcoin,KeyPath,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP32\KeyPath.cs,FromBytes,The following statement contains a magic number: result[i] = Utils.ToUInt32(data' i * 4' true);
Magic Number,NBitcoin,KeyPath,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP32\KeyPath.cs,KeyPath,The following statement contains a magic number: indexes.Length > 255
Magic Number,NBitcoin,BitcoinConfirmationCode,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinConfirmationCode.cs,Check,The following statement contains a magic number: pointbprefix = (byte)(pointbprefix ^ (byte)(derived[63] & (byte)0x01));
Magic Number,NBitcoin,BitcoinEncryptedSecretNoEC,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,GenerateWif,The following statement contains a magic number: var addresshash = Hashes.Hash256(addressBytes).ToBytes().SafeSubarray(0' 4);
Magic Number,NBitcoin,BitcoinEncryptedSecretNoEC,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,GetKey,The following statement contains a magic number: var salt = Hashes.Hash256(addressBytes).ToBytes().SafeSubarray(0' 4);
Magic Number,NBitcoin,BitcoinEncryptedSecretEC,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,GetKey,The following statement contains a magic number: keyBytes = new byte[32 - keyBytes.Length].Concat(keyBytes).ToArray();
Magic Number,NBitcoin,BitcoinEncryptedSecretEC,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,GetKey,The following statement contains a magic number: keyBytes.Length < 32
Magic Number,NBitcoin,BitcoinEncryptedSecretEC,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,HashAddress,The following statement contains a magic number: return Hashes.Hash256(Encoders.ASCII.DecodeData(address.ToString())).ToBytes().Take(4).ToArray();
Magic Number,NBitcoin,BitcoinEncryptedSecretEC,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,CalculatePassFactor,The following statement contains a magic number: passfactor = SCrypt.BitcoinComputeDerivedKey(Encoding.UTF8.GetBytes(password)' ownerEntropy' 32);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,CreateAES256,The following statement contains a magic number: aes.KeySize = 256;
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,CreateAES256,The following statement contains a magic number: aes.IV = new byte[16];
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptKey,The following statement contains a magic number: var keyhalf1 = key.SafeSubarray(0' 16);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptKey,The following statement contains a magic number: var keyhalf2 = key.SafeSubarray(16' 16);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptKey,The following statement contains a magic number: var keyhalf2 = key.SafeSubarray(16' 16);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptKey,The following statement contains a magic number: var derivedhalf1 = derived.SafeSubarray(0' 32);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptKey,The following statement contains a magic number: var derivedhalf2 = derived.SafeSubarray(32' 32);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptKey,The following statement contains a magic number: var derivedhalf2 = derived.SafeSubarray(32' 32);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptKey,The following statement contains a magic number: var encryptedhalf1 = new byte[16];
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptKey,The following statement contains a magic number: var encryptedhalf2 = new byte[16];
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptKey,The following statement contains a magic number: i < 16
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptKey,The following statement contains a magic number: encrypt.TransformBlock(derivedhalf1' 0' 16' encryptedhalf1' 0);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptKey,The following statement contains a magic number: derivedhalf1[16 + i] = (byte)(keyhalf2[i] ^ derivedhalf1[16 + i]);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptKey,The following statement contains a magic number: derivedhalf1[16 + i] = (byte)(keyhalf2[i] ^ derivedhalf1[16 + i]);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptKey,The following statement contains a magic number: i < 16
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptKey,The following statement contains a magic number: encrypt.TransformBlock(derivedhalf1' 16' 16' encryptedhalf2' 0);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptKey,The following statement contains a magic number: encrypt.TransformBlock(derivedhalf1' 16' 16' encryptedhalf2' 0);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptKey,The following statement contains a magic number: var derivedhalf1 = derived.SafeSubarray(0' 32);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptKey,The following statement contains a magic number: var derivedhalf2 = derived.SafeSubarray(32' 32);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptKey,The following statement contains a magic number: var derivedhalf2 = derived.SafeSubarray(32' 32);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptKey,The following statement contains a magic number: var encryptedHalf1 = encrypted.SafeSubarray(0' 16);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptKey,The following statement contains a magic number: var encryptedHalf2 = encrypted.SafeSubarray(16' 16);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptKey,The following statement contains a magic number: var encryptedHalf2 = encrypted.SafeSubarray(16' 16);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptKey,The following statement contains a magic number: byte[] bitcoinprivkey1 = new byte[16];
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptKey,The following statement contains a magic number: byte[] bitcoinprivkey2 = new byte[16];
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptKey,The following statement contains a magic number: decrypt.TransformBlock(encryptedHalf1' 0' 16' bitcoinprivkey1' 0);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptKey,The following statement contains a magic number: decrypt.TransformBlock(encryptedHalf1' 0' 16' bitcoinprivkey1' 0);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptKey,The following statement contains a magic number: i < 16
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptKey,The following statement contains a magic number: decrypt.TransformBlock(encryptedHalf2' 0' 16' bitcoinprivkey2' 0);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptKey,The following statement contains a magic number: decrypt.TransformBlock(encryptedHalf2' 0' 16' bitcoinprivkey2' 0);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptKey,The following statement contains a magic number: bitcoinprivkey2[i] ^= derivedhalf1[16 + i];
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptKey,The following statement contains a magic number: i < 16
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptSeed,The following statement contains a magic number: var derivedhalf1 = derived.SafeSubarray(0' 32);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptSeed,The following statement contains a magic number: var derivedhalf2 = derived.SafeSubarray(32' 32);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptSeed,The following statement contains a magic number: var derivedhalf2 = derived.SafeSubarray(32' 32);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptSeed,The following statement contains a magic number: var encryptedhalf1 = new byte[16];
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptSeed,The following statement contains a magic number: var encryptedhalf2 = new byte[16];
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptSeed,The following statement contains a magic number: i < 16
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptSeed,The following statement contains a magic number: encrypt.TransformBlock(derivedhalf1' 0' 16' encryptedhalf1' 0);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptSeed,The following statement contains a magic number: var half = encryptedhalf1.SafeSubarray(8' 8).Concat(seedb.SafeSubarray(16' 8)).ToArray();
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptSeed,The following statement contains a magic number: var half = encryptedhalf1.SafeSubarray(8' 8).Concat(seedb.SafeSubarray(16' 8)).ToArray();
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptSeed,The following statement contains a magic number: var half = encryptedhalf1.SafeSubarray(8' 8).Concat(seedb.SafeSubarray(16' 8)).ToArray();
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptSeed,The following statement contains a magic number: var half = encryptedhalf1.SafeSubarray(8' 8).Concat(seedb.SafeSubarray(16' 8)).ToArray();
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptSeed,The following statement contains a magic number: derivedhalf1[16 + i] = (byte)(half[i] ^ derivedhalf1[16 + i]);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptSeed,The following statement contains a magic number: derivedhalf1[16 + i] = (byte)(half[i] ^ derivedhalf1[16 + i]);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptSeed,The following statement contains a magic number: i < 16
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptSeed,The following statement contains a magic number: encrypt.TransformBlock(derivedhalf1' 16' 16' encryptedhalf2' 0);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,EncryptSeed,The following statement contains a magic number: encrypt.TransformBlock(derivedhalf1' 16' 16' encryptedhalf2' 0);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptSeed,The following statement contains a magic number: byte[] seedb = new byte[24];
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptSeed,The following statement contains a magic number: var derivedhalf1 = derived.SafeSubarray(0' 32);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptSeed,The following statement contains a magic number: var derivedhalf2 = derived.SafeSubarray(32' 32);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptSeed,The following statement contains a magic number: var derivedhalf2 = derived.SafeSubarray(32' 32);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptSeed,The following statement contains a magic number: var encryptedhalf2 = encrypted.SafeSubarray(16' 16);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptSeed,The following statement contains a magic number: var encryptedhalf2 = encrypted.SafeSubarray(16' 16);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptSeed,The following statement contains a magic number: byte[] half = new byte[16];
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptSeed,The following statement contains a magic number: decrypt.TransformBlock(encryptedhalf2' 0' 16' half' 0);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptSeed,The following statement contains a magic number: decrypt.TransformBlock(encryptedhalf2' 0' 16' half' 0);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptSeed,The following statement contains a magic number: half[i] = (byte)(half[i] ^ derivedhalf1[16 + i]);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptSeed,The following statement contains a magic number: i < 16
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptSeed,The following statement contains a magic number: i < 8
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptSeed,The following statement contains a magic number: encrypted[i + 8] = half[i];
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptSeed,The following statement contains a magic number: i < 8
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptSeed,The following statement contains a magic number: var encryptedhalf1 = encrypted.SafeSubarray(0' 16);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptSeed,The following statement contains a magic number: decrypt.TransformBlock(encryptedhalf1' 0' 16' seedb' 0);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptSeed,The following statement contains a magic number: decrypt.TransformBlock(encryptedhalf1' 0' 16' seedb' 0);
Magic Number,NBitcoin,BitcoinEncryptedSecret,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinEncryptedSecret.cs,DecryptSeed,The following statement contains a magic number: i < 16
Magic Number,NBitcoin,LotSequence,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinPassphraseCode.cs,LotSequence,The following statement contains a magic number: lot > 1048575 || lot < 0
Magic Number,NBitcoin,LotSequence,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinPassphraseCode.cs,LotSequence,The following statement contains a magic number: sequence > 1024 || sequence < 0
Magic Number,NBitcoin,LotSequence,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinPassphraseCode.cs,LotSequence,The following statement contains a magic number: uint lotSequence = (uint)lot * 4096 + (uint)sequence;
Magic Number,NBitcoin,LotSequence,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinPassphraseCode.cs,LotSequence,The following statement contains a magic number: _Bytes =  				new[]  					{  						(byte)(lotSequence >> 24)'  						(byte)(lotSequence >> 16)'  						(byte)(lotSequence >> 8)'  						(byte)(lotSequence)  					};
Magic Number,NBitcoin,LotSequence,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinPassphraseCode.cs,LotSequence,The following statement contains a magic number: _Bytes =  				new[]  					{  						(byte)(lotSequence >> 24)'  						(byte)(lotSequence >> 16)'  						(byte)(lotSequence >> 8)'  						(byte)(lotSequence)  					};
Magic Number,NBitcoin,LotSequence,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinPassphraseCode.cs,LotSequence,The following statement contains a magic number: _Bytes =  				new[]  					{  						(byte)(lotSequence >> 24)'  						(byte)(lotSequence >> 16)'  						(byte)(lotSequence >> 8)'  						(byte)(lotSequence)  					};
Magic Number,NBitcoin,LotSequence,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinPassphraseCode.cs,LotSequence,The following statement contains a magic number: uint lotSequence =  				((uint)_Bytes[0] << 24) +  				((uint)_Bytes[1] << 16) +  				((uint)_Bytes[2] << 8) +  				((uint)_Bytes[3] << 0);
Magic Number,NBitcoin,LotSequence,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinPassphraseCode.cs,LotSequence,The following statement contains a magic number: uint lotSequence =  				((uint)_Bytes[0] << 24) +  				((uint)_Bytes[1] << 16) +  				((uint)_Bytes[2] << 8) +  				((uint)_Bytes[3] << 0);
Magic Number,NBitcoin,LotSequence,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinPassphraseCode.cs,LotSequence,The following statement contains a magic number: uint lotSequence =  				((uint)_Bytes[0] << 24) +  				((uint)_Bytes[1] << 16) +  				((uint)_Bytes[2] << 8) +  				((uint)_Bytes[3] << 0);
Magic Number,NBitcoin,LotSequence,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinPassphraseCode.cs,LotSequence,The following statement contains a magic number: uint lotSequence =  				((uint)_Bytes[0] << 24) +  				((uint)_Bytes[1] << 16) +  				((uint)_Bytes[2] << 8) +  				((uint)_Bytes[3] << 0);
Magic Number,NBitcoin,LotSequence,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinPassphraseCode.cs,LotSequence,The following statement contains a magic number: uint lotSequence =  				((uint)_Bytes[0] << 24) +  				((uint)_Bytes[1] << 16) +  				((uint)_Bytes[2] << 8) +  				((uint)_Bytes[3] << 0);
Magic Number,NBitcoin,LotSequence,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinPassphraseCode.cs,LotSequence,The following statement contains a magic number: _Lot = (int)(lotSequence / 4096);
Magic Number,NBitcoin,BitcoinPassphraseCode,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinPassphraseCode.cs,GenerateWif,The following statement contains a magic number: ownersalt = ownersalt ?? RandomUtils.GetBytes(8);
Magic Number,NBitcoin,BitcoinPassphraseCode,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinPassphraseCode.cs,GenerateWif,The following statement contains a magic number: ownersalt = ownersalt.Take(4).ToArray();
Magic Number,NBitcoin,BitcoinPassphraseCode,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinPassphraseCode.cs,GenerateWif,The following statement contains a magic number: var prefactor = SCrypt.BitcoinComputeDerivedKey(Encoding.UTF8.GetBytes(passphrase)' ownersalt' 32);
Magic Number,NBitcoin,BitcoinPassphraseCode,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinPassphraseCode.cs,GenerateEncryptedSecret,The following statement contains a magic number: seedb = seedb ?? RandomUtils.GetBytes(24);
Magic Number,NBitcoin,BitcoinPassphraseCode,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinPassphraseCode.cs,GenerateEncryptedSecret,The following statement contains a magic number: var bytes =  				new[] { flagByte }  				.Concat(addresshash)  				.Concat(this.OwnerEntropy)  				.Concat(encrypted.Take(8).ToArray())  				.Concat(encrypted.Skip(16).ToArray())  				.ToArray();
Magic Number,NBitcoin,BitcoinPassphraseCode,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinPassphraseCode.cs,GenerateEncryptedSecret,The following statement contains a magic number: var bytes =  				new[] { flagByte }  				.Concat(addresshash)  				.Concat(this.OwnerEntropy)  				.Concat(encrypted.Take(8).ToArray())  				.Concat(encrypted.Skip(16).ToArray())  				.ToArray();
Magic Number,NBitcoin,BitcoinPassphraseCode,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP38\BitcoinPassphraseCode.cs,GenerateEncryptedSecret,The following statement contains a magic number: return new EncryptedKeyResult(encryptedSecret' generatedaddress' seedb' () =>  			{  				//ECMultiply factorb by G' call the result pointb. The result is 33 bytes.  				var pointb = new Key(factorb).PubKey.ToBytes();  				//The first byte is 0x02 or 0x03. XOR it by (derivedhalf2[31] & 0x01)' call the resulting byte pointbprefix.  				var pointbprefix = (byte)(pointb[0] ^ (byte)(derived[63] & 0x01));  				var pointbx = BitcoinEncryptedSecret.EncryptKey(pointb.Skip(1).ToArray()' derived);  				var encryptedpointb = new byte[] { pointbprefix }.Concat(pointbx).ToArray();    				var confirmBytes =  					Network.GetVersionBytes(Base58Type.CONFIRMATION_CODE' true)  					.Concat(new[] { flagByte })  					.Concat(addresshash)  					.Concat(OwnerEntropy)  					.Concat(encryptedpointb)  					.ToArray();    				return new BitcoinConfirmationCode(Network.NetworkStringParser.GetBase58CheckEncoder().EncodeData(confirmBytes)' Network);  			});
Magic Number,NBitcoin,Mnemonic,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP39\Mnemonic.cs,Mnemonic,The following statement contains a magic number: entropy = RandomUtils.GetBytes(32);
Magic Number,NBitcoin,Mnemonic,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP39\Mnemonic.cs,Mnemonic,The following statement contains a magic number: var i = Array.IndexOf(entArray' entropy.Length * 8);
Magic Number,NBitcoin,Mnemonic,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP39\Mnemonic.cs,GenerateEntropy,The following statement contains a magic number: return RandomUtils.GetBytes(entArray[i] / 8);
Magic Number,NBitcoin,Mnemonic,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP39\Mnemonic.cs,ToInt,The following statement contains a magic number: bits.Length != 11
Magic Number,NBitcoin,Mnemonic,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP39\Mnemonic.cs,ToInt,The following statement contains a magic number: int base2Divide = 1024;
Magic Number,NBitcoin,Mnemonic,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP39\Mnemonic.cs,ToInt,The following statement contains a magic number: base2Divide = base2Divide / 2;
Magic Number,NBitcoin,Mnemonic,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP39\Mnemonic.cs,DeriveSeed,The following statement contains a magic number: return Pbkdf2.ComputeDerivedKey(new HMACSHA512(bytes)' salt' 2048' 64);
Magic Number,NBitcoin,Mnemonic,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP39\Mnemonic.cs,DeriveSeed,The following statement contains a magic number: return Pbkdf2.ComputeDerivedKey(new HMACSHA512(bytes)' salt' 2048' 64);
Magic Number,NBitcoin,Wordlist,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP39\Wordlist.cs,AutoDetectLanguage,The following statement contains a magic number: languageCount[2]++;
Magic Number,NBitcoin,Wordlist,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP39\Wordlist.cs,AutoDetectLanguage,The following statement contains a magic number: languageCount[3]++;
Magic Number,NBitcoin,Wordlist,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP39\Wordlist.cs,AutoDetectLanguage,The following statement contains a magic number: languageCount[4]++;
Magic Number,NBitcoin,Wordlist,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP39\Wordlist.cs,AutoDetectLanguage,The following statement contains a magic number: languageCount[5]++;
Magic Number,NBitcoin,Wordlist,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP39\Wordlist.cs,AutoDetectLanguage,The following statement contains a magic number: languageCount[6]++;
Magic Number,NBitcoin,Wordlist,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP39\Wordlist.cs,ToBits,The following statement contains a magic number: values.Any(v => v >= 2048)
Magic Number,NBitcoin,Wordlist,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP39\Wordlist.cs,ToBits,The following statement contains a magic number: BitArray result = new BitArray(values.Length * 11);
Magic Number,NBitcoin,Wordlist,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP39\Wordlist.cs,ToBits,The following statement contains a magic number: var v = (val & (1 << (10 - p))) != 0;
Magic Number,NBitcoin,Wordlist,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP39\Wordlist.cs,ToBits,The following statement contains a magic number: p < 11
Magic Number,NBitcoin,Wordlist,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP39\Wordlist.cs,ToIntegers,The following statement contains a magic number: return  				bits  				.OfType<bool>()  				.Select((v' i) => new  				{  					Group = i / 11'  					Value = v ? 1 << (10 - (i % 11)) : 0  				})  				.GroupBy(_ => _.Group' _ => _.Value)  				.Select(g => g.Sum())  				.ToArray();
Magic Number,NBitcoin,Wordlist,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP39\Wordlist.cs,ToIntegers,The following statement contains a magic number: return  				bits  				.OfType<bool>()  				.Select((v' i) => new  				{  					Group = i / 11'  					Value = v ? 1 << (10 - (i % 11)) : 0  				})  				.GroupBy(_ => _.Group' _ => _.Value)  				.Select(g => g.Sum())  				.ToArray();
Magic Number,NBitcoin,Wordlist,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BIP39\Wordlist.cs,ToIntegers,The following statement contains a magic number: return  				bits  				.OfType<bool>()  				.Select((v' i) => new  				{  					Group = i / 11'  					Value = v ? 1 << (10 - (i % 11)) : 0  				})  				.GroupBy(_ => _.Group' _ => _.Value)  				.Select(g => g.Sum())  				.ToArray();
Magic Number,NBitcoin,BitcoinScriptAddress,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BitcoinAddress.cs,Validate,The following statement contains a magic number: data.Length == versionBytes.Length + 20
Magic Number,NBitcoin,BitcoinPubKeyAddress,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BitcoinPubKeyAddress.cs,Validate,The following statement contains a magic number: data.Length == versionBytes.Length + 20
Magic Number,NBitcoin,BitcoinWitPubKeyAddress,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BitcoinSegwitAddress.cs,Validate,The following statement contains a magic number: data.Length == 20 && witVersion == 0
Magic Number,NBitcoin,BitcoinWitScriptAddress,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BitcoinSegwitAddress.cs,Validate,The following statement contains a magic number: data.Length == 32 && witVersion == 0
Magic Number,NBitcoin,BitcoinStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BitcoinStream.cs,ReadWriteNumber,The following statement contains a magic number: bytes[i] = (byte)(value >> i * 8);
Magic Number,NBitcoin,BitcoinStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BitcoinStream.cs,ReadWriteNumber,The following statement contains a magic number: valueTemp += v << (i * 8);
Magic Number,NBitcoin,BitcoinStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BitcoinStream.cs,ReadWriteNumberInefficient,The following statement contains a magic number: bytes[i] = (byte)(value >> i * 8);
Magic Number,NBitcoin,BitcoinStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BitcoinStream.cs,ReadWriteNumberInefficient,The following statement contains a magic number: valueTemp += v << (i * 8);
Magic Number,NBitcoin,BitcoinStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BitcoinStream.cs,ReadWrite,The following statement contains a magic number: Span<byte> bytes = stackalloc byte[4];
Magic Number,NBitcoin,BitReader,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BitWriter.cs,ToString,The following statement contains a magic number: i != 0 && i % 8 == 0
Magic Number,NBitcoin,BitWriter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BitWriter.cs,Write,The following statement contains a magic number: Write(bytes' bytes.Length * 8);
Magic Number,NBitcoin,BitWriter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BitWriter.cs,ToByteArray,The following statement contains a magic number: int arrayLength = bits.Length / 8;
Magic Number,NBitcoin,BitWriter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BitWriter.cs,ToByteArray,The following statement contains a magic number: bits.Length % 8 != 0
Magic Number,NBitcoin,BitWriter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BitWriter.cs,ToByteArray,The following statement contains a magic number: int b = i / 8;
Magic Number,NBitcoin,BitWriter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BitWriter.cs,ToByteArray,The following statement contains a magic number: int offset = i % 8;
Magic Number,NBitcoin,BitWriter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BitWriter.cs,SwapEndianBytes,The following statement contains a magic number: newByte += (byte)(((bytes[i] >> ib) & 1) << (7 - ib));
Magic Number,NBitcoin,BitWriter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BitWriter.cs,SwapEndianBytes,The following statement contains a magic number: ib < 8
Magic Number,NBitcoin,BitWriter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BitWriter.cs,ToString,The following statement contains a magic number: i != 0 && i % 8 == 0
Magic Number,NBitcoin,Block,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Block.cs,CreateBlock,The following statement contains a magic number: var ms = new MemoryStream(100);
Magic Number,NBitcoin,Block,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Block.cs,GetCoinbaseHeight,The following statement contains a magic number: Header.Version < 2 || Transactions.Count == 0 || Transactions[0].Inputs.Count == 0
Magic Number,NBitcoin,Block,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Block.cs,CreateNextBlockWithCoinbase,The following statement contains a magic number: tx.Inputs.Add(scriptSig: new Script(Op.GetPushOp(RandomUtils.GetBytes(30))));
Magic Number,NBitcoin,Block,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Block.cs,GetWeight,The following statement contains a magic number: return this.GetSerializedSize(TransactionOptions.None) * 3 + this.GetSerializedSize(TransactionOptions.All);
Magic Number,NBitcoin,Block,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Block.cs,CreateNextBlockWithCoinbase,The following statement contains a magic number: tx.Inputs.Add(scriptSig: new Script(Op.GetPushOp(RandomUtils.GetBytes(30))));
Magic Number,NBitcoin,BloomFilter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BloomFilter.cs,BloomFilter,The following statement contains a magic number: vData = new byte[Math.Min((uint)(-1 / LN2SQUARED * nElements * (decimal)Math.Log(nFPRate))' MAX_BLOOM_FILTER_SIZE) / 8];
Magic Number,NBitcoin,BloomFilter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BloomFilter.cs,BloomFilter,The following statement contains a magic number: this.nHashFuncs = Math.Min((uint)(vData.Length * 8 / nElements * LN2)' MAX_HASH_FUNCS);
Magic Number,NBitcoin,BloomFilter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BloomFilter.cs,Hash,The following statement contains a magic number: return (uint)(Hashes.MurmurHash3(nHashNum * 0xFBA4C795 + nTweak' vDataToHash) % (vData.Length * 8));
Magic Number,NBitcoin,BloomFilter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BloomFilter.cs,Insert,The following statement contains a magic number: vData[nIndex >> 3] |= (byte)(1 << (7 & (int)nIndex));
Magic Number,NBitcoin,BloomFilter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BloomFilter.cs,Insert,The following statement contains a magic number: vData[nIndex >> 3] |= (byte)(1 << (7 & (int)nIndex));
Magic Number,NBitcoin,BloomFilter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BloomFilter.cs,Contains,The following statement contains a magic number: (vData[nIndex >> 3] & (byte)(1 << (7 & (int)nIndex))) == 0
Magic Number,NBitcoin,BloomFilter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BloomFilter.cs,Contains,The following statement contains a magic number: (vData[nIndex >> 3] & (byte)(1 << (7 & (int)nIndex))) == 0
Magic Number,NBitcoin,CachedTransactionRepository,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\CachedTransactionRepository.cs,CachedTransactionRepository,The following statement contains a magic number: MaxCachedTransactions = 100;
Magic Number,NBitcoin,ChainedBlock,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ChainedBlock.cs,GetLocator,The following statement contains a magic number: nStep *= 2;
Magic Number,NBitcoin,ChainedBlock,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ChainedBlock.cs,GetLocator,The following statement contains a magic number: vHave.Count > 10
Magic Number,NBitcoin,ChainedBlock,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ChainedBlock.cs,GetWorkRequired,The following statement contains a magic number: this.Header.BlockTime > pindexLast.Header.BlockTime + TimeSpan.FromTicks(consensus.PowTargetSpacing.Ticks * 2)
Magic Number,NBitcoin,ChainedBlock,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ChainedBlock.cs,GetWorkRequired,The following statement contains a magic number: nActualTimespan = TimeSpan.FromTicks(consensus.PowTargetTimespan.Ticks / 4);
Magic Number,NBitcoin,ChainedBlock,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ChainedBlock.cs,GetWorkRequired,The following statement contains a magic number: nActualTimespan < TimeSpan.FromTicks(consensus.PowTargetTimespan.Ticks / 4)
Magic Number,NBitcoin,ChainedBlock,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ChainedBlock.cs,GetWorkRequired,The following statement contains a magic number: nActualTimespan = TimeSpan.FromTicks(consensus.PowTargetTimespan.Ticks * 4);
Magic Number,NBitcoin,ChainedBlock,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ChainedBlock.cs,GetWorkRequired,The following statement contains a magic number: nActualTimespan > TimeSpan.FromTicks(consensus.PowTargetTimespan.Ticks * 4)
Magic Number,NBitcoin,ChainedBlock,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ChainedBlock.cs,GetMedianTimePast,The following statement contains a magic number: return pmedian[pbegin + ((pend - pbegin) / 2)];
Magic Number,NBitcoin,ConcurrentChain,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ConcurrentChain.cs,AddOrReplaceBlocksByHeight,The following statement contains a magic number: Array.Resize(ref _BlocksByHeight' (int)((_BlocksByHeight.Length + 100) * 1.1));
Magic Number,NBitcoin,ConcurrentChain,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ConcurrentChain.cs,AddOrReplaceBlocksByHeight,The following statement contains a magic number: Array.Resize(ref _BlocksByHeight' (int)((_BlocksByHeight.Length + 100) * 1.1));
Magic Number,NBitcoin,ConsensusFactory,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ConsensusFactory.cs,GetProtocolCapabilities,The following statement contains a magic number: return new ProtocolCapabilities() 			{ 				PeerTooOld = protocolVersion < 209U' 				SupportTimeAddress = protocolVersion >= 31402U' 				SupportGetBlock = protocolVersion < 32000U || protocolVersion > 32400U' 				SupportPingPong = protocolVersion > 60000U' 				SupportMempoolQuery = protocolVersion >= 60002U' 				SupportReject = protocolVersion >= 70002U' 				SupportNodeBloom = protocolVersion >= 70011U' 				SupportSendHeaders = protocolVersion >= 70012U' 				SupportWitness = protocolVersion >= 70012U' 				SupportCompactBlocks = protocolVersion >= 70014U' 				SupportCheckSum = protocolVersion >= 60002' 				SupportUserAgent = protocolVersion >= 60002 			};
Magic Number,NBitcoin,ConsensusFactory,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ConsensusFactory.cs,GetProtocolCapabilities,The following statement contains a magic number: return new ProtocolCapabilities() 			{ 				PeerTooOld = protocolVersion < 209U' 				SupportTimeAddress = protocolVersion >= 31402U' 				SupportGetBlock = protocolVersion < 32000U || protocolVersion > 32400U' 				SupportPingPong = protocolVersion > 60000U' 				SupportMempoolQuery = protocolVersion >= 60002U' 				SupportReject = protocolVersion >= 70002U' 				SupportNodeBloom = protocolVersion >= 70011U' 				SupportSendHeaders = protocolVersion >= 70012U' 				SupportWitness = protocolVersion >= 70012U' 				SupportCompactBlocks = protocolVersion >= 70014U' 				SupportCheckSum = protocolVersion >= 60002' 				SupportUserAgent = protocolVersion >= 60002 			};
Magic Number,NBitcoin,ConsensusFactory,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ConsensusFactory.cs,GetProtocolCapabilities,The following statement contains a magic number: return new ProtocolCapabilities() 			{ 				PeerTooOld = protocolVersion < 209U' 				SupportTimeAddress = protocolVersion >= 31402U' 				SupportGetBlock = protocolVersion < 32000U || protocolVersion > 32400U' 				SupportPingPong = protocolVersion > 60000U' 				SupportMempoolQuery = protocolVersion >= 60002U' 				SupportReject = protocolVersion >= 70002U' 				SupportNodeBloom = protocolVersion >= 70011U' 				SupportSendHeaders = protocolVersion >= 70012U' 				SupportWitness = protocolVersion >= 70012U' 				SupportCompactBlocks = protocolVersion >= 70014U' 				SupportCheckSum = protocolVersion >= 60002' 				SupportUserAgent = protocolVersion >= 60002 			};
Magic Number,NBitcoin,ConsensusFactory,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ConsensusFactory.cs,GetProtocolCapabilities,The following statement contains a magic number: return new ProtocolCapabilities() 			{ 				PeerTooOld = protocolVersion < 209U' 				SupportTimeAddress = protocolVersion >= 31402U' 				SupportGetBlock = protocolVersion < 32000U || protocolVersion > 32400U' 				SupportPingPong = protocolVersion > 60000U' 				SupportMempoolQuery = protocolVersion >= 60002U' 				SupportReject = protocolVersion >= 70002U' 				SupportNodeBloom = protocolVersion >= 70011U' 				SupportSendHeaders = protocolVersion >= 70012U' 				SupportWitness = protocolVersion >= 70012U' 				SupportCompactBlocks = protocolVersion >= 70014U' 				SupportCheckSum = protocolVersion >= 60002' 				SupportUserAgent = protocolVersion >= 60002 			};
Magic Number,NBitcoin,ConsensusFactory,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ConsensusFactory.cs,GetProtocolCapabilities,The following statement contains a magic number: return new ProtocolCapabilities() 			{ 				PeerTooOld = protocolVersion < 209U' 				SupportTimeAddress = protocolVersion >= 31402U' 				SupportGetBlock = protocolVersion < 32000U || protocolVersion > 32400U' 				SupportPingPong = protocolVersion > 60000U' 				SupportMempoolQuery = protocolVersion >= 60002U' 				SupportReject = protocolVersion >= 70002U' 				SupportNodeBloom = protocolVersion >= 70011U' 				SupportSendHeaders = protocolVersion >= 70012U' 				SupportWitness = protocolVersion >= 70012U' 				SupportCompactBlocks = protocolVersion >= 70014U' 				SupportCheckSum = protocolVersion >= 60002' 				SupportUserAgent = protocolVersion >= 60002 			};
Magic Number,NBitcoin,ConsensusFactory,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ConsensusFactory.cs,GetProtocolCapabilities,The following statement contains a magic number: return new ProtocolCapabilities() 			{ 				PeerTooOld = protocolVersion < 209U' 				SupportTimeAddress = protocolVersion >= 31402U' 				SupportGetBlock = protocolVersion < 32000U || protocolVersion > 32400U' 				SupportPingPong = protocolVersion > 60000U' 				SupportMempoolQuery = protocolVersion >= 60002U' 				SupportReject = protocolVersion >= 70002U' 				SupportNodeBloom = protocolVersion >= 70011U' 				SupportSendHeaders = protocolVersion >= 70012U' 				SupportWitness = protocolVersion >= 70012U' 				SupportCompactBlocks = protocolVersion >= 70014U' 				SupportCheckSum = protocolVersion >= 60002' 				SupportUserAgent = protocolVersion >= 60002 			};
Magic Number,NBitcoin,ConsensusFactory,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ConsensusFactory.cs,GetProtocolCapabilities,The following statement contains a magic number: return new ProtocolCapabilities() 			{ 				PeerTooOld = protocolVersion < 209U' 				SupportTimeAddress = protocolVersion >= 31402U' 				SupportGetBlock = protocolVersion < 32000U || protocolVersion > 32400U' 				SupportPingPong = protocolVersion > 60000U' 				SupportMempoolQuery = protocolVersion >= 60002U' 				SupportReject = protocolVersion >= 70002U' 				SupportNodeBloom = protocolVersion >= 70011U' 				SupportSendHeaders = protocolVersion >= 70012U' 				SupportWitness = protocolVersion >= 70012U' 				SupportCompactBlocks = protocolVersion >= 70014U' 				SupportCheckSum = protocolVersion >= 60002' 				SupportUserAgent = protocolVersion >= 60002 			};
Magic Number,NBitcoin,ConsensusFactory,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ConsensusFactory.cs,GetProtocolCapabilities,The following statement contains a magic number: return new ProtocolCapabilities() 			{ 				PeerTooOld = protocolVersion < 209U' 				SupportTimeAddress = protocolVersion >= 31402U' 				SupportGetBlock = protocolVersion < 32000U || protocolVersion > 32400U' 				SupportPingPong = protocolVersion > 60000U' 				SupportMempoolQuery = protocolVersion >= 60002U' 				SupportReject = protocolVersion >= 70002U' 				SupportNodeBloom = protocolVersion >= 70011U' 				SupportSendHeaders = protocolVersion >= 70012U' 				SupportWitness = protocolVersion >= 70012U' 				SupportCompactBlocks = protocolVersion >= 70014U' 				SupportCheckSum = protocolVersion >= 60002' 				SupportUserAgent = protocolVersion >= 60002 			};
Magic Number,NBitcoin,ConsensusFactory,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ConsensusFactory.cs,GetProtocolCapabilities,The following statement contains a magic number: return new ProtocolCapabilities() 			{ 				PeerTooOld = protocolVersion < 209U' 				SupportTimeAddress = protocolVersion >= 31402U' 				SupportGetBlock = protocolVersion < 32000U || protocolVersion > 32400U' 				SupportPingPong = protocolVersion > 60000U' 				SupportMempoolQuery = protocolVersion >= 60002U' 				SupportReject = protocolVersion >= 70002U' 				SupportNodeBloom = protocolVersion >= 70011U' 				SupportSendHeaders = protocolVersion >= 70012U' 				SupportWitness = protocolVersion >= 70012U' 				SupportCompactBlocks = protocolVersion >= 70014U' 				SupportCheckSum = protocolVersion >= 60002' 				SupportUserAgent = protocolVersion >= 60002 			};
Magic Number,NBitcoin,ConsensusFactory,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ConsensusFactory.cs,GetProtocolCapabilities,The following statement contains a magic number: return new ProtocolCapabilities() 			{ 				PeerTooOld = protocolVersion < 209U' 				SupportTimeAddress = protocolVersion >= 31402U' 				SupportGetBlock = protocolVersion < 32000U || protocolVersion > 32400U' 				SupportPingPong = protocolVersion > 60000U' 				SupportMempoolQuery = protocolVersion >= 60002U' 				SupportReject = protocolVersion >= 70002U' 				SupportNodeBloom = protocolVersion >= 70011U' 				SupportSendHeaders = protocolVersion >= 70012U' 				SupportWitness = protocolVersion >= 70012U' 				SupportCompactBlocks = protocolVersion >= 70014U' 				SupportCheckSum = protocolVersion >= 60002' 				SupportUserAgent = protocolVersion >= 60002 			};
Magic Number,NBitcoin,ConsensusFactory,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ConsensusFactory.cs,GetProtocolCapabilities,The following statement contains a magic number: return new ProtocolCapabilities() 			{ 				PeerTooOld = protocolVersion < 209U' 				SupportTimeAddress = protocolVersion >= 31402U' 				SupportGetBlock = protocolVersion < 32000U || protocolVersion > 32400U' 				SupportPingPong = protocolVersion > 60000U' 				SupportMempoolQuery = protocolVersion >= 60002U' 				SupportReject = protocolVersion >= 70002U' 				SupportNodeBloom = protocolVersion >= 70011U' 				SupportSendHeaders = protocolVersion >= 70012U' 				SupportWitness = protocolVersion >= 70012U' 				SupportCompactBlocks = protocolVersion >= 70014U' 				SupportCheckSum = protocolVersion >= 60002' 				SupportUserAgent = protocolVersion >= 60002 			};
Magic Number,NBitcoin,ConsensusFactory,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ConsensusFactory.cs,GetProtocolCapabilities,The following statement contains a magic number: return new ProtocolCapabilities() 			{ 				PeerTooOld = protocolVersion < 209U' 				SupportTimeAddress = protocolVersion >= 31402U' 				SupportGetBlock = protocolVersion < 32000U || protocolVersion > 32400U' 				SupportPingPong = protocolVersion > 60000U' 				SupportMempoolQuery = protocolVersion >= 60002U' 				SupportReject = protocolVersion >= 70002U' 				SupportNodeBloom = protocolVersion >= 70011U' 				SupportSendHeaders = protocolVersion >= 70012U' 				SupportWitness = protocolVersion >= 70012U' 				SupportCompactBlocks = protocolVersion >= 70014U' 				SupportCheckSum = protocolVersion >= 60002' 				SupportUserAgent = protocolVersion >= 60002 			};
Magic Number,NBitcoin,ConsensusFactory,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ConsensusFactory.cs,GetProtocolCapabilities,The following statement contains a magic number: return new ProtocolCapabilities() 			{ 				PeerTooOld = protocolVersion < 209U' 				SupportTimeAddress = protocolVersion >= 31402U' 				SupportGetBlock = protocolVersion < 32000U || protocolVersion > 32400U' 				SupportPingPong = protocolVersion > 60000U' 				SupportMempoolQuery = protocolVersion >= 60002U' 				SupportReject = protocolVersion >= 70002U' 				SupportNodeBloom = protocolVersion >= 70011U' 				SupportSendHeaders = protocolVersion >= 70012U' 				SupportWitness = protocolVersion >= 70012U' 				SupportCompactBlocks = protocolVersion >= 70014U' 				SupportCheckSum = protocolVersion >= 60002' 				SupportUserAgent = protocolVersion >= 60002 			};
Magic Number,NBitcoin,FeeRate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\FeeRate.cs,FeeRate,The following statement contains a magic number: _FeePerK = (long)((decimal)feePaid.Satoshi / (decimal)size * 1000m);
Magic Number,NBitcoin,FeeRate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\FeeRate.cs,FeeRate,The following statement contains a magic number: _FeePerK = Money.Satoshis(satoshiPerByte * 1000);
Magic Number,NBitcoin,FeeRate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\FeeRate.cs,GetFee,The following statement contains a magic number: Money nFee = _FeePerK.Satoshi * virtualSize / 1000;
Magic Number,NBitcoin,FeeRate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\FeeRate.cs,ToString,The following statement contains a magic number: rounded == 0 || (Math.Abs(rounded - value) / value) < 0.001m
Magic Number,NBitcoin,FileLock,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\FileLock.cs,FileLock,The following statement contains a magic number: source.CancelAfter(20000);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC1918,The following statement contains a magic number: return address.IsIPv4() && (  				bytes[15 - 3] == 10 ||  				(bytes[15 - 3] == 192 && bytes[15 - 2] == 168) ||  				(bytes[15 - 3] == 172 && (bytes[15 - 2] >= 16 && bytes[15 - 2] <= 31)));
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC1918,The following statement contains a magic number: return address.IsIPv4() && (  				bytes[15 - 3] == 10 ||  				(bytes[15 - 3] == 192 && bytes[15 - 2] == 168) ||  				(bytes[15 - 3] == 172 && (bytes[15 - 2] >= 16 && bytes[15 - 2] <= 31)));
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC1918,The following statement contains a magic number: return address.IsIPv4() && (  				bytes[15 - 3] == 10 ||  				(bytes[15 - 3] == 192 && bytes[15 - 2] == 168) ||  				(bytes[15 - 3] == 172 && (bytes[15 - 2] >= 16 && bytes[15 - 2] <= 31)));
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC1918,The following statement contains a magic number: return address.IsIPv4() && (  				bytes[15 - 3] == 10 ||  				(bytes[15 - 3] == 192 && bytes[15 - 2] == 168) ||  				(bytes[15 - 3] == 172 && (bytes[15 - 2] >= 16 && bytes[15 - 2] <= 31)));
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC1918,The following statement contains a magic number: return address.IsIPv4() && (  				bytes[15 - 3] == 10 ||  				(bytes[15 - 3] == 192 && bytes[15 - 2] == 168) ||  				(bytes[15 - 3] == 172 && (bytes[15 - 2] >= 16 && bytes[15 - 2] <= 31)));
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC1918,The following statement contains a magic number: return address.IsIPv4() && (  				bytes[15 - 3] == 10 ||  				(bytes[15 - 3] == 192 && bytes[15 - 2] == 168) ||  				(bytes[15 - 3] == 172 && (bytes[15 - 2] >= 16 && bytes[15 - 2] <= 31)));
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC1918,The following statement contains a magic number: return address.IsIPv4() && (  				bytes[15 - 3] == 10 ||  				(bytes[15 - 3] == 192 && bytes[15 - 2] == 168) ||  				(bytes[15 - 3] == 172 && (bytes[15 - 2] >= 16 && bytes[15 - 2] <= 31)));
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC1918,The following statement contains a magic number: return address.IsIPv4() && (  				bytes[15 - 3] == 10 ||  				(bytes[15 - 3] == 192 && bytes[15 - 2] == 168) ||  				(bytes[15 - 3] == 172 && (bytes[15 - 2] >= 16 && bytes[15 - 2] <= 31)));
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC1918,The following statement contains a magic number: return address.IsIPv4() && (  				bytes[15 - 3] == 10 ||  				(bytes[15 - 3] == 192 && bytes[15 - 2] == 168) ||  				(bytes[15 - 3] == 172 && (bytes[15 - 2] >= 16 && bytes[15 - 2] <= 31)));
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC1918,The following statement contains a magic number: return address.IsIPv4() && (  				bytes[15 - 3] == 10 ||  				(bytes[15 - 3] == 192 && bytes[15 - 2] == 168) ||  				(bytes[15 - 3] == 172 && (bytes[15 - 2] >= 16 && bytes[15 - 2] <= 31)));
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC1918,The following statement contains a magic number: return address.IsIPv4() && (  				bytes[15 - 3] == 10 ||  				(bytes[15 - 3] == 192 && bytes[15 - 2] == 168) ||  				(bytes[15 - 3] == 172 && (bytes[15 - 2] >= 16 && bytes[15 - 2] <= 31)));
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC1918,The following statement contains a magic number: return address.IsIPv4() && (  				bytes[15 - 3] == 10 ||  				(bytes[15 - 3] == 192 && bytes[15 - 2] == 168) ||  				(bytes[15 - 3] == 172 && (bytes[15 - 2] >= 16 && bytes[15 - 2] <= 31)));
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC1918,The following statement contains a magic number: return address.IsIPv4() && (  				bytes[15 - 3] == 10 ||  				(bytes[15 - 3] == 192 && bytes[15 - 2] == 168) ||  				(bytes[15 - 3] == 172 && (bytes[15 - 2] >= 16 && bytes[15 - 2] <= 31)));
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC1918,The following statement contains a magic number: return address.IsIPv4() && (  				bytes[15 - 3] == 10 ||  				(bytes[15 - 3] == 192 && bytes[15 - 2] == 168) ||  				(bytes[15 - 3] == 172 && (bytes[15 - 2] >= 16 && bytes[15 - 2] <= 31)));
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC1918,The following statement contains a magic number: return address.IsIPv4() && (  				bytes[15 - 3] == 10 ||  				(bytes[15 - 3] == 192 && bytes[15 - 2] == 168) ||  				(bytes[15 - 3] == 172 && (bytes[15 - 2] >= 16 && bytes[15 - 2] <= 31)));
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC1918,The following statement contains a magic number: return address.IsIPv4() && (  				bytes[15 - 3] == 10 ||  				(bytes[15 - 3] == 192 && bytes[15 - 2] == 168) ||  				(bytes[15 - 3] == 172 && (bytes[15 - 2] >= 16 && bytes[15 - 2] <= 31)));
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC1918,The following statement contains a magic number: return address.IsIPv4() && (  				bytes[15 - 3] == 10 ||  				(bytes[15 - 3] == 192 && bytes[15 - 2] == 168) ||  				(bytes[15 - 3] == 172 && (bytes[15 - 2] >= 16 && bytes[15 - 2] <= 31)));
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC1918,The following statement contains a magic number: return address.IsIPv4() && (  				bytes[15 - 3] == 10 ||  				(bytes[15 - 3] == 192 && bytes[15 - 2] == 168) ||  				(bytes[15 - 3] == 172 && (bytes[15 - 2] >= 16 && bytes[15 - 2] <= 31)));
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC3927,The following statement contains a magic number: return address.IsIPv4() && (bytes[15 - 3] == 169 && bytes[15 - 2] == 254);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC3927,The following statement contains a magic number: return address.IsIPv4() && (bytes[15 - 3] == 169 && bytes[15 - 2] == 254);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC3927,The following statement contains a magic number: return address.IsIPv4() && (bytes[15 - 3] == 169 && bytes[15 - 2] == 254);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC3927,The following statement contains a magic number: return address.IsIPv4() && (bytes[15 - 3] == 169 && bytes[15 - 2] == 254);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC3927,The following statement contains a magic number: return address.IsIPv4() && (bytes[15 - 3] == 169 && bytes[15 - 2] == 254);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC3927,The following statement contains a magic number: return address.IsIPv4() && (bytes[15 - 3] == 169 && bytes[15 - 2] == 254);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC3849,The following statement contains a magic number: return bytes[15 - 15] == 0x20 && bytes[15 - 14] == 0x01 && bytes[15 - 13] == 0x0D && bytes[15 - 12] == 0xB8;
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC3849,The following statement contains a magic number: return bytes[15 - 15] == 0x20 && bytes[15 - 14] == 0x01 && bytes[15 - 13] == 0x0D && bytes[15 - 12] == 0xB8;
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC3849,The following statement contains a magic number: return bytes[15 - 15] == 0x20 && bytes[15 - 14] == 0x01 && bytes[15 - 13] == 0x0D && bytes[15 - 12] == 0xB8;
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC3849,The following statement contains a magic number: return bytes[15 - 15] == 0x20 && bytes[15 - 14] == 0x01 && bytes[15 - 13] == 0x0D && bytes[15 - 12] == 0xB8;
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC3849,The following statement contains a magic number: return bytes[15 - 15] == 0x20 && bytes[15 - 14] == 0x01 && bytes[15 - 13] == 0x0D && bytes[15 - 12] == 0xB8;
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC3849,The following statement contains a magic number: return bytes[15 - 15] == 0x20 && bytes[15 - 14] == 0x01 && bytes[15 - 13] == 0x0D && bytes[15 - 12] == 0xB8;
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC3849,The following statement contains a magic number: return bytes[15 - 15] == 0x20 && bytes[15 - 14] == 0x01 && bytes[15 - 13] == 0x0D && bytes[15 - 12] == 0xB8;
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC3849,The following statement contains a magic number: return bytes[15 - 15] == 0x20 && bytes[15 - 14] == 0x01 && bytes[15 - 13] == 0x0D && bytes[15 - 12] == 0xB8;
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC3964,The following statement contains a magic number: return (bytes[15 - 15] == 0x20 && bytes[15 - 14] == 0x02);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC3964,The following statement contains a magic number: return (bytes[15 - 15] == 0x20 && bytes[15 - 14] == 0x02);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC3964,The following statement contains a magic number: return (bytes[15 - 15] == 0x20 && bytes[15 - 14] == 0x02);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC3964,The following statement contains a magic number: return (bytes[15 - 15] == 0x20 && bytes[15 - 14] == 0x02);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC4380,The following statement contains a magic number: return (bytes[15 - 15] == 0x20 && bytes[15 - 14] == 0x01 && bytes[15 - 13] == 0 && bytes[15 - 12] == 0);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC4380,The following statement contains a magic number: return (bytes[15 - 15] == 0x20 && bytes[15 - 14] == 0x01 && bytes[15 - 13] == 0 && bytes[15 - 12] == 0);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC4380,The following statement contains a magic number: return (bytes[15 - 15] == 0x20 && bytes[15 - 14] == 0x01 && bytes[15 - 13] == 0 && bytes[15 - 12] == 0);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC4380,The following statement contains a magic number: return (bytes[15 - 15] == 0x20 && bytes[15 - 14] == 0x01 && bytes[15 - 13] == 0 && bytes[15 - 12] == 0);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC4380,The following statement contains a magic number: return (bytes[15 - 15] == 0x20 && bytes[15 - 14] == 0x01 && bytes[15 - 13] == 0 && bytes[15 - 12] == 0);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC4380,The following statement contains a magic number: return (bytes[15 - 15] == 0x20 && bytes[15 - 14] == 0x01 && bytes[15 - 13] == 0 && bytes[15 - 12] == 0);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC4380,The following statement contains a magic number: return (bytes[15 - 15] == 0x20 && bytes[15 - 14] == 0x01 && bytes[15 - 13] == 0 && bytes[15 - 12] == 0);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC4380,The following statement contains a magic number: return (bytes[15 - 15] == 0x20 && bytes[15 - 14] == 0x01 && bytes[15 - 13] == 0 && bytes[15 - 12] == 0);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC4193,The following statement contains a magic number: return ((bytes[15 - 15] & 0xFE) == 0xFC);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC4193,The following statement contains a magic number: return ((bytes[15 - 15] & 0xFE) == 0xFC);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC4843,The following statement contains a magic number: return (bytes[15 - 15] == 0x20 && bytes[15 - 14] == 0x01 && bytes[15 - 13] == 0x00 && (bytes[15 - 12] & 0xF0) == 0x10);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC4843,The following statement contains a magic number: return (bytes[15 - 15] == 0x20 && bytes[15 - 14] == 0x01 && bytes[15 - 13] == 0x00 && (bytes[15 - 12] & 0xF0) == 0x10);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC4843,The following statement contains a magic number: return (bytes[15 - 15] == 0x20 && bytes[15 - 14] == 0x01 && bytes[15 - 13] == 0x00 && (bytes[15 - 12] & 0xF0) == 0x10);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC4843,The following statement contains a magic number: return (bytes[15 - 15] == 0x20 && bytes[15 - 14] == 0x01 && bytes[15 - 13] == 0x00 && (bytes[15 - 12] & 0xF0) == 0x10);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC4843,The following statement contains a magic number: return (bytes[15 - 15] == 0x20 && bytes[15 - 14] == 0x01 && bytes[15 - 13] == 0x00 && (bytes[15 - 12] & 0xF0) == 0x10);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC4843,The following statement contains a magic number: return (bytes[15 - 15] == 0x20 && bytes[15 - 14] == 0x01 && bytes[15 - 13] == 0x00 && (bytes[15 - 12] & 0xF0) == 0x10);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC4843,The following statement contains a magic number: return (bytes[15 - 15] == 0x20 && bytes[15 - 14] == 0x01 && bytes[15 - 13] == 0x00 && (bytes[15 - 12] & 0xF0) == 0x10);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsRFC4843,The following statement contains a magic number: return (bytes[15 - 15] == 0x20 && bytes[15 - 14] == 0x01 && bytes[15 - 13] == 0x00 && (bytes[15 - 12] & 0xF0) == 0x10);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,GetGroup,The following statement contains a magic number: int nClass = 2;
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,GetGroup,The following statement contains a magic number: int nBits = 16;
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,GetGroup,The following statement contains a magic number: nClass = 255;
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,GetGroup,The following statement contains a magic number: vchRet.Add(bytes[15 - (15 - nStartByte)]);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,GetGroup,The following statement contains a magic number: vchRet.Add(bytes[15 - (15 - nStartByte)]);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,GetGroup,The following statement contains a magic number: nBits -= 8;
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,GetGroup,The following statement contains a magic number: nBits >= 8
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,GetGroup,The following statement contains a magic number: vchRet.Add((byte)(bytes[15 - (15 - nStartByte)] | ((1 << nBits) - 1)));
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,GetGroup,The following statement contains a magic number: vchRet.Add((byte)(bytes[15 - (15 - nStartByte)] | ((1 << nBits) - 1)));
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,TryConvertToOnionDNSEndpoint,The following statement contains a magic number: var onionHost = Encoders.Base32.EncodeData(bytes' pchOnionCat.Length' 16 - pchOnionCat.Length);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,AsOnionCatIPEndpoint,The following statement contains a magic number: !dns.Host.EndsWith(".onion"' StringComparison.OrdinalIgnoreCase) || dns.Host.Length != 16 + 6
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,AsOnionCatIPEndpoint,The following statement contains a magic number: !dns.Host.EndsWith(".onion"' StringComparison.OrdinalIgnoreCase) || dns.Host.Length != 16 + 6
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,AsOnionCatIPEndpoint,The following statement contains a magic number: var ipArray = new byte[16];
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,AsOnionCatIPEndpoint,The following statement contains a magic number: var vchAddr = Encoders.Base32.DecodeData(dns.Host.Substring(0' dns.Host.Length - 6));
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,AsOnionCatIPEndpoint,The following statement contains a magic number: vchAddr.Length != 16 - pchOnionCat.Length
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsLocal,The following statement contains a magic number: address.IsIPv4() && (bytes[15 - 3] == 127 || bytes[15 - 3] == 0)
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsLocal,The following statement contains a magic number: address.IsIPv4() && (bytes[15 - 3] == 127 || bytes[15 - 3] == 0)
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsLocal,The following statement contains a magic number: address.IsIPv4() && (bytes[15 - 3] == 127 || bytes[15 - 3] == 0)
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsLocal,The following statement contains a magic number: address.IsIPv4() && (bytes[15 - 3] == 127 || bytes[15 - 3] == 0)
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsLocal,The following statement contains a magic number: address.IsIPv4() && (bytes[15 - 3] == 127 || bytes[15 - 3] == 0)
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsLocal,The following statement contains a magic number: byte[] pchLocal = new byte[16] { 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 1 };
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsLocal,The following statement contains a magic number: (Utils.ArrayEqual(bytes' 0' pchLocal' 0' 16) ? 0 : 1) == 0
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsMulticast,The following statement contains a magic number: return (address.IsIPv4() && (bytes[15 - 3] & 0xF0) == 0xE0)  				   || (bytes[15 - 15] == 0xFF);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsMulticast,The following statement contains a magic number: return (address.IsIPv4() && (bytes[15 - 3] & 0xF0) == 0xE0)  				   || (bytes[15 - 15] == 0xFF);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsMulticast,The following statement contains a magic number: return (address.IsIPv4() && (bytes[15 - 3] & 0xF0) == 0xE0)  				   || (bytes[15 - 15] == 0xFF);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsMulticast,The following statement contains a magic number: return (address.IsIPv4() && (bytes[15 - 3] & 0xF0) == 0xE0)  				   || (bytes[15 - 15] == 0xFF);
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsValid,The following statement contains a magic number: byte[] ipNone = new byte[16];
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsValid,The following statement contains a magic number: (Utils.ArrayEqual(ip' 0' ipNone' 0' 16) ? 0 : 1) == 0
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsValid,The following statement contains a magic number: Utils.ArrayEqual(ip' 12' new byte[] { 0xFF' 0xFF' 0xFF' 0xFF }' 0' 4)
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsValid,The following statement contains a magic number: Utils.ArrayEqual(ip' 12' new byte[] { 0xFF' 0xFF' 0xFF' 0xFF }' 0' 4)
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsValid,The following statement contains a magic number: Utils.ArrayEqual(ip' 12' new byte[] { 0x0' 0x0' 0x0' 0x0 }' 0' 4)
Magic Number,NBitcoin,IpExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\IpExtensions.cs,IsValid,The following statement contains a magic number: Utils.ArrayEqual(ip' 12' new byte[] { 0x0' 0x0' 0x0' 0x0 }' 0' 4)
Magic Number,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,SignCompact,The following statement contains a magic number: i < 4
Magic Number,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,SignCompact,The following statement contains a magic number: int headerByte = recId + 27 + (IsCompressed ? 4 : 0);
Magic Number,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,SignCompact,The following statement contains a magic number: int headerByte = recId + 27 + (IsCompressed ? 4 : 0);
Magic Number,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,SignCompact,The following statement contains a magic number: byte[] sigData = new byte[65];
Magic Number,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,SignCompact,The following statement contains a magic number: Array.Copy(Utils.BigIntegerToBytes(sig.R' 32)' 0' sigData' 1' 32);
Magic Number,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,SignCompact,The following statement contains a magic number: Array.Copy(Utils.BigIntegerToBytes(sig.R' 32)' 0' sigData' 1' 32);
Magic Number,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,SignCompact,The following statement contains a magic number: Array.Copy(Utils.BigIntegerToBytes(sig.S' 32)' 0' sigData' 33' 32);
Magic Number,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,SignCompact,The following statement contains a magic number: Array.Copy(Utils.BigIntegerToBytes(sig.S' 32)' 0' sigData' 33' 32);
Magic Number,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,SignCompact,The following statement contains a magic number: Array.Copy(Utils.BigIntegerToBytes(sig.S' 32)' 0' sigData' 33' 32);
Magic Number,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,Decrypt,The following statement contains a magic number: encrypted.Length < 85
Magic Number,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,Decrypt,The following statement contains a magic number: var magic = encrypted.SafeSubarray(0' 4);
Magic Number,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,Decrypt,The following statement contains a magic number: var ephemeralPubkeyBytes = encrypted.SafeSubarray(4' 33);
Magic Number,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,Decrypt,The following statement contains a magic number: var ephemeralPubkeyBytes = encrypted.SafeSubarray(4' 33);
Magic Number,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,Decrypt,The following statement contains a magic number: var cipherText = encrypted.SafeSubarray(37' encrypted.Length - 32 - 37);
Magic Number,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,Decrypt,The following statement contains a magic number: var cipherText = encrypted.SafeSubarray(37' encrypted.Length - 32 - 37);
Magic Number,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,Decrypt,The following statement contains a magic number: var cipherText = encrypted.SafeSubarray(37' encrypted.Length - 32 - 37);
Magic Number,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,Decrypt,The following statement contains a magic number: var mac = encrypted.SafeSubarray(encrypted.Length - 32);
Magic Number,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,Decrypt,The following statement contains a magic number: var iv = sharedKey.SafeSubarray(0' 16);
Magic Number,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,Decrypt,The following statement contains a magic number: var encryptionKey = sharedKey.SafeSubarray(16' 16);
Magic Number,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,Decrypt,The following statement contains a magic number: var encryptionKey = sharedKey.SafeSubarray(16' 16);
Magic Number,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,Decrypt,The following statement contains a magic number: var hashingKey = sharedKey.SafeSubarray(32);
Magic Number,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,Decrypt,The following statement contains a magic number: var hashMAC = Hashes.HMACSHA256(hashingKey' encrypted.SafeSubarray(0' encrypted.Length - 32));
Magic Number,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,Derivate,The following statement contains a magic number: (nChild >> 31) == 0
Magic Number,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,Derivate,The following statement contains a magic number: var ll = l.SafeSubarray(0' 32);
Magic Number,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,Derivate,The following statement contains a magic number: var lr = l.SafeSubarray(32' 32);
Magic Number,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,Derivate,The following statement contains a magic number: var lr = l.SafeSubarray(32' 32);
Magic Number,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,Derivate,The following statement contains a magic number: keyBytes = new byte[32 - keyBytes.Length].Concat(keyBytes).ToArray();
Magic Number,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,Derivate,The following statement contains a magic number: keyBytes.Length < 32
Magic Number,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,Uncover,The following statement contains a magic number: priv = new byte[32 - priv.Length].Concat(priv).ToArray();
Magic Number,NBitcoin,Key,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Key.cs,Uncover,The following statement contains a magic number: priv.Length < 32
Magic Number,NBitcoin,KeyId,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\KeyId.cs,KeyId,The following statement contains a magic number: value.Length != 20
Magic Number,NBitcoin,WitKeyId,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\KeyId.cs,WitKeyId,The following statement contains a magic number: value.Length != 20
Magic Number,NBitcoin,WitScriptId,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\KeyId.cs,WitScriptId,The following statement contains a magic number: value.Length != 32
Magic Number,NBitcoin,ScriptId,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\KeyId.cs,ScriptId,The following statement contains a magic number: value.Length != 20
Magic Number,NBitcoin,MerkleNode,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\MerkleNode.cs,GetRoot,The following statement contains a magic number: leafCount > 1024 * 1024
Magic Number,NBitcoin,MerkleNode,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\MerkleNode.cs,GetRoot,The following statement contains a magic number: leafCount > 1024 * 1024
Magic Number,NBitcoin,BitcoinFormatter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Money.cs,Format,The following statement contains a magic number: var rest = new string('#'' 10 - decPos);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,Network,The following statement contains a magic number: this._MagicBytes = new byte[]  			{  				(byte)Magic'  				(byte)(Magic >> 8)'  				(byte)(Magic >> 16)'  				(byte)(Magic >> 24)  			};
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,Network,The following statement contains a magic number: this._MagicBytes = new byte[]  			{  				(byte)Magic'  				(byte)(Magic >> 8)'  				(byte)(Magic >> 16)'  				(byte)(Magic >> 24)  			};
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,Network,The following statement contains a magic number: this._MagicBytes = new byte[]  			{  				(byte)Magic'  				(byte)(Magic >> 8)'  				(byte)(Magic >> 16)'  				(byte)(Magic >> 24)  			};
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitMain,The following statement contains a magic number: consensus.CoinbaseMaturity = 100;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitMain,The following statement contains a magic number: consensus.SubsidyHalvingInterval = 210000;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitMain,The following statement contains a magic number: consensus.MajorityEnforceBlockUpgrade = 750;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitMain,The following statement contains a magic number: consensus.MajorityRejectBlockOutdated = 950;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitMain,The following statement contains a magic number: consensus.MajorityWindow = 1000;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitMain,The following statement contains a magic number: consensus.BuriedDeployments[BuriedDeployments.BIP34] = 227931;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitMain,The following statement contains a magic number: consensus.BuriedDeployments[BuriedDeployments.BIP65] = 388381;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitMain,The following statement contains a magic number: consensus.BuriedDeployments[BuriedDeployments.BIP66] = 363725;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitMain,The following statement contains a magic number: consensus.PowTargetTimespan = TimeSpan.FromSeconds(14 * 24 * 60 * 60);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitMain,The following statement contains a magic number: consensus.PowTargetTimespan = TimeSpan.FromSeconds(14 * 24 * 60 * 60);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitMain,The following statement contains a magic number: consensus.PowTargetTimespan = TimeSpan.FromSeconds(14 * 24 * 60 * 60);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitMain,The following statement contains a magic number: consensus.PowTargetTimespan = TimeSpan.FromSeconds(14 * 24 * 60 * 60);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitMain,The following statement contains a magic number: consensus.PowTargetSpacing = TimeSpan.FromSeconds(10 * 60);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitMain,The following statement contains a magic number: consensus.PowTargetSpacing = TimeSpan.FromSeconds(10 * 60);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitMain,The following statement contains a magic number: consensus.RuleChangeActivationThreshold = 1916;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitMain,The following statement contains a magic number: consensus.MinerConfirmationWindow = 2016;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitMain,The following statement contains a magic number: consensus.BIP9Deployments[BIP9Deployments.TestDummy] = new BIP9DeploymentsParameters(28' 1199145601' 1230767999);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitMain,The following statement contains a magic number: consensus.BIP9Deployments[BIP9Deployments.TestDummy] = new BIP9DeploymentsParameters(28' 1199145601' 1230767999);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitMain,The following statement contains a magic number: consensus.BIP9Deployments[BIP9Deployments.TestDummy] = new BIP9DeploymentsParameters(28' 1199145601' 1230767999);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitMain,The following statement contains a magic number: consensus.BIP9Deployments[BIP9Deployments.CSV] = new BIP9DeploymentsParameters(0' 1462060800' 1493596800);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitMain,The following statement contains a magic number: consensus.BIP9Deployments[BIP9Deployments.CSV] = new BIP9DeploymentsParameters(0' 1462060800' 1493596800);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitMain,The following statement contains a magic number: consensus.BIP9Deployments[BIP9Deployments.Segwit] = new BIP9DeploymentsParameters(1' 1479168000' 1510704000);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitMain,The following statement contains a magic number: consensus.BIP9Deployments[BIP9Deployments.Segwit] = new BIP9DeploymentsParameters(1' 1479168000' 1510704000);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitMain,The following statement contains a magic number: nDefaultPort = 8333;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitMain,The following statement contains a magic number: nRPCPort = 8332;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitMain,The following statement contains a magic number: base58Prefixes[(int)Base58Type.SCRIPT_ADDRESS] = new byte[] { (5) };
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitMain,The following statement contains a magic number: base58Prefixes[(int)Base58Type.SECRET_KEY] = new byte[] { (128) };
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitMain,The following statement contains a magic number: base58Prefixes[(int)Base58Type.ASSET_ID] = new byte[] { 23 };
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitMain,The following statement contains a magic number: TimeSpan nOneWeek = TimeSpan.FromDays(7);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitTest,The following statement contains a magic number: consensus.SubsidyHalvingInterval = 210000;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitTest,The following statement contains a magic number: consensus.MajorityEnforceBlockUpgrade = 51;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitTest,The following statement contains a magic number: consensus.MajorityRejectBlockOutdated = 75;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitTest,The following statement contains a magic number: consensus.MajorityWindow = 100;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitTest,The following statement contains a magic number: consensus.BuriedDeployments[BuriedDeployments.BIP34] = 21111;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitTest,The following statement contains a magic number: consensus.BuriedDeployments[BuriedDeployments.BIP65] = 581885;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitTest,The following statement contains a magic number: consensus.BuriedDeployments[BuriedDeployments.BIP66] = 330776;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitTest,The following statement contains a magic number: consensus.PowTargetTimespan = TimeSpan.FromSeconds(14 * 24 * 60 * 60);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitTest,The following statement contains a magic number: consensus.PowTargetTimespan = TimeSpan.FromSeconds(14 * 24 * 60 * 60);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitTest,The following statement contains a magic number: consensus.PowTargetTimespan = TimeSpan.FromSeconds(14 * 24 * 60 * 60);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitTest,The following statement contains a magic number: consensus.PowTargetTimespan = TimeSpan.FromSeconds(14 * 24 * 60 * 60);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitTest,The following statement contains a magic number: consensus.PowTargetSpacing = TimeSpan.FromSeconds(10 * 60);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitTest,The following statement contains a magic number: consensus.PowTargetSpacing = TimeSpan.FromSeconds(10 * 60);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitTest,The following statement contains a magic number: consensus.RuleChangeActivationThreshold = 1512;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitTest,The following statement contains a magic number: consensus.MinerConfirmationWindow = 2016;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitTest,The following statement contains a magic number: consensus.BIP9Deployments[BIP9Deployments.TestDummy] = new BIP9DeploymentsParameters(28' 1199145601' 1230767999);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitTest,The following statement contains a magic number: consensus.BIP9Deployments[BIP9Deployments.TestDummy] = new BIP9DeploymentsParameters(28' 1199145601' 1230767999);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitTest,The following statement contains a magic number: consensus.BIP9Deployments[BIP9Deployments.TestDummy] = new BIP9DeploymentsParameters(28' 1199145601' 1230767999);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitTest,The following statement contains a magic number: consensus.BIP9Deployments[BIP9Deployments.CSV] = new BIP9DeploymentsParameters(0' 1456790400' 1493596800);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitTest,The following statement contains a magic number: consensus.BIP9Deployments[BIP9Deployments.CSV] = new BIP9DeploymentsParameters(0' 1456790400' 1493596800);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitTest,The following statement contains a magic number: consensus.BIP9Deployments[BIP9Deployments.Segwit] = new BIP9DeploymentsParameters(1' 1462060800' 1493596800);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitTest,The following statement contains a magic number: consensus.BIP9Deployments[BIP9Deployments.Segwit] = new BIP9DeploymentsParameters(1' 1462060800' 1493596800);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitTest,The following statement contains a magic number: nDefaultPort = 18333;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitTest,The following statement contains a magic number: nRPCPort = 18332;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitTest,The following statement contains a magic number: base58Prefixes[(int)Base58Type.PUBKEY_ADDRESS] = new byte[] { (111) };
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitTest,The following statement contains a magic number: base58Prefixes[(int)Base58Type.SCRIPT_ADDRESS] = new byte[] { (196) };
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitTest,The following statement contains a magic number: base58Prefixes[(int)Base58Type.SECRET_KEY] = new byte[] { (239) };
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitTest,The following statement contains a magic number: base58Prefixes[(int)Base58Type.ASSET_ID] = new byte[] { 115 };
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitTest,The following statement contains a magic number: TimeSpan nOneWeek = TimeSpan.FromDays(7);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitReg,The following statement contains a magic number: consensus.SubsidyHalvingInterval = 150;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitReg,The following statement contains a magic number: consensus.MajorityEnforceBlockUpgrade = 750;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitReg,The following statement contains a magic number: consensus.MajorityRejectBlockOutdated = 950;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitReg,The following statement contains a magic number: consensus.MajorityWindow = 1000;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitReg,The following statement contains a magic number: consensus.BuriedDeployments[BuriedDeployments.BIP34] = 100000000;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitReg,The following statement contains a magic number: consensus.BuriedDeployments[BuriedDeployments.BIP65] = 100000000;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitReg,The following statement contains a magic number: consensus.BuriedDeployments[BuriedDeployments.BIP66] = 100000000;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitReg,The following statement contains a magic number: consensus.PowTargetTimespan = TimeSpan.FromSeconds(14 * 24 * 60 * 60);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitReg,The following statement contains a magic number: consensus.PowTargetTimespan = TimeSpan.FromSeconds(14 * 24 * 60 * 60);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitReg,The following statement contains a magic number: consensus.PowTargetTimespan = TimeSpan.FromSeconds(14 * 24 * 60 * 60);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitReg,The following statement contains a magic number: consensus.PowTargetTimespan = TimeSpan.FromSeconds(14 * 24 * 60 * 60);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitReg,The following statement contains a magic number: consensus.PowTargetSpacing = TimeSpan.FromSeconds(10 * 60);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitReg,The following statement contains a magic number: consensus.PowTargetSpacing = TimeSpan.FromSeconds(10 * 60);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitReg,The following statement contains a magic number: consensus.RuleChangeActivationThreshold = 108;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitReg,The following statement contains a magic number: consensus.MinerConfirmationWindow = 144;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitReg,The following statement contains a magic number: consensus.BIP9Deployments[BIP9Deployments.TestDummy] = new BIP9DeploymentsParameters(28' 0' 999999999);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitReg,The following statement contains a magic number: consensus.BIP9Deployments[BIP9Deployments.TestDummy] = new BIP9DeploymentsParameters(28' 0' 999999999);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitReg,The following statement contains a magic number: consensus.BIP9Deployments[BIP9Deployments.CSV] = new BIP9DeploymentsParameters(0' 0' 999999999);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitReg,The following statement contains a magic number: consensus.BIP9Deployments[BIP9Deployments.Segwit] = new BIP9DeploymentsParameters(1' BIP9DeploymentsParameters.AlwaysActive' 999999999);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitReg,The following statement contains a magic number: nDefaultPort = 18444;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitReg,The following statement contains a magic number: nRPCPort = 18443;
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitReg,The following statement contains a magic number: base58Prefixes[(int)Base58Type.PUBKEY_ADDRESS] = new byte[] { (111) };
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitReg,The following statement contains a magic number: base58Prefixes[(int)Base58Type.SCRIPT_ADDRESS] = new byte[] { (196) };
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,InitReg,The following statement contains a magic number: base58Prefixes[(int)Base58Type.SECRET_KEY] = new byte[] { (239) };
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,CreateGenesisBlock,The following statement contains a magic number: txNew.Inputs.Add(scriptSig: new Script(Op.GetPushOp(486604799)' new Op()  			{  				Code = (OpcodeType)0x1'  				PushData = new[] { (byte)4 }  			}' Op.GetPushOp(Encoders.ASCII.DecodeData(pszTimestamp))));
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,CreateGenesisBlock,The following statement contains a magic number: txNew.Inputs.Add(scriptSig: new Script(Op.GetPushOp(486604799)' new Op()  			{  				Code = (OpcodeType)0x1'  				PushData = new[] { (byte)4 }  			}' Op.GetPushOp(Encoders.ASCII.DecodeData(pszTimestamp))));
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,Parse,The following statement contains a magic number: witVersion == 0 && bytes.Length == 20 && type == Bech32Type.WITNESS_PUBKEY_ADDRESS
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,Parse,The following statement contains a magic number: witVersion == 0 && bytes.Length == 32 && type == Bech32Type.WITNESS_SCRIPT_ADDRESS
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,GetReward,The following statement contains a magic number: long nSubsidy = new Money(50 * Money.COIN);
Magic Number,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,GetReward,The following statement contains a magic number: halvings >= 64
Magic Number,NBitcoin,PartialMerkleTree,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\PartialMerkleTree.cs,ReadWrite,The following statement contains a magic number: writer.Write((vBytes[p / 8] & (1 << (p % 8))) != 0);
Magic Number,NBitcoin,PartialMerkleTree,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\PartialMerkleTree.cs,ReadWrite,The following statement contains a magic number: writer.Write((vBytes[p / 8] & (1 << (p % 8))) != 0);
Magic Number,NBitcoin,PartialMerkleTree,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\PartialMerkleTree.cs,ReadWrite,The following statement contains a magic number: p < vBytes.Length * 8
Magic Number,NBitcoin,PerformanceSnapshot,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\PerformanceCounter.cs,ToKBSec,The following statement contains a magic number: double speed = ((double)bytesPerSec / 1024.0);
Magic Number,NBitcoin,PubKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\PubKey.cs,Check,The following statement contains a magic number: var quick = data != null &&  					(  						(count == 33 && (data[offset + 0] == 0x02 || data[offset + 0] == 0x03)) ||  						(count == 65 && (data[offset + 0] == 0x04 || data[offset + 0] == 0x06 || data[offset + 0] == 0x07))  					);
Magic Number,NBitcoin,PubKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\PubKey.cs,Check,The following statement contains a magic number: var quick = data != null &&  					(  						(count == 33 && (data[offset + 0] == 0x02 || data[offset + 0] == 0x03)) ||  						(count == 65 && (data[offset + 0] == 0x04 || data[offset + 0] == 0x06 || data[offset + 0] == 0x07))  					);
Magic Number,NBitcoin,PubKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\PubKey.cs,DecodeSig,The following statement contains a magic number: BigInteger r = new BigInteger(1' signatureEncoded.SafeSubarray(1' 32));
Magic Number,NBitcoin,PubKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\PubKey.cs,DecodeSig,The following statement contains a magic number: BigInteger s = new BigInteger(1' signatureEncoded.SafeSubarray(33' 32));
Magic Number,NBitcoin,PubKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\PubKey.cs,DecodeSig,The following statement contains a magic number: BigInteger s = new BigInteger(1' signatureEncoded.SafeSubarray(33' 32));
Magic Number,NBitcoin,PubKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\PubKey.cs,RecoverCompact,The following statement contains a magic number: signatureEncoded.Length < 65
Magic Number,NBitcoin,PubKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\PubKey.cs,RecoverCompact,The following statement contains a magic number: header < 27 || header > 34
Magic Number,NBitcoin,PubKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\PubKey.cs,RecoverCompact,The following statement contains a magic number: header < 27 || header > 34
Magic Number,NBitcoin,PubKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\PubKey.cs,RecoverCompact,The following statement contains a magic number: header -= 4;
Magic Number,NBitcoin,PubKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\PubKey.cs,RecoverCompact,The following statement contains a magic number: header >= 31
Magic Number,NBitcoin,PubKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\PubKey.cs,RecoverCompact,The following statement contains a magic number: int recId = header - 27;
Magic Number,NBitcoin,PubKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\PubKey.cs,Derivate,The following statement contains a magic number: byte[] l = new byte[32];
Magic Number,NBitcoin,PubKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\PubKey.cs,Derivate,The following statement contains a magic number: byte[] r = new byte[32];
Magic Number,NBitcoin,PubKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\PubKey.cs,Derivate,The following statement contains a magic number: (nChild >> 31) == 0
Magic Number,NBitcoin,PubKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\PubKey.cs,Derivate,The following statement contains a magic number: Array.Copy(lr' l' 32);
Magic Number,NBitcoin,PubKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\PubKey.cs,Derivate,The following statement contains a magic number: Array.Copy(lr' 32' r' 0' 32);
Magic Number,NBitcoin,PubKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\PubKey.cs,Derivate,The following statement contains a magic number: Array.Copy(lr' 32' r' 0' 32);
Magic Number,NBitcoin,PubKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\PubKey.cs,Encrypt,The following statement contains a magic number: var iv = sharedKey.SafeSubarray(0' 16);
Magic Number,NBitcoin,PubKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\PubKey.cs,Encrypt,The following statement contains a magic number: var encryptionKey = sharedKey.SafeSubarray(16' 16);
Magic Number,NBitcoin,PubKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\PubKey.cs,Encrypt,The following statement contains a magic number: var encryptionKey = sharedKey.SafeSubarray(16' 16);
Magic Number,NBitcoin,PubKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\PubKey.cs,Encrypt,The following statement contains a magic number: var hashingKey = sharedKey.SafeSubarray(32);
Magic Number,NBitcoin,RandomUtils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RandomUtils.cs,PushEntropy,The following statement contains a magic number: data[i] ^= entropy[pos % 32];
Magic Number,NBitcoin,RandomUtils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RandomUtils.cs,PushEntropy,The following statement contains a magic number: data[i] ^= entropy[pos % 32];
Magic Number,NBitcoin,RandomUtils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RandomUtils.cs,PushEntropy,The following statement contains a magic number: entropyIndex = pos % 32;
Magic Number,NBitcoin,RandomUtils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RandomUtils.cs,GetUInt256,The following statement contains a magic number: return new uint256(GetBytes(32));
Magic Number,NBitcoin,Script,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Script.cs,ToString,The following statement contains a magic number: var builder = new StringBuilder(300);
Magic Number,NBitcoin,Script,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Script.cs,CombineSignatures,The following statement contains a magic number: scriptPubKey = new KeyId(scriptPubKey.ToBytes(true).SafeSubarray(1' 20)).ScriptPubKey;
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,VerifyWitnessProgram,The following statement contains a magic number: wit.Program.Length == 32
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,EvalScript,The following statement contains a magic number: s.Length > 10000
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,EvalScript,The following statement contains a magic number: opcode.Code > OpcodeType.OP_16 && ++nOpCount > 201
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,EvalScript,The following statement contains a magic number: _stack.Count + altstack.Count > 1000
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,CheckSequence,The following statement contains a magic number: txTo.Version < 2
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,IsCompressedOrUncompressedPubKey,The following statement contains a magic number: vchPubKey.Length < 33
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,IsCompressedOrUncompressedPubKey,The following statement contains a magic number: vchPubKey.Length != 65
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,IsCompressedPubKey,The following statement contains a magic number: vchPubKey.Length != 33
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,IsLowDERSignature,The following statement contains a magic number: int nLenR = vchSig[3];
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,IsLowDERSignature,The following statement contains a magic number: int nLenS = vchSig[5 + nLenR];
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,IsLowDERSignature,The following statement contains a magic number: var S = 6 + nLenR;
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,CheckSignatureElement,The following statement contains a magic number: return vchSig != null  						&&  						 CompareBigEndian(vchSig' i' len' vchZero' 0) > 0 &&  						 CompareBigEndian(vchSig' i' len' half ? vchMaxModHalfOrder : vchMaxModOrder' 32) <= 0;
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,IsValidSignatureEncoding,The following statement contains a magic number: signLen < 9 || signLen > 73
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,IsValidSignatureEncoding,The following statement contains a magic number: signLen < 9 || signLen > 73
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,IsValidSignatureEncoding,The following statement contains a magic number: sig[1] != signLen - 3
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,IsValidSignatureEncoding,The following statement contains a magic number: uint lenR = sig[3];
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,IsValidSignatureEncoding,The following statement contains a magic number: 5 + lenR >= signLen
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,IsValidSignatureEncoding,The following statement contains a magic number: uint lenS = sig[5 + lenR];
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,IsValidSignatureEncoding,The following statement contains a magic number: (lenR + lenS + 7) != signLen
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,IsValidSignatureEncoding,The following statement contains a magic number: sig[2] != 0x02
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,IsValidSignatureEncoding,The following statement contains a magic number: (sig[4] & 0x80) != 0
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,IsValidSignatureEncoding,The following statement contains a magic number: lenR > 1 && (sig[4] == 0x00) && (sig[5] & 0x80) == 0
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,IsValidSignatureEncoding,The following statement contains a magic number: lenR > 1 && (sig[4] == 0x00) && (sig[5] & 0x80) == 0
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,IsValidSignatureEncoding,The following statement contains a magic number: sig[lenR + 4] != 0x02
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,IsValidSignatureEncoding,The following statement contains a magic number: (sig[lenR + 6] & 0x80) != 0
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,IsValidSignatureEncoding,The following statement contains a magic number: lenS > 1 && (sig[lenR + 6] == 0x00) && (sig[lenR + 7] & 0x80) == 0
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,IsValidSignatureEncoding,The following statement contains a magic number: lenS > 1 && (sig[lenR + 6] == 0x00) && (sig[lenR + 7] & 0x80) == 0
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,CheckSig,The following statement contains a magic number: var nLenR = vchSig[3];
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,CheckSig,The following statement contains a magic number: var nLenS = vchSig[5 + nLenR];
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,CheckSig,The following statement contains a magic number: var R = 4;
Magic Number,NBitcoin,ScriptEvaluationContext,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,CheckSig,The following statement contains a magic number: var S = 6 + nLenR;
Magic Number,NBitcoin,CScriptNum,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,CScriptNum,The following statement contains a magic number: vch.Length <= 1 || (vch[vch.Length - 2] & 0x80) == 0
Magic Number,NBitcoin,CScriptNum,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,serialize,The following statement contains a magic number: absvalue >>= 8;
Magic Number,NBitcoin,CScriptNum,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,set_vch,The following statement contains a magic number: result |= ((long)(vch[i])) << 8 * i;
Magic Number,NBitcoin,CScriptNum,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,set_vch,The following statement contains a magic number: var temp = ~(0x80UL << (8 * (vch.Length - 1)));
Magic Number,NBitcoin,ContextStack<T>,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,ContextStack,The following statement contains a magic number: _array = new T[16];
Magic Number,NBitcoin,ContextStack<T>,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptEvaluationContext.cs,EnsureSize,The following statement contains a magic number: Array.Resize(ref _array' 2 * _array.Length);
Magic Number,NBitcoin,Op,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptReader.cs,GetValidOpCode,The following statement contains a magic number: var valid = new bool[256];
Magic Number,NBitcoin,Op,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptReader.cs,GetValidOpCode,The following statement contains a magic number: i == 255
Magic Number,NBitcoin,Op,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptReader.cs,ToString,The following statement contains a magic number: return result.Length == 2 && result[0] == '0' ? result.Substring(1) : result;
Magic Number,NBitcoin,Op,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptReader.cs,GetLong,The following statement contains a magic number: result |= ((long)(vch[i])) << 8 * i;
Magic Number,NBitcoin,Op,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\ScriptReader.cs,GetLong,The following statement contains a magic number: var temp = ~(0x80UL << (8 * (vch.Length - 1)));
Magic Number,NBitcoin,Sequence,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Sequence.cs,Sequence,The following statement contains a magic number: throw new ArgumentOutOfRangeException("Relative lock time must be positive and lower or equals to " + (0xFFFF * 512) + " seconds (approx 388 days)");
Magic Number,NBitcoin,Sequence,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Sequence.cs,Sequence,The following statement contains a magic number: period.TotalSeconds > (0xFFFF * 512) || period.TotalSeconds < 0
Magic Number,NBitcoin,SlimChain,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\SlimChain.cs,TrySetTipNoLock,The following statement contains a magic number: Array.Resize(ref _BlockHashesByHeight' (int)((_Height + 100) * 1.1));
Magic Number,NBitcoin,SlimChain,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\SlimChain.cs,TrySetTipNoLock,The following statement contains a magic number: Array.Resize(ref _BlockHashesByHeight' (int)((_Height + 100) * 1.1));
Magic Number,NBitcoin,SlimChain,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\SlimChain.cs,GetLocatorNoLock,The following statement contains a magic number: nStep *= 2;
Magic Number,NBitcoin,SlimChain,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\SlimChain.cs,GetLocatorNoLock,The following statement contains a magic number: vHave.Count > 10
Magic Number,NBitcoin,SlimChain,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\SlimChain.cs,Save,The following statement contains a magic number: var bytes = new byte[32];
Magic Number,NBitcoin,SlimChain,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\SlimChain.cs,Save,The following statement contains a magic number: output.Write(bytes' 0' 32);
Magic Number,NBitcoin,SlimChain,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\SlimChain.cs,Load,The following statement contains a magic number: var bytes = new byte[32];
Magic Number,NBitcoin,SlimChain,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\SlimChain.cs,Load,The following statement contains a magic number: input.ReadBytes(32' bytes) == 32
Magic Number,NBitcoin,SlimChain,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\SlimChain.cs,Load,The following statement contains a magic number: input.ReadBytes(32' bytes) == 32
Magic Number,NBitcoin,PayToMultiSigTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,CheckScriptPubKeyCore,The following statement contains a magic number: ops.Length < 3
Magic Number,NBitcoin,PayToMultiSigTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,CheckScriptPubKeyCore,The following statement contains a magic number: var keyCount = ops[ops.Length - 2].GetInt();
Magic Number,NBitcoin,PayToMultiSigTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,CheckScriptPubKeyCore,The following statement contains a magic number: keyCount.Value < 0 || keyCount.Value > 20
Magic Number,NBitcoin,PayToMultiSigTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,ExtractScriptPubKeyParameters,The following statement contains a magic number: var keyCount = ops[ops.Length - 2].GetInt().Value;
Magic Number,NBitcoin,PayToScriptHashTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,FastCheckScriptPubKey,The following statement contains a magic number: return  				   bytes.Length == 23 &&  				   bytes[0] == (byte)OpcodeType.OP_HASH160 &&  				   bytes[1] == 0x14 &&  				   bytes[22] == (byte)OpcodeType.OP_EQUAL;
Magic Number,NBitcoin,PayToScriptHashTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,FastCheckScriptPubKey,The following statement contains a magic number: return  				   bytes.Length == 23 &&  				   bytes[0] == (byte)OpcodeType.OP_HASH160 &&  				   bytes[1] == 0x14 &&  				   bytes[22] == (byte)OpcodeType.OP_EQUAL;
Magic Number,NBitcoin,PayToScriptHashTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,CheckScriptSigCore,The following statement contains a magic number: redeemBytes.Length > 520
Magic Number,NBitcoin,PayToScriptHashTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,ExtractScriptPubKeyParameters,The following statement contains a magic number: return new ScriptId(scriptPubKey.ToBytes(true).SafeSubarray(2' 20));
Magic Number,NBitcoin,PayToScriptHashTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,ExtractScriptPubKeyParameters,The following statement contains a magic number: return new ScriptId(scriptPubKey.ToBytes(true).SafeSubarray(2' 20));
Magic Number,NBitcoin,PayToPubkeyTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,FastCheckScriptPubKey,The following statement contains a magic number: return  				 scriptPubKey.Length > 3 &&  				 PubKey.Check(scriptPubKey.ToBytes(true)' 1' scriptPubKey.Length - 2' false) &&  				 scriptPubKey.ToBytes(true)[scriptPubKey.Length - 1] == 0xac;
Magic Number,NBitcoin,PayToPubkeyTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,FastCheckScriptPubKey,The following statement contains a magic number: return  				 scriptPubKey.Length > 3 &&  				 PubKey.Check(scriptPubKey.ToBytes(true)' 1' scriptPubKey.Length - 2' false) &&  				 scriptPubKey.ToBytes(true)[scriptPubKey.Length - 1] == 0xac;
Magic Number,NBitcoin,PayToPubkeyTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,FastCheckScriptSig,The following statement contains a magic number: return (67 + 1 <= scriptSig.Length && scriptSig.Length <= 80 + 2) || scriptSig.Length == 9 + 1;
Magic Number,NBitcoin,PayToPubkeyTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,FastCheckScriptSig,The following statement contains a magic number: return (67 + 1 <= scriptSig.Length && scriptSig.Length <= 80 + 2) || scriptSig.Length == 9 + 1;
Magic Number,NBitcoin,PayToPubkeyTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,FastCheckScriptSig,The following statement contains a magic number: return (67 + 1 <= scriptSig.Length && scriptSig.Length <= 80 + 2) || scriptSig.Length == 9 + 1;
Magic Number,NBitcoin,PayToPubkeyTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,FastCheckScriptSig,The following statement contains a magic number: return (67 + 1 <= scriptSig.Length && scriptSig.Length <= 80 + 2) || scriptSig.Length == 9 + 1;
Magic Number,NBitcoin,PayToPubkeyTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,ExtractScriptPubKeyParameters,The following statement contains a magic number: return new PubKey(scriptPubKey.ToBytes(true).SafeSubarray(1' scriptPubKey.Length - 2)' true);
Magic Number,NBitcoin,PayToPubkeyHashTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,FastCheckScriptPubKey,The following statement contains a magic number: return bytes.Length == 25 &&  				   bytes[0] == (byte)OpcodeType.OP_DUP &&  				   bytes[1] == (byte)OpcodeType.OP_HASH160 &&  				   bytes[2] == 0x14 &&  				   bytes[24] == (byte)OpcodeType.OP_CHECKSIG;
Magic Number,NBitcoin,PayToPubkeyHashTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,FastCheckScriptPubKey,The following statement contains a magic number: return bytes.Length == 25 &&  				   bytes[0] == (byte)OpcodeType.OP_DUP &&  				   bytes[1] == (byte)OpcodeType.OP_HASH160 &&  				   bytes[2] == 0x14 &&  				   bytes[24] == (byte)OpcodeType.OP_CHECKSIG;
Magic Number,NBitcoin,PayToPubkeyHashTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,FastCheckScriptPubKey,The following statement contains a magic number: return bytes.Length == 25 &&  				   bytes[0] == (byte)OpcodeType.OP_DUP &&  				   bytes[1] == (byte)OpcodeType.OP_HASH160 &&  				   bytes[2] == 0x14 &&  				   bytes[24] == (byte)OpcodeType.OP_CHECKSIG;
Magic Number,NBitcoin,PayToPubkeyHashTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,ExtractScriptPubKeyParameters,The following statement contains a magic number: return new KeyId(scriptPubKey.ToBytes(true).SafeSubarray(3' 20));
Magic Number,NBitcoin,PayToPubkeyHashTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,ExtractScriptPubKeyParameters,The following statement contains a magic number: return new KeyId(scriptPubKey.ToBytes(true).SafeSubarray(3' 20));
Magic Number,NBitcoin,PayToPubkeyHashTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,CheckScriptSigCore,The following statement contains a magic number: ops.Length != 2
Magic Number,NBitcoin,PayToWitPubKeyHashTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,CheckScriptPubKey,The following statement contains a magic number: return bytes.Length == 22 && bytes[0] == 0 && bytes[1] == 20;
Magic Number,NBitcoin,PayToWitPubKeyHashTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,CheckScriptPubKey,The following statement contains a magic number: return bytes.Length == 22 && bytes[0] == 0 && bytes[1] == 20;
Magic Number,NBitcoin,PayToWitPubKeyHashTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,ExtractScriptPubKeyParameters,The following statement contains a magic number: byte[] data = new byte[20];
Magic Number,NBitcoin,PayToWitPubKeyHashTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,ExtractScriptPubKeyParameters,The following statement contains a magic number: Array.Copy(scriptPubKey.ToBytes(true)' 2' data' 0' 20);
Magic Number,NBitcoin,PayToWitPubKeyHashTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,ExtractScriptPubKeyParameters,The following statement contains a magic number: Array.Copy(scriptPubKey.ToBytes(true)' 2' data' 0' 20);
Magic Number,NBitcoin,PayToWitPubKeyHashTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,CheckWitScriptCore,The following statement contains a magic number: return witScript.PushCount == 2 &&  				   ((witScript[0].Length == 0) || (TransactionSignature.IsValid(witScript[0]' ScriptVerify.None))) &&  				   PubKey.Check(witScript[1]' false);
Magic Number,NBitcoin,PayToWitScriptHashTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,CheckScriptPubKey,The following statement contains a magic number: return bytes.Length == 34 && bytes[0] == 0 && bytes[1] == 32;
Magic Number,NBitcoin,PayToWitScriptHashTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,CheckScriptPubKey,The following statement contains a magic number: return bytes.Length == 34 && bytes[0] == 0 && bytes[1] == 32;
Magic Number,NBitcoin,PayToWitScriptHashTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,ExtractScriptPubKeyParameters,The following statement contains a magic number: byte[] data = new byte[32];
Magic Number,NBitcoin,PayToWitScriptHashTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,ExtractScriptPubKeyParameters,The following statement contains a magic number: Array.Copy(scriptPubKey.ToBytes(true)' 2' data' 0' 32);
Magic Number,NBitcoin,PayToWitScriptHashTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,ExtractScriptPubKeyParameters,The following statement contains a magic number: Array.Copy(scriptPubKey.ToBytes(true)' 2' data' 0' 32);
Magic Number,NBitcoin,WitProgramParameters,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,NeedWitnessRedeemScript,The following statement contains a magic number: return Version == OpcodeType.OP_0 && Program?.Length is 32;
Magic Number,NBitcoin,WitProgramParameters,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,VerifyWitnessRedeemScript,The following statement contains a magic number: Version == OpcodeType.OP_0 && Program?.Length is 32
Magic Number,NBitcoin,PayToWitTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,CheckScriptPubKey,The following statement contains a magic number: bytes.Length < 4 || bytes.Length > 34
Magic Number,NBitcoin,PayToWitTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,CheckScriptPubKey,The following statement contains a magic number: bytes.Length < 4 || bytes.Length > 34
Magic Number,NBitcoin,PayToWitTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,CheckScriptPubKey,The following statement contains a magic number: return bytes[1] + 2 == bytes.Length;
Magic Number,NBitcoin,PayToWitTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,ExtractScriptPubKeyParameters,The following statement contains a magic number: ops.Length != 2 || ops[1].PushData == null
Magic Number,NBitcoin,PayToWitTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,ExtractScriptPubKeyParameters,The following statement contains a magic number: ops[1].PushData.Length == 20
Magic Number,NBitcoin,PayToWitTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,ExtractScriptPubKeyParameters,The following statement contains a magic number: ops[1].PushData.Length == 32
Magic Number,NBitcoin,PayToWitTemplate,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\StandardScriptTemplate.cs,ExtractScriptPubKeyParameters2,The following statement contains a magic number: ops.Length != 2 || ops[1].PushData == null
Magic Number,NBitcoin,Target,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Target.cs,ToBytes,The following statement contains a magic number: return new byte[]  			{  				(byte)(bits >> 24)'  				(byte)(bits >> 16)'  				(byte)(bits >> 8)'  				(byte)(bits)  			};
Magic Number,NBitcoin,Target,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Target.cs,ToBytes,The following statement contains a magic number: return new byte[]  			{  				(byte)(bits >> 24)'  				(byte)(bits >> 16)'  				(byte)(bits >> 8)'  				(byte)(bits)  			};
Magic Number,NBitcoin,Target,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Target.cs,ToBytes,The following statement contains a magic number: return new byte[]  			{  				(byte)(bits >> 24)'  				(byte)(bits >> 16)'  				(byte)(bits >> 8)'  				(byte)(bits)  			};
Magic Number,NBitcoin,Target,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Target.cs,Target,The following statement contains a magic number: var val = new BigInteger(compact.SafeSubarray(1' 3));
Magic Number,NBitcoin,Target,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Target.cs,Target,The following statement contains a magic number: _Target = val.ShiftLeft(8 * (exp - 3));
Magic Number,NBitcoin,Target,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Target.cs,Target,The following statement contains a magic number: _Target = val.ShiftLeft(8 * (exp - 3));
Magic Number,NBitcoin,Target,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Target.cs,Target,The following statement contains a magic number: compact.Length == 4
Magic Number,NBitcoin,Target,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Target.cs,ToUInt256,The following statement contains a magic number: var missingZero = 32 - array.Length;
Magic Number,NBitcoin,OutPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,TryParse,The following statement contains a magic number: splitted[0].Length != 32 * 2 + 4 * 2
Magic Number,NBitcoin,OutPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,TryParse,The following statement contains a magic number: splitted[0].Length != 32 * 2 + 4 * 2
Magic Number,NBitcoin,OutPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,TryParse,The following statement contains a magic number: splitted[0].Length != 32 * 2 + 4 * 2
Magic Number,NBitcoin,OutPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,TryParse,The following statement contains a magic number: splitted[0].Length != 32 * 2 + 4 * 2
Magic Number,NBitcoin,OutPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,TryParse,The following statement contains a magic number: var outputIndex = splitted[0].Substring(32 * 2);
Magic Number,NBitcoin,OutPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,TryParse,The following statement contains a magic number: var outputIndex = splitted[0].Substring(32 * 2);
Magic Number,NBitcoin,OutPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,TryParse,The following statement contains a magic number: !uint256.TryParse(splitted[0].Substring(0' 32 * 2)' out hash)
Magic Number,NBitcoin,OutPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,TryParse,The following statement contains a magic number: !uint256.TryParse(splitted[0].Substring(0' 32 * 2)' out hash)
Magic Number,NBitcoin,OutPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,TryParse,The following statement contains a magic number: splitted.Length != 2
Magic Number,NBitcoin,OutPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,GetHashCode,The following statement contains a magic number: return 17 + hash.GetHashCode() * 31 + n.GetHashCode() * 31 * 31;
Magic Number,NBitcoin,OutPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,GetHashCode,The following statement contains a magic number: return 17 + hash.GetHashCode() * 31 + n.GetHashCode() * 31 * 31;
Magic Number,NBitcoin,OutPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,GetHashCode,The following statement contains a magic number: return 17 + hash.GetHashCode() * 31 + n.GetHashCode() * 31 * 31;
Magic Number,NBitcoin,OutPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,GetHashCode,The following statement contains a magic number: return 17 + hash.GetHashCode() * 31 + n.GetHashCode() * 31 * 31;
Magic Number,NBitcoin,TxOutCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,CompressAmount,The following statement contains a magic number: n /= 10;
Magic Number,NBitcoin,TxOutCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,CompressAmount,The following statement contains a magic number: ((n % 10) == 0) && e < 9
Magic Number,NBitcoin,TxOutCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,CompressAmount,The following statement contains a magic number: ((n % 10) == 0) && e < 9
Magic Number,NBitcoin,TxOutCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,CompressAmount,The following statement contains a magic number: int d = (int)(n % 10);
Magic Number,NBitcoin,TxOutCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,CompressAmount,The following statement contains a magic number: n /= 10;
Magic Number,NBitcoin,TxOutCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,CompressAmount,The following statement contains a magic number: return 1 + (n * 9 + (ulong)(d - 1)) * 10 + (ulong)e;
Magic Number,NBitcoin,TxOutCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,CompressAmount,The following statement contains a magic number: return 1 + (n * 9 + (ulong)(d - 1)) * 10 + (ulong)e;
Magic Number,NBitcoin,TxOutCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,CompressAmount,The following statement contains a magic number: e < 9
Magic Number,NBitcoin,TxOutCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,DecompressAmount,The following statement contains a magic number: int e = (int)(x % 10);
Magic Number,NBitcoin,TxOutCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,DecompressAmount,The following statement contains a magic number: x /= 10;
Magic Number,NBitcoin,TxOutCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,DecompressAmount,The following statement contains a magic number: int d = (int)((x % 9) + 1);
Magic Number,NBitcoin,TxOutCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,DecompressAmount,The following statement contains a magic number: x /= 9;
Magic Number,NBitcoin,TxOutCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,DecompressAmount,The following statement contains a magic number: n = (x * 10 + (ulong)d);
Magic Number,NBitcoin,TxOutCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,DecompressAmount,The following statement contains a magic number: e < 9
Magic Number,NBitcoin,TxOutCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,DecompressAmount,The following statement contains a magic number: n *= 10;
Magic Number,NBitcoin,ScriptCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,Compress,The following statement contains a magic number: result = new byte[21];
Magic Number,NBitcoin,ScriptCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,Compress,The following statement contains a magic number: Array.Copy(keyID.ToBytes(true)' 0' result' 1' 20);
Magic Number,NBitcoin,ScriptCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,Compress,The following statement contains a magic number: result = new byte[21];
Magic Number,NBitcoin,ScriptCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,Compress,The following statement contains a magic number: Array.Copy(scriptID.ToBytes(true)' 0' result' 1' 20);
Magic Number,NBitcoin,ScriptCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,Compress,The following statement contains a magic number: result = new byte[33];
Magic Number,NBitcoin,ScriptCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,Compress,The following statement contains a magic number: Array.Copy(pubBytes' 1' result' 1' 32);
Magic Number,NBitcoin,ScriptCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,Decompress,The following statement contains a magic number: switch (nSize)  			{  				case 0x00:  					return PayToPubkeyHashTemplate.Instance.GenerateScriptPubKey(new KeyId(data.SafeSubarray(0' 20)));  				case 0x01:  					return PayToScriptHashTemplate.Instance.GenerateScriptPubKey(new ScriptId(data.SafeSubarray(0' 20)));  				case 0x02:  				case 0x03:  					var keyPart = data.SafeSubarray(0' 32);  					var keyBytes = new byte[33];  					keyBytes[0] = (byte)nSize;  					Array.Copy(keyPart' 0' keyBytes' 1' 32);  					return PayToPubkeyTemplate.Instance.GenerateScriptPubKey(keyBytes);  				case 0x04:  				case 0x05:  					byte[] vch = new byte[33];  					vch[0] = (byte)(nSize - 2);  					Array.Copy(data' 0' vch' 1' 32);  					PubKey pubkey = new PubKey(vch' true);  					pubkey = pubkey.Decompress();  					return PayToPubkeyTemplate.Instance.GenerateScriptPubKey(pubkey);  			}
Magic Number,NBitcoin,ScriptCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,Decompress,The following statement contains a magic number: switch (nSize)  			{  				case 0x00:  					return PayToPubkeyHashTemplate.Instance.GenerateScriptPubKey(new KeyId(data.SafeSubarray(0' 20)));  				case 0x01:  					return PayToScriptHashTemplate.Instance.GenerateScriptPubKey(new ScriptId(data.SafeSubarray(0' 20)));  				case 0x02:  				case 0x03:  					var keyPart = data.SafeSubarray(0' 32);  					var keyBytes = new byte[33];  					keyBytes[0] = (byte)nSize;  					Array.Copy(keyPart' 0' keyBytes' 1' 32);  					return PayToPubkeyTemplate.Instance.GenerateScriptPubKey(keyBytes);  				case 0x04:  				case 0x05:  					byte[] vch = new byte[33];  					vch[0] = (byte)(nSize - 2);  					Array.Copy(data' 0' vch' 1' 32);  					PubKey pubkey = new PubKey(vch' true);  					pubkey = pubkey.Decompress();  					return PayToPubkeyTemplate.Instance.GenerateScriptPubKey(pubkey);  			}
Magic Number,NBitcoin,ScriptCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,Decompress,The following statement contains a magic number: switch (nSize)  			{  				case 0x00:  					return PayToPubkeyHashTemplate.Instance.GenerateScriptPubKey(new KeyId(data.SafeSubarray(0' 20)));  				case 0x01:  					return PayToScriptHashTemplate.Instance.GenerateScriptPubKey(new ScriptId(data.SafeSubarray(0' 20)));  				case 0x02:  				case 0x03:  					var keyPart = data.SafeSubarray(0' 32);  					var keyBytes = new byte[33];  					keyBytes[0] = (byte)nSize;  					Array.Copy(keyPart' 0' keyBytes' 1' 32);  					return PayToPubkeyTemplate.Instance.GenerateScriptPubKey(keyBytes);  				case 0x04:  				case 0x05:  					byte[] vch = new byte[33];  					vch[0] = (byte)(nSize - 2);  					Array.Copy(data' 0' vch' 1' 32);  					PubKey pubkey = new PubKey(vch' true);  					pubkey = pubkey.Decompress();  					return PayToPubkeyTemplate.Instance.GenerateScriptPubKey(pubkey);  			}
Magic Number,NBitcoin,ScriptCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,Decompress,The following statement contains a magic number: switch (nSize)  			{  				case 0x00:  					return PayToPubkeyHashTemplate.Instance.GenerateScriptPubKey(new KeyId(data.SafeSubarray(0' 20)));  				case 0x01:  					return PayToScriptHashTemplate.Instance.GenerateScriptPubKey(new ScriptId(data.SafeSubarray(0' 20)));  				case 0x02:  				case 0x03:  					var keyPart = data.SafeSubarray(0' 32);  					var keyBytes = new byte[33];  					keyBytes[0] = (byte)nSize;  					Array.Copy(keyPart' 0' keyBytes' 1' 32);  					return PayToPubkeyTemplate.Instance.GenerateScriptPubKey(keyBytes);  				case 0x04:  				case 0x05:  					byte[] vch = new byte[33];  					vch[0] = (byte)(nSize - 2);  					Array.Copy(data' 0' vch' 1' 32);  					PubKey pubkey = new PubKey(vch' true);  					pubkey = pubkey.Decompress();  					return PayToPubkeyTemplate.Instance.GenerateScriptPubKey(pubkey);  			}
Magic Number,NBitcoin,ScriptCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,Decompress,The following statement contains a magic number: switch (nSize)  			{  				case 0x00:  					return PayToPubkeyHashTemplate.Instance.GenerateScriptPubKey(new KeyId(data.SafeSubarray(0' 20)));  				case 0x01:  					return PayToScriptHashTemplate.Instance.GenerateScriptPubKey(new ScriptId(data.SafeSubarray(0' 20)));  				case 0x02:  				case 0x03:  					var keyPart = data.SafeSubarray(0' 32);  					var keyBytes = new byte[33];  					keyBytes[0] = (byte)nSize;  					Array.Copy(keyPart' 0' keyBytes' 1' 32);  					return PayToPubkeyTemplate.Instance.GenerateScriptPubKey(keyBytes);  				case 0x04:  				case 0x05:  					byte[] vch = new byte[33];  					vch[0] = (byte)(nSize - 2);  					Array.Copy(data' 0' vch' 1' 32);  					PubKey pubkey = new PubKey(vch' true);  					pubkey = pubkey.Decompress();  					return PayToPubkeyTemplate.Instance.GenerateScriptPubKey(pubkey);  			}
Magic Number,NBitcoin,ScriptCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,Decompress,The following statement contains a magic number: switch (nSize)  			{  				case 0x00:  					return PayToPubkeyHashTemplate.Instance.GenerateScriptPubKey(new KeyId(data.SafeSubarray(0' 20)));  				case 0x01:  					return PayToScriptHashTemplate.Instance.GenerateScriptPubKey(new ScriptId(data.SafeSubarray(0' 20)));  				case 0x02:  				case 0x03:  					var keyPart = data.SafeSubarray(0' 32);  					var keyBytes = new byte[33];  					keyBytes[0] = (byte)nSize;  					Array.Copy(keyPart' 0' keyBytes' 1' 32);  					return PayToPubkeyTemplate.Instance.GenerateScriptPubKey(keyBytes);  				case 0x04:  				case 0x05:  					byte[] vch = new byte[33];  					vch[0] = (byte)(nSize - 2);  					Array.Copy(data' 0' vch' 1' 32);  					PubKey pubkey = new PubKey(vch' true);  					pubkey = pubkey.Decompress();  					return PayToPubkeyTemplate.Instance.GenerateScriptPubKey(pubkey);  			}
Magic Number,NBitcoin,ScriptCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,Decompress,The following statement contains a magic number: switch (nSize)  			{  				case 0x00:  					return PayToPubkeyHashTemplate.Instance.GenerateScriptPubKey(new KeyId(data.SafeSubarray(0' 20)));  				case 0x01:  					return PayToScriptHashTemplate.Instance.GenerateScriptPubKey(new ScriptId(data.SafeSubarray(0' 20)));  				case 0x02:  				case 0x03:  					var keyPart = data.SafeSubarray(0' 32);  					var keyBytes = new byte[33];  					keyBytes[0] = (byte)nSize;  					Array.Copy(keyPart' 0' keyBytes' 1' 32);  					return PayToPubkeyTemplate.Instance.GenerateScriptPubKey(keyBytes);  				case 0x04:  				case 0x05:  					byte[] vch = new byte[33];  					vch[0] = (byte)(nSize - 2);  					Array.Copy(data' 0' vch' 1' 32);  					PubKey pubkey = new PubKey(vch' true);  					pubkey = pubkey.Decompress();  					return PayToPubkeyTemplate.Instance.GenerateScriptPubKey(pubkey);  			}
Magic Number,NBitcoin,ScriptCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,Decompress,The following statement contains a magic number: switch (nSize)  			{  				case 0x00:  					return PayToPubkeyHashTemplate.Instance.GenerateScriptPubKey(new KeyId(data.SafeSubarray(0' 20)));  				case 0x01:  					return PayToScriptHashTemplate.Instance.GenerateScriptPubKey(new ScriptId(data.SafeSubarray(0' 20)));  				case 0x02:  				case 0x03:  					var keyPart = data.SafeSubarray(0' 32);  					var keyBytes = new byte[33];  					keyBytes[0] = (byte)nSize;  					Array.Copy(keyPart' 0' keyBytes' 1' 32);  					return PayToPubkeyTemplate.Instance.GenerateScriptPubKey(keyBytes);  				case 0x04:  				case 0x05:  					byte[] vch = new byte[33];  					vch[0] = (byte)(nSize - 2);  					Array.Copy(data' 0' vch' 1' 32);  					PubKey pubkey = new PubKey(vch' true);  					pubkey = pubkey.Decompress();  					return PayToPubkeyTemplate.Instance.GenerateScriptPubKey(pubkey);  			}
Magic Number,NBitcoin,ScriptCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,GetSpecialSize,The following statement contains a magic number: return 20;
Magic Number,NBitcoin,ScriptCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,GetSpecialSize,The following statement contains a magic number: return 32;
Magic Number,NBitcoin,ScriptCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,GetSpecialSize,The following statement contains a magic number: nSize == 2 || nSize == 3 || nSize == 4 || nSize == 5
Magic Number,NBitcoin,ScriptCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,GetSpecialSize,The following statement contains a magic number: nSize == 2 || nSize == 3 || nSize == 4 || nSize == 5
Magic Number,NBitcoin,ScriptCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,GetSpecialSize,The following statement contains a magic number: nSize == 2 || nSize == 3 || nSize == 4 || nSize == 5
Magic Number,NBitcoin,ScriptCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,GetSpecialSize,The following statement contains a magic number: nSize == 2 || nSize == 3 || nSize == 4 || nSize == 5
Magic Number,NBitcoin,TxOut,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,GetDustThreshold,The following statement contains a magic number: int nSize = this.GetSerializedSize() + 148;
Magic Number,NBitcoin,TxOut,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,GetDustThreshold,The following statement contains a magic number: return 3 * minRelayTxFee.GetFee(nSize);
Magic Number,NBitcoin,Transaction,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,PrecomputeHash,The following statement contains a magic number: _Hashes = invalidateExisting ? new uint256[2] : _Hashes ?? new uint256[2];
Magic Number,NBitcoin,Transaction,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,PrecomputeHash,The following statement contains a magic number: _Hashes = invalidateExisting ? new uint256[2] : _Hashes ?? new uint256[2];
Magic Number,NBitcoin,Transaction,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,CalculateSequenceLocks,The following statement contains a magic number: bool fEnforceBIP68 = Version >= 2  							  && (flags & LockTimeFlags.VerifySequence) != 0;
Magic Number,NBitcoin,Transaction,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,Check,The following statement contains a magic number: Inputs[0].ScriptSig.Length < 2 || Inputs[0].ScriptSig.Length > 100
Magic Number,NBitcoin,Transaction,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,Check,The following statement contains a magic number: Inputs[0].ScriptSig.Length < 2 || Inputs[0].ScriptSig.Length > 100
Magic Number,NBitcoin,DefaultCoinSelector,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\TransactionBuilder.cs,ApproximateBestSubset,The following statement contains a magic number: nPass == 0 ? _Rand.Next(0' 2) == 0 : !vfIncluded[i]
Magic Number,NBitcoin,DefaultCoinSelector,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\TransactionBuilder.cs,ApproximateBestSubset,The following statement contains a magic number: nPass < 2 && !fReachedTarget
Magic Number,NBitcoin,TransactionBuilder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\TransactionBuilder.cs,SetColoredChange,The following statement contains a magic number: marker.SetQuantity(ctx.Transaction.Outputs.Count - 2' changeAmount.Quantity);
Magic Number,NBitcoin,TransactionBuilder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\TransactionBuilder.cs,SendAsset,The following statement contains a magic number: builders.Add(ctx =>  			{  				var marker = ctx.GetColorMarker(false);  				var txout = ctx.Transaction.Outputs.Add(GetDust(scriptPubKey)' scriptPubKey);  				marker.SetQuantity(ctx.Transaction.Outputs.Count - 2' asset.Quantity);  				ctx.AdditionalFees += txout.Value;  				return asset;  			});
Magic Number,NBitcoin,TransactionBuilder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\TransactionBuilder.cs,GetDust,The following statement contains a magic number: return GetDust(new Script(new byte[25]));
Magic Number,NBitcoin,TransactionBuilder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\TransactionBuilder.cs,Verify,The following statement contains a magic number: margin = GetDust() * 2;
Magic Number,NBitcoin,TransactionBuilder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\TransactionBuilder.cs,EstimateSizes,The following statement contains a magic number: baseSize += (32 + 4) + 4;
Magic Number,NBitcoin,TransactionBuilder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\TransactionBuilder.cs,EstimateSizes,The following statement contains a magic number: baseSize += (32 + 4) + 4;
Magic Number,NBitcoin,TransactionBuilder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\TransactionBuilder.cs,EstimateSizes,The following statement contains a magic number: baseSize += (32 + 4) + 4;
Magic Number,NBitcoin,TransactionBuilder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\TransactionBuilder.cs,EstimateSizes,The following statement contains a magic number: witSize += 2;
Magic Number,NBitcoin,TransactionSignature,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\TransactionSignature.cs,ValidLength,The following statement contains a magic number: return (67 <= length && length <= 80) || length == 9;
Magic Number,NBitcoin,TransactionSignature,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\TransactionSignature.cs,ValidLength,The following statement contains a magic number: return (67 <= length && length <= 80) || length == 9;
Magic Number,NBitcoin,TransactionSignature,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\TransactionSignature.cs,ValidLength,The following statement contains a magic number: return (67 <= length && length <= 80) || length == 9;
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,TryParse,The following statement contains a magic number: hex = hex.Substring(2);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,TryParse,The following statement contains a magic number: hex.Length != WIDTH_BYTE * 2
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,GetByte,The following statement contains a magic number: switch (uintIndex)  			{  				case 0:  					value = pn0;  					break;  				case 1:  					value = pn1;  					break;  				case 2:  					value = pn2;  					break;  				case 3:  					value = pn3;  					break;  				case 4:  					value = pn4;  					break;  				case 5:  					value = pn5;  					break;  				case 6:  					value = pn6;  					break;  				case 7:  					value = pn7;  					break;  				default:  					throw new ArgumentOutOfRangeException("index");  			}
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,GetByte,The following statement contains a magic number: switch (uintIndex)  			{  				case 0:  					value = pn0;  					break;  				case 1:  					value = pn1;  					break;  				case 2:  					value = pn2;  					break;  				case 3:  					value = pn3;  					break;  				case 4:  					value = pn4;  					break;  				case 5:  					value = pn5;  					break;  				case 6:  					value = pn6;  					break;  				case 7:  					value = pn7;  					break;  				default:  					throw new ArgumentOutOfRangeException("index");  			}
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,GetByte,The following statement contains a magic number: switch (uintIndex)  			{  				case 0:  					value = pn0;  					break;  				case 1:  					value = pn1;  					break;  				case 2:  					value = pn2;  					break;  				case 3:  					value = pn3;  					break;  				case 4:  					value = pn4;  					break;  				case 5:  					value = pn5;  					break;  				case 6:  					value = pn6;  					break;  				case 7:  					value = pn7;  					break;  				default:  					throw new ArgumentOutOfRangeException("index");  			}
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,GetByte,The following statement contains a magic number: switch (uintIndex)  			{  				case 0:  					value = pn0;  					break;  				case 1:  					value = pn1;  					break;  				case 2:  					value = pn2;  					break;  				case 3:  					value = pn3;  					break;  				case 4:  					value = pn4;  					break;  				case 5:  					value = pn5;  					break;  				case 6:  					value = pn6;  					break;  				case 7:  					value = pn7;  					break;  				default:  					throw new ArgumentOutOfRangeException("index");  			}
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,GetByte,The following statement contains a magic number: switch (uintIndex)  			{  				case 0:  					value = pn0;  					break;  				case 1:  					value = pn1;  					break;  				case 2:  					value = pn2;  					break;  				case 3:  					value = pn3;  					break;  				case 4:  					value = pn4;  					break;  				case 5:  					value = pn5;  					break;  				case 6:  					value = pn6;  					break;  				case 7:  					value = pn7;  					break;  				default:  					throw new ArgumentOutOfRangeException("index");  			}
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,GetByte,The following statement contains a magic number: switch (uintIndex)  			{  				case 0:  					value = pn0;  					break;  				case 1:  					value = pn1;  					break;  				case 2:  					value = pn2;  					break;  				case 3:  					value = pn3;  					break;  				case 4:  					value = pn4;  					break;  				case 5:  					value = pn5;  					break;  				case 6:  					value = pn6;  					break;  				case 7:  					value = pn7;  					break;  				default:  					throw new ArgumentOutOfRangeException("index");  			}
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,GetByte,The following statement contains a magic number: return (byte)(value >> (byteIndex * 8));
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn1 = (uint)(b >> 32);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: vch = vch.Take(32).ToArray();
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn0 = Utils.ToUInt32(vch' offset + 4 * 0' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn1 = Utils.ToUInt32(vch' offset + 4 * 1' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn2 = Utils.ToUInt32(vch' offset + 4 * 2' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn2 = Utils.ToUInt32(vch' offset + 4 * 2' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn3 = Utils.ToUInt32(vch' offset + 4 * 3' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn3 = Utils.ToUInt32(vch' offset + 4 * 3' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn4 = Utils.ToUInt32(vch' offset + 4 * 4' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn4 = Utils.ToUInt32(vch' offset + 4 * 4' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn5 = Utils.ToUInt32(vch' offset + 4 * 5' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn5 = Utils.ToUInt32(vch' offset + 4 * 5' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn6 = Utils.ToUInt32(vch' offset + 4 * 6' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn6 = Utils.ToUInt32(vch' offset + 4 * 6' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn7 = Utils.ToUInt32(vch' offset + 4 * 7' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn7 = Utils.ToUInt32(vch' offset + 4 * 7' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn1 = Utils.ToUInt32(bytes.Slice(4 * 1)' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn2 = Utils.ToUInt32(bytes.Slice(4 * 2)' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn2 = Utils.ToUInt32(bytes.Slice(4 * 2)' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn3 = Utils.ToUInt32(bytes.Slice(4 * 3)' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn3 = Utils.ToUInt32(bytes.Slice(4 * 3)' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn4 = Utils.ToUInt32(bytes.Slice(4 * 4)' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn4 = Utils.ToUInt32(bytes.Slice(4 * 4)' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn5 = Utils.ToUInt32(bytes.Slice(4 * 5)' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn5 = Utils.ToUInt32(bytes.Slice(4 * 5)' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn6 = Utils.ToUInt32(bytes.Slice(4 * 6)' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn6 = Utils.ToUInt32(bytes.Slice(4 * 6)' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn7 = Utils.ToUInt32(bytes.Slice(4 * 7)' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn7 = Utils.ToUInt32(bytes.Slice(4 * 7)' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: str = str.Substring(2);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn0 = Utils.ToUInt32(bytes' 4 * 0' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn1 = Utils.ToUInt32(bytes' 4 * 1' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn2 = Utils.ToUInt32(bytes' 4 * 2' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn2 = Utils.ToUInt32(bytes' 4 * 2' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn3 = Utils.ToUInt32(bytes' 4 * 3' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn3 = Utils.ToUInt32(bytes' 4 * 3' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn4 = Utils.ToUInt32(bytes' 4 * 4' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn4 = Utils.ToUInt32(bytes' 4 * 4' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn5 = Utils.ToUInt32(bytes' 4 * 5' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn5 = Utils.ToUInt32(bytes' 4 * 5' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn6 = Utils.ToUInt32(bytes' 4 * 6' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn6 = Utils.ToUInt32(bytes' 4 * 6' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn7 = Utils.ToUInt32(bytes' 4 * 7' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint256,The following statement contains a magic number: pn7 = Utils.ToUInt32(bytes' 4 * 7' true);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn0' true)' 0' output' 4 * 0' 4);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn0' true)' 0' output' 4 * 0' 4);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn1' true)' 0' output' 4 * 1' 4);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn1' true)' 0' output' 4 * 1' 4);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn2' true)' 0' output' 4 * 2' 4);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn2' true)' 0' output' 4 * 2' 4);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn2' true)' 0' output' 4 * 2' 4);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn3' true)' 0' output' 4 * 3' 4);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn3' true)' 0' output' 4 * 3' 4);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn3' true)' 0' output' 4 * 3' 4);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn4' true)' 0' output' 4 * 4' 4);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn4' true)' 0' output' 4 * 4' 4);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn4' true)' 0' output' 4 * 4' 4);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn5' true)' 0' output' 4 * 5' 4);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn5' true)' 0' output' 4 * 5' 4);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn5' true)' 0' output' 4 * 5' 4);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn6' true)' 0' output' 4 * 6' 4);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn6' true)' 0' output' 4 * 6' 4);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn6' true)' 0' output' 4 * 6' 4);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn7' true)' 0' output' 4 * 7' 4);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn7' true)' 0' output' 4 * 7' 4);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn7' true)' 0' output' 4 * 7' 4);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: output = output.Slice(4);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: output = output.Slice(4);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: output = output.Slice(4);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: output = output.Slice(4);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: output = output.Slice(4);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: output = output.Slice(4);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: output = output.Slice(4);
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,GetLow64,The following statement contains a magic number: return pn0 | (ulong)pn1 << 32;
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,GetHashCode,The following statement contains a magic number: int hash = 17;
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + (int)pn0;
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + (int)pn1;
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + (int)pn2;
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + (int)pn3;
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + (int)pn4;
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + (int)pn5;
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + (int)pn6;
Magic Number,NBitcoin,uint256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + (int)pn7;
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,TryParse,The following statement contains a magic number: hex = hex.Substring(2);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,TryParse,The following statement contains a magic number: hex.Length != WIDTH_BYTE * 2
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,GetByte,The following statement contains a magic number: switch (uintIndex)  			{  				case 0:  					value = pn0;  					break;  				case 1:  					value = pn1;  					break;  				case 2:  					value = pn2;  					break;  				case 3:  					value = pn3;  					break;  				case 4:  					value = pn4;  					break;  				default:  					throw new ArgumentOutOfRangeException("index");  			}
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,GetByte,The following statement contains a magic number: switch (uintIndex)  			{  				case 0:  					value = pn0;  					break;  				case 1:  					value = pn1;  					break;  				case 2:  					value = pn2;  					break;  				case 3:  					value = pn3;  					break;  				case 4:  					value = pn4;  					break;  				default:  					throw new ArgumentOutOfRangeException("index");  			}
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,GetByte,The following statement contains a magic number: switch (uintIndex)  			{  				case 0:  					value = pn0;  					break;  				case 1:  					value = pn1;  					break;  				case 2:  					value = pn2;  					break;  				case 3:  					value = pn3;  					break;  				case 4:  					value = pn4;  					break;  				default:  					throw new ArgumentOutOfRangeException("index");  			}
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,GetByte,The following statement contains a magic number: return (byte)(value >> (byteIndex * 8));
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint160,The following statement contains a magic number: pn1 = (uint)(b >> 32);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint160,The following statement contains a magic number: pn0 = Utils.ToUInt32(vch' 4 * 0' true);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint160,The following statement contains a magic number: pn1 = Utils.ToUInt32(vch' 4 * 1' true);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint160,The following statement contains a magic number: pn2 = Utils.ToUInt32(vch' 4 * 2' true);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint160,The following statement contains a magic number: pn2 = Utils.ToUInt32(vch' 4 * 2' true);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint160,The following statement contains a magic number: pn3 = Utils.ToUInt32(vch' 4 * 3' true);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint160,The following statement contains a magic number: pn3 = Utils.ToUInt32(vch' 4 * 3' true);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint160,The following statement contains a magic number: pn4 = Utils.ToUInt32(vch' 4 * 4' true);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint160,The following statement contains a magic number: pn4 = Utils.ToUInt32(vch' 4 * 4' true);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint160,The following statement contains a magic number: str = str.Substring(2);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint160,The following statement contains a magic number: pn0 = Utils.ToUInt32(bytes' 4 * 0' true);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint160,The following statement contains a magic number: pn1 = Utils.ToUInt32(bytes' 4 * 1' true);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint160,The following statement contains a magic number: pn2 = Utils.ToUInt32(bytes' 4 * 2' true);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint160,The following statement contains a magic number: pn2 = Utils.ToUInt32(bytes' 4 * 2' true);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint160,The following statement contains a magic number: pn3 = Utils.ToUInt32(bytes' 4 * 3' true);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint160,The following statement contains a magic number: pn3 = Utils.ToUInt32(bytes' 4 * 3' true);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint160,The following statement contains a magic number: pn4 = Utils.ToUInt32(bytes' 4 * 4' true);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,uint160,The following statement contains a magic number: pn4 = Utils.ToUInt32(bytes' 4 * 4' true);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn0' true)' 0' arr' 4 * 0' 4);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn0' true)' 0' arr' 4 * 0' 4);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn1' true)' 0' arr' 4 * 1' 4);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn1' true)' 0' arr' 4 * 1' 4);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn2' true)' 0' arr' 4 * 2' 4);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn2' true)' 0' arr' 4 * 2' 4);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn2' true)' 0' arr' 4 * 2' 4);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn3' true)' 0' arr' 4 * 3' 4);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn3' true)' 0' arr' 4 * 3' 4);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn3' true)' 0' arr' 4 * 3' 4);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn4' true)' 0' arr' 4 * 4' 4);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn4' true)' 0' arr' 4 * 4' 4);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,ToBytes,The following statement contains a magic number: Buffer.BlockCopy(Utils.ToBytes(pn4' true)' 0' arr' 4 * 4' 4);
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,GetLow64,The following statement contains a magic number: return pn0 | (ulong)pn1 << 32;
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,GetHashCode,The following statement contains a magic number: int hash = 17;
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + (int)pn0;
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + (int)pn1;
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + (int)pn2;
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + (int)pn3;
Magic Number,NBitcoin,uint160,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\UInt2561.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + (int)pn4;
Magic Number,NBitcoin,Extensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToUnixTimestamp,The following statement contains a magic number: return (int)Math.Truncate((value.ToUniversalTime().Subtract(new DateTime(1970' 1' 1))).TotalSeconds);
Magic Number,NBitcoin,Extensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,UnixTimestamp,The following statement contains a magic number: return (int)Math.Truncate((DateTime.UtcNow.Subtract(new DateTime(1970' 1' 1))).TotalSeconds);
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,MapToIPv6,The following statement contains a magic number: byte[] ipv6Bytes = new byte[16] {  			 0'0' 0'0' 0'0' 0'0' 0'0' 0xFF'0xFF'  			 ipv4Bytes [0]' ipv4Bytes [1]' ipv4Bytes [2]' ipv4Bytes [3]  			 };
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,MapToIPv6,The following statement contains a magic number: byte[] ipv6Bytes = new byte[16] {  			 0'0' 0'0' 0'0' 0'0' 0'0' 0xFF'0xFF'  			 ipv4Bytes [0]' ipv4Bytes [1]' ipv4Bytes [2]' ipv4Bytes [3]  			 };
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,MapToIPv6,The following statement contains a magic number: byte[] ipv6Bytes = new byte[16] {  			 0'0' 0'0' 0'0' 0'0' 0'0' 0xFF'0xFF'  			 ipv4Bytes [0]' ipv4Bytes [1]' ipv4Bytes [2]' ipv4Bytes [3]  			 };
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,MapToIPv4,The following statement contains a magic number: return new IPAddress(new[] { ipv6Bytes[12]' ipv6Bytes[13]' ipv6Bytes[14]' ipv6Bytes[15] });
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,MapToIPv4,The following statement contains a magic number: return new IPAddress(new[] { ipv6Bytes[12]' ipv6Bytes[13]' ipv6Bytes[14]' ipv6Bytes[15] });
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,MapToIPv4,The following statement contains a magic number: return new IPAddress(new[] { ipv6Bytes[12]' ipv6Bytes[13]' ipv6Bytes[14]' ipv6Bytes[15] });
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,MapToIPv4,The following statement contains a magic number: return new IPAddress(new[] { ipv6Bytes[12]' ipv6Bytes[13]' ipv6Bytes[14]' ipv6Bytes[15] });
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,IsIPv4MappedToIPv6,The following statement contains a magic number: i < 10
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,IsIPv4MappedToIPv6,The following statement contains a magic number: return bytes[10] == 0xFF && bytes[11] == 0xFF;
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,IsIPv4MappedToIPv6,The following statement contains a magic number: return bytes[10] == 0xFF && bytes[11] == 0xFF;
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ExceptionToString,The following statement contains a magic number: StringBuilder stringBuilder = new StringBuilder(128);
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToBytes,The following statement contains a magic number: return new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)'  				};
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToBytes,The following statement contains a magic number: return new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)'  				};
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToBytes,The following statement contains a magic number: return new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)'  				};
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToBytes,The following statement contains a magic number: output[1] = (byte)(value >> 8);
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToBytes,The following statement contains a magic number: output[2] = (byte)(value >> 16);
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToBytes,The following statement contains a magic number: output[2] = (byte)(value >> 16);
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToBytes,The following statement contains a magic number: output[3] = (byte)(value >> 24);
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToBytes,The following statement contains a magic number: output[3] = (byte)(value >> 24);
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToBytes,The following statement contains a magic number: return new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)'  					(byte)(value >> 32)'  					(byte)(value >> 40)'  					(byte)(value >> 48)'  					(byte)(value >> 56)'  				};
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToBytes,The following statement contains a magic number: return new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)'  					(byte)(value >> 32)'  					(byte)(value >> 40)'  					(byte)(value >> 48)'  					(byte)(value >> 56)'  				};
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToBytes,The following statement contains a magic number: return new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)'  					(byte)(value >> 32)'  					(byte)(value >> 40)'  					(byte)(value >> 48)'  					(byte)(value >> 56)'  				};
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToBytes,The following statement contains a magic number: return new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)'  					(byte)(value >> 32)'  					(byte)(value >> 40)'  					(byte)(value >> 48)'  					(byte)(value >> 56)'  				};
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToBytes,The following statement contains a magic number: return new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)'  					(byte)(value >> 32)'  					(byte)(value >> 40)'  					(byte)(value >> 48)'  					(byte)(value >> 56)'  				};
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToBytes,The following statement contains a magic number: return new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)'  					(byte)(value >> 32)'  					(byte)(value >> 40)'  					(byte)(value >> 48)'  					(byte)(value >> 56)'  				};
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToBytes,The following statement contains a magic number: return new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)'  					(byte)(value >> 32)'  					(byte)(value >> 40)'  					(byte)(value >> 48)'  					(byte)(value >> 56)'  				};
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToUInt32,The following statement contains a magic number: return value[index]  					   + ((uint)value[index + 1] << 8)  					   + ((uint)value[index + 2] << 16)  					   + ((uint)value[index + 3] << 24);
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToUInt32,The following statement contains a magic number: return value[index]  					   + ((uint)value[index + 1] << 8)  					   + ((uint)value[index + 2] << 16)  					   + ((uint)value[index + 3] << 24);
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToUInt32,The following statement contains a magic number: return value[index]  					   + ((uint)value[index + 1] << 8)  					   + ((uint)value[index + 2] << 16)  					   + ((uint)value[index + 3] << 24);
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToUInt32,The following statement contains a magic number: return value[index]  					   + ((uint)value[index + 1] << 8)  					   + ((uint)value[index + 2] << 16)  					   + ((uint)value[index + 3] << 24);
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToUInt32,The following statement contains a magic number: return value[index]  					   + ((uint)value[index + 1] << 8)  					   + ((uint)value[index + 2] << 16)  					   + ((uint)value[index + 3] << 24);
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToUInt32,The following statement contains a magic number: return value[0]  					   + ((uint)value[1] << 8)  					   + ((uint)value[2] << 16)  					   + ((uint)value[3] << 24);
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToUInt32,The following statement contains a magic number: return value[0]  					   + ((uint)value[1] << 8)  					   + ((uint)value[2] << 16)  					   + ((uint)value[3] << 24);
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToUInt32,The following statement contains a magic number: return value[0]  					   + ((uint)value[1] << 8)  					   + ((uint)value[2] << 16)  					   + ((uint)value[3] << 24);
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToUInt32,The following statement contains a magic number: return value[0]  					   + ((uint)value[1] << 8)  					   + ((uint)value[2] << 16)  					   + ((uint)value[3] << 24);
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToUInt32,The following statement contains a magic number: return value[0]  					   + ((uint)value[1] << 8)  					   + ((uint)value[2] << 16)  					   + ((uint)value[3] << 24);
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToUInt64,The following statement contains a magic number: return value[0]  					   + ((ulong)value[1] << 8)  					   + ((ulong)value[2] << 16)  					   + ((ulong)value[3] << 24)  					   + ((ulong)value[4] << 32)  					   + ((ulong)value[5] << 40)  					   + ((ulong)value[6] << 48)  					   + ((ulong)value[7] << 56);
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToUInt64,The following statement contains a magic number: return value[0]  					   + ((ulong)value[1] << 8)  					   + ((ulong)value[2] << 16)  					   + ((ulong)value[3] << 24)  					   + ((ulong)value[4] << 32)  					   + ((ulong)value[5] << 40)  					   + ((ulong)value[6] << 48)  					   + ((ulong)value[7] << 56);
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToUInt64,The following statement contains a magic number: return value[0]  					   + ((ulong)value[1] << 8)  					   + ((ulong)value[2] << 16)  					   + ((ulong)value[3] << 24)  					   + ((ulong)value[4] << 32)  					   + ((ulong)value[5] << 40)  					   + ((ulong)value[6] << 48)  					   + ((ulong)value[7] << 56);
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToUInt64,The following statement contains a magic number: return value[0]  					   + ((ulong)value[1] << 8)  					   + ((ulong)value[2] << 16)  					   + ((ulong)value[3] << 24)  					   + ((ulong)value[4] << 32)  					   + ((ulong)value[5] << 40)  					   + ((ulong)value[6] << 48)  					   + ((ulong)value[7] << 56);
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToUInt64,The following statement contains a magic number: return value[0]  					   + ((ulong)value[1] << 8)  					   + ((ulong)value[2] << 16)  					   + ((ulong)value[3] << 24)  					   + ((ulong)value[4] << 32)  					   + ((ulong)value[5] << 40)  					   + ((ulong)value[6] << 48)  					   + ((ulong)value[7] << 56);
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToUInt64,The following statement contains a magic number: return value[0]  					   + ((ulong)value[1] << 8)  					   + ((ulong)value[2] << 16)  					   + ((ulong)value[3] << 24)  					   + ((ulong)value[4] << 32)  					   + ((ulong)value[5] << 40)  					   + ((ulong)value[6] << 48)  					   + ((ulong)value[7] << 56);
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToUInt64,The following statement contains a magic number: return value[0]  					   + ((ulong)value[1] << 8)  					   + ((ulong)value[2] << 16)  					   + ((ulong)value[3] << 24)  					   + ((ulong)value[4] << 32)  					   + ((ulong)value[5] << 40)  					   + ((ulong)value[6] << 48)  					   + ((ulong)value[7] << 56);
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToUInt64,The following statement contains a magic number: return value[0]  					   + ((ulong)value[1] << 8)  					   + ((ulong)value[2] << 16)  					   + ((ulong)value[3] << 24)  					   + ((ulong)value[4] << 32)  					   + ((ulong)value[5] << 40)  					   + ((ulong)value[6] << 48)  					   + ((ulong)value[7] << 56);
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToUInt64,The following statement contains a magic number: return value[0]  					   + ((ulong)value[1] << 8)  					   + ((ulong)value[2] << 16)  					   + ((ulong)value[3] << 24)  					   + ((ulong)value[4] << 32)  					   + ((ulong)value[5] << 40)  					   + ((ulong)value[6] << 48)  					   + ((ulong)value[7] << 56);
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToUInt64,The following statement contains a magic number: return value[0]  					   + ((ulong)value[1] << 8)  					   + ((ulong)value[2] << 16)  					   + ((ulong)value[3] << 24)  					   + ((ulong)value[4] << 32)  					   + ((ulong)value[5] << 40)  					   + ((ulong)value[6] << 48)  					   + ((ulong)value[7] << 56);
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToUInt64,The following statement contains a magic number: return value[0]  					   + ((ulong)value[1] << 8)  					   + ((ulong)value[2] << 16)  					   + ((ulong)value[3] << 24)  					   + ((ulong)value[4] << 32)  					   + ((ulong)value[5] << 40)  					   + ((ulong)value[6] << 48)  					   + ((ulong)value[7] << 56);
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToUInt64,The following statement contains a magic number: return value[0]  					   + ((ulong)value[1] << 8)  					   + ((ulong)value[2] << 16)  					   + ((ulong)value[3] << 24)  					   + ((ulong)value[4] << 32)  					   + ((ulong)value[5] << 40)  					   + ((ulong)value[6] << 48)  					   + ((ulong)value[7] << 56);
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,ToUInt64,The following statement contains a magic number: return value[0]  					   + ((ulong)value[1] << 8)  					   + ((ulong)value[2] << 16)  					   + ((ulong)value[3] << 24)  					   + ((ulong)value[4] << 32)  					   + ((ulong)value[5] << 40)  					   + ((ulong)value[6] << 48)  					   + ((ulong)value[7] << 56);
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,GetHashCode,The following statement contains a magic number: int hash = 17;
Magic Number,NBitcoin,Utils,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Utils.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + array[i];
Magic Number,NBitcoin.BouncyCastle.Asn1,Asn1InputStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\Asn1InputStream.cs,Asn1InputStream,The following statement contains a magic number: this.tmpBuffers = new byte[16][];
Magic Number,NBitcoin.BouncyCastle.Asn1,Asn1InputStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\Asn1InputStream.cs,ReadTagNumber,The following statement contains a magic number: tagNo <<= 7;
Magic Number,NBitcoin.BouncyCastle.Asn1,Asn1InputStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\Asn1InputStream.cs,ReadLength,The following statement contains a magic number: size > 4
Magic Number,NBitcoin.BouncyCastle.Asn1,Asn1InputStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\Asn1InputStream.cs,ReadLength,The following statement contains a magic number: length = (length << 8) + next;
Magic Number,NBitcoin.BouncyCastle.Asn1,Asn1InputStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\Asn1InputStream.cs,ReadLength,The following statement contains a magic number: length > 127
Magic Number,NBitcoin.BouncyCastle.Asn1,Asn1Sequence,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\Asn1Sequence.cs,Asn1GetHashCode,The following statement contains a magic number: hc *= 17;
Magic Number,NBitcoin.BouncyCastle.Asn1,DerGenerator,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\DERGenerator.cs,WriteLength,The following statement contains a magic number: (val >>= 8) != 0
Magic Number,NBitcoin.BouncyCastle.Asn1,DerGenerator,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\DERGenerator.cs,WriteLength,The following statement contains a magic number: length > 127
Magic Number,NBitcoin.BouncyCastle.Asn1,DerObjectIdentifier,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\DerObjectIdentifier.cs,WriteField,The following statement contains a magic number: byte[] result = new byte[9];
Magic Number,NBitcoin.BouncyCastle.Asn1,DerObjectIdentifier,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\DerObjectIdentifier.cs,WriteField,The following statement contains a magic number: int pos = 8;
Magic Number,NBitcoin.BouncyCastle.Asn1,DerObjectIdentifier,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\DerObjectIdentifier.cs,WriteField,The following statement contains a magic number: fieldValue >>= 7;
Magic Number,NBitcoin.BouncyCastle.Asn1,DerObjectIdentifier,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\DerObjectIdentifier.cs,WriteField,The following statement contains a magic number: fieldValue >= (1L << 7)
Magic Number,NBitcoin.BouncyCastle.Asn1,DerObjectIdentifier,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\DerObjectIdentifier.cs,WriteField,The following statement contains a magic number: outputStream.Write(result' pos' 9 - pos);
Magic Number,NBitcoin.BouncyCastle.Asn1,DerObjectIdentifier,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\DerObjectIdentifier.cs,WriteField,The following statement contains a magic number: int byteCount = (fieldValue.BitLength + 6) / 7;
Magic Number,NBitcoin.BouncyCastle.Asn1,DerObjectIdentifier,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\DerObjectIdentifier.cs,WriteField,The following statement contains a magic number: int byteCount = (fieldValue.BitLength + 6) / 7;
Magic Number,NBitcoin.BouncyCastle.Asn1,DerObjectIdentifier,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\DerObjectIdentifier.cs,IsValidIdentifier,The following statement contains a magic number: identifier.Length < 3 || identifier[1] != '.'
Magic Number,NBitcoin.BouncyCastle.Asn1,DerObjectIdentifier,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\DerObjectIdentifier.cs,IsValidIdentifier,The following statement contains a magic number: return IsValidBranchID(identifier' 2);
Magic Number,NBitcoin.BouncyCastle.Asn1,DerObjectIdentifier,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\DerObjectIdentifier.cs,MakeOidStringFromBytes,The following statement contains a magic number: value < 40
Magic Number,NBitcoin.BouncyCastle.Asn1,DerOutputStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\DerOutputStream.cs,WriteLength,The following statement contains a magic number: (val >>= 8) != 0
Magic Number,NBitcoin.BouncyCastle.Asn1,DerOutputStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\DerOutputStream.cs,WriteLength,The following statement contains a magic number: length > 127
Magic Number,NBitcoin.BouncyCastle.Asn1,DerOutputStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\DerOutputStream.cs,WriteTag,The following statement contains a magic number: tagNo < 31
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp112r2Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: BigInteger h = BigInteger.ValueOf(4);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp128r2Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: BigInteger h = BigInteger.ValueOf(4);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp160k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: BigInteger b = BigInteger.ValueOf(7);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp160k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("9ba48cba5ebcb9b6bd33b92830b2a2e0e192f10a"' 16)'  					new BigInteger("c39c6c3b3a36d7701b9c71a1f5804ae5d0003f4"' 16)'  					new BigInteger[]{  						new BigInteger("9162fbe73984472a0a9e"' 16)'  						new BigInteger("-96341f1138933bc2f505"' 16) }'  					new BigInteger[]{  						new BigInteger("127971af8721782ecffa3"' 16)'  						new BigInteger("9162fbe73984472a0a9e"' 16) }'  					new BigInteger("9162fbe73984472a0a9d0590"' 16)'  					new BigInteger("96341f1138933bc2f503fd44"' 16)'  					176);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp160k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("9ba48cba5ebcb9b6bd33b92830b2a2e0e192f10a"' 16)'  					new BigInteger("c39c6c3b3a36d7701b9c71a1f5804ae5d0003f4"' 16)'  					new BigInteger[]{  						new BigInteger("9162fbe73984472a0a9e"' 16)'  						new BigInteger("-96341f1138933bc2f505"' 16) }'  					new BigInteger[]{  						new BigInteger("127971af8721782ecffa3"' 16)'  						new BigInteger("9162fbe73984472a0a9e"' 16) }'  					new BigInteger("9162fbe73984472a0a9d0590"' 16)'  					new BigInteger("96341f1138933bc2f503fd44"' 16)'  					176);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp160k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("9ba48cba5ebcb9b6bd33b92830b2a2e0e192f10a"' 16)'  					new BigInteger("c39c6c3b3a36d7701b9c71a1f5804ae5d0003f4"' 16)'  					new BigInteger[]{  						new BigInteger("9162fbe73984472a0a9e"' 16)'  						new BigInteger("-96341f1138933bc2f505"' 16) }'  					new BigInteger[]{  						new BigInteger("127971af8721782ecffa3"' 16)'  						new BigInteger("9162fbe73984472a0a9e"' 16) }'  					new BigInteger("9162fbe73984472a0a9d0590"' 16)'  					new BigInteger("96341f1138933bc2f503fd44"' 16)'  					176);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp160k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("9ba48cba5ebcb9b6bd33b92830b2a2e0e192f10a"' 16)'  					new BigInteger("c39c6c3b3a36d7701b9c71a1f5804ae5d0003f4"' 16)'  					new BigInteger[]{  						new BigInteger("9162fbe73984472a0a9e"' 16)'  						new BigInteger("-96341f1138933bc2f505"' 16) }'  					new BigInteger[]{  						new BigInteger("127971af8721782ecffa3"' 16)'  						new BigInteger("9162fbe73984472a0a9e"' 16) }'  					new BigInteger("9162fbe73984472a0a9d0590"' 16)'  					new BigInteger("96341f1138933bc2f503fd44"' 16)'  					176);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp160k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("9ba48cba5ebcb9b6bd33b92830b2a2e0e192f10a"' 16)'  					new BigInteger("c39c6c3b3a36d7701b9c71a1f5804ae5d0003f4"' 16)'  					new BigInteger[]{  						new BigInteger("9162fbe73984472a0a9e"' 16)'  						new BigInteger("-96341f1138933bc2f505"' 16) }'  					new BigInteger[]{  						new BigInteger("127971af8721782ecffa3"' 16)'  						new BigInteger("9162fbe73984472a0a9e"' 16) }'  					new BigInteger("9162fbe73984472a0a9d0590"' 16)'  					new BigInteger("96341f1138933bc2f503fd44"' 16)'  					176);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp160k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("9ba48cba5ebcb9b6bd33b92830b2a2e0e192f10a"' 16)'  					new BigInteger("c39c6c3b3a36d7701b9c71a1f5804ae5d0003f4"' 16)'  					new BigInteger[]{  						new BigInteger("9162fbe73984472a0a9e"' 16)'  						new BigInteger("-96341f1138933bc2f505"' 16) }'  					new BigInteger[]{  						new BigInteger("127971af8721782ecffa3"' 16)'  						new BigInteger("9162fbe73984472a0a9e"' 16) }'  					new BigInteger("9162fbe73984472a0a9d0590"' 16)'  					new BigInteger("96341f1138933bc2f503fd44"' 16)'  					176);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp160k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("9ba48cba5ebcb9b6bd33b92830b2a2e0e192f10a"' 16)'  					new BigInteger("c39c6c3b3a36d7701b9c71a1f5804ae5d0003f4"' 16)'  					new BigInteger[]{  						new BigInteger("9162fbe73984472a0a9e"' 16)'  						new BigInteger("-96341f1138933bc2f505"' 16) }'  					new BigInteger[]{  						new BigInteger("127971af8721782ecffa3"' 16)'  						new BigInteger("9162fbe73984472a0a9e"' 16) }'  					new BigInteger("9162fbe73984472a0a9d0590"' 16)'  					new BigInteger("96341f1138933bc2f503fd44"' 16)'  					176);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp160k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("9ba48cba5ebcb9b6bd33b92830b2a2e0e192f10a"' 16)'  					new BigInteger("c39c6c3b3a36d7701b9c71a1f5804ae5d0003f4"' 16)'  					new BigInteger[]{  						new BigInteger("9162fbe73984472a0a9e"' 16)'  						new BigInteger("-96341f1138933bc2f505"' 16) }'  					new BigInteger[]{  						new BigInteger("127971af8721782ecffa3"' 16)'  						new BigInteger("9162fbe73984472a0a9e"' 16) }'  					new BigInteger("9162fbe73984472a0a9d0590"' 16)'  					new BigInteger("96341f1138933bc2f503fd44"' 16)'  					176);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp160k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("9ba48cba5ebcb9b6bd33b92830b2a2e0e192f10a"' 16)'  					new BigInteger("c39c6c3b3a36d7701b9c71a1f5804ae5d0003f4"' 16)'  					new BigInteger[]{  						new BigInteger("9162fbe73984472a0a9e"' 16)'  						new BigInteger("-96341f1138933bc2f505"' 16) }'  					new BigInteger[]{  						new BigInteger("127971af8721782ecffa3"' 16)'  						new BigInteger("9162fbe73984472a0a9e"' 16) }'  					new BigInteger("9162fbe73984472a0a9d0590"' 16)'  					new BigInteger("96341f1138933bc2f503fd44"' 16)'  					176);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp192k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: BigInteger b = BigInteger.ValueOf(3);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp192k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("bb85691939b869c1d087f601554b96b80cb4f55b35f433c2"' 16)'  					new BigInteger("3d84f26c12238d7b4f3d516613c1759033b1a5800175d0b1"' 16)'  					new BigInteger[]{  						new BigInteger("71169be7330b3038edb025f1"' 16)'  						new BigInteger("-b3fb3400dec5c4adceb8655c"' 16) }'  					new BigInteger[]{  						new BigInteger("12511cfe811d0f4e6bc688b4d"' 16)'  						new BigInteger("71169be7330b3038edb025f1"' 16) }'  					new BigInteger("71169be7330b3038edb025f1d0f9"' 16)'  					new BigInteger("b3fb3400dec5c4adceb8655d4c94"' 16)'  					208);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp192k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("bb85691939b869c1d087f601554b96b80cb4f55b35f433c2"' 16)'  					new BigInteger("3d84f26c12238d7b4f3d516613c1759033b1a5800175d0b1"' 16)'  					new BigInteger[]{  						new BigInteger("71169be7330b3038edb025f1"' 16)'  						new BigInteger("-b3fb3400dec5c4adceb8655c"' 16) }'  					new BigInteger[]{  						new BigInteger("12511cfe811d0f4e6bc688b4d"' 16)'  						new BigInteger("71169be7330b3038edb025f1"' 16) }'  					new BigInteger("71169be7330b3038edb025f1d0f9"' 16)'  					new BigInteger("b3fb3400dec5c4adceb8655d4c94"' 16)'  					208);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp192k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("bb85691939b869c1d087f601554b96b80cb4f55b35f433c2"' 16)'  					new BigInteger("3d84f26c12238d7b4f3d516613c1759033b1a5800175d0b1"' 16)'  					new BigInteger[]{  						new BigInteger("71169be7330b3038edb025f1"' 16)'  						new BigInteger("-b3fb3400dec5c4adceb8655c"' 16) }'  					new BigInteger[]{  						new BigInteger("12511cfe811d0f4e6bc688b4d"' 16)'  						new BigInteger("71169be7330b3038edb025f1"' 16) }'  					new BigInteger("71169be7330b3038edb025f1d0f9"' 16)'  					new BigInteger("b3fb3400dec5c4adceb8655d4c94"' 16)'  					208);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp192k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("bb85691939b869c1d087f601554b96b80cb4f55b35f433c2"' 16)'  					new BigInteger("3d84f26c12238d7b4f3d516613c1759033b1a5800175d0b1"' 16)'  					new BigInteger[]{  						new BigInteger("71169be7330b3038edb025f1"' 16)'  						new BigInteger("-b3fb3400dec5c4adceb8655c"' 16) }'  					new BigInteger[]{  						new BigInteger("12511cfe811d0f4e6bc688b4d"' 16)'  						new BigInteger("71169be7330b3038edb025f1"' 16) }'  					new BigInteger("71169be7330b3038edb025f1d0f9"' 16)'  					new BigInteger("b3fb3400dec5c4adceb8655d4c94"' 16)'  					208);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp192k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("bb85691939b869c1d087f601554b96b80cb4f55b35f433c2"' 16)'  					new BigInteger("3d84f26c12238d7b4f3d516613c1759033b1a5800175d0b1"' 16)'  					new BigInteger[]{  						new BigInteger("71169be7330b3038edb025f1"' 16)'  						new BigInteger("-b3fb3400dec5c4adceb8655c"' 16) }'  					new BigInteger[]{  						new BigInteger("12511cfe811d0f4e6bc688b4d"' 16)'  						new BigInteger("71169be7330b3038edb025f1"' 16) }'  					new BigInteger("71169be7330b3038edb025f1d0f9"' 16)'  					new BigInteger("b3fb3400dec5c4adceb8655d4c94"' 16)'  					208);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp192k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("bb85691939b869c1d087f601554b96b80cb4f55b35f433c2"' 16)'  					new BigInteger("3d84f26c12238d7b4f3d516613c1759033b1a5800175d0b1"' 16)'  					new BigInteger[]{  						new BigInteger("71169be7330b3038edb025f1"' 16)'  						new BigInteger("-b3fb3400dec5c4adceb8655c"' 16) }'  					new BigInteger[]{  						new BigInteger("12511cfe811d0f4e6bc688b4d"' 16)'  						new BigInteger("71169be7330b3038edb025f1"' 16) }'  					new BigInteger("71169be7330b3038edb025f1d0f9"' 16)'  					new BigInteger("b3fb3400dec5c4adceb8655d4c94"' 16)'  					208);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp192k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("bb85691939b869c1d087f601554b96b80cb4f55b35f433c2"' 16)'  					new BigInteger("3d84f26c12238d7b4f3d516613c1759033b1a5800175d0b1"' 16)'  					new BigInteger[]{  						new BigInteger("71169be7330b3038edb025f1"' 16)'  						new BigInteger("-b3fb3400dec5c4adceb8655c"' 16) }'  					new BigInteger[]{  						new BigInteger("12511cfe811d0f4e6bc688b4d"' 16)'  						new BigInteger("71169be7330b3038edb025f1"' 16) }'  					new BigInteger("71169be7330b3038edb025f1d0f9"' 16)'  					new BigInteger("b3fb3400dec5c4adceb8655d4c94"' 16)'  					208);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp192k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("bb85691939b869c1d087f601554b96b80cb4f55b35f433c2"' 16)'  					new BigInteger("3d84f26c12238d7b4f3d516613c1759033b1a5800175d0b1"' 16)'  					new BigInteger[]{  						new BigInteger("71169be7330b3038edb025f1"' 16)'  						new BigInteger("-b3fb3400dec5c4adceb8655c"' 16) }'  					new BigInteger[]{  						new BigInteger("12511cfe811d0f4e6bc688b4d"' 16)'  						new BigInteger("71169be7330b3038edb025f1"' 16) }'  					new BigInteger("71169be7330b3038edb025f1d0f9"' 16)'  					new BigInteger("b3fb3400dec5c4adceb8655d4c94"' 16)'  					208);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp192k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("bb85691939b869c1d087f601554b96b80cb4f55b35f433c2"' 16)'  					new BigInteger("3d84f26c12238d7b4f3d516613c1759033b1a5800175d0b1"' 16)'  					new BigInteger[]{  						new BigInteger("71169be7330b3038edb025f1"' 16)'  						new BigInteger("-b3fb3400dec5c4adceb8655c"' 16) }'  					new BigInteger[]{  						new BigInteger("12511cfe811d0f4e6bc688b4d"' 16)'  						new BigInteger("71169be7330b3038edb025f1"' 16) }'  					new BigInteger("71169be7330b3038edb025f1d0f9"' 16)'  					new BigInteger("b3fb3400dec5c4adceb8655d4c94"' 16)'  					208);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp224k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: BigInteger b = BigInteger.ValueOf(5);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp224k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("fe0e87005b4e83761908c5131d552a850b3f58b749c37cf5b84d6768"' 16)'  					new BigInteger("60dcd2104c4cbc0be6eeefc2bdd610739ec34e317f9b33046c9e4788"' 16)'  					new BigInteger[]{  						new BigInteger("6b8cf07d4ca75c88957d9d670591"' 16)'  						new BigInteger("-b8adf1378a6eb73409fa6c9c637d"' 16) }'  					new BigInteger[]{  						new BigInteger("1243ae1b4d71613bc9f780a03690e"' 16)'  						new BigInteger("6b8cf07d4ca75c88957d9d670591"' 16) }'  					new BigInteger("6b8cf07d4ca75c88957d9d67059037a4"' 16)'  					new BigInteger("b8adf1378a6eb73409fa6c9c637ba7f5"' 16)'  					240);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp224k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("fe0e87005b4e83761908c5131d552a850b3f58b749c37cf5b84d6768"' 16)'  					new BigInteger("60dcd2104c4cbc0be6eeefc2bdd610739ec34e317f9b33046c9e4788"' 16)'  					new BigInteger[]{  						new BigInteger("6b8cf07d4ca75c88957d9d670591"' 16)'  						new BigInteger("-b8adf1378a6eb73409fa6c9c637d"' 16) }'  					new BigInteger[]{  						new BigInteger("1243ae1b4d71613bc9f780a03690e"' 16)'  						new BigInteger("6b8cf07d4ca75c88957d9d670591"' 16) }'  					new BigInteger("6b8cf07d4ca75c88957d9d67059037a4"' 16)'  					new BigInteger("b8adf1378a6eb73409fa6c9c637ba7f5"' 16)'  					240);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp224k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("fe0e87005b4e83761908c5131d552a850b3f58b749c37cf5b84d6768"' 16)'  					new BigInteger("60dcd2104c4cbc0be6eeefc2bdd610739ec34e317f9b33046c9e4788"' 16)'  					new BigInteger[]{  						new BigInteger("6b8cf07d4ca75c88957d9d670591"' 16)'  						new BigInteger("-b8adf1378a6eb73409fa6c9c637d"' 16) }'  					new BigInteger[]{  						new BigInteger("1243ae1b4d71613bc9f780a03690e"' 16)'  						new BigInteger("6b8cf07d4ca75c88957d9d670591"' 16) }'  					new BigInteger("6b8cf07d4ca75c88957d9d67059037a4"' 16)'  					new BigInteger("b8adf1378a6eb73409fa6c9c637ba7f5"' 16)'  					240);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp224k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("fe0e87005b4e83761908c5131d552a850b3f58b749c37cf5b84d6768"' 16)'  					new BigInteger("60dcd2104c4cbc0be6eeefc2bdd610739ec34e317f9b33046c9e4788"' 16)'  					new BigInteger[]{  						new BigInteger("6b8cf07d4ca75c88957d9d670591"' 16)'  						new BigInteger("-b8adf1378a6eb73409fa6c9c637d"' 16) }'  					new BigInteger[]{  						new BigInteger("1243ae1b4d71613bc9f780a03690e"' 16)'  						new BigInteger("6b8cf07d4ca75c88957d9d670591"' 16) }'  					new BigInteger("6b8cf07d4ca75c88957d9d67059037a4"' 16)'  					new BigInteger("b8adf1378a6eb73409fa6c9c637ba7f5"' 16)'  					240);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp224k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("fe0e87005b4e83761908c5131d552a850b3f58b749c37cf5b84d6768"' 16)'  					new BigInteger("60dcd2104c4cbc0be6eeefc2bdd610739ec34e317f9b33046c9e4788"' 16)'  					new BigInteger[]{  						new BigInteger("6b8cf07d4ca75c88957d9d670591"' 16)'  						new BigInteger("-b8adf1378a6eb73409fa6c9c637d"' 16) }'  					new BigInteger[]{  						new BigInteger("1243ae1b4d71613bc9f780a03690e"' 16)'  						new BigInteger("6b8cf07d4ca75c88957d9d670591"' 16) }'  					new BigInteger("6b8cf07d4ca75c88957d9d67059037a4"' 16)'  					new BigInteger("b8adf1378a6eb73409fa6c9c637ba7f5"' 16)'  					240);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp224k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("fe0e87005b4e83761908c5131d552a850b3f58b749c37cf5b84d6768"' 16)'  					new BigInteger("60dcd2104c4cbc0be6eeefc2bdd610739ec34e317f9b33046c9e4788"' 16)'  					new BigInteger[]{  						new BigInteger("6b8cf07d4ca75c88957d9d670591"' 16)'  						new BigInteger("-b8adf1378a6eb73409fa6c9c637d"' 16) }'  					new BigInteger[]{  						new BigInteger("1243ae1b4d71613bc9f780a03690e"' 16)'  						new BigInteger("6b8cf07d4ca75c88957d9d670591"' 16) }'  					new BigInteger("6b8cf07d4ca75c88957d9d67059037a4"' 16)'  					new BigInteger("b8adf1378a6eb73409fa6c9c637ba7f5"' 16)'  					240);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp224k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("fe0e87005b4e83761908c5131d552a850b3f58b749c37cf5b84d6768"' 16)'  					new BigInteger("60dcd2104c4cbc0be6eeefc2bdd610739ec34e317f9b33046c9e4788"' 16)'  					new BigInteger[]{  						new BigInteger("6b8cf07d4ca75c88957d9d670591"' 16)'  						new BigInteger("-b8adf1378a6eb73409fa6c9c637d"' 16) }'  					new BigInteger[]{  						new BigInteger("1243ae1b4d71613bc9f780a03690e"' 16)'  						new BigInteger("6b8cf07d4ca75c88957d9d670591"' 16) }'  					new BigInteger("6b8cf07d4ca75c88957d9d67059037a4"' 16)'  					new BigInteger("b8adf1378a6eb73409fa6c9c637ba7f5"' 16)'  					240);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp224k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("fe0e87005b4e83761908c5131d552a850b3f58b749c37cf5b84d6768"' 16)'  					new BigInteger("60dcd2104c4cbc0be6eeefc2bdd610739ec34e317f9b33046c9e4788"' 16)'  					new BigInteger[]{  						new BigInteger("6b8cf07d4ca75c88957d9d670591"' 16)'  						new BigInteger("-b8adf1378a6eb73409fa6c9c637d"' 16) }'  					new BigInteger[]{  						new BigInteger("1243ae1b4d71613bc9f780a03690e"' 16)'  						new BigInteger("6b8cf07d4ca75c88957d9d670591"' 16) }'  					new BigInteger("6b8cf07d4ca75c88957d9d67059037a4"' 16)'  					new BigInteger("b8adf1378a6eb73409fa6c9c637ba7f5"' 16)'  					240);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp224k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("fe0e87005b4e83761908c5131d552a850b3f58b749c37cf5b84d6768"' 16)'  					new BigInteger("60dcd2104c4cbc0be6eeefc2bdd610739ec34e317f9b33046c9e4788"' 16)'  					new BigInteger[]{  						new BigInteger("6b8cf07d4ca75c88957d9d670591"' 16)'  						new BigInteger("-b8adf1378a6eb73409fa6c9c637d"' 16) }'  					new BigInteger[]{  						new BigInteger("1243ae1b4d71613bc9f780a03690e"' 16)'  						new BigInteger("6b8cf07d4ca75c88957d9d670591"' 16) }'  					new BigInteger("6b8cf07d4ca75c88957d9d67059037a4"' 16)'  					new BigInteger("b8adf1378a6eb73409fa6c9c637ba7f5"' 16)'  					240);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp256k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: BigInteger b = BigInteger.ValueOf(7);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp256k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"' 16)'  					new BigInteger("5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72"' 16)'  					new BigInteger[]{  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16)'  						new BigInteger("-e4437ed6010e88286f547fa90abfe4c3"' 16) }'  					new BigInteger[]{  						new BigInteger("114ca50f7a8e2f3f657c1108d9d44cfd8"' 16)'  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16) }'  					new BigInteger("3086d221a7d46bcde86c90e49284eb153dab"' 16)'  					new BigInteger("e4437ed6010e88286f547fa90abfe4c42212"' 16)'  					272);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp256k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"' 16)'  					new BigInteger("5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72"' 16)'  					new BigInteger[]{  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16)'  						new BigInteger("-e4437ed6010e88286f547fa90abfe4c3"' 16) }'  					new BigInteger[]{  						new BigInteger("114ca50f7a8e2f3f657c1108d9d44cfd8"' 16)'  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16) }'  					new BigInteger("3086d221a7d46bcde86c90e49284eb153dab"' 16)'  					new BigInteger("e4437ed6010e88286f547fa90abfe4c42212"' 16)'  					272);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp256k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"' 16)'  					new BigInteger("5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72"' 16)'  					new BigInteger[]{  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16)'  						new BigInteger("-e4437ed6010e88286f547fa90abfe4c3"' 16) }'  					new BigInteger[]{  						new BigInteger("114ca50f7a8e2f3f657c1108d9d44cfd8"' 16)'  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16) }'  					new BigInteger("3086d221a7d46bcde86c90e49284eb153dab"' 16)'  					new BigInteger("e4437ed6010e88286f547fa90abfe4c42212"' 16)'  					272);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp256k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"' 16)'  					new BigInteger("5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72"' 16)'  					new BigInteger[]{  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16)'  						new BigInteger("-e4437ed6010e88286f547fa90abfe4c3"' 16) }'  					new BigInteger[]{  						new BigInteger("114ca50f7a8e2f3f657c1108d9d44cfd8"' 16)'  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16) }'  					new BigInteger("3086d221a7d46bcde86c90e49284eb153dab"' 16)'  					new BigInteger("e4437ed6010e88286f547fa90abfe4c42212"' 16)'  					272);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp256k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"' 16)'  					new BigInteger("5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72"' 16)'  					new BigInteger[]{  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16)'  						new BigInteger("-e4437ed6010e88286f547fa90abfe4c3"' 16) }'  					new BigInteger[]{  						new BigInteger("114ca50f7a8e2f3f657c1108d9d44cfd8"' 16)'  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16) }'  					new BigInteger("3086d221a7d46bcde86c90e49284eb153dab"' 16)'  					new BigInteger("e4437ed6010e88286f547fa90abfe4c42212"' 16)'  					272);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp256k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"' 16)'  					new BigInteger("5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72"' 16)'  					new BigInteger[]{  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16)'  						new BigInteger("-e4437ed6010e88286f547fa90abfe4c3"' 16) }'  					new BigInteger[]{  						new BigInteger("114ca50f7a8e2f3f657c1108d9d44cfd8"' 16)'  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16) }'  					new BigInteger("3086d221a7d46bcde86c90e49284eb153dab"' 16)'  					new BigInteger("e4437ed6010e88286f547fa90abfe4c42212"' 16)'  					272);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp256k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"' 16)'  					new BigInteger("5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72"' 16)'  					new BigInteger[]{  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16)'  						new BigInteger("-e4437ed6010e88286f547fa90abfe4c3"' 16) }'  					new BigInteger[]{  						new BigInteger("114ca50f7a8e2f3f657c1108d9d44cfd8"' 16)'  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16) }'  					new BigInteger("3086d221a7d46bcde86c90e49284eb153dab"' 16)'  					new BigInteger("e4437ed6010e88286f547fa90abfe4c42212"' 16)'  					272);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp256k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"' 16)'  					new BigInteger("5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72"' 16)'  					new BigInteger[]{  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16)'  						new BigInteger("-e4437ed6010e88286f547fa90abfe4c3"' 16) }'  					new BigInteger[]{  						new BigInteger("114ca50f7a8e2f3f657c1108d9d44cfd8"' 16)'  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16) }'  					new BigInteger("3086d221a7d46bcde86c90e49284eb153dab"' 16)'  					new BigInteger("e4437ed6010e88286f547fa90abfe4c42212"' 16)'  					272);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Secp256k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"' 16)'  					new BigInteger("5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72"' 16)'  					new BigInteger[]{  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16)'  						new BigInteger("-e4437ed6010e88286f547fa90abfe4c3"' 16) }'  					new BigInteger[]{  						new BigInteger("114ca50f7a8e2f3f657c1108d9d44cfd8"' 16)'  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16) }'  					new BigInteger("3086d221a7d46bcde86c90e49284eb153dab"' 16)'  					new BigInteger("e4437ed6010e88286f547fa90abfe4c42212"' 16)'  					272);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Sect113r1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: BigInteger h = BigInteger.ValueOf(2);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Sect113r2Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: BigInteger h = BigInteger.ValueOf(2);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Sect131r1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: BigInteger h = BigInteger.ValueOf(2);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Sect131r2Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: BigInteger h = BigInteger.ValueOf(2);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Sect163k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: BigInteger h = BigInteger.ValueOf(2);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Sect163r1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: BigInteger h = BigInteger.ValueOf(2);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Sect163r2Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: BigInteger h = BigInteger.ValueOf(2);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Sect193r1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: BigInteger h = BigInteger.ValueOf(2);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Sect193r2Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: BigInteger h = BigInteger.ValueOf(2);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Sect233k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: BigInteger h = BigInteger.ValueOf(4);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Sect233r1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: BigInteger h = BigInteger.ValueOf(2);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Sect239k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: BigInteger h = BigInteger.ValueOf(4);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Sect283k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: BigInteger h = BigInteger.ValueOf(4);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Sect283r1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: BigInteger h = BigInteger.ValueOf(2);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Sect409k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: BigInteger h = BigInteger.ValueOf(4);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Sect409r1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: BigInteger h = BigInteger.ValueOf(2);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Sect571k1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: BigInteger h = BigInteger.ValueOf(4);
Magic Number,NBitcoin.BouncyCastle.Asn1.Sec,Sect571r1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\sec\SECNamedCurves.cs,CreateParameters,The following statement contains a magic number: BigInteger h = BigInteger.ValueOf(2);
Magic Number,NBitcoin.BouncyCastle.Asn1.X9,X9IntegerConverter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\x9\X9IntegerConverter.cs,GetByteLength,The following statement contains a magic number: return (fe.FieldSize + 7) / 8;
Magic Number,NBitcoin.BouncyCastle.Asn1.X9,X9IntegerConverter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\x9\X9IntegerConverter.cs,GetByteLength,The following statement contains a magic number: return (fe.FieldSize + 7) / 8;
Magic Number,NBitcoin.BouncyCastle.Asn1.X9,X9IntegerConverter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\x9\X9IntegerConverter.cs,GetByteLength,The following statement contains a magic number: return (c.FieldSize + 7) / 8;
Magic Number,NBitcoin.BouncyCastle.Asn1.X9,X9IntegerConverter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\x9\X9IntegerConverter.cs,GetByteLength,The following statement contains a magic number: return (c.FieldSize + 7) / 8;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,GeneralDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\GeneralDigest.cs,GeneralDigest,The following statement contains a magic number: xBuf = new byte[4];
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,GeneralDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\GeneralDigest.cs,BlockUpdate,The following statement contains a magic number: xBufOff == 4
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,GeneralDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\GeneralDigest.cs,BlockUpdate,The following statement contains a magic number: int limit = ((length - i) & ~3) + i;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,GeneralDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\GeneralDigest.cs,Finish,The following statement contains a magic number: long bitLength = (byteCount << 3);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,GeneralDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\GeneralDigest.cs,Finish,The following statement contains a magic number: Update((byte)128);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,LongDigest,The following statement contains a magic number: xBuf = new byte[8];
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,Finish,The following statement contains a magic number: long lowBitLength = byteCount1 << 3;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,Finish,The following statement contains a magic number: Update((byte)128);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,ProcessWord,The following statement contains a magic number: ++wOff == 16
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,AdjustByteCounts,The following statement contains a magic number: byteCount2 += (long)((ulong)byteCount1 >> 61);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,ProcessLength,The following statement contains a magic number: wOff > 14
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,ProcessLength,The following statement contains a magic number: W[14] = (ulong)hiW;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,ProcessLength,The following statement contains a magic number: W[15] = (ulong)lowW;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,ProcessBlock,The following statement contains a magic number: W[ti] = Sigma1(W[ti - 2]) + W[ti - 7] + Sigma0(W[ti - 15]) + W[ti - 16];
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,ProcessBlock,The following statement contains a magic number: W[ti] = Sigma1(W[ti - 2]) + W[ti - 7] + Sigma0(W[ti - 15]) + W[ti - 16];
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,ProcessBlock,The following statement contains a magic number: W[ti] = Sigma1(W[ti - 2]) + W[ti - 7] + Sigma0(W[ti - 15]) + W[ti - 16];
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,ProcessBlock,The following statement contains a magic number: W[ti] = Sigma1(W[ti - 2]) + W[ti - 7] + Sigma0(W[ti - 15]) + W[ti - 16];
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,ProcessBlock,The following statement contains a magic number: ti <= 79
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,ProcessBlock,The following statement contains a magic number: i < 10
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,ProcessBlock,The following statement contains a magic number: Array.Clear(W' 0' 16);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,Sum0,The following statement contains a magic number: return ((x << 36) | (x >> 28)) ^ ((x << 30) | (x >> 34)) ^ ((x << 25) | (x >> 39));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,Sum0,The following statement contains a magic number: return ((x << 36) | (x >> 28)) ^ ((x << 30) | (x >> 34)) ^ ((x << 25) | (x >> 39));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,Sum0,The following statement contains a magic number: return ((x << 36) | (x >> 28)) ^ ((x << 30) | (x >> 34)) ^ ((x << 25) | (x >> 39));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,Sum0,The following statement contains a magic number: return ((x << 36) | (x >> 28)) ^ ((x << 30) | (x >> 34)) ^ ((x << 25) | (x >> 39));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,Sum0,The following statement contains a magic number: return ((x << 36) | (x >> 28)) ^ ((x << 30) | (x >> 34)) ^ ((x << 25) | (x >> 39));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,Sum0,The following statement contains a magic number: return ((x << 36) | (x >> 28)) ^ ((x << 30) | (x >> 34)) ^ ((x << 25) | (x >> 39));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,Sum1,The following statement contains a magic number: return ((x << 50) | (x >> 14)) ^ ((x << 46) | (x >> 18)) ^ ((x << 23) | (x >> 41));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,Sum1,The following statement contains a magic number: return ((x << 50) | (x >> 14)) ^ ((x << 46) | (x >> 18)) ^ ((x << 23) | (x >> 41));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,Sum1,The following statement contains a magic number: return ((x << 50) | (x >> 14)) ^ ((x << 46) | (x >> 18)) ^ ((x << 23) | (x >> 41));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,Sum1,The following statement contains a magic number: return ((x << 50) | (x >> 14)) ^ ((x << 46) | (x >> 18)) ^ ((x << 23) | (x >> 41));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,Sum1,The following statement contains a magic number: return ((x << 50) | (x >> 14)) ^ ((x << 46) | (x >> 18)) ^ ((x << 23) | (x >> 41));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,Sum1,The following statement contains a magic number: return ((x << 50) | (x >> 14)) ^ ((x << 46) | (x >> 18)) ^ ((x << 23) | (x >> 41));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,Sigma0,The following statement contains a magic number: return ((x << 63) | (x >> 1)) ^ ((x << 56) | (x >> 8)) ^ (x >> 7);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,Sigma0,The following statement contains a magic number: return ((x << 63) | (x >> 1)) ^ ((x << 56) | (x >> 8)) ^ (x >> 7);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,Sigma0,The following statement contains a magic number: return ((x << 63) | (x >> 1)) ^ ((x << 56) | (x >> 8)) ^ (x >> 7);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,Sigma0,The following statement contains a magic number: return ((x << 63) | (x >> 1)) ^ ((x << 56) | (x >> 8)) ^ (x >> 7);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,Sigma1,The following statement contains a magic number: return ((x << 45) | (x >> 19)) ^ ((x << 3) | (x >> 61)) ^ (x >> 6);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,Sigma1,The following statement contains a magic number: return ((x << 45) | (x >> 19)) ^ ((x << 3) | (x >> 61)) ^ (x >> 6);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,Sigma1,The following statement contains a magic number: return ((x << 45) | (x >> 19)) ^ ((x << 3) | (x >> 61)) ^ (x >> 6);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,Sigma1,The following statement contains a magic number: return ((x << 45) | (x >> 19)) ^ ((x << 3) | (x >> 61)) ^ (x >> 6);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,LongDigest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\LongDigest.cs,Sigma1,The following statement contains a magic number: return ((x << 45) | (x >> 19)) ^ ((x << 3) | (x >> 61)) ^ (x >> 6);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessWord,The following statement contains a magic number: X[xOff++] = (input[inOff] & 0xff) | ((input[inOff + 1] & 0xff) << 8) 				| ((input[inOff + 2] & 0xff) << 16) | ((input[inOff + 3] & 0xff) << 24);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessWord,The following statement contains a magic number: X[xOff++] = (input[inOff] & 0xff) | ((input[inOff + 1] & 0xff) << 8) 				| ((input[inOff + 2] & 0xff) << 16) | ((input[inOff + 3] & 0xff) << 24);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessWord,The following statement contains a magic number: X[xOff++] = (input[inOff] & 0xff) | ((input[inOff + 1] & 0xff) << 8) 				| ((input[inOff + 2] & 0xff) << 16) | ((input[inOff + 3] & 0xff) << 24);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessWord,The following statement contains a magic number: X[xOff++] = (input[inOff] & 0xff) | ((input[inOff + 1] & 0xff) << 8) 				| ((input[inOff + 2] & 0xff) << 16) | ((input[inOff + 3] & 0xff) << 24);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessWord,The following statement contains a magic number: X[xOff++] = (input[inOff] & 0xff) | ((input[inOff + 1] & 0xff) << 8) 				| ((input[inOff + 2] & 0xff) << 16) | ((input[inOff + 3] & 0xff) << 24);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessWord,The following statement contains a magic number: xOff == 16
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessLength,The following statement contains a magic number: xOff > 14
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessLength,The following statement contains a magic number: X[14] = (int)(bitLength & 0xffffffff);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessLength,The following statement contains a magic number: X[15] = (int)((ulong)bitLength >> 32);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessLength,The following statement contains a magic number: X[15] = (int)((ulong)bitLength >> 32);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,UnpackWord,The following statement contains a magic number: outBytes[outOff + 1] = (byte)((uint)word >> 8);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,UnpackWord,The following statement contains a magic number: outBytes[outOff + 2] = (byte)((uint)word >> 16);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,UnpackWord,The following statement contains a magic number: outBytes[outOff + 2] = (byte)((uint)word >> 16);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,UnpackWord,The following statement contains a magic number: outBytes[outOff + 3] = (byte)((uint)word >> 24);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,UnpackWord,The following statement contains a magic number: outBytes[outOff + 3] = (byte)((uint)word >> 24);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,DoFinal,The following statement contains a magic number: UnpackWord(H1' output' outOff + 4);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,DoFinal,The following statement contains a magic number: UnpackWord(H2' output' outOff + 8);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,DoFinal,The following statement contains a magic number: UnpackWord(H3' output' outOff + 12);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,DoFinal,The following statement contains a magic number: UnpackWord(H4' output' outOff + 16);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,RL,The following statement contains a magic number: return (x << n) | (int)((uint)x >> (32 - n));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a + F1(b' c' d) + X[0]' 11) + e;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F1(a' b' c) + X[1]' 14) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d + F1(e' a' b) + X[2]' 15) + c;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d + F1(e' a' b) + X[2]' 15) + c;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c + F1(d' e' a) + X[3]' 12) + b;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c + F1(d' e' a) + X[3]' 12) + b;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b + F1(c' d' e) + X[4]' 5) + a;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b + F1(c' d' e) + X[4]' 5) + a;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a + F1(b' c' d) + X[5]' 8) + e;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a + F1(b' c' d) + X[5]' 8) + e;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F1(a' b' c) + X[6]' 7) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F1(a' b' c) + X[6]' 7) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d + F1(e' a' b) + X[7]' 9) + c;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d + F1(e' a' b) + X[7]' 9) + c;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c + F1(d' e' a) + X[8]' 11) + b;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c + F1(d' e' a) + X[8]' 11) + b;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b + F1(c' d' e) + X[9]' 13) + a;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b + F1(c' d' e) + X[9]' 13) + a;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a + F1(b' c' d) + X[10]' 14) + e;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a + F1(b' c' d) + X[10]' 14) + e;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F1(a' b' c) + X[11]' 15) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F1(a' b' c) + X[11]' 15) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d + F1(e' a' b) + X[12]' 6) + c;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d + F1(e' a' b) + X[12]' 6) + c;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c + F1(d' e' a) + X[13]' 7) + b;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c + F1(d' e' a) + X[13]' 7) + b;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b + F1(c' d' e) + X[14]' 9) + a;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b + F1(c' d' e) + X[14]' 9) + a;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a + F1(b' c' d) + X[15]' 8) + e;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a + F1(b' c' d) + X[15]' 8) + e;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa + F5(bb' cc' dd) + X[5] + unchecked((int)0x50a28be6)' 8) + ee;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa + F5(bb' cc' dd) + X[5] + unchecked((int)0x50a28be6)' 8) + ee;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee + F5(aa' bb' cc) + X[14] + unchecked((int)0x50a28be6)' 9) + dd;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee + F5(aa' bb' cc) + X[14] + unchecked((int)0x50a28be6)' 9) + dd;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F5(ee' aa' bb) + X[7] + unchecked((int)0x50a28be6)' 9) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F5(ee' aa' bb) + X[7] + unchecked((int)0x50a28be6)' 9) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc + F5(dd' ee' aa) + X[0] + unchecked((int)0x50a28be6)' 11) + bb;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F5(cc' dd' ee) + X[9] + unchecked((int)0x50a28be6)' 13) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F5(cc' dd' ee) + X[9] + unchecked((int)0x50a28be6)' 13) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa + F5(bb' cc' dd) + X[2] + unchecked((int)0x50a28be6)' 15) + ee;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa + F5(bb' cc' dd) + X[2] + unchecked((int)0x50a28be6)' 15) + ee;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee + F5(aa' bb' cc) + X[11] + unchecked((int)0x50a28be6)' 15) + dd;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee + F5(aa' bb' cc) + X[11] + unchecked((int)0x50a28be6)' 15) + dd;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F5(ee' aa' bb) + X[4] + unchecked((int)0x50a28be6)' 5) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F5(ee' aa' bb) + X[4] + unchecked((int)0x50a28be6)' 5) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc + F5(dd' ee' aa) + X[13] + unchecked((int)0x50a28be6)' 7) + bb;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc + F5(dd' ee' aa) + X[13] + unchecked((int)0x50a28be6)' 7) + bb;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F5(cc' dd' ee) + X[6] + unchecked((int)0x50a28be6)' 7) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F5(cc' dd' ee) + X[6] + unchecked((int)0x50a28be6)' 7) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa + F5(bb' cc' dd) + X[15] + unchecked((int)0x50a28be6)' 8) + ee;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa + F5(bb' cc' dd) + X[15] + unchecked((int)0x50a28be6)' 8) + ee;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee + F5(aa' bb' cc) + X[8] + unchecked((int)0x50a28be6)' 11) + dd;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee + F5(aa' bb' cc) + X[8] + unchecked((int)0x50a28be6)' 11) + dd;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F5(ee' aa' bb) + X[1] + unchecked((int)0x50a28be6)' 14) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc + F5(dd' ee' aa) + X[10] + unchecked((int)0x50a28be6)' 14) + bb;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc + F5(dd' ee' aa) + X[10] + unchecked((int)0x50a28be6)' 14) + bb;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F5(cc' dd' ee) + X[3] + unchecked((int)0x50a28be6)' 12) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F5(cc' dd' ee) + X[3] + unchecked((int)0x50a28be6)' 12) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa + F5(bb' cc' dd) + X[12] + unchecked((int)0x50a28be6)' 6) + ee;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa + F5(bb' cc' dd) + X[12] + unchecked((int)0x50a28be6)' 6) + ee;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F2(a' b' c) + X[7] + unchecked((int)0x5a827999)' 7) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F2(a' b' c) + X[7] + unchecked((int)0x5a827999)' 7) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d + F2(e' a' b) + X[4] + unchecked((int)0x5a827999)' 6) + c;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d + F2(e' a' b) + X[4] + unchecked((int)0x5a827999)' 6) + c;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c + F2(d' e' a) + X[13] + unchecked((int)0x5a827999)' 8) + b;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c + F2(d' e' a) + X[13] + unchecked((int)0x5a827999)' 8) + b;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b + F2(c' d' e) + X[1] + unchecked((int)0x5a827999)' 13) + a;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a + F2(b' c' d) + X[10] + unchecked((int)0x5a827999)' 11) + e;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a + F2(b' c' d) + X[10] + unchecked((int)0x5a827999)' 11) + e;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F2(a' b' c) + X[6] + unchecked((int)0x5a827999)' 9) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F2(a' b' c) + X[6] + unchecked((int)0x5a827999)' 9) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d + F2(e' a' b) + X[15] + unchecked((int)0x5a827999)' 7) + c;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d + F2(e' a' b) + X[15] + unchecked((int)0x5a827999)' 7) + c;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c + F2(d' e' a) + X[3] + unchecked((int)0x5a827999)' 15) + b;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c + F2(d' e' a) + X[3] + unchecked((int)0x5a827999)' 15) + b;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b + F2(c' d' e) + X[12] + unchecked((int)0x5a827999)' 7) + a;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b + F2(c' d' e) + X[12] + unchecked((int)0x5a827999)' 7) + a;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a + F2(b' c' d) + X[0] + unchecked((int)0x5a827999)' 12) + e;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F2(a' b' c) + X[9] + unchecked((int)0x5a827999)' 15) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F2(a' b' c) + X[9] + unchecked((int)0x5a827999)' 15) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d + F2(e' a' b) + X[5] + unchecked((int)0x5a827999)' 9) + c;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d + F2(e' a' b) + X[5] + unchecked((int)0x5a827999)' 9) + c;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c + F2(d' e' a) + X[2] + unchecked((int)0x5a827999)' 11) + b;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c + F2(d' e' a) + X[2] + unchecked((int)0x5a827999)' 11) + b;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b + F2(c' d' e) + X[14] + unchecked((int)0x5a827999)' 7) + a;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b + F2(c' d' e) + X[14] + unchecked((int)0x5a827999)' 7) + a;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a + F2(b' c' d) + X[11] + unchecked((int)0x5a827999)' 13) + e;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a + F2(b' c' d) + X[11] + unchecked((int)0x5a827999)' 13) + e;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F2(a' b' c) + X[8] + unchecked((int)0x5a827999)' 12) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F2(a' b' c) + X[8] + unchecked((int)0x5a827999)' 12) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee + F4(aa' bb' cc) + X[6] + unchecked((int)0x5c4dd124)' 9) + dd;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee + F4(aa' bb' cc) + X[6] + unchecked((int)0x5c4dd124)' 9) + dd;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F4(ee' aa' bb) + X[11] + unchecked((int)0x5c4dd124)' 13) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F4(ee' aa' bb) + X[11] + unchecked((int)0x5c4dd124)' 13) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc + F4(dd' ee' aa) + X[3] + unchecked((int)0x5c4dd124)' 15) + bb;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc + F4(dd' ee' aa) + X[3] + unchecked((int)0x5c4dd124)' 15) + bb;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F4(cc' dd' ee) + X[7] + unchecked((int)0x5c4dd124)' 7) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F4(cc' dd' ee) + X[7] + unchecked((int)0x5c4dd124)' 7) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa + F4(bb' cc' dd) + X[0] + unchecked((int)0x5c4dd124)' 12) + ee;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee + F4(aa' bb' cc) + X[13] + unchecked((int)0x5c4dd124)' 8) + dd;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee + F4(aa' bb' cc) + X[13] + unchecked((int)0x5c4dd124)' 8) + dd;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F4(ee' aa' bb) + X[5] + unchecked((int)0x5c4dd124)' 9) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F4(ee' aa' bb) + X[5] + unchecked((int)0x5c4dd124)' 9) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc + F4(dd' ee' aa) + X[10] + unchecked((int)0x5c4dd124)' 11) + bb;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc + F4(dd' ee' aa) + X[10] + unchecked((int)0x5c4dd124)' 11) + bb;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F4(cc' dd' ee) + X[14] + unchecked((int)0x5c4dd124)' 7) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F4(cc' dd' ee) + X[14] + unchecked((int)0x5c4dd124)' 7) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa + F4(bb' cc' dd) + X[15] + unchecked((int)0x5c4dd124)' 7) + ee;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa + F4(bb' cc' dd) + X[15] + unchecked((int)0x5c4dd124)' 7) + ee;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee + F4(aa' bb' cc) + X[8] + unchecked((int)0x5c4dd124)' 12) + dd;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee + F4(aa' bb' cc) + X[8] + unchecked((int)0x5c4dd124)' 12) + dd;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F4(ee' aa' bb) + X[12] + unchecked((int)0x5c4dd124)' 7) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F4(ee' aa' bb) + X[12] + unchecked((int)0x5c4dd124)' 7) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc + F4(dd' ee' aa) + X[4] + unchecked((int)0x5c4dd124)' 6) + bb;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc + F4(dd' ee' aa) + X[4] + unchecked((int)0x5c4dd124)' 6) + bb;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F4(cc' dd' ee) + X[9] + unchecked((int)0x5c4dd124)' 15) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F4(cc' dd' ee) + X[9] + unchecked((int)0x5c4dd124)' 15) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa + F4(bb' cc' dd) + X[1] + unchecked((int)0x5c4dd124)' 13) + ee;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee + F4(aa' bb' cc) + X[2] + unchecked((int)0x5c4dd124)' 11) + dd;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee + F4(aa' bb' cc) + X[2] + unchecked((int)0x5c4dd124)' 11) + dd;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d + F3(e' a' b) + X[3] + unchecked((int)0x6ed9eba1)' 11) + c;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d + F3(e' a' b) + X[3] + unchecked((int)0x6ed9eba1)' 11) + c;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c + F3(d' e' a) + X[10] + unchecked((int)0x6ed9eba1)' 13) + b;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c + F3(d' e' a) + X[10] + unchecked((int)0x6ed9eba1)' 13) + b;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b + F3(c' d' e) + X[14] + unchecked((int)0x6ed9eba1)' 6) + a;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b + F3(c' d' e) + X[14] + unchecked((int)0x6ed9eba1)' 6) + a;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a + F3(b' c' d) + X[4] + unchecked((int)0x6ed9eba1)' 7) + e;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a + F3(b' c' d) + X[4] + unchecked((int)0x6ed9eba1)' 7) + e;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F3(a' b' c) + X[9] + unchecked((int)0x6ed9eba1)' 14) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F3(a' b' c) + X[9] + unchecked((int)0x6ed9eba1)' 14) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d + F3(e' a' b) + X[15] + unchecked((int)0x6ed9eba1)' 9) + c;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d + F3(e' a' b) + X[15] + unchecked((int)0x6ed9eba1)' 9) + c;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c + F3(d' e' a) + X[8] + unchecked((int)0x6ed9eba1)' 13) + b;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c + F3(d' e' a) + X[8] + unchecked((int)0x6ed9eba1)' 13) + b;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b + F3(c' d' e) + X[1] + unchecked((int)0x6ed9eba1)' 15) + a;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a + F3(b' c' d) + X[2] + unchecked((int)0x6ed9eba1)' 14) + e;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a + F3(b' c' d) + X[2] + unchecked((int)0x6ed9eba1)' 14) + e;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F3(a' b' c) + X[7] + unchecked((int)0x6ed9eba1)' 8) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F3(a' b' c) + X[7] + unchecked((int)0x6ed9eba1)' 8) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d + F3(e' a' b) + X[0] + unchecked((int)0x6ed9eba1)' 13) + c;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c + F3(d' e' a) + X[6] + unchecked((int)0x6ed9eba1)' 6) + b;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c + F3(d' e' a) + X[6] + unchecked((int)0x6ed9eba1)' 6) + b;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b + F3(c' d' e) + X[13] + unchecked((int)0x6ed9eba1)' 5) + a;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b + F3(c' d' e) + X[13] + unchecked((int)0x6ed9eba1)' 5) + a;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a + F3(b' c' d) + X[11] + unchecked((int)0x6ed9eba1)' 12) + e;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a + F3(b' c' d) + X[11] + unchecked((int)0x6ed9eba1)' 12) + e;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F3(a' b' c) + X[5] + unchecked((int)0x6ed9eba1)' 7) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F3(a' b' c) + X[5] + unchecked((int)0x6ed9eba1)' 7) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d + F3(e' a' b) + X[12] + unchecked((int)0x6ed9eba1)' 5) + c;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d + F3(e' a' b) + X[12] + unchecked((int)0x6ed9eba1)' 5) + c;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F3(ee' aa' bb) + X[15] + unchecked((int)0x6d703ef3)' 9) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F3(ee' aa' bb) + X[15] + unchecked((int)0x6d703ef3)' 9) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc + F3(dd' ee' aa) + X[5] + unchecked((int)0x6d703ef3)' 7) + bb;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc + F3(dd' ee' aa) + X[5] + unchecked((int)0x6d703ef3)' 7) + bb;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F3(cc' dd' ee) + X[1] + unchecked((int)0x6d703ef3)' 15) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa + F3(bb' cc' dd) + X[3] + unchecked((int)0x6d703ef3)' 11) + ee;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa + F3(bb' cc' dd) + X[3] + unchecked((int)0x6d703ef3)' 11) + ee;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee + F3(aa' bb' cc) + X[7] + unchecked((int)0x6d703ef3)' 8) + dd;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee + F3(aa' bb' cc) + X[7] + unchecked((int)0x6d703ef3)' 8) + dd;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F3(ee' aa' bb) + X[14] + unchecked((int)0x6d703ef3)' 6) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F3(ee' aa' bb) + X[14] + unchecked((int)0x6d703ef3)' 6) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc + F3(dd' ee' aa) + X[6] + unchecked((int)0x6d703ef3)' 6) + bb;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc + F3(dd' ee' aa) + X[6] + unchecked((int)0x6d703ef3)' 6) + bb;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F3(cc' dd' ee) + X[9] + unchecked((int)0x6d703ef3)' 14) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F3(cc' dd' ee) + X[9] + unchecked((int)0x6d703ef3)' 14) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa + F3(bb' cc' dd) + X[11] + unchecked((int)0x6d703ef3)' 12) + ee;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa + F3(bb' cc' dd) + X[11] + unchecked((int)0x6d703ef3)' 12) + ee;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee + F3(aa' bb' cc) + X[8] + unchecked((int)0x6d703ef3)' 13) + dd;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee + F3(aa' bb' cc) + X[8] + unchecked((int)0x6d703ef3)' 13) + dd;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F3(ee' aa' bb) + X[12] + unchecked((int)0x6d703ef3)' 5) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F3(ee' aa' bb) + X[12] + unchecked((int)0x6d703ef3)' 5) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc + F3(dd' ee' aa) + X[2] + unchecked((int)0x6d703ef3)' 14) + bb;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc + F3(dd' ee' aa) + X[2] + unchecked((int)0x6d703ef3)' 14) + bb;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F3(cc' dd' ee) + X[10] + unchecked((int)0x6d703ef3)' 13) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F3(cc' dd' ee) + X[10] + unchecked((int)0x6d703ef3)' 13) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa + F3(bb' cc' dd) + X[0] + unchecked((int)0x6d703ef3)' 13) + ee;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee + F3(aa' bb' cc) + X[4] + unchecked((int)0x6d703ef3)' 7) + dd;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee + F3(aa' bb' cc) + X[4] + unchecked((int)0x6d703ef3)' 7) + dd;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F3(ee' aa' bb) + X[13] + unchecked((int)0x6d703ef3)' 5) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F3(ee' aa' bb) + X[13] + unchecked((int)0x6d703ef3)' 5) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c + F4(d' e' a) + X[1] + unchecked((int)0x8f1bbcdc)' 11) + b;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b + F4(c' d' e) + X[9] + unchecked((int)0x8f1bbcdc)' 12) + a;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b + F4(c' d' e) + X[9] + unchecked((int)0x8f1bbcdc)' 12) + a;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a + F4(b' c' d) + X[11] + unchecked((int)0x8f1bbcdc)' 14) + e;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a + F4(b' c' d) + X[11] + unchecked((int)0x8f1bbcdc)' 14) + e;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F4(a' b' c) + X[10] + unchecked((int)0x8f1bbcdc)' 15) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F4(a' b' c) + X[10] + unchecked((int)0x8f1bbcdc)' 15) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d + F4(e' a' b) + X[0] + unchecked((int)0x8f1bbcdc)' 14) + c;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c + F4(d' e' a) + X[8] + unchecked((int)0x8f1bbcdc)' 15) + b;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c + F4(d' e' a) + X[8] + unchecked((int)0x8f1bbcdc)' 15) + b;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b + F4(c' d' e) + X[12] + unchecked((int)0x8f1bbcdc)' 9) + a;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b + F4(c' d' e) + X[12] + unchecked((int)0x8f1bbcdc)' 9) + a;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a + F4(b' c' d) + X[4] + unchecked((int)0x8f1bbcdc)' 8) + e;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a + F4(b' c' d) + X[4] + unchecked((int)0x8f1bbcdc)' 8) + e;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F4(a' b' c) + X[13] + unchecked((int)0x8f1bbcdc)' 9) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F4(a' b' c) + X[13] + unchecked((int)0x8f1bbcdc)' 9) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d + F4(e' a' b) + X[3] + unchecked((int)0x8f1bbcdc)' 14) + c;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d + F4(e' a' b) + X[3] + unchecked((int)0x8f1bbcdc)' 14) + c;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c + F4(d' e' a) + X[7] + unchecked((int)0x8f1bbcdc)' 5) + b;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c + F4(d' e' a) + X[7] + unchecked((int)0x8f1bbcdc)' 5) + b;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b + F4(c' d' e) + X[15] + unchecked((int)0x8f1bbcdc)' 6) + a;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b + F4(c' d' e) + X[15] + unchecked((int)0x8f1bbcdc)' 6) + a;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a + F4(b' c' d) + X[14] + unchecked((int)0x8f1bbcdc)' 8) + e;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a + F4(b' c' d) + X[14] + unchecked((int)0x8f1bbcdc)' 8) + e;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F4(a' b' c) + X[5] + unchecked((int)0x8f1bbcdc)' 6) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F4(a' b' c) + X[5] + unchecked((int)0x8f1bbcdc)' 6) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d + F4(e' a' b) + X[6] + unchecked((int)0x8f1bbcdc)' 5) + c;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d + F4(e' a' b) + X[6] + unchecked((int)0x8f1bbcdc)' 5) + c;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c + F4(d' e' a) + X[2] + unchecked((int)0x8f1bbcdc)' 12) + b;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c + F4(d' e' a) + X[2] + unchecked((int)0x8f1bbcdc)' 12) + b;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc + F2(dd' ee' aa) + X[8] + unchecked((int)0x7a6d76e9)' 15) + bb;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc + F2(dd' ee' aa) + X[8] + unchecked((int)0x7a6d76e9)' 15) + bb;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F2(cc' dd' ee) + X[6] + unchecked((int)0x7a6d76e9)' 5) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F2(cc' dd' ee) + X[6] + unchecked((int)0x7a6d76e9)' 5) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa + F2(bb' cc' dd) + X[4] + unchecked((int)0x7a6d76e9)' 8) + ee;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa + F2(bb' cc' dd) + X[4] + unchecked((int)0x7a6d76e9)' 8) + ee;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee + F2(aa' bb' cc) + X[1] + unchecked((int)0x7a6d76e9)' 11) + dd;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F2(ee' aa' bb) + X[3] + unchecked((int)0x7a6d76e9)' 14) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F2(ee' aa' bb) + X[3] + unchecked((int)0x7a6d76e9)' 14) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc + F2(dd' ee' aa) + X[11] + unchecked((int)0x7a6d76e9)' 14) + bb;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc + F2(dd' ee' aa) + X[11] + unchecked((int)0x7a6d76e9)' 14) + bb;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F2(cc' dd' ee) + X[15] + unchecked((int)0x7a6d76e9)' 6) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F2(cc' dd' ee) + X[15] + unchecked((int)0x7a6d76e9)' 6) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa + F2(bb' cc' dd) + X[0] + unchecked((int)0x7a6d76e9)' 14) + ee;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee + F2(aa' bb' cc) + X[5] + unchecked((int)0x7a6d76e9)' 6) + dd;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee + F2(aa' bb' cc) + X[5] + unchecked((int)0x7a6d76e9)' 6) + dd;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F2(ee' aa' bb) + X[12] + unchecked((int)0x7a6d76e9)' 9) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F2(ee' aa' bb) + X[12] + unchecked((int)0x7a6d76e9)' 9) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc + F2(dd' ee' aa) + X[2] + unchecked((int)0x7a6d76e9)' 12) + bb;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc + F2(dd' ee' aa) + X[2] + unchecked((int)0x7a6d76e9)' 12) + bb;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F2(cc' dd' ee) + X[13] + unchecked((int)0x7a6d76e9)' 9) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F2(cc' dd' ee) + X[13] + unchecked((int)0x7a6d76e9)' 9) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa + F2(bb' cc' dd) + X[9] + unchecked((int)0x7a6d76e9)' 12) + ee;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa + F2(bb' cc' dd) + X[9] + unchecked((int)0x7a6d76e9)' 12) + ee;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee + F2(aa' bb' cc) + X[7] + unchecked((int)0x7a6d76e9)' 5) + dd;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee + F2(aa' bb' cc) + X[7] + unchecked((int)0x7a6d76e9)' 5) + dd;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F2(ee' aa' bb) + X[10] + unchecked((int)0x7a6d76e9)' 15) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F2(ee' aa' bb) + X[10] + unchecked((int)0x7a6d76e9)' 15) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc + F2(dd' ee' aa) + X[14] + unchecked((int)0x7a6d76e9)' 8) + bb;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc + F2(dd' ee' aa) + X[14] + unchecked((int)0x7a6d76e9)' 8) + bb;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b + F5(c' d' e) + X[4] + unchecked((int)0xa953fd4e)' 9) + a;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b + F5(c' d' e) + X[4] + unchecked((int)0xa953fd4e)' 9) + a;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a + F5(b' c' d) + X[0] + unchecked((int)0xa953fd4e)' 15) + e;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F5(a' b' c) + X[5] + unchecked((int)0xa953fd4e)' 5) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F5(a' b' c) + X[5] + unchecked((int)0xa953fd4e)' 5) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d + F5(e' a' b) + X[9] + unchecked((int)0xa953fd4e)' 11) + c;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d + F5(e' a' b) + X[9] + unchecked((int)0xa953fd4e)' 11) + c;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c + F5(d' e' a) + X[7] + unchecked((int)0xa953fd4e)' 6) + b;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c + F5(d' e' a) + X[7] + unchecked((int)0xa953fd4e)' 6) + b;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b + F5(c' d' e) + X[12] + unchecked((int)0xa953fd4e)' 8) + a;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b + F5(c' d' e) + X[12] + unchecked((int)0xa953fd4e)' 8) + a;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a + F5(b' c' d) + X[2] + unchecked((int)0xa953fd4e)' 13) + e;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a + F5(b' c' d) + X[2] + unchecked((int)0xa953fd4e)' 13) + e;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F5(a' b' c) + X[10] + unchecked((int)0xa953fd4e)' 12) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F5(a' b' c) + X[10] + unchecked((int)0xa953fd4e)' 12) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d + F5(e' a' b) + X[14] + unchecked((int)0xa953fd4e)' 5) + c;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d + F5(e' a' b) + X[14] + unchecked((int)0xa953fd4e)' 5) + c;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c + F5(d' e' a) + X[1] + unchecked((int)0xa953fd4e)' 12) + b;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b + F5(c' d' e) + X[3] + unchecked((int)0xa953fd4e)' 13) + a;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b + F5(c' d' e) + X[3] + unchecked((int)0xa953fd4e)' 13) + a;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a + F5(b' c' d) + X[8] + unchecked((int)0xa953fd4e)' 14) + e;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a + F5(b' c' d) + X[8] + unchecked((int)0xa953fd4e)' 14) + e;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F5(a' b' c) + X[11] + unchecked((int)0xa953fd4e)' 11) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e + F5(a' b' c) + X[11] + unchecked((int)0xa953fd4e)' 11) + d;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d + F5(e' a' b) + X[6] + unchecked((int)0xa953fd4e)' 8) + c;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d + F5(e' a' b) + X[6] + unchecked((int)0xa953fd4e)' 8) + c;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: a = RL(a' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c + F5(d' e' a) + X[15] + unchecked((int)0xa953fd4e)' 5) + b;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: c = RL(c + F5(d' e' a) + X[15] + unchecked((int)0xa953fd4e)' 5) + b;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: e = RL(e' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b + F5(c' d' e) + X[13] + unchecked((int)0xa953fd4e)' 6) + a;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: b = RL(b + F5(c' d' e) + X[13] + unchecked((int)0xa953fd4e)' 6) + a;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: d = RL(d' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F1(cc' dd' ee) + X[12]' 8) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F1(cc' dd' ee) + X[12]' 8) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa + F1(bb' cc' dd) + X[15]' 5) + ee;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa + F1(bb' cc' dd) + X[15]' 5) + ee;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee + F1(aa' bb' cc) + X[10]' 12) + dd;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee + F1(aa' bb' cc) + X[10]' 12) + dd;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F1(ee' aa' bb) + X[4]' 9) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F1(ee' aa' bb) + X[4]' 9) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc + F1(dd' ee' aa) + X[1]' 12) + bb;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F1(cc' dd' ee) + X[5]' 5) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F1(cc' dd' ee) + X[5]' 5) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa + F1(bb' cc' dd) + X[8]' 14) + ee;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa + F1(bb' cc' dd) + X[8]' 14) + ee;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee + F1(aa' bb' cc) + X[7]' 6) + dd;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee + F1(aa' bb' cc) + X[7]' 6) + dd;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F1(ee' aa' bb) + X[6]' 8) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F1(ee' aa' bb) + X[6]' 8) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc + F1(dd' ee' aa) + X[2]' 13) + bb;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc + F1(dd' ee' aa) + X[2]' 13) + bb;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F1(cc' dd' ee) + X[13]' 6) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F1(cc' dd' ee) + X[13]' 6) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa + F1(bb' cc' dd) + X[14]' 5) + ee;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa + F1(bb' cc' dd) + X[14]' 5) + ee;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee + F1(aa' bb' cc) + X[0]' 15) + dd;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F1(ee' aa' bb) + X[3]' 13) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd + F1(ee' aa' bb) + X[3]' 13) + cc;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: aa = RL(aa' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc + F1(dd' ee' aa) + X[9]' 11) + bb;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: cc = RL(cc + F1(dd' ee' aa) + X[9]' 11) + bb;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: ee = RL(ee' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F1(cc' dd' ee) + X[11]' 11) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: bb = RL(bb + F1(cc' dd' ee) + X[11]' 11) + aa;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,RipeMD160Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\RipeMD160Digest.cs,ProcessBlock,The following statement contains a magic number: dd = RL(dd' 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessWord,The following statement contains a magic number: ++xOff == 16
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessLength,The following statement contains a magic number: xOff > 14
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessLength,The following statement contains a magic number: X[14] = (uint)((ulong)bitLength >> 32);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessLength,The following statement contains a magic number: X[14] = (uint)((ulong)bitLength >> 32);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessLength,The following statement contains a magic number: X[15] = (uint)((ulong)bitLength);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,DoFinal,The following statement contains a magic number: Pack.UInt32_To_BE(H2' output' outOff + 4);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,DoFinal,The following statement contains a magic number: Pack.UInt32_To_BE(H3' output' outOff + 8);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,DoFinal,The following statement contains a magic number: Pack.UInt32_To_BE(H4' output' outOff + 12);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,DoFinal,The following statement contains a magic number: Pack.UInt32_To_BE(H5' output' outOff + 16);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: uint t = X[i - 3] ^ X[i - 8] ^ X[i - 14] ^ X[i - 16];
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: uint t = X[i - 3] ^ X[i - 8] ^ X[i - 14] ^ X[i - 16];
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: uint t = X[i - 3] ^ X[i - 8] ^ X[i - 14] ^ X[i - 16];
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: uint t = X[i - 3] ^ X[i - 8] ^ X[i - 14] ^ X[i - 16];
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: X[i] = t << 1 | t >> 31;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: i < 80
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: E += (A << 5 | (A >> 27)) + F(B' C' D) + X[idx++] + Y1;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: E += (A << 5 | (A >> 27)) + F(B' C' D) + X[idx++] + Y1;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: B = B << 30 | (B >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: B = B << 30 | (B >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: D += (E << 5 | (E >> 27)) + F(A' B' C) + X[idx++] + Y1;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: D += (E << 5 | (E >> 27)) + F(A' B' C) + X[idx++] + Y1;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: A = A << 30 | (A >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: A = A << 30 | (A >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: C += (D << 5 | (D >> 27)) + F(E' A' B) + X[idx++] + Y1;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: C += (D << 5 | (D >> 27)) + F(E' A' B) + X[idx++] + Y1;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: E = E << 30 | (E >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: E = E << 30 | (E >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: B += (C << 5 | (C >> 27)) + F(D' E' A) + X[idx++] + Y1;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: B += (C << 5 | (C >> 27)) + F(D' E' A) + X[idx++] + Y1;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: D = D << 30 | (D >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: D = D << 30 | (D >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: A += (B << 5 | (B >> 27)) + F(C' D' E) + X[idx++] + Y1;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: A += (B << 5 | (B >> 27)) + F(C' D' E) + X[idx++] + Y1;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: C = C << 30 | (C >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: C = C << 30 | (C >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: j < 4
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: E += (A << 5 | (A >> 27)) + H(B' C' D) + X[idx++] + Y2;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: E += (A << 5 | (A >> 27)) + H(B' C' D) + X[idx++] + Y2;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: B = B << 30 | (B >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: B = B << 30 | (B >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: D += (E << 5 | (E >> 27)) + H(A' B' C) + X[idx++] + Y2;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: D += (E << 5 | (E >> 27)) + H(A' B' C) + X[idx++] + Y2;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: A = A << 30 | (A >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: A = A << 30 | (A >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: C += (D << 5 | (D >> 27)) + H(E' A' B) + X[idx++] + Y2;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: C += (D << 5 | (D >> 27)) + H(E' A' B) + X[idx++] + Y2;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: E = E << 30 | (E >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: E = E << 30 | (E >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: B += (C << 5 | (C >> 27)) + H(D' E' A) + X[idx++] + Y2;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: B += (C << 5 | (C >> 27)) + H(D' E' A) + X[idx++] + Y2;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: D = D << 30 | (D >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: D = D << 30 | (D >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: A += (B << 5 | (B >> 27)) + H(C' D' E) + X[idx++] + Y2;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: A += (B << 5 | (B >> 27)) + H(C' D' E) + X[idx++] + Y2;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: C = C << 30 | (C >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: C = C << 30 | (C >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: j < 4
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: E += (A << 5 | (A >> 27)) + G(B' C' D) + X[idx++] + Y3;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: E += (A << 5 | (A >> 27)) + G(B' C' D) + X[idx++] + Y3;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: B = B << 30 | (B >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: B = B << 30 | (B >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: D += (E << 5 | (E >> 27)) + G(A' B' C) + X[idx++] + Y3;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: D += (E << 5 | (E >> 27)) + G(A' B' C) + X[idx++] + Y3;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: A = A << 30 | (A >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: A = A << 30 | (A >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: C += (D << 5 | (D >> 27)) + G(E' A' B) + X[idx++] + Y3;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: C += (D << 5 | (D >> 27)) + G(E' A' B) + X[idx++] + Y3;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: E = E << 30 | (E >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: E = E << 30 | (E >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: B += (C << 5 | (C >> 27)) + G(D' E' A) + X[idx++] + Y3;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: B += (C << 5 | (C >> 27)) + G(D' E' A) + X[idx++] + Y3;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: D = D << 30 | (D >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: D = D << 30 | (D >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: A += (B << 5 | (B >> 27)) + G(C' D' E) + X[idx++] + Y3;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: A += (B << 5 | (B >> 27)) + G(C' D' E) + X[idx++] + Y3;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: C = C << 30 | (C >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: C = C << 30 | (C >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: j < 4
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: E += (A << 5 | (A >> 27)) + H(B' C' D) + X[idx++] + Y4;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: E += (A << 5 | (A >> 27)) + H(B' C' D) + X[idx++] + Y4;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: B = B << 30 | (B >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: B = B << 30 | (B >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: D += (E << 5 | (E >> 27)) + H(A' B' C) + X[idx++] + Y4;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: D += (E << 5 | (E >> 27)) + H(A' B' C) + X[idx++] + Y4;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: A = A << 30 | (A >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: A = A << 30 | (A >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: C += (D << 5 | (D >> 27)) + H(E' A' B) + X[idx++] + Y4;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: C += (D << 5 | (D >> 27)) + H(E' A' B) + X[idx++] + Y4;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: E = E << 30 | (E >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: E = E << 30 | (E >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: B += (C << 5 | (C >> 27)) + H(D' E' A) + X[idx++] + Y4;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: B += (C << 5 | (C >> 27)) + H(D' E' A) + X[idx++] + Y4;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: D = D << 30 | (D >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: D = D << 30 | (D >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: A += (B << 5 | (B >> 27)) + H(C' D' E) + X[idx++] + Y4;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: A += (B << 5 | (B >> 27)) + H(C' D' E) + X[idx++] + Y4;
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: C = C << 30 | (C >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: C = C << 30 | (C >> 2);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: j < 4
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha1Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha1Digest.cs,ProcessBlock,The following statement contains a magic number: Array.Clear(X' 0' 16);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,ProcessWord,The following statement contains a magic number: ++xOff == 16
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,ProcessLength,The following statement contains a magic number: xOff > 14
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,ProcessLength,The following statement contains a magic number: X[14] = (uint)((ulong)bitLength >> 32);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,ProcessLength,The following statement contains a magic number: X[14] = (uint)((ulong)bitLength >> 32);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,ProcessLength,The following statement contains a magic number: X[15] = (uint)((ulong)bitLength);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,DoFinal,The following statement contains a magic number: Pack.UInt32_To_BE(H2' output' outOff + 4);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,DoFinal,The following statement contains a magic number: Pack.UInt32_To_BE(H3' output' outOff + 8);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,DoFinal,The following statement contains a magic number: Pack.UInt32_To_BE(H4' output' outOff + 12);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,DoFinal,The following statement contains a magic number: Pack.UInt32_To_BE(H5' output' outOff + 16);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,DoFinal,The following statement contains a magic number: Pack.UInt32_To_BE(H6' output' outOff + 20);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,DoFinal,The following statement contains a magic number: Pack.UInt32_To_BE(H7' output' outOff + 24);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,ProcessBlock,The following statement contains a magic number: X[ti] = Theta1(X[ti - 2]) + X[ti - 7] + Theta0(X[ti - 15]) + X[ti - 16];
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,ProcessBlock,The following statement contains a magic number: X[ti] = Theta1(X[ti - 2]) + X[ti - 7] + Theta0(X[ti - 15]) + X[ti - 16];
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,ProcessBlock,The following statement contains a magic number: X[ti] = Theta1(X[ti - 2]) + X[ti - 7] + Theta0(X[ti - 15]) + X[ti - 16];
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,ProcessBlock,The following statement contains a magic number: X[ti] = Theta1(X[ti - 2]) + X[ti - 7] + Theta0(X[ti - 15]) + X[ti - 16];
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,ProcessBlock,The following statement contains a magic number: ti <= 63
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,ProcessBlock,The following statement contains a magic number: i < 8
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,ProcessBlock,The following statement contains a magic number: Array.Clear(X' 0' 16);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,Sum0,The following statement contains a magic number: return ((x >> 2) | (x << 30)) ^ ((x >> 13) | (x << 19)) ^ ((x >> 22) | (x << 10));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,Sum0,The following statement contains a magic number: return ((x >> 2) | (x << 30)) ^ ((x >> 13) | (x << 19)) ^ ((x >> 22) | (x << 10));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,Sum0,The following statement contains a magic number: return ((x >> 2) | (x << 30)) ^ ((x >> 13) | (x << 19)) ^ ((x >> 22) | (x << 10));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,Sum0,The following statement contains a magic number: return ((x >> 2) | (x << 30)) ^ ((x >> 13) | (x << 19)) ^ ((x >> 22) | (x << 10));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,Sum0,The following statement contains a magic number: return ((x >> 2) | (x << 30)) ^ ((x >> 13) | (x << 19)) ^ ((x >> 22) | (x << 10));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,Sum0,The following statement contains a magic number: return ((x >> 2) | (x << 30)) ^ ((x >> 13) | (x << 19)) ^ ((x >> 22) | (x << 10));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,Sum1,The following statement contains a magic number: return ((x >> 6) | (x << 26)) ^ ((x >> 11) | (x << 21)) ^ ((x >> 25) | (x << 7));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,Sum1,The following statement contains a magic number: return ((x >> 6) | (x << 26)) ^ ((x >> 11) | (x << 21)) ^ ((x >> 25) | (x << 7));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,Sum1,The following statement contains a magic number: return ((x >> 6) | (x << 26)) ^ ((x >> 11) | (x << 21)) ^ ((x >> 25) | (x << 7));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,Sum1,The following statement contains a magic number: return ((x >> 6) | (x << 26)) ^ ((x >> 11) | (x << 21)) ^ ((x >> 25) | (x << 7));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,Sum1,The following statement contains a magic number: return ((x >> 6) | (x << 26)) ^ ((x >> 11) | (x << 21)) ^ ((x >> 25) | (x << 7));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,Sum1,The following statement contains a magic number: return ((x >> 6) | (x << 26)) ^ ((x >> 11) | (x << 21)) ^ ((x >> 25) | (x << 7));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,Theta0,The following statement contains a magic number: return ((x >> 7) | (x << 25)) ^ ((x >> 18) | (x << 14)) ^ (x >> 3);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,Theta0,The following statement contains a magic number: return ((x >> 7) | (x << 25)) ^ ((x >> 18) | (x << 14)) ^ (x >> 3);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,Theta0,The following statement contains a magic number: return ((x >> 7) | (x << 25)) ^ ((x >> 18) | (x << 14)) ^ (x >> 3);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,Theta0,The following statement contains a magic number: return ((x >> 7) | (x << 25)) ^ ((x >> 18) | (x << 14)) ^ (x >> 3);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,Theta0,The following statement contains a magic number: return ((x >> 7) | (x << 25)) ^ ((x >> 18) | (x << 14)) ^ (x >> 3);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,Theta1,The following statement contains a magic number: return ((x >> 17) | (x << 15)) ^ ((x >> 19) | (x << 13)) ^ (x >> 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,Theta1,The following statement contains a magic number: return ((x >> 17) | (x << 15)) ^ ((x >> 19) | (x << 13)) ^ (x >> 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,Theta1,The following statement contains a magic number: return ((x >> 17) | (x << 15)) ^ ((x >> 19) | (x << 13)) ^ (x >> 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,Theta1,The following statement contains a magic number: return ((x >> 17) | (x << 15)) ^ ((x >> 19) | (x << 13)) ^ (x >> 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha224Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha224Digest.cs,Theta1,The following statement contains a magic number: return ((x >> 17) | (x << 15)) ^ ((x >> 19) | (x << 13)) ^ (x >> 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,ProcessWord,The following statement contains a magic number: ++xOff == 16
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,ProcessLength,The following statement contains a magic number: xOff > 14
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,ProcessLength,The following statement contains a magic number: X[14] = (uint)((ulong)bitLength >> 32);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,ProcessLength,The following statement contains a magic number: X[14] = (uint)((ulong)bitLength >> 32);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,ProcessLength,The following statement contains a magic number: X[15] = (uint)((ulong)bitLength);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,DoFinal,The following statement contains a magic number: Pack.UInt32_To_BE((uint)H2' output' outOff + 4);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,DoFinal,The following statement contains a magic number: Pack.UInt32_To_BE((uint)H3' output' outOff + 8);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,DoFinal,The following statement contains a magic number: Pack.UInt32_To_BE((uint)H4' output' outOff + 12);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,DoFinal,The following statement contains a magic number: Pack.UInt32_To_BE((uint)H5' output' outOff + 16);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,DoFinal,The following statement contains a magic number: Pack.UInt32_To_BE((uint)H6' output' outOff + 20);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,DoFinal,The following statement contains a magic number: Pack.UInt32_To_BE((uint)H7' output' outOff + 24);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,DoFinal,The following statement contains a magic number: Pack.UInt32_To_BE((uint)H8' output' outOff + 28);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,ProcessBlock,The following statement contains a magic number: X[ti] = Theta1(X[ti - 2]) + X[ti - 7] + Theta0(X[ti - 15]) + X[ti - 16];
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,ProcessBlock,The following statement contains a magic number: X[ti] = Theta1(X[ti - 2]) + X[ti - 7] + Theta0(X[ti - 15]) + X[ti - 16];
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,ProcessBlock,The following statement contains a magic number: X[ti] = Theta1(X[ti - 2]) + X[ti - 7] + Theta0(X[ti - 15]) + X[ti - 16];
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,ProcessBlock,The following statement contains a magic number: X[ti] = Theta1(X[ti - 2]) + X[ti - 7] + Theta0(X[ti - 15]) + X[ti - 16];
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,ProcessBlock,The following statement contains a magic number: ti <= 63
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,ProcessBlock,The following statement contains a magic number: i < 8
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,ProcessBlock,The following statement contains a magic number: Array.Clear(X' 0' 16);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,Sum1Ch,The following statement contains a magic number: return (((x >> 6) | (x << 26)) ^ ((x >> 11) | (x << 21)) ^ ((x >> 25) | (x << 7))) 				+ ((x & y) ^ ((~x) & z));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,Sum1Ch,The following statement contains a magic number: return (((x >> 6) | (x << 26)) ^ ((x >> 11) | (x << 21)) ^ ((x >> 25) | (x << 7))) 				+ ((x & y) ^ ((~x) & z));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,Sum1Ch,The following statement contains a magic number: return (((x >> 6) | (x << 26)) ^ ((x >> 11) | (x << 21)) ^ ((x >> 25) | (x << 7))) 				+ ((x & y) ^ ((~x) & z));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,Sum1Ch,The following statement contains a magic number: return (((x >> 6) | (x << 26)) ^ ((x >> 11) | (x << 21)) ^ ((x >> 25) | (x << 7))) 				+ ((x & y) ^ ((~x) & z));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,Sum1Ch,The following statement contains a magic number: return (((x >> 6) | (x << 26)) ^ ((x >> 11) | (x << 21)) ^ ((x >> 25) | (x << 7))) 				+ ((x & y) ^ ((~x) & z));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,Sum1Ch,The following statement contains a magic number: return (((x >> 6) | (x << 26)) ^ ((x >> 11) | (x << 21)) ^ ((x >> 25) | (x << 7))) 				+ ((x & y) ^ ((~x) & z));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,Sum0Maj,The following statement contains a magic number: return (((x >> 2) | (x << 30)) ^ ((x >> 13) | (x << 19)) ^ ((x >> 22) | (x << 10))) 				+ ((x & y) ^ (x & z) ^ (y & z));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,Sum0Maj,The following statement contains a magic number: return (((x >> 2) | (x << 30)) ^ ((x >> 13) | (x << 19)) ^ ((x >> 22) | (x << 10))) 				+ ((x & y) ^ (x & z) ^ (y & z));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,Sum0Maj,The following statement contains a magic number: return (((x >> 2) | (x << 30)) ^ ((x >> 13) | (x << 19)) ^ ((x >> 22) | (x << 10))) 				+ ((x & y) ^ (x & z) ^ (y & z));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,Sum0Maj,The following statement contains a magic number: return (((x >> 2) | (x << 30)) ^ ((x >> 13) | (x << 19)) ^ ((x >> 22) | (x << 10))) 				+ ((x & y) ^ (x & z) ^ (y & z));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,Sum0Maj,The following statement contains a magic number: return (((x >> 2) | (x << 30)) ^ ((x >> 13) | (x << 19)) ^ ((x >> 22) | (x << 10))) 				+ ((x & y) ^ (x & z) ^ (y & z));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,Sum0Maj,The following statement contains a magic number: return (((x >> 2) | (x << 30)) ^ ((x >> 13) | (x << 19)) ^ ((x >> 22) | (x << 10))) 				+ ((x & y) ^ (x & z) ^ (y & z));
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,Theta0,The following statement contains a magic number: return ((x >> 7) | (x << 25)) ^ ((x >> 18) | (x << 14)) ^ (x >> 3);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,Theta0,The following statement contains a magic number: return ((x >> 7) | (x << 25)) ^ ((x >> 18) | (x << 14)) ^ (x >> 3);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,Theta0,The following statement contains a magic number: return ((x >> 7) | (x << 25)) ^ ((x >> 18) | (x << 14)) ^ (x >> 3);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,Theta0,The following statement contains a magic number: return ((x >> 7) | (x << 25)) ^ ((x >> 18) | (x << 14)) ^ (x >> 3);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,Theta0,The following statement contains a magic number: return ((x >> 7) | (x << 25)) ^ ((x >> 18) | (x << 14)) ^ (x >> 3);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,Theta1,The following statement contains a magic number: return ((x >> 17) | (x << 15)) ^ ((x >> 19) | (x << 13)) ^ (x >> 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,Theta1,The following statement contains a magic number: return ((x >> 17) | (x << 15)) ^ ((x >> 19) | (x << 13)) ^ (x >> 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,Theta1,The following statement contains a magic number: return ((x >> 17) | (x << 15)) ^ ((x >> 19) | (x << 13)) ^ (x >> 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,Theta1,The following statement contains a magic number: return ((x >> 17) | (x << 15)) ^ ((x >> 19) | (x << 13)) ^ (x >> 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha256Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha256Digest.cs,Theta1,The following statement contains a magic number: return ((x >> 17) | (x << 15)) ^ ((x >> 19) | (x << 13)) ^ (x >> 10);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha384Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha384Digest.cs,DoFinal,The following statement contains a magic number: Pack.UInt64_To_BE(H2' output' outOff + 8);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha384Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha384Digest.cs,DoFinal,The following statement contains a magic number: Pack.UInt64_To_BE(H3' output' outOff + 16);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha384Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha384Digest.cs,DoFinal,The following statement contains a magic number: Pack.UInt64_To_BE(H4' output' outOff + 24);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha384Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha384Digest.cs,DoFinal,The following statement contains a magic number: Pack.UInt64_To_BE(H5' output' outOff + 32);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha384Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha384Digest.cs,DoFinal,The following statement contains a magic number: Pack.UInt64_To_BE(H6' output' outOff + 40);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha512Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha512Digest.cs,DoFinal,The following statement contains a magic number: Pack.UInt64_To_BE(H2' output' outOff + 8);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha512Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha512Digest.cs,DoFinal,The following statement contains a magic number: Pack.UInt64_To_BE(H3' output' outOff + 16);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha512Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha512Digest.cs,DoFinal,The following statement contains a magic number: Pack.UInt64_To_BE(H4' output' outOff + 24);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha512Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha512Digest.cs,DoFinal,The following statement contains a magic number: Pack.UInt64_To_BE(H5' output' outOff + 32);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha512Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha512Digest.cs,DoFinal,The following statement contains a magic number: Pack.UInt64_To_BE(H6' output' outOff + 40);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha512Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha512Digest.cs,DoFinal,The following statement contains a magic number: Pack.UInt64_To_BE(H7' output' outOff + 48);
Magic Number,NBitcoin.BouncyCastle.Crypto.Digests,Sha512Digest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\digests\Sha512Digest.cs,DoFinal,The following statement contains a magic number: Pack.UInt64_To_BE(H8' output' outOff + 56);
Magic Number,NBitcoin.BouncyCastle.Crypto.EC,SecP256K1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\ec\CustomNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"' 16)'  					new BigInteger("5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72"' 16)'  					new BigInteger[]{  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16)'  						new BigInteger("-e4437ed6010e88286f547fa90abfe4c3"' 16) }'  					new BigInteger[]{  						new BigInteger("114ca50f7a8e2f3f657c1108d9d44cfd8"' 16)'  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16) }'  					new BigInteger("3086d221a7d46bcde86c90e49284eb153dab"' 16)'  					new BigInteger("e4437ed6010e88286f547fa90abfe4c42212"' 16)'  					272);
Magic Number,NBitcoin.BouncyCastle.Crypto.EC,SecP256K1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\ec\CustomNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"' 16)'  					new BigInteger("5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72"' 16)'  					new BigInteger[]{  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16)'  						new BigInteger("-e4437ed6010e88286f547fa90abfe4c3"' 16) }'  					new BigInteger[]{  						new BigInteger("114ca50f7a8e2f3f657c1108d9d44cfd8"' 16)'  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16) }'  					new BigInteger("3086d221a7d46bcde86c90e49284eb153dab"' 16)'  					new BigInteger("e4437ed6010e88286f547fa90abfe4c42212"' 16)'  					272);
Magic Number,NBitcoin.BouncyCastle.Crypto.EC,SecP256K1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\ec\CustomNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"' 16)'  					new BigInteger("5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72"' 16)'  					new BigInteger[]{  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16)'  						new BigInteger("-e4437ed6010e88286f547fa90abfe4c3"' 16) }'  					new BigInteger[]{  						new BigInteger("114ca50f7a8e2f3f657c1108d9d44cfd8"' 16)'  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16) }'  					new BigInteger("3086d221a7d46bcde86c90e49284eb153dab"' 16)'  					new BigInteger("e4437ed6010e88286f547fa90abfe4c42212"' 16)'  					272);
Magic Number,NBitcoin.BouncyCastle.Crypto.EC,SecP256K1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\ec\CustomNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"' 16)'  					new BigInteger("5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72"' 16)'  					new BigInteger[]{  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16)'  						new BigInteger("-e4437ed6010e88286f547fa90abfe4c3"' 16) }'  					new BigInteger[]{  						new BigInteger("114ca50f7a8e2f3f657c1108d9d44cfd8"' 16)'  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16) }'  					new BigInteger("3086d221a7d46bcde86c90e49284eb153dab"' 16)'  					new BigInteger("e4437ed6010e88286f547fa90abfe4c42212"' 16)'  					272);
Magic Number,NBitcoin.BouncyCastle.Crypto.EC,SecP256K1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\ec\CustomNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"' 16)'  					new BigInteger("5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72"' 16)'  					new BigInteger[]{  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16)'  						new BigInteger("-e4437ed6010e88286f547fa90abfe4c3"' 16) }'  					new BigInteger[]{  						new BigInteger("114ca50f7a8e2f3f657c1108d9d44cfd8"' 16)'  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16) }'  					new BigInteger("3086d221a7d46bcde86c90e49284eb153dab"' 16)'  					new BigInteger("e4437ed6010e88286f547fa90abfe4c42212"' 16)'  					272);
Magic Number,NBitcoin.BouncyCastle.Crypto.EC,SecP256K1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\ec\CustomNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"' 16)'  					new BigInteger("5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72"' 16)'  					new BigInteger[]{  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16)'  						new BigInteger("-e4437ed6010e88286f547fa90abfe4c3"' 16) }'  					new BigInteger[]{  						new BigInteger("114ca50f7a8e2f3f657c1108d9d44cfd8"' 16)'  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16) }'  					new BigInteger("3086d221a7d46bcde86c90e49284eb153dab"' 16)'  					new BigInteger("e4437ed6010e88286f547fa90abfe4c42212"' 16)'  					272);
Magic Number,NBitcoin.BouncyCastle.Crypto.EC,SecP256K1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\ec\CustomNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"' 16)'  					new BigInteger("5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72"' 16)'  					new BigInteger[]{  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16)'  						new BigInteger("-e4437ed6010e88286f547fa90abfe4c3"' 16) }'  					new BigInteger[]{  						new BigInteger("114ca50f7a8e2f3f657c1108d9d44cfd8"' 16)'  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16) }'  					new BigInteger("3086d221a7d46bcde86c90e49284eb153dab"' 16)'  					new BigInteger("e4437ed6010e88286f547fa90abfe4c42212"' 16)'  					272);
Magic Number,NBitcoin.BouncyCastle.Crypto.EC,SecP256K1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\ec\CustomNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"' 16)'  					new BigInteger("5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72"' 16)'  					new BigInteger[]{  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16)'  						new BigInteger("-e4437ed6010e88286f547fa90abfe4c3"' 16) }'  					new BigInteger[]{  						new BigInteger("114ca50f7a8e2f3f657c1108d9d44cfd8"' 16)'  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16) }'  					new BigInteger("3086d221a7d46bcde86c90e49284eb153dab"' 16)'  					new BigInteger("e4437ed6010e88286f547fa90abfe4c42212"' 16)'  					272);
Magic Number,NBitcoin.BouncyCastle.Crypto.EC,SecP256K1Holder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\ec\CustomNamedCurves.cs,CreateParameters,The following statement contains a magic number: GlvTypeBParameters glv = new GlvTypeBParameters(  					new BigInteger("7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"' 16)'  					new BigInteger("5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72"' 16)'  					new BigInteger[]{  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16)'  						new BigInteger("-e4437ed6010e88286f547fa90abfe4c3"' 16) }'  					new BigInteger[]{  						new BigInteger("114ca50f7a8e2f3f657c1108d9d44cfd8"' 16)'  						new BigInteger("3086d221a7d46bcde86c90e49284eb15"' 16) }'  					new BigInteger("3086d221a7d46bcde86c90e49284eb153dab"' 16)'  					new BigInteger("e4437ed6010e88286f547fa90abfe4c42212"' 16)'  					272);
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,Shift,The following statement contains a magic number: return (r >> shift) | (r << (32 - shift));
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,FFmulX,The following statement contains a magic number: return ((x & m2) << 1) ^ (((x & m1) >> 7) * m3);
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,FFmulX2,The following statement contains a magic number: uint t0 = (x & m5) << 2;
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,FFmulX2,The following statement contains a magic number: return t0 ^ (t1 >> 2) ^ (t1 >> 5);
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,FFmulX2,The following statement contains a magic number: return t0 ^ (t1 >> 2) ^ (t1 >> 5);
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,Inv_Mcol,The following statement contains a magic number: t1 = t0 ^ Shift(t0' 8);
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,Inv_Mcol,The following statement contains a magic number: t0 ^= t1 ^ Shift(t1' 16);
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,SubWord,The following statement contains a magic number: return (uint)S[x & 255] 				| (((uint)S[(x >> 8) & 255]) << 8) 				| (((uint)S[(x >> 16) & 255]) << 16) 				| (((uint)S[(x >> 24) & 255]) << 24);
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,SubWord,The following statement contains a magic number: return (uint)S[x & 255] 				| (((uint)S[(x >> 8) & 255]) << 8) 				| (((uint)S[(x >> 16) & 255]) << 16) 				| (((uint)S[(x >> 24) & 255]) << 24);
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,SubWord,The following statement contains a magic number: return (uint)S[x & 255] 				| (((uint)S[(x >> 8) & 255]) << 8) 				| (((uint)S[(x >> 16) & 255]) << 16) 				| (((uint)S[(x >> 24) & 255]) << 24);
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,SubWord,The following statement contains a magic number: return (uint)S[x & 255] 				| (((uint)S[(x >> 8) & 255]) << 8) 				| (((uint)S[(x >> 16) & 255]) << 16) 				| (((uint)S[(x >> 24) & 255]) << 24);
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,SubWord,The following statement contains a magic number: return (uint)S[x & 255] 				| (((uint)S[(x >> 8) & 255]) << 8) 				| (((uint)S[(x >> 16) & 255]) << 16) 				| (((uint)S[(x >> 24) & 255]) << 24);
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,SubWord,The following statement contains a magic number: return (uint)S[x & 255] 				| (((uint)S[(x >> 8) & 255]) << 8) 				| (((uint)S[(x >> 16) & 255]) << 16) 				| (((uint)S[(x >> 24) & 255]) << 24);
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,SubWord,The following statement contains a magic number: return (uint)S[x & 255] 				| (((uint)S[(x >> 8) & 255]) << 8) 				| (((uint)S[(x >> 16) & 255]) << 16) 				| (((uint)S[(x >> 24) & 255]) << 24);
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,SubWord,The following statement contains a magic number: return (uint)S[x & 255] 				| (((uint)S[(x >> 8) & 255]) << 8) 				| (((uint)S[(x >> 16) & 255]) << 16) 				| (((uint)S[(x >> 24) & 255]) << 24);
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,SubWord,The following statement contains a magic number: return (uint)S[x & 255] 				| (((uint)S[(x >> 8) & 255]) << 8) 				| (((uint)S[(x >> 16) & 255]) << 16) 				| (((uint)S[(x >> 24) & 255]) << 24);
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,SubWord,The following statement contains a magic number: return (uint)S[x & 255] 				| (((uint)S[(x >> 8) & 255]) << 8) 				| (((uint)S[(x >> 16) & 255]) << 16) 				| (((uint)S[(x >> 24) & 255]) << 24);
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: keyLen < 16 || keyLen > 32 || (keyLen & 7) != 0
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: keyLen < 16 || keyLen > 32 || (keyLen & 7) != 0
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: keyLen < 16 || keyLen > 32 || (keyLen & 7) != 0
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: int KC = keyLen >> 2;
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: this.ROUNDS = KC + 6;
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: W[i] = new uint[4];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: switch (KC) 			{ 				case 4: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3;  						for (int i = 1; i <= 10; ++i) 						{ 							uint u = SubWord(Shift(t3' 8)) ^ rcon[i - 1]; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 						}  						break; 					} 				case 6: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5;  						uint rcon = 1; 						uint u = SubWord(Shift(t5' 8)) ^ rcon; 						rcon <<= 1; 						t0 ^= u; 						W[1][2] = t0; 						t1 ^= t0; 						W[1][3] = t1; 						t2 ^= t1; 						W[2][0] = t2; 						t3 ^= t2; 						W[2][1] = t3; 						t4 ^= t3; 						W[2][2] = t4; 						t5 ^= t4; 						W[2][3] = t5;  						for (int i = 3; i < 12; i += 3) 						{ 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							t4 ^= t3; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							u = SubWord(Shift(t5' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i + 1][2] = t0; 							t1 ^= t0; 							W[i + 1][3] = t1; 							t2 ^= t1; 							W[i + 2][0] = t2; 							t3 ^= t2; 							W[i + 2][1] = t3; 							t4 ^= t3; 							W[i + 2][2] = t4; 							t5 ^= t4; 							W[i + 2][3] = t5; 						}  						u = SubWord(Shift(t5' 8)) ^ rcon; 						t0 ^= u; 						W[12][0] = t0; 						t1 ^= t0; 						W[12][1] = t1; 						t2 ^= t1; 						W[12][2] = t2; 						t3 ^= t2; 						W[12][3] = t3;  						break; 					} 				case 8: 					{ 						uint t0 = Pack.LE_To_UInt32(key' 0); 						W[0][0] = t0; 						uint t1 = Pack.LE_To_UInt32(key' 4); 						W[0][1] = t1; 						uint t2 = Pack.LE_To_UInt32(key' 8); 						W[0][2] = t2; 						uint t3 = Pack.LE_To_UInt32(key' 12); 						W[0][3] = t3; 						uint t4 = Pack.LE_To_UInt32(key' 16); 						W[1][0] = t4; 						uint t5 = Pack.LE_To_UInt32(key' 20); 						W[1][1] = t5; 						uint t6 = Pack.LE_To_UInt32(key' 24); 						W[1][2] = t6; 						uint t7 = Pack.LE_To_UInt32(key' 28); 						W[1][3] = t7;  						uint u' rcon = 1;  						for (int i = 2; i < 14; i += 2) 						{ 							u = SubWord(Shift(t7' 8)) ^ rcon; 							rcon <<= 1; 							t0 ^= u; 							W[i][0] = t0; 							t1 ^= t0; 							W[i][1] = t1; 							t2 ^= t1; 							W[i][2] = t2; 							t3 ^= t2; 							W[i][3] = t3; 							u = SubWord(t3); 							t4 ^= u; 							W[i + 1][0] = t4; 							t5 ^= t4; 							W[i + 1][1] = t5; 							t6 ^= t5; 							W[i + 1][2] = t6; 							t7 ^= t6; 							W[i + 1][3] = t7; 						}  						u = SubWord(Shift(t7' 8)) ^ rcon; 						t0 ^= u; 						W[14][0] = t0; 						t1 ^= t0; 						W[14][1] = t1; 						t2 ^= t1; 						W[14][2] = t2; 						t3 ^= t2; 						W[14][3] = t3;  						break; 					} 				default: 					{ 						throw new InvalidOperationException("Should never get here"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,GenerateWorkingKey,The following statement contains a magic number: i < 4
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,ProcessBlock,The following statement contains a magic number: Check.DataLength(input' inOff' 16' "input buffer too short");
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,ProcessBlock,The following statement contains a magic number: Check.OutputLength(output' outOff' 16' "output buffer too short");
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,UnPackBlock,The following statement contains a magic number: C1 = Pack.LE_To_UInt32(bytes' off + 4);
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,UnPackBlock,The following statement contains a magic number: C2 = Pack.LE_To_UInt32(bytes' off + 8);
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,UnPackBlock,The following statement contains a magic number: C3 = Pack.LE_To_UInt32(bytes' off + 12);
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,PackBlock,The following statement contains a magic number: Pack.UInt32_To_LE(C1' bytes' off + 4);
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,PackBlock,The following statement contains a magic number: Pack.UInt32_To_LE(C2' bytes' off + 8);
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,PackBlock,The following statement contains a magic number: Pack.UInt32_To_LE(C3' bytes' off + 12);
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: uint t2 = this.C2 ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: uint r0' r1' r2' r3 = this.C3 ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r0 = T0[t0 & 255] ^ T1[(t1 >> 8) & 255] ^ T2[(t2 >> 16) & 255] ^ T3[r3 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r0 = T0[t0 & 255] ^ T1[(t1 >> 8) & 255] ^ T2[(t2 >> 16) & 255] ^ T3[r3 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r0 = T0[t0 & 255] ^ T1[(t1 >> 8) & 255] ^ T2[(t2 >> 16) & 255] ^ T3[r3 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r0 = T0[t0 & 255] ^ T1[(t1 >> 8) & 255] ^ T2[(t2 >> 16) & 255] ^ T3[r3 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r0 = T0[t0 & 255] ^ T1[(t1 >> 8) & 255] ^ T2[(t2 >> 16) & 255] ^ T3[r3 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r0 = T0[t0 & 255] ^ T1[(t1 >> 8) & 255] ^ T2[(t2 >> 16) & 255] ^ T3[r3 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r1 = T0[t1 & 255] ^ T1[(t2 >> 8) & 255] ^ T2[(r3 >> 16) & 255] ^ T3[t0 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r1 = T0[t1 & 255] ^ T1[(t2 >> 8) & 255] ^ T2[(r3 >> 16) & 255] ^ T3[t0 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r1 = T0[t1 & 255] ^ T1[(t2 >> 8) & 255] ^ T2[(r3 >> 16) & 255] ^ T3[t0 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r1 = T0[t1 & 255] ^ T1[(t2 >> 8) & 255] ^ T2[(r3 >> 16) & 255] ^ T3[t0 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r1 = T0[t1 & 255] ^ T1[(t2 >> 8) & 255] ^ T2[(r3 >> 16) & 255] ^ T3[t0 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r1 = T0[t1 & 255] ^ T1[(t2 >> 8) & 255] ^ T2[(r3 >> 16) & 255] ^ T3[t0 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r2 = T0[t2 & 255] ^ T1[(r3 >> 8) & 255] ^ T2[(t0 >> 16) & 255] ^ T3[t1 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r2 = T0[t2 & 255] ^ T1[(r3 >> 8) & 255] ^ T2[(t0 >> 16) & 255] ^ T3[t1 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r2 = T0[t2 & 255] ^ T1[(r3 >> 8) & 255] ^ T2[(t0 >> 16) & 255] ^ T3[t1 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r2 = T0[t2 & 255] ^ T1[(r3 >> 8) & 255] ^ T2[(t0 >> 16) & 255] ^ T3[t1 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r2 = T0[t2 & 255] ^ T1[(r3 >> 8) & 255] ^ T2[(t0 >> 16) & 255] ^ T3[t1 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r2 = T0[t2 & 255] ^ T1[(r3 >> 8) & 255] ^ T2[(t0 >> 16) & 255] ^ T3[t1 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r2 = T0[t2 & 255] ^ T1[(r3 >> 8) & 255] ^ T2[(t0 >> 16) & 255] ^ T3[t1 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r3 = T0[r3 & 255] ^ T1[(t0 >> 8) & 255] ^ T2[(t1 >> 16) & 255] ^ T3[t2 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r3 = T0[r3 & 255] ^ T1[(t0 >> 8) & 255] ^ T2[(t1 >> 16) & 255] ^ T3[t2 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r3 = T0[r3 & 255] ^ T1[(t0 >> 8) & 255] ^ T2[(t1 >> 16) & 255] ^ T3[t2 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r3 = T0[r3 & 255] ^ T1[(t0 >> 8) & 255] ^ T2[(t1 >> 16) & 255] ^ T3[t2 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r3 = T0[r3 & 255] ^ T1[(t0 >> 8) & 255] ^ T2[(t1 >> 16) & 255] ^ T3[t2 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r3 = T0[r3 & 255] ^ T1[(t0 >> 8) & 255] ^ T2[(t1 >> 16) & 255] ^ T3[t2 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r3 = T0[r3 & 255] ^ T1[(t0 >> 8) & 255] ^ T2[(t1 >> 16) & 255] ^ T3[t2 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: t0 = T0[r0 & 255] ^ T1[(r1 >> 8) & 255] ^ T2[(r2 >> 16) & 255] ^ T3[r3 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: t0 = T0[r0 & 255] ^ T1[(r1 >> 8) & 255] ^ T2[(r2 >> 16) & 255] ^ T3[r3 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: t0 = T0[r0 & 255] ^ T1[(r1 >> 8) & 255] ^ T2[(r2 >> 16) & 255] ^ T3[r3 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: t0 = T0[r0 & 255] ^ T1[(r1 >> 8) & 255] ^ T2[(r2 >> 16) & 255] ^ T3[r3 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: t0 = T0[r0 & 255] ^ T1[(r1 >> 8) & 255] ^ T2[(r2 >> 16) & 255] ^ T3[r3 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: t0 = T0[r0 & 255] ^ T1[(r1 >> 8) & 255] ^ T2[(r2 >> 16) & 255] ^ T3[r3 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: t1 = T0[r1 & 255] ^ T1[(r2 >> 8) & 255] ^ T2[(r3 >> 16) & 255] ^ T3[r0 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: t1 = T0[r1 & 255] ^ T1[(r2 >> 8) & 255] ^ T2[(r3 >> 16) & 255] ^ T3[r0 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: t1 = T0[r1 & 255] ^ T1[(r2 >> 8) & 255] ^ T2[(r3 >> 16) & 255] ^ T3[r0 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: t1 = T0[r1 & 255] ^ T1[(r2 >> 8) & 255] ^ T2[(r3 >> 16) & 255] ^ T3[r0 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: t1 = T0[r1 & 255] ^ T1[(r2 >> 8) & 255] ^ T2[(r3 >> 16) & 255] ^ T3[r0 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: t1 = T0[r1 & 255] ^ T1[(r2 >> 8) & 255] ^ T2[(r3 >> 16) & 255] ^ T3[r0 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: t2 = T0[r2 & 255] ^ T1[(r3 >> 8) & 255] ^ T2[(r0 >> 16) & 255] ^ T3[r1 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: t2 = T0[r2 & 255] ^ T1[(r3 >> 8) & 255] ^ T2[(r0 >> 16) & 255] ^ T3[r1 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: t2 = T0[r2 & 255] ^ T1[(r3 >> 8) & 255] ^ T2[(r0 >> 16) & 255] ^ T3[r1 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: t2 = T0[r2 & 255] ^ T1[(r3 >> 8) & 255] ^ T2[(r0 >> 16) & 255] ^ T3[r1 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: t2 = T0[r2 & 255] ^ T1[(r3 >> 8) & 255] ^ T2[(r0 >> 16) & 255] ^ T3[r1 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: t2 = T0[r2 & 255] ^ T1[(r3 >> 8) & 255] ^ T2[(r0 >> 16) & 255] ^ T3[r1 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: t2 = T0[r2 & 255] ^ T1[(r3 >> 8) & 255] ^ T2[(r0 >> 16) & 255] ^ T3[r1 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r3 = T0[r3 & 255] ^ T1[(r0 >> 8) & 255] ^ T2[(r1 >> 16) & 255] ^ T3[r2 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r3 = T0[r3 & 255] ^ T1[(r0 >> 8) & 255] ^ T2[(r1 >> 16) & 255] ^ T3[r2 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r3 = T0[r3 & 255] ^ T1[(r0 >> 8) & 255] ^ T2[(r1 >> 16) & 255] ^ T3[r2 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r3 = T0[r3 & 255] ^ T1[(r0 >> 8) & 255] ^ T2[(r1 >> 16) & 255] ^ T3[r2 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r3 = T0[r3 & 255] ^ T1[(r0 >> 8) & 255] ^ T2[(r1 >> 16) & 255] ^ T3[r2 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r3 = T0[r3 & 255] ^ T1[(r0 >> 8) & 255] ^ T2[(r1 >> 16) & 255] ^ T3[r2 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r3 = T0[r3 & 255] ^ T1[(r0 >> 8) & 255] ^ T2[(r1 >> 16) & 255] ^ T3[r2 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r0 = T0[t0 & 255] ^ T1[(t1 >> 8) & 255] ^ T2[(t2 >> 16) & 255] ^ T3[r3 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r0 = T0[t0 & 255] ^ T1[(t1 >> 8) & 255] ^ T2[(t2 >> 16) & 255] ^ T3[r3 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r0 = T0[t0 & 255] ^ T1[(t1 >> 8) & 255] ^ T2[(t2 >> 16) & 255] ^ T3[r3 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r0 = T0[t0 & 255] ^ T1[(t1 >> 8) & 255] ^ T2[(t2 >> 16) & 255] ^ T3[r3 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r0 = T0[t0 & 255] ^ T1[(t1 >> 8) & 255] ^ T2[(t2 >> 16) & 255] ^ T3[r3 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r0 = T0[t0 & 255] ^ T1[(t1 >> 8) & 255] ^ T2[(t2 >> 16) & 255] ^ T3[r3 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r1 = T0[t1 & 255] ^ T1[(t2 >> 8) & 255] ^ T2[(r3 >> 16) & 255] ^ T3[t0 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r1 = T0[t1 & 255] ^ T1[(t2 >> 8) & 255] ^ T2[(r3 >> 16) & 255] ^ T3[t0 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r1 = T0[t1 & 255] ^ T1[(t2 >> 8) & 255] ^ T2[(r3 >> 16) & 255] ^ T3[t0 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r1 = T0[t1 & 255] ^ T1[(t2 >> 8) & 255] ^ T2[(r3 >> 16) & 255] ^ T3[t0 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r1 = T0[t1 & 255] ^ T1[(t2 >> 8) & 255] ^ T2[(r3 >> 16) & 255] ^ T3[t0 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r1 = T0[t1 & 255] ^ T1[(t2 >> 8) & 255] ^ T2[(r3 >> 16) & 255] ^ T3[t0 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r2 = T0[t2 & 255] ^ T1[(r3 >> 8) & 255] ^ T2[(t0 >> 16) & 255] ^ T3[t1 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r2 = T0[t2 & 255] ^ T1[(r3 >> 8) & 255] ^ T2[(t0 >> 16) & 255] ^ T3[t1 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r2 = T0[t2 & 255] ^ T1[(r3 >> 8) & 255] ^ T2[(t0 >> 16) & 255] ^ T3[t1 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r2 = T0[t2 & 255] ^ T1[(r3 >> 8) & 255] ^ T2[(t0 >> 16) & 255] ^ T3[t1 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r2 = T0[t2 & 255] ^ T1[(r3 >> 8) & 255] ^ T2[(t0 >> 16) & 255] ^ T3[t1 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r2 = T0[t2 & 255] ^ T1[(r3 >> 8) & 255] ^ T2[(t0 >> 16) & 255] ^ T3[t1 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r2 = T0[t2 & 255] ^ T1[(r3 >> 8) & 255] ^ T2[(t0 >> 16) & 255] ^ T3[t1 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r3 = T0[r3 & 255] ^ T1[(t0 >> 8) & 255] ^ T2[(t1 >> 16) & 255] ^ T3[t2 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r3 = T0[r3 & 255] ^ T1[(t0 >> 8) & 255] ^ T2[(t1 >> 16) & 255] ^ T3[t2 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r3 = T0[r3 & 255] ^ T1[(t0 >> 8) & 255] ^ T2[(t1 >> 16) & 255] ^ T3[t2 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r3 = T0[r3 & 255] ^ T1[(t0 >> 8) & 255] ^ T2[(t1 >> 16) & 255] ^ T3[t2 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r3 = T0[r3 & 255] ^ T1[(t0 >> 8) & 255] ^ T2[(t1 >> 16) & 255] ^ T3[t2 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r3 = T0[r3 & 255] ^ T1[(t0 >> 8) & 255] ^ T2[(t1 >> 16) & 255] ^ T3[t2 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: r3 = T0[r3 & 255] ^ T1[(t0 >> 8) & 255] ^ T2[(t1 >> 16) & 255] ^ T3[t2 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C0 = (uint)S[r0 & 255] ^ (((uint)S[(r1 >> 8) & 255]) << 8) ^ (((uint)S[(r2 >> 16) & 255]) << 16) ^ (((uint)S[r3 >> 24]) << 24) ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C0 = (uint)S[r0 & 255] ^ (((uint)S[(r1 >> 8) & 255]) << 8) ^ (((uint)S[(r2 >> 16) & 255]) << 16) ^ (((uint)S[r3 >> 24]) << 24) ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C0 = (uint)S[r0 & 255] ^ (((uint)S[(r1 >> 8) & 255]) << 8) ^ (((uint)S[(r2 >> 16) & 255]) << 16) ^ (((uint)S[r3 >> 24]) << 24) ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C0 = (uint)S[r0 & 255] ^ (((uint)S[(r1 >> 8) & 255]) << 8) ^ (((uint)S[(r2 >> 16) & 255]) << 16) ^ (((uint)S[r3 >> 24]) << 24) ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C0 = (uint)S[r0 & 255] ^ (((uint)S[(r1 >> 8) & 255]) << 8) ^ (((uint)S[(r2 >> 16) & 255]) << 16) ^ (((uint)S[r3 >> 24]) << 24) ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C0 = (uint)S[r0 & 255] ^ (((uint)S[(r1 >> 8) & 255]) << 8) ^ (((uint)S[(r2 >> 16) & 255]) << 16) ^ (((uint)S[r3 >> 24]) << 24) ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C0 = (uint)S[r0 & 255] ^ (((uint)S[(r1 >> 8) & 255]) << 8) ^ (((uint)S[(r2 >> 16) & 255]) << 16) ^ (((uint)S[r3 >> 24]) << 24) ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C0 = (uint)S[r0 & 255] ^ (((uint)S[(r1 >> 8) & 255]) << 8) ^ (((uint)S[(r2 >> 16) & 255]) << 16) ^ (((uint)S[r3 >> 24]) << 24) ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C0 = (uint)S[r0 & 255] ^ (((uint)S[(r1 >> 8) & 255]) << 8) ^ (((uint)S[(r2 >> 16) & 255]) << 16) ^ (((uint)S[r3 >> 24]) << 24) ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C1 = (uint)S[r1 & 255] ^ (((uint)S[(r2 >> 8) & 255]) << 8) ^ (((uint)S[(r3 >> 16) & 255]) << 16) ^ (((uint)S[r0 >> 24]) << 24) ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C1 = (uint)S[r1 & 255] ^ (((uint)S[(r2 >> 8) & 255]) << 8) ^ (((uint)S[(r3 >> 16) & 255]) << 16) ^ (((uint)S[r0 >> 24]) << 24) ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C1 = (uint)S[r1 & 255] ^ (((uint)S[(r2 >> 8) & 255]) << 8) ^ (((uint)S[(r3 >> 16) & 255]) << 16) ^ (((uint)S[r0 >> 24]) << 24) ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C1 = (uint)S[r1 & 255] ^ (((uint)S[(r2 >> 8) & 255]) << 8) ^ (((uint)S[(r3 >> 16) & 255]) << 16) ^ (((uint)S[r0 >> 24]) << 24) ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C1 = (uint)S[r1 & 255] ^ (((uint)S[(r2 >> 8) & 255]) << 8) ^ (((uint)S[(r3 >> 16) & 255]) << 16) ^ (((uint)S[r0 >> 24]) << 24) ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C1 = (uint)S[r1 & 255] ^ (((uint)S[(r2 >> 8) & 255]) << 8) ^ (((uint)S[(r3 >> 16) & 255]) << 16) ^ (((uint)S[r0 >> 24]) << 24) ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C1 = (uint)S[r1 & 255] ^ (((uint)S[(r2 >> 8) & 255]) << 8) ^ (((uint)S[(r3 >> 16) & 255]) << 16) ^ (((uint)S[r0 >> 24]) << 24) ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C1 = (uint)S[r1 & 255] ^ (((uint)S[(r2 >> 8) & 255]) << 8) ^ (((uint)S[(r3 >> 16) & 255]) << 16) ^ (((uint)S[r0 >> 24]) << 24) ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C1 = (uint)S[r1 & 255] ^ (((uint)S[(r2 >> 8) & 255]) << 8) ^ (((uint)S[(r3 >> 16) & 255]) << 16) ^ (((uint)S[r0 >> 24]) << 24) ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C2 = (uint)S[r2 & 255] ^ (((uint)S[(r3 >> 8) & 255]) << 8) ^ (((uint)S[(r0 >> 16) & 255]) << 16) ^ (((uint)S[r1 >> 24]) << 24) ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C2 = (uint)S[r2 & 255] ^ (((uint)S[(r3 >> 8) & 255]) << 8) ^ (((uint)S[(r0 >> 16) & 255]) << 16) ^ (((uint)S[r1 >> 24]) << 24) ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C2 = (uint)S[r2 & 255] ^ (((uint)S[(r3 >> 8) & 255]) << 8) ^ (((uint)S[(r0 >> 16) & 255]) << 16) ^ (((uint)S[r1 >> 24]) << 24) ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C2 = (uint)S[r2 & 255] ^ (((uint)S[(r3 >> 8) & 255]) << 8) ^ (((uint)S[(r0 >> 16) & 255]) << 16) ^ (((uint)S[r1 >> 24]) << 24) ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C2 = (uint)S[r2 & 255] ^ (((uint)S[(r3 >> 8) & 255]) << 8) ^ (((uint)S[(r0 >> 16) & 255]) << 16) ^ (((uint)S[r1 >> 24]) << 24) ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C2 = (uint)S[r2 & 255] ^ (((uint)S[(r3 >> 8) & 255]) << 8) ^ (((uint)S[(r0 >> 16) & 255]) << 16) ^ (((uint)S[r1 >> 24]) << 24) ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C2 = (uint)S[r2 & 255] ^ (((uint)S[(r3 >> 8) & 255]) << 8) ^ (((uint)S[(r0 >> 16) & 255]) << 16) ^ (((uint)S[r1 >> 24]) << 24) ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C2 = (uint)S[r2 & 255] ^ (((uint)S[(r3 >> 8) & 255]) << 8) ^ (((uint)S[(r0 >> 16) & 255]) << 16) ^ (((uint)S[r1 >> 24]) << 24) ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C2 = (uint)S[r2 & 255] ^ (((uint)S[(r3 >> 8) & 255]) << 8) ^ (((uint)S[(r0 >> 16) & 255]) << 16) ^ (((uint)S[r1 >> 24]) << 24) ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C2 = (uint)S[r2 & 255] ^ (((uint)S[(r3 >> 8) & 255]) << 8) ^ (((uint)S[(r0 >> 16) & 255]) << 16) ^ (((uint)S[r1 >> 24]) << 24) ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C3 = (uint)S[r3 & 255] ^ (((uint)S[(r0 >> 8) & 255]) << 8) ^ (((uint)S[(r1 >> 16) & 255]) << 16) ^ (((uint)S[r2 >> 24]) << 24) ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C3 = (uint)S[r3 & 255] ^ (((uint)S[(r0 >> 8) & 255]) << 8) ^ (((uint)S[(r1 >> 16) & 255]) << 16) ^ (((uint)S[r2 >> 24]) << 24) ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C3 = (uint)S[r3 & 255] ^ (((uint)S[(r0 >> 8) & 255]) << 8) ^ (((uint)S[(r1 >> 16) & 255]) << 16) ^ (((uint)S[r2 >> 24]) << 24) ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C3 = (uint)S[r3 & 255] ^ (((uint)S[(r0 >> 8) & 255]) << 8) ^ (((uint)S[(r1 >> 16) & 255]) << 16) ^ (((uint)S[r2 >> 24]) << 24) ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C3 = (uint)S[r3 & 255] ^ (((uint)S[(r0 >> 8) & 255]) << 8) ^ (((uint)S[(r1 >> 16) & 255]) << 16) ^ (((uint)S[r2 >> 24]) << 24) ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C3 = (uint)S[r3 & 255] ^ (((uint)S[(r0 >> 8) & 255]) << 8) ^ (((uint)S[(r1 >> 16) & 255]) << 16) ^ (((uint)S[r2 >> 24]) << 24) ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C3 = (uint)S[r3 & 255] ^ (((uint)S[(r0 >> 8) & 255]) << 8) ^ (((uint)S[(r1 >> 16) & 255]) << 16) ^ (((uint)S[r2 >> 24]) << 24) ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C3 = (uint)S[r3 & 255] ^ (((uint)S[(r0 >> 8) & 255]) << 8) ^ (((uint)S[(r1 >> 16) & 255]) << 16) ^ (((uint)S[r2 >> 24]) << 24) ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C3 = (uint)S[r3 & 255] ^ (((uint)S[(r0 >> 8) & 255]) << 8) ^ (((uint)S[(r1 >> 16) & 255]) << 16) ^ (((uint)S[r2 >> 24]) << 24) ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,EncryptBlock,The following statement contains a magic number: this.C3 = (uint)S[r3 & 255] ^ (((uint)S[(r0 >> 8) & 255]) << 8) ^ (((uint)S[(r1 >> 16) & 255]) << 16) ^ (((uint)S[r2 >> 24]) << 24) ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: uint t2 = this.C2 ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: uint r0' r1' r2' r3 = this.C3 ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r0 = Tinv0[t0 & 255] ^ Tinv1[(r3 >> 8) & 255] ^ Tinv2[(t2 >> 16) & 255] ^ Tinv3[t1 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r0 = Tinv0[t0 & 255] ^ Tinv1[(r3 >> 8) & 255] ^ Tinv2[(t2 >> 16) & 255] ^ Tinv3[t1 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r0 = Tinv0[t0 & 255] ^ Tinv1[(r3 >> 8) & 255] ^ Tinv2[(t2 >> 16) & 255] ^ Tinv3[t1 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r0 = Tinv0[t0 & 255] ^ Tinv1[(r3 >> 8) & 255] ^ Tinv2[(t2 >> 16) & 255] ^ Tinv3[t1 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r0 = Tinv0[t0 & 255] ^ Tinv1[(r3 >> 8) & 255] ^ Tinv2[(t2 >> 16) & 255] ^ Tinv3[t1 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r0 = Tinv0[t0 & 255] ^ Tinv1[(r3 >> 8) & 255] ^ Tinv2[(t2 >> 16) & 255] ^ Tinv3[t1 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r1 = Tinv0[t1 & 255] ^ Tinv1[(t0 >> 8) & 255] ^ Tinv2[(r3 >> 16) & 255] ^ Tinv3[t2 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r1 = Tinv0[t1 & 255] ^ Tinv1[(t0 >> 8) & 255] ^ Tinv2[(r3 >> 16) & 255] ^ Tinv3[t2 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r1 = Tinv0[t1 & 255] ^ Tinv1[(t0 >> 8) & 255] ^ Tinv2[(r3 >> 16) & 255] ^ Tinv3[t2 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r1 = Tinv0[t1 & 255] ^ Tinv1[(t0 >> 8) & 255] ^ Tinv2[(r3 >> 16) & 255] ^ Tinv3[t2 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r1 = Tinv0[t1 & 255] ^ Tinv1[(t0 >> 8) & 255] ^ Tinv2[(r3 >> 16) & 255] ^ Tinv3[t2 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r1 = Tinv0[t1 & 255] ^ Tinv1[(t0 >> 8) & 255] ^ Tinv2[(r3 >> 16) & 255] ^ Tinv3[t2 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r2 = Tinv0[t2 & 255] ^ Tinv1[(t1 >> 8) & 255] ^ Tinv2[(t0 >> 16) & 255] ^ Tinv3[r3 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r2 = Tinv0[t2 & 255] ^ Tinv1[(t1 >> 8) & 255] ^ Tinv2[(t0 >> 16) & 255] ^ Tinv3[r3 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r2 = Tinv0[t2 & 255] ^ Tinv1[(t1 >> 8) & 255] ^ Tinv2[(t0 >> 16) & 255] ^ Tinv3[r3 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r2 = Tinv0[t2 & 255] ^ Tinv1[(t1 >> 8) & 255] ^ Tinv2[(t0 >> 16) & 255] ^ Tinv3[r3 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r2 = Tinv0[t2 & 255] ^ Tinv1[(t1 >> 8) & 255] ^ Tinv2[(t0 >> 16) & 255] ^ Tinv3[r3 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r2 = Tinv0[t2 & 255] ^ Tinv1[(t1 >> 8) & 255] ^ Tinv2[(t0 >> 16) & 255] ^ Tinv3[r3 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r2 = Tinv0[t2 & 255] ^ Tinv1[(t1 >> 8) & 255] ^ Tinv2[(t0 >> 16) & 255] ^ Tinv3[r3 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r3 = Tinv0[r3 & 255] ^ Tinv1[(t2 >> 8) & 255] ^ Tinv2[(t1 >> 16) & 255] ^ Tinv3[t0 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r3 = Tinv0[r3 & 255] ^ Tinv1[(t2 >> 8) & 255] ^ Tinv2[(t1 >> 16) & 255] ^ Tinv3[t0 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r3 = Tinv0[r3 & 255] ^ Tinv1[(t2 >> 8) & 255] ^ Tinv2[(t1 >> 16) & 255] ^ Tinv3[t0 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r3 = Tinv0[r3 & 255] ^ Tinv1[(t2 >> 8) & 255] ^ Tinv2[(t1 >> 16) & 255] ^ Tinv3[t0 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r3 = Tinv0[r3 & 255] ^ Tinv1[(t2 >> 8) & 255] ^ Tinv2[(t1 >> 16) & 255] ^ Tinv3[t0 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r3 = Tinv0[r3 & 255] ^ Tinv1[(t2 >> 8) & 255] ^ Tinv2[(t1 >> 16) & 255] ^ Tinv3[t0 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r3 = Tinv0[r3 & 255] ^ Tinv1[(t2 >> 8) & 255] ^ Tinv2[(t1 >> 16) & 255] ^ Tinv3[t0 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: t0 = Tinv0[r0 & 255] ^ Tinv1[(r3 >> 8) & 255] ^ Tinv2[(r2 >> 16) & 255] ^ Tinv3[r1 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: t0 = Tinv0[r0 & 255] ^ Tinv1[(r3 >> 8) & 255] ^ Tinv2[(r2 >> 16) & 255] ^ Tinv3[r1 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: t0 = Tinv0[r0 & 255] ^ Tinv1[(r3 >> 8) & 255] ^ Tinv2[(r2 >> 16) & 255] ^ Tinv3[r1 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: t0 = Tinv0[r0 & 255] ^ Tinv1[(r3 >> 8) & 255] ^ Tinv2[(r2 >> 16) & 255] ^ Tinv3[r1 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: t0 = Tinv0[r0 & 255] ^ Tinv1[(r3 >> 8) & 255] ^ Tinv2[(r2 >> 16) & 255] ^ Tinv3[r1 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: t0 = Tinv0[r0 & 255] ^ Tinv1[(r3 >> 8) & 255] ^ Tinv2[(r2 >> 16) & 255] ^ Tinv3[r1 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: t1 = Tinv0[r1 & 255] ^ Tinv1[(r0 >> 8) & 255] ^ Tinv2[(r3 >> 16) & 255] ^ Tinv3[r2 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: t1 = Tinv0[r1 & 255] ^ Tinv1[(r0 >> 8) & 255] ^ Tinv2[(r3 >> 16) & 255] ^ Tinv3[r2 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: t1 = Tinv0[r1 & 255] ^ Tinv1[(r0 >> 8) & 255] ^ Tinv2[(r3 >> 16) & 255] ^ Tinv3[r2 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: t1 = Tinv0[r1 & 255] ^ Tinv1[(r0 >> 8) & 255] ^ Tinv2[(r3 >> 16) & 255] ^ Tinv3[r2 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: t1 = Tinv0[r1 & 255] ^ Tinv1[(r0 >> 8) & 255] ^ Tinv2[(r3 >> 16) & 255] ^ Tinv3[r2 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: t1 = Tinv0[r1 & 255] ^ Tinv1[(r0 >> 8) & 255] ^ Tinv2[(r3 >> 16) & 255] ^ Tinv3[r2 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: t2 = Tinv0[r2 & 255] ^ Tinv1[(r1 >> 8) & 255] ^ Tinv2[(r0 >> 16) & 255] ^ Tinv3[r3 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: t2 = Tinv0[r2 & 255] ^ Tinv1[(r1 >> 8) & 255] ^ Tinv2[(r0 >> 16) & 255] ^ Tinv3[r3 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: t2 = Tinv0[r2 & 255] ^ Tinv1[(r1 >> 8) & 255] ^ Tinv2[(r0 >> 16) & 255] ^ Tinv3[r3 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: t2 = Tinv0[r2 & 255] ^ Tinv1[(r1 >> 8) & 255] ^ Tinv2[(r0 >> 16) & 255] ^ Tinv3[r3 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: t2 = Tinv0[r2 & 255] ^ Tinv1[(r1 >> 8) & 255] ^ Tinv2[(r0 >> 16) & 255] ^ Tinv3[r3 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: t2 = Tinv0[r2 & 255] ^ Tinv1[(r1 >> 8) & 255] ^ Tinv2[(r0 >> 16) & 255] ^ Tinv3[r3 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: t2 = Tinv0[r2 & 255] ^ Tinv1[(r1 >> 8) & 255] ^ Tinv2[(r0 >> 16) & 255] ^ Tinv3[r3 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r3 = Tinv0[r3 & 255] ^ Tinv1[(r2 >> 8) & 255] ^ Tinv2[(r1 >> 16) & 255] ^ Tinv3[r0 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r3 = Tinv0[r3 & 255] ^ Tinv1[(r2 >> 8) & 255] ^ Tinv2[(r1 >> 16) & 255] ^ Tinv3[r0 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r3 = Tinv0[r3 & 255] ^ Tinv1[(r2 >> 8) & 255] ^ Tinv2[(r1 >> 16) & 255] ^ Tinv3[r0 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r3 = Tinv0[r3 & 255] ^ Tinv1[(r2 >> 8) & 255] ^ Tinv2[(r1 >> 16) & 255] ^ Tinv3[r0 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r3 = Tinv0[r3 & 255] ^ Tinv1[(r2 >> 8) & 255] ^ Tinv2[(r1 >> 16) & 255] ^ Tinv3[r0 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r3 = Tinv0[r3 & 255] ^ Tinv1[(r2 >> 8) & 255] ^ Tinv2[(r1 >> 16) & 255] ^ Tinv3[r0 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r3 = Tinv0[r3 & 255] ^ Tinv1[(r2 >> 8) & 255] ^ Tinv2[(r1 >> 16) & 255] ^ Tinv3[r0 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r0 = Tinv0[t0 & 255] ^ Tinv1[(r3 >> 8) & 255] ^ Tinv2[(t2 >> 16) & 255] ^ Tinv3[t1 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r0 = Tinv0[t0 & 255] ^ Tinv1[(r3 >> 8) & 255] ^ Tinv2[(t2 >> 16) & 255] ^ Tinv3[t1 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r0 = Tinv0[t0 & 255] ^ Tinv1[(r3 >> 8) & 255] ^ Tinv2[(t2 >> 16) & 255] ^ Tinv3[t1 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r0 = Tinv0[t0 & 255] ^ Tinv1[(r3 >> 8) & 255] ^ Tinv2[(t2 >> 16) & 255] ^ Tinv3[t1 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r0 = Tinv0[t0 & 255] ^ Tinv1[(r3 >> 8) & 255] ^ Tinv2[(t2 >> 16) & 255] ^ Tinv3[t1 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r0 = Tinv0[t0 & 255] ^ Tinv1[(r3 >> 8) & 255] ^ Tinv2[(t2 >> 16) & 255] ^ Tinv3[t1 >> 24] ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r1 = Tinv0[t1 & 255] ^ Tinv1[(t0 >> 8) & 255] ^ Tinv2[(r3 >> 16) & 255] ^ Tinv3[t2 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r1 = Tinv0[t1 & 255] ^ Tinv1[(t0 >> 8) & 255] ^ Tinv2[(r3 >> 16) & 255] ^ Tinv3[t2 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r1 = Tinv0[t1 & 255] ^ Tinv1[(t0 >> 8) & 255] ^ Tinv2[(r3 >> 16) & 255] ^ Tinv3[t2 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r1 = Tinv0[t1 & 255] ^ Tinv1[(t0 >> 8) & 255] ^ Tinv2[(r3 >> 16) & 255] ^ Tinv3[t2 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r1 = Tinv0[t1 & 255] ^ Tinv1[(t0 >> 8) & 255] ^ Tinv2[(r3 >> 16) & 255] ^ Tinv3[t2 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r1 = Tinv0[t1 & 255] ^ Tinv1[(t0 >> 8) & 255] ^ Tinv2[(r3 >> 16) & 255] ^ Tinv3[t2 >> 24] ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r2 = Tinv0[t2 & 255] ^ Tinv1[(t1 >> 8) & 255] ^ Tinv2[(t0 >> 16) & 255] ^ Tinv3[r3 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r2 = Tinv0[t2 & 255] ^ Tinv1[(t1 >> 8) & 255] ^ Tinv2[(t0 >> 16) & 255] ^ Tinv3[r3 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r2 = Tinv0[t2 & 255] ^ Tinv1[(t1 >> 8) & 255] ^ Tinv2[(t0 >> 16) & 255] ^ Tinv3[r3 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r2 = Tinv0[t2 & 255] ^ Tinv1[(t1 >> 8) & 255] ^ Tinv2[(t0 >> 16) & 255] ^ Tinv3[r3 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r2 = Tinv0[t2 & 255] ^ Tinv1[(t1 >> 8) & 255] ^ Tinv2[(t0 >> 16) & 255] ^ Tinv3[r3 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r2 = Tinv0[t2 & 255] ^ Tinv1[(t1 >> 8) & 255] ^ Tinv2[(t0 >> 16) & 255] ^ Tinv3[r3 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r2 = Tinv0[t2 & 255] ^ Tinv1[(t1 >> 8) & 255] ^ Tinv2[(t0 >> 16) & 255] ^ Tinv3[r3 >> 24] ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r3 = Tinv0[r3 & 255] ^ Tinv1[(t2 >> 8) & 255] ^ Tinv2[(t1 >> 16) & 255] ^ Tinv3[t0 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r3 = Tinv0[r3 & 255] ^ Tinv1[(t2 >> 8) & 255] ^ Tinv2[(t1 >> 16) & 255] ^ Tinv3[t0 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r3 = Tinv0[r3 & 255] ^ Tinv1[(t2 >> 8) & 255] ^ Tinv2[(t1 >> 16) & 255] ^ Tinv3[t0 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r3 = Tinv0[r3 & 255] ^ Tinv1[(t2 >> 8) & 255] ^ Tinv2[(t1 >> 16) & 255] ^ Tinv3[t0 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r3 = Tinv0[r3 & 255] ^ Tinv1[(t2 >> 8) & 255] ^ Tinv2[(t1 >> 16) & 255] ^ Tinv3[t0 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r3 = Tinv0[r3 & 255] ^ Tinv1[(t2 >> 8) & 255] ^ Tinv2[(t1 >> 16) & 255] ^ Tinv3[t0 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: r3 = Tinv0[r3 & 255] ^ Tinv1[(t2 >> 8) & 255] ^ Tinv2[(t1 >> 16) & 255] ^ Tinv3[t0 >> 24] ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C0 = (uint)Si[r0 & 255] ^ (((uint)Si[(r3 >> 8) & 255]) << 8) ^ (((uint)Si[(r2 >> 16) & 255]) << 16) ^ (((uint)Si[r1 >> 24]) << 24) ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C0 = (uint)Si[r0 & 255] ^ (((uint)Si[(r3 >> 8) & 255]) << 8) ^ (((uint)Si[(r2 >> 16) & 255]) << 16) ^ (((uint)Si[r1 >> 24]) << 24) ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C0 = (uint)Si[r0 & 255] ^ (((uint)Si[(r3 >> 8) & 255]) << 8) ^ (((uint)Si[(r2 >> 16) & 255]) << 16) ^ (((uint)Si[r1 >> 24]) << 24) ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C0 = (uint)Si[r0 & 255] ^ (((uint)Si[(r3 >> 8) & 255]) << 8) ^ (((uint)Si[(r2 >> 16) & 255]) << 16) ^ (((uint)Si[r1 >> 24]) << 24) ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C0 = (uint)Si[r0 & 255] ^ (((uint)Si[(r3 >> 8) & 255]) << 8) ^ (((uint)Si[(r2 >> 16) & 255]) << 16) ^ (((uint)Si[r1 >> 24]) << 24) ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C0 = (uint)Si[r0 & 255] ^ (((uint)Si[(r3 >> 8) & 255]) << 8) ^ (((uint)Si[(r2 >> 16) & 255]) << 16) ^ (((uint)Si[r1 >> 24]) << 24) ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C0 = (uint)Si[r0 & 255] ^ (((uint)Si[(r3 >> 8) & 255]) << 8) ^ (((uint)Si[(r2 >> 16) & 255]) << 16) ^ (((uint)Si[r1 >> 24]) << 24) ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C0 = (uint)Si[r0 & 255] ^ (((uint)Si[(r3 >> 8) & 255]) << 8) ^ (((uint)Si[(r2 >> 16) & 255]) << 16) ^ (((uint)Si[r1 >> 24]) << 24) ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C0 = (uint)Si[r0 & 255] ^ (((uint)Si[(r3 >> 8) & 255]) << 8) ^ (((uint)Si[(r2 >> 16) & 255]) << 16) ^ (((uint)Si[r1 >> 24]) << 24) ^ kw[0];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C1 = (uint)Si[r1 & 255] ^ (((uint)Si[(r0 >> 8) & 255]) << 8) ^ (((uint)Si[(r3 >> 16) & 255]) << 16) ^ (((uint)Si[r2 >> 24]) << 24) ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C1 = (uint)Si[r1 & 255] ^ (((uint)Si[(r0 >> 8) & 255]) << 8) ^ (((uint)Si[(r3 >> 16) & 255]) << 16) ^ (((uint)Si[r2 >> 24]) << 24) ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C1 = (uint)Si[r1 & 255] ^ (((uint)Si[(r0 >> 8) & 255]) << 8) ^ (((uint)Si[(r3 >> 16) & 255]) << 16) ^ (((uint)Si[r2 >> 24]) << 24) ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C1 = (uint)Si[r1 & 255] ^ (((uint)Si[(r0 >> 8) & 255]) << 8) ^ (((uint)Si[(r3 >> 16) & 255]) << 16) ^ (((uint)Si[r2 >> 24]) << 24) ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C1 = (uint)Si[r1 & 255] ^ (((uint)Si[(r0 >> 8) & 255]) << 8) ^ (((uint)Si[(r3 >> 16) & 255]) << 16) ^ (((uint)Si[r2 >> 24]) << 24) ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C1 = (uint)Si[r1 & 255] ^ (((uint)Si[(r0 >> 8) & 255]) << 8) ^ (((uint)Si[(r3 >> 16) & 255]) << 16) ^ (((uint)Si[r2 >> 24]) << 24) ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C1 = (uint)Si[r1 & 255] ^ (((uint)Si[(r0 >> 8) & 255]) << 8) ^ (((uint)Si[(r3 >> 16) & 255]) << 16) ^ (((uint)Si[r2 >> 24]) << 24) ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C1 = (uint)Si[r1 & 255] ^ (((uint)Si[(r0 >> 8) & 255]) << 8) ^ (((uint)Si[(r3 >> 16) & 255]) << 16) ^ (((uint)Si[r2 >> 24]) << 24) ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C1 = (uint)Si[r1 & 255] ^ (((uint)Si[(r0 >> 8) & 255]) << 8) ^ (((uint)Si[(r3 >> 16) & 255]) << 16) ^ (((uint)Si[r2 >> 24]) << 24) ^ kw[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C2 = (uint)Si[r2 & 255] ^ (((uint)Si[(r1 >> 8) & 255]) << 8) ^ (((uint)Si[(r0 >> 16) & 255]) << 16) ^ (((uint)Si[r3 >> 24]) << 24) ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C2 = (uint)Si[r2 & 255] ^ (((uint)Si[(r1 >> 8) & 255]) << 8) ^ (((uint)Si[(r0 >> 16) & 255]) << 16) ^ (((uint)Si[r3 >> 24]) << 24) ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C2 = (uint)Si[r2 & 255] ^ (((uint)Si[(r1 >> 8) & 255]) << 8) ^ (((uint)Si[(r0 >> 16) & 255]) << 16) ^ (((uint)Si[r3 >> 24]) << 24) ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C2 = (uint)Si[r2 & 255] ^ (((uint)Si[(r1 >> 8) & 255]) << 8) ^ (((uint)Si[(r0 >> 16) & 255]) << 16) ^ (((uint)Si[r3 >> 24]) << 24) ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C2 = (uint)Si[r2 & 255] ^ (((uint)Si[(r1 >> 8) & 255]) << 8) ^ (((uint)Si[(r0 >> 16) & 255]) << 16) ^ (((uint)Si[r3 >> 24]) << 24) ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C2 = (uint)Si[r2 & 255] ^ (((uint)Si[(r1 >> 8) & 255]) << 8) ^ (((uint)Si[(r0 >> 16) & 255]) << 16) ^ (((uint)Si[r3 >> 24]) << 24) ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C2 = (uint)Si[r2 & 255] ^ (((uint)Si[(r1 >> 8) & 255]) << 8) ^ (((uint)Si[(r0 >> 16) & 255]) << 16) ^ (((uint)Si[r3 >> 24]) << 24) ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C2 = (uint)Si[r2 & 255] ^ (((uint)Si[(r1 >> 8) & 255]) << 8) ^ (((uint)Si[(r0 >> 16) & 255]) << 16) ^ (((uint)Si[r3 >> 24]) << 24) ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C2 = (uint)Si[r2 & 255] ^ (((uint)Si[(r1 >> 8) & 255]) << 8) ^ (((uint)Si[(r0 >> 16) & 255]) << 16) ^ (((uint)Si[r3 >> 24]) << 24) ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C2 = (uint)Si[r2 & 255] ^ (((uint)Si[(r1 >> 8) & 255]) << 8) ^ (((uint)Si[(r0 >> 16) & 255]) << 16) ^ (((uint)Si[r3 >> 24]) << 24) ^ kw[2];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C3 = (uint)Si[r3 & 255] ^ (((uint)Si[(r2 >> 8) & 255]) << 8) ^ (((uint)Si[(r1 >> 16) & 255]) << 16) ^ (((uint)Si[r0 >> 24]) << 24) ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C3 = (uint)Si[r3 & 255] ^ (((uint)Si[(r2 >> 8) & 255]) << 8) ^ (((uint)Si[(r1 >> 16) & 255]) << 16) ^ (((uint)Si[r0 >> 24]) << 24) ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C3 = (uint)Si[r3 & 255] ^ (((uint)Si[(r2 >> 8) & 255]) << 8) ^ (((uint)Si[(r1 >> 16) & 255]) << 16) ^ (((uint)Si[r0 >> 24]) << 24) ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C3 = (uint)Si[r3 & 255] ^ (((uint)Si[(r2 >> 8) & 255]) << 8) ^ (((uint)Si[(r1 >> 16) & 255]) << 16) ^ (((uint)Si[r0 >> 24]) << 24) ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C3 = (uint)Si[r3 & 255] ^ (((uint)Si[(r2 >> 8) & 255]) << 8) ^ (((uint)Si[(r1 >> 16) & 255]) << 16) ^ (((uint)Si[r0 >> 24]) << 24) ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C3 = (uint)Si[r3 & 255] ^ (((uint)Si[(r2 >> 8) & 255]) << 8) ^ (((uint)Si[(r1 >> 16) & 255]) << 16) ^ (((uint)Si[r0 >> 24]) << 24) ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C3 = (uint)Si[r3 & 255] ^ (((uint)Si[(r2 >> 8) & 255]) << 8) ^ (((uint)Si[(r1 >> 16) & 255]) << 16) ^ (((uint)Si[r0 >> 24]) << 24) ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C3 = (uint)Si[r3 & 255] ^ (((uint)Si[(r2 >> 8) & 255]) << 8) ^ (((uint)Si[(r1 >> 16) & 255]) << 16) ^ (((uint)Si[r0 >> 24]) << 24) ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C3 = (uint)Si[r3 & 255] ^ (((uint)Si[(r2 >> 8) & 255]) << 8) ^ (((uint)Si[(r1 >> 16) & 255]) << 16) ^ (((uint)Si[r0 >> 24]) << 24) ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Engines,AesFastEngine,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\engines\AesFastEngine.cs,DecryptBlock,The following statement contains a magic number: this.C3 = (uint)Si[r3 & 255] ^ (((uint)Si[(r2 >> 8) & 255]) << 8) ^ (((uint)Si[(r1 >> 16) & 255]) << 16) ^ (((uint)Si[r0 >> 24]) << 24) ^ kw[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Paddings,PaddedBufferedBlockCipher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\paddings\PaddedBufferedBlockCipher.cs,DoFinal,The following statement contains a magic number: (outOff + 2 * blockSize) > output.Length
Magic Number,NBitcoin.BouncyCastle.Crypto.Signers,ECDsaSigner,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\signers\ECDsaSigner.cs,CalculateE,The following statement contains a magic number: int messageBitLength = message.Length * 8;
Magic Number,NBitcoin.BouncyCastle.Crypto.Signers,HMacDsaKCalculator,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\signers\HMacDsaKCalculator.cs,Init,The following statement contains a magic number: byte[] x = new byte[(n.BitLength + 7) / 8];
Magic Number,NBitcoin.BouncyCastle.Crypto.Signers,HMacDsaKCalculator,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\signers\HMacDsaKCalculator.cs,Init,The following statement contains a magic number: byte[] x = new byte[(n.BitLength + 7) / 8];
Magic Number,NBitcoin.BouncyCastle.Crypto.Signers,HMacDsaKCalculator,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\signers\HMacDsaKCalculator.cs,Init,The following statement contains a magic number: byte[] m = new byte[(n.BitLength + 7) / 8];
Magic Number,NBitcoin.BouncyCastle.Crypto.Signers,HMacDsaKCalculator,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\signers\HMacDsaKCalculator.cs,Init,The following statement contains a magic number: byte[] m = new byte[(n.BitLength + 7) / 8];
Magic Number,NBitcoin.BouncyCastle.Crypto.Signers,HMacDsaKCalculator,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\signers\HMacDsaKCalculator.cs,NextK,The following statement contains a magic number: byte[] t = new byte[((n.BitLength + 7) / 8)];
Magic Number,NBitcoin.BouncyCastle.Crypto.Signers,HMacDsaKCalculator,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\signers\HMacDsaKCalculator.cs,NextK,The following statement contains a magic number: byte[] t = new byte[((n.BitLength + 7) / 8)];
Magic Number,NBitcoin.BouncyCastle.Crypto.Signers,HMacDsaKCalculator,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\signers\HMacDsaKCalculator.cs,BitsToInt,The following statement contains a magic number: v = v.ShiftRight(t.Length * 8 - n.BitLength);
Magic Number,NBitcoin.BouncyCastle.Crypto.Signers,HMacDsaKCalculator,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\signers\HMacDsaKCalculator.cs,BitsToInt,The following statement contains a magic number: t.Length * 8 > n.BitLength
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt16_To_BE,The following statement contains a magic number: bs[0] = (byte)(n >> 8);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt16_To_BE,The following statement contains a magic number: bs[off] = (byte)(n >> 8);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,BE_To_UInt16,The following statement contains a magic number: uint n = (uint)bs[0] << 8 				| (uint)bs[1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,BE_To_UInt16,The following statement contains a magic number: uint n = (uint)bs[off] << 8 				| (uint)bs[off + 1];
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt32_To_BE,The following statement contains a magic number: byte[] bs = new byte[4];
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt32_To_BE,The following statement contains a magic number: bs[0] = (byte)(n >> 24);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt32_To_BE,The following statement contains a magic number: bs[1] = (byte)(n >> 16);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt32_To_BE,The following statement contains a magic number: bs[2] = (byte)(n >> 8);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt32_To_BE,The following statement contains a magic number: bs[2] = (byte)(n >> 8);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt32_To_BE,The following statement contains a magic number: bs[3] = (byte)(n);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt32_To_BE,The following statement contains a magic number: bs[off] = (byte)(n >> 24);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt32_To_BE,The following statement contains a magic number: bs[off + 1] = (byte)(n >> 16);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt32_To_BE,The following statement contains a magic number: bs[off + 2] = (byte)(n >> 8);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt32_To_BE,The following statement contains a magic number: bs[off + 2] = (byte)(n >> 8);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt32_To_BE,The following statement contains a magic number: bs[off + 3] = (byte)(n);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt32_To_BE,The following statement contains a magic number: byte[] bs = new byte[4 * ns.Length];
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt32_To_BE,The following statement contains a magic number: off += 4;
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,BE_To_UInt32,The following statement contains a magic number: return (uint)bs[0] << 24 				| (uint)bs[1] << 16 				| (uint)bs[2] << 8 				| (uint)bs[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,BE_To_UInt32,The following statement contains a magic number: return (uint)bs[0] << 24 				| (uint)bs[1] << 16 				| (uint)bs[2] << 8 				| (uint)bs[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,BE_To_UInt32,The following statement contains a magic number: return (uint)bs[0] << 24 				| (uint)bs[1] << 16 				| (uint)bs[2] << 8 				| (uint)bs[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,BE_To_UInt32,The following statement contains a magic number: return (uint)bs[0] << 24 				| (uint)bs[1] << 16 				| (uint)bs[2] << 8 				| (uint)bs[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,BE_To_UInt32,The following statement contains a magic number: return (uint)bs[0] << 24 				| (uint)bs[1] << 16 				| (uint)bs[2] << 8 				| (uint)bs[3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,BE_To_UInt32,The following statement contains a magic number: return (uint)bs[off] << 24 				| (uint)bs[off + 1] << 16 				| (uint)bs[off + 2] << 8 				| (uint)bs[off + 3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,BE_To_UInt32,The following statement contains a magic number: return (uint)bs[off] << 24 				| (uint)bs[off + 1] << 16 				| (uint)bs[off + 2] << 8 				| (uint)bs[off + 3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,BE_To_UInt32,The following statement contains a magic number: return (uint)bs[off] << 24 				| (uint)bs[off + 1] << 16 				| (uint)bs[off + 2] << 8 				| (uint)bs[off + 3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,BE_To_UInt32,The following statement contains a magic number: return (uint)bs[off] << 24 				| (uint)bs[off + 1] << 16 				| (uint)bs[off + 2] << 8 				| (uint)bs[off + 3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,BE_To_UInt32,The following statement contains a magic number: return (uint)bs[off] << 24 				| (uint)bs[off + 1] << 16 				| (uint)bs[off + 2] << 8 				| (uint)bs[off + 3];
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,BE_To_UInt32,The following statement contains a magic number: off += 4;
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt64_To_BE,The following statement contains a magic number: byte[] bs = new byte[8];
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt64_To_BE,The following statement contains a magic number: UInt32_To_BE((uint)(n >> 32)' bs);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt64_To_BE,The following statement contains a magic number: UInt32_To_BE((uint)(n)' bs' 4);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt64_To_BE,The following statement contains a magic number: UInt32_To_BE((uint)(n >> 32)' bs' off);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt64_To_BE,The following statement contains a magic number: UInt32_To_BE((uint)(n)' bs' off + 4);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt64_To_BE,The following statement contains a magic number: byte[] bs = new byte[8 * ns.Length];
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt64_To_BE,The following statement contains a magic number: off += 8;
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,BE_To_UInt64,The following statement contains a magic number: uint lo = BE_To_UInt32(bs' 4);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,BE_To_UInt64,The following statement contains a magic number: return ((ulong)hi << 32) | (ulong)lo;
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,BE_To_UInt64,The following statement contains a magic number: uint lo = BE_To_UInt32(bs' off + 4);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,BE_To_UInt64,The following statement contains a magic number: return ((ulong)hi << 32) | (ulong)lo;
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,BE_To_UInt64,The following statement contains a magic number: off += 8;
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt16_To_LE,The following statement contains a magic number: bs[1] = (byte)(n >> 8);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt16_To_LE,The following statement contains a magic number: bs[off + 1] = (byte)(n >> 8);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,LE_To_UInt16,The following statement contains a magic number: uint n = (uint)bs[0] 				| (uint)bs[1] << 8;
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,LE_To_UInt16,The following statement contains a magic number: uint n = (uint)bs[off] 				| (uint)bs[off + 1] << 8;
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt32_To_LE,The following statement contains a magic number: byte[] bs = new byte[4];
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt32_To_LE,The following statement contains a magic number: bs[1] = (byte)(n >> 8);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt32_To_LE,The following statement contains a magic number: bs[2] = (byte)(n >> 16);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt32_To_LE,The following statement contains a magic number: bs[2] = (byte)(n >> 16);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt32_To_LE,The following statement contains a magic number: bs[3] = (byte)(n >> 24);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt32_To_LE,The following statement contains a magic number: bs[3] = (byte)(n >> 24);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt32_To_LE,The following statement contains a magic number: bs[off + 1] = (byte)(n >> 8);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt32_To_LE,The following statement contains a magic number: bs[off + 2] = (byte)(n >> 16);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt32_To_LE,The following statement contains a magic number: bs[off + 2] = (byte)(n >> 16);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt32_To_LE,The following statement contains a magic number: bs[off + 3] = (byte)(n >> 24);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt32_To_LE,The following statement contains a magic number: bs[off + 3] = (byte)(n >> 24);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt32_To_LE,The following statement contains a magic number: byte[] bs = new byte[4 * ns.Length];
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt32_To_LE,The following statement contains a magic number: off += 4;
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,LE_To_UInt32,The following statement contains a magic number: return (uint)bs[0] 				| (uint)bs[1] << 8 				| (uint)bs[2] << 16 				| (uint)bs[3] << 24;
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,LE_To_UInt32,The following statement contains a magic number: return (uint)bs[0] 				| (uint)bs[1] << 8 				| (uint)bs[2] << 16 				| (uint)bs[3] << 24;
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,LE_To_UInt32,The following statement contains a magic number: return (uint)bs[0] 				| (uint)bs[1] << 8 				| (uint)bs[2] << 16 				| (uint)bs[3] << 24;
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,LE_To_UInt32,The following statement contains a magic number: return (uint)bs[0] 				| (uint)bs[1] << 8 				| (uint)bs[2] << 16 				| (uint)bs[3] << 24;
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,LE_To_UInt32,The following statement contains a magic number: return (uint)bs[0] 				| (uint)bs[1] << 8 				| (uint)bs[2] << 16 				| (uint)bs[3] << 24;
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,LE_To_UInt32,The following statement contains a magic number: return (uint)bs[off] 				| (uint)bs[off + 1] << 8 				| (uint)bs[off + 2] << 16 				| (uint)bs[off + 3] << 24;
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,LE_To_UInt32,The following statement contains a magic number: return (uint)bs[off] 				| (uint)bs[off + 1] << 8 				| (uint)bs[off + 2] << 16 				| (uint)bs[off + 3] << 24;
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,LE_To_UInt32,The following statement contains a magic number: return (uint)bs[off] 				| (uint)bs[off + 1] << 8 				| (uint)bs[off + 2] << 16 				| (uint)bs[off + 3] << 24;
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,LE_To_UInt32,The following statement contains a magic number: return (uint)bs[off] 				| (uint)bs[off + 1] << 8 				| (uint)bs[off + 2] << 16 				| (uint)bs[off + 3] << 24;
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,LE_To_UInt32,The following statement contains a magic number: return (uint)bs[off] 				| (uint)bs[off + 1] << 8 				| (uint)bs[off + 2] << 16 				| (uint)bs[off + 3] << 24;
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,LE_To_UInt32,The following statement contains a magic number: off += 4;
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,LE_To_UInt32,The following statement contains a magic number: bOff += 4;
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,LE_To_UInt32,The following statement contains a magic number: off += 4;
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt64_To_LE,The following statement contains a magic number: byte[] bs = new byte[8];
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt64_To_LE,The following statement contains a magic number: UInt32_To_LE((uint)(n >> 32)' bs' 4);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt64_To_LE,The following statement contains a magic number: UInt32_To_LE((uint)(n >> 32)' bs' 4);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt64_To_LE,The following statement contains a magic number: UInt32_To_LE((uint)(n >> 32)' bs' off + 4);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,UInt64_To_LE,The following statement contains a magic number: UInt32_To_LE((uint)(n >> 32)' bs' off + 4);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,LE_To_UInt64,The following statement contains a magic number: uint hi = LE_To_UInt32(bs' 4);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,LE_To_UInt64,The following statement contains a magic number: return ((ulong)hi << 32) | (ulong)lo;
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,LE_To_UInt64,The following statement contains a magic number: uint hi = LE_To_UInt32(bs' off + 4);
Magic Number,NBitcoin.BouncyCastle.Crypto.Utilities,Pack,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\crypto\util\Pack.cs,LE_To_UInt64,The following statement contains a magic number: return ((ulong)hi << 32) | (ulong)lo;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BigInteger,The following statement contains a magic number: Two = SMALL_CONSTANTS[2];
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BigInteger,The following statement contains a magic number: Three = SMALL_CONSTANTS[3];
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BigInteger,The following statement contains a magic number: Ten = SMALL_CONSTANTS[10];
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BigInteger,The following statement contains a magic number: radix2 = ValueOf(2);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BigInteger,The following statement contains a magic number: radix8 = ValueOf(8);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BigInteger,The following statement contains a magic number: radix10 = ValueOf(10);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BigInteger,The following statement contains a magic number: radix16 = ValueOf(16);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (radix)  			{  				case 2:  					// Is there anyway to restrict to binary digits?  					style = NumberStyles.Integer;  					chunk = chunk2;  					r = radix2;  					rE = radix2E;  					break;  				case 8:  					// Is there anyway to restrict to octal digits?  					style = NumberStyles.Integer;  					chunk = chunk8;  					r = radix8;  					rE = radix8E;  					break;  				case 10:  					// This style seems to handle spaces and minus sign already (our processing redundant?)  					style = NumberStyles.Integer;  					chunk = chunk10;  					r = radix10;  					rE = radix10E;  					break;  				case 16:  					// TODO Should this be HexNumber?  					style = NumberStyles.AllowHexSpecifier;  					chunk = chunk16;  					r = radix16;  					rE = radix16E;  					break;  				default:  					throw new FormatException("Only bases 2' 8' 10' or 16 allowed");  			}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (radix)  			{  				case 2:  					// Is there anyway to restrict to binary digits?  					style = NumberStyles.Integer;  					chunk = chunk2;  					r = radix2;  					rE = radix2E;  					break;  				case 8:  					// Is there anyway to restrict to octal digits?  					style = NumberStyles.Integer;  					chunk = chunk8;  					r = radix8;  					rE = radix8E;  					break;  				case 10:  					// This style seems to handle spaces and minus sign already (our processing redundant?)  					style = NumberStyles.Integer;  					chunk = chunk10;  					r = radix10;  					rE = radix10E;  					break;  				case 16:  					// TODO Should this be HexNumber?  					style = NumberStyles.AllowHexSpecifier;  					chunk = chunk16;  					r = radix16;  					rE = radix16E;  					break;  				default:  					throw new FormatException("Only bases 2' 8' 10' or 16 allowed");  			}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (radix)  			{  				case 2:  					// Is there anyway to restrict to binary digits?  					style = NumberStyles.Integer;  					chunk = chunk2;  					r = radix2;  					rE = radix2E;  					break;  				case 8:  					// Is there anyway to restrict to octal digits?  					style = NumberStyles.Integer;  					chunk = chunk8;  					r = radix8;  					rE = radix8E;  					break;  				case 10:  					// This style seems to handle spaces and minus sign already (our processing redundant?)  					style = NumberStyles.Integer;  					chunk = chunk10;  					r = radix10;  					rE = radix10E;  					break;  				case 16:  					// TODO Should this be HexNumber?  					style = NumberStyles.AllowHexSpecifier;  					chunk = chunk16;  					r = radix16;  					rE = radix16E;  					break;  				default:  					throw new FormatException("Only bases 2' 8' 10' or 16 allowed");  			}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (radix)  			{  				case 2:  					// Is there anyway to restrict to binary digits?  					style = NumberStyles.Integer;  					chunk = chunk2;  					r = radix2;  					rE = radix2E;  					break;  				case 8:  					// Is there anyway to restrict to octal digits?  					style = NumberStyles.Integer;  					chunk = chunk8;  					r = radix8;  					rE = radix8E;  					break;  				case 10:  					// This style seems to handle spaces and minus sign already (our processing redundant?)  					style = NumberStyles.Integer;  					chunk = chunk10;  					r = radix10;  					rE = radix10E;  					break;  				case 16:  					// TODO Should this be HexNumber?  					style = NumberStyles.AllowHexSpecifier;  					chunk = chunk16;  					r = radix16;  					rE = radix16E;  					break;  				default:  					throw new FormatException("Only bases 2' 8' 10' or 16 allowed");  			}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (radix)  					{  						case 2:  							// TODO Need this because we are parsing in radix 10 above  							if (i >= 2)  								throw new FormatException("Bad character in radix 2 string: " + s);    							// TODO Parse 64 bits at a time  							b = b.ShiftLeft(1);  							break;  						case 8:  							// TODO Need this because we are parsing in radix 10 above  							if (i >= 8)  								throw new FormatException("Bad character in radix 8 string: " + s);    							// TODO Parse 63 bits at a time  							b = b.ShiftLeft(3);  							break;  						case 16:  							b = b.ShiftLeft(64);  							break;  						default:  							b = b.Multiply(rE);  							break;  					}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (radix)  					{  						case 2:  							// TODO Need this because we are parsing in radix 10 above  							if (i >= 2)  								throw new FormatException("Bad character in radix 2 string: " + s);    							// TODO Parse 64 bits at a time  							b = b.ShiftLeft(1);  							break;  						case 8:  							// TODO Need this because we are parsing in radix 10 above  							if (i >= 8)  								throw new FormatException("Bad character in radix 8 string: " + s);    							// TODO Parse 63 bits at a time  							b = b.ShiftLeft(3);  							break;  						case 16:  							b = b.ShiftLeft(64);  							break;  						default:  							b = b.Multiply(rE);  							break;  					}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (radix)  					{  						case 2:  							// TODO Need this because we are parsing in radix 10 above  							if (i >= 2)  								throw new FormatException("Bad character in radix 2 string: " + s);    							// TODO Parse 64 bits at a time  							b = b.ShiftLeft(1);  							break;  						case 8:  							// TODO Need this because we are parsing in radix 10 above  							if (i >= 8)  								throw new FormatException("Bad character in radix 8 string: " + s);    							// TODO Parse 63 bits at a time  							b = b.ShiftLeft(3);  							break;  						case 16:  							b = b.ShiftLeft(64);  							break;  						default:  							b = b.Multiply(rE);  							break;  					}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (radix)  					{  						case 2:  							// TODO Need this because we are parsing in radix 10 above  							if (i >= 2)  								throw new FormatException("Bad character in radix 2 string: " + s);    							// TODO Parse 64 bits at a time  							b = b.ShiftLeft(1);  							break;  						case 8:  							// TODO Need this because we are parsing in radix 10 above  							if (i >= 8)  								throw new FormatException("Bad character in radix 8 string: " + s);    							// TODO Parse 63 bits at a time  							b = b.ShiftLeft(3);  							break;  						case 16:  							b = b.ShiftLeft(64);  							break;  						default:  							b = b.Multiply(rE);  							break;  					}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (radix)  					{  						case 2:  							// TODO Need this because we are parsing in radix 10 above  							if (i >= 2)  								throw new FormatException("Bad character in radix 2 string: " + s);    							// TODO Parse 64 bits at a time  							b = b.ShiftLeft(1);  							break;  						case 8:  							// TODO Need this because we are parsing in radix 10 above  							if (i >= 8)  								throw new FormatException("Bad character in radix 8 string: " + s);    							// TODO Parse 63 bits at a time  							b = b.ShiftLeft(3);  							break;  						case 16:  							b = b.ShiftLeft(64);  							break;  						default:  							b = b.Multiply(rE);  							break;  					}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (radix)  					{  						case 2:  							// TODO Need this because we are parsing in radix 10 above  							if (i >= 2)  								throw new FormatException("Bad character in radix 2 string: " + s);    							// TODO Parse 64 bits at a time  							b = b.ShiftLeft(1);  							break;  						case 8:  							// TODO Need this because we are parsing in radix 10 above  							if (i >= 8)  								throw new FormatException("Bad character in radix 8 string: " + s);    							// TODO Parse 63 bits at a time  							b = b.ShiftLeft(3);  							break;  						case 16:  							b = b.ShiftLeft(64);  							break;  						default:  							b = b.Multiply(rE);  							break;  					}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (radix)  					{  						case 2:  							// TODO Need this because we are parsing in radix 10 above  							if (i >= 2)  								throw new FormatException("Bad character in radix 2 string: " + s);    							// TODO Parse 64 bits at a time  							b = b.ShiftLeft(1);  							break;  						case 8:  							// TODO Need this because we are parsing in radix 10 above  							if (i >= 8)  								throw new FormatException("Bad character in radix 8 string: " + s);    							// TODO Parse 63 bits at a time  							b = b.ShiftLeft(3);  							break;  						case 16:  							b = b.ShiftLeft(64);  							break;  						default:  							b = b.Multiply(rE);  							break;  					}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BigInteger,The following statement contains a magic number: radix == 2
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,MakeMagnitude,The following statement contains a magic number: int nInts = (end - firstSignificant + 3) / BytesPerInt;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,MakeMagnitude,The following statement contains a magic number: v <<= 8;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BigInteger,The following statement contains a magic number: b[0] &= (byte)(255U >> xBits);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BigInteger,The following statement contains a magic number: bitLength < 2
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BigInteger,The following statement contains a magic number: this.magnitude = random.Next(2) == 0  					? Two.magnitude  					: Three.magnitude;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BigInteger,The following statement contains a magic number: bitLength == 2
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BigInteger,The following statement contains a magic number: byte mask = (byte)(255U >> xBits);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BigInteger,The following statement contains a magic number: byte lead = (byte)(1 << (7 - xBits));
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,AddMagnitudes,The following statement contains a magic number: m = (long)((ulong)m >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BitCnt,The following statement contains a magic number: u = (u & 0x33333333) + ((u >> 2) & 0x33333333);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BitCnt,The following statement contains a magic number: u = (u + (u >> 4)) & 0x0f0f0f0f;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BitCnt,The following statement contains a magic number: u += (u >> 8);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BitCnt,The following statement contains a magic number: u += (u >> 16);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,CalcBitLength,The following statement contains a magic number: int bitLength = 32 * ((mag.Length - indx) - 1);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BitLen,The following statement contains a magic number: uint t = v >> 24;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BitLen,The following statement contains a magic number: return 24 + BitLengthTable[t];
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BitLen,The following statement contains a magic number: t = v >> 16;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BitLen,The following statement contains a magic number: return 16 + BitLengthTable[t];
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BitLen,The following statement contains a magic number: t = v >> 8;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,BitLen,The following statement contains a magic number: return 8 + BitLengthTable[t];
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,Divide,The following statement contains a magic number: iCount = new int[(shift >> 5) + 1];
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,Divide,The following statement contains a magic number: iCount[0] = 1 << (shift % 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,Divide,The following statement contains a magic number: xBitLength = 32 * (x.Length - xStart - 1) + BitLen(x[xStart]);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,Divide,The following statement contains a magic number: shift < 2
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,DivideAndRemainder,The following statement contains a magic number: BigInteger[] biggies = new BigInteger[2];
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,CheckProbablePrime,The following statement contains a magic number: return BitLength < 16 && IntValue == prime;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,RabinMillerTest,The following statement contains a magic number: Debug.Assert(bits > 2);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,RabinMillerTest,The following statement contains a magic number: int iterations = ((certainty - 1) / 2) + 1;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,RabinMillerTest,The following statement contains a magic number: int itersFor100Cert = bits >= 1024 ? 4  									: bits >= 512 ? 8  									: bits >= 256 ? 16  									: 50;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,RabinMillerTest,The following statement contains a magic number: int itersFor100Cert = bits >= 1024 ? 4  									: bits >= 512 ? 8  									: bits >= 256 ? 16  									: 50;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,RabinMillerTest,The following statement contains a magic number: int itersFor100Cert = bits >= 1024 ? 4  									: bits >= 512 ? 8  									: bits >= 256 ? 16  									: 50;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,RabinMillerTest,The following statement contains a magic number: int itersFor100Cert = bits >= 1024 ? 4  									: bits >= 512 ? 8  									: bits >= 256 ? 16  									: 50;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,RabinMillerTest,The following statement contains a magic number: int itersFor100Cert = bits >= 1024 ? 4  									: bits >= 512 ? 8  									: bits >= 256 ? 16  									: 50;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,RabinMillerTest,The following statement contains a magic number: int itersFor100Cert = bits >= 1024 ? 4  									: bits >= 512 ? 8  									: bits >= 256 ? 16  									: 50;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,RabinMillerTest,The following statement contains a magic number: int itersFor100Cert = bits >= 1024 ? 4  									: bits >= 512 ? 8  									: bits >= 256 ? 16  									: 50;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,RabinMillerTest,The following statement contains a magic number: certainty < 100
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,RabinMillerTest,The following statement contains a magic number: BigInteger montRadix = One.ShiftLeft(32 * n.magnitude.Length).Remainder(n);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,Jacobi,The following statement contains a magic number: (e & 1) != 0 && ((bLsw & 7) == 3 || (bLsw & 7) == 5)
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,Jacobi,The following statement contains a magic number: (e & 1) != 0 && ((bLsw & 7) == 3 || (bLsw & 7) == 5)
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,Jacobi,The following statement contains a magic number: (e & 1) != 0 && ((bLsw & 7) == 3 || (bLsw & 7) == 5)
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,Jacobi,The following statement contains a magic number: (e & 1) != 0 && ((bLsw & 7) == 3 || (bLsw & 7) == 5)
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,Jacobi,The following statement contains a magic number: (bLsw & 3) == 3 && (a1Lsw & 3) == 3
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,Jacobi,The following statement contains a magic number: (bLsw & 3) == 3 && (a1Lsw & 3) == 3
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,Jacobi,The following statement contains a magic number: (bLsw & 3) == 3 && (a1Lsw & 3) == 3
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,Jacobi,The following statement contains a magic number: (bLsw & 3) == 3 && (a1Lsw & 3) == 3
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ModInversePow2,The following statement contains a magic number: pow < 64
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ModInversePow2,The following statement contains a magic number: int bitsCorrect = 64;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ModInversePow2,The following statement contains a magic number: pow > 64
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ModInverse32,The following statement contains a magic number: int x = d + (((d + 1) & 4) << 1);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ModInverse32,The following statement contains a magic number: Debug.Assert(((d * x) & 15) == 1);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ModInverse32,The following statement contains a magic number: x *= 2 - d * x;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ModInverse32,The following statement contains a magic number: x *= 2 - d * x;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ModInverse32,The following statement contains a magic number: x *= 2 - d * x;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ModInverse64,The following statement contains a magic number: long x = d + (((d + 1L) & 4L) << 1);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ModInverse64,The following statement contains a magic number: Debug.Assert(((d * x) & 15L) == 1L);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ModInverse64,The following statement contains a magic number: x *= 2 - d * x;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ModInverse64,The following statement contains a magic number: x *= 2 - d * x;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ModInverse64,The following statement contains a magic number: x *= 2 - d * x;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ModInverse64,The following statement contains a magic number: x *= 2 - d * x;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ModPowBarrett,The following statement contains a magic number: BigInteger mr = One.ShiftLeft((k + 1) << 5);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ModPowBarrett,The following statement contains a magic number: BigInteger yu = One.ShiftLeft(k << 6).Divide(m);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ModPowBarrett,The following statement contains a magic number: int mult = window & 0xFF' lastZeroes = window >> 8;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ModPowBarrett,The following statement contains a magic number: lastZeroes = window >> 8;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ModPowMonty,The following statement contains a magic number: int powR = 32 * n;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ModPowMonty,The following statement contains a magic number: bool smallMontyModulus = m.BitLength + 2 <= powR;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ModPowMonty,The following statement contains a magic number: e.magnitude.Length > 1 || e.BitCount > 2
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ModPowMonty,The following statement contains a magic number: int mult = window & 0xFF' lastZeroes = window >> 8;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ModPowMonty,The following statement contains a magic number: lastZeroes = window >> 8;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,GetWindowList,The following statement contains a magic number: int resultSize = (((mag.Length - 1) << 5) + leadingBits) / (1 + extraBits) + 2;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,GetWindowList,The following statement contains a magic number: int resultSize = (((mag.Length - 1) << 5) + leadingBits) / (1 + extraBits) + 2;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,GetWindowList,The following statement contains a magic number: int bitPos = 33 - leadingBits;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,GetWindowList,The following statement contains a magic number: mult = (mult << 1) | (int)((uint)v >> 31);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,GetWindowList,The following statement contains a magic number: bitPos < 32
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,CreateWindowEntry,The following statement contains a magic number: return mult | (zeroes << 8);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,Square,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,Square,The following statement contains a magic number: c = (c >> 32) + (prod >> 31);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,Square,The following statement contains a magic number: c = (c >> 32) + (prod >> 31);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,Square,The following statement contains a magic number: w[wBase] = (int)(c >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,Square,The following statement contains a magic number: w[wBase] += (int)(c >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,Multiply,The following statement contains a magic number: val = (long)((ulong)val >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,MontgomeryReduce,The following statement contains a magic number: carry >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,MontgomeryReduce,The following statement contains a magic number: carry >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,MontgomeryReduce,The following statement contains a magic number: Debug.Assert(carry >> 32 == 0);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,MultiplyMonty,The following statement contains a magic number: carry = (carry >> 32) + (prod2 >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,MultiplyMonty,The following statement contains a magic number: carry = (carry >> 32) + (prod2 >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,MultiplyMonty,The following statement contains a magic number: a[j + 2] = (int)carry;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,MultiplyMonty,The following statement contains a magic number: carry = (carry >> 32) + (prod1 >> 32) + (prod2 >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,MultiplyMonty,The following statement contains a magic number: carry = (carry >> 32) + (prod1 >> 32) + (prod2 >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,MultiplyMonty,The following statement contains a magic number: carry = (carry >> 32) + (prod1 >> 32) + (prod2 >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,MultiplyMonty,The following statement contains a magic number: aMax = (int)(carry >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,MultiplyMonty,The following statement contains a magic number: carry = (carry >> 32) + (prod1 >> 32) + (prod2 >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,MultiplyMonty,The following statement contains a magic number: carry = (carry >> 32) + (prod1 >> 32) + (prod2 >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,MultiplyMonty,The following statement contains a magic number: carry = (carry >> 32) + (prod1 >> 32) + (prod2 >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,MultiplyMonty,The following statement contains a magic number: a[j + 2] = (int)carry;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,MultiplyMonty,The following statement contains a magic number: carry = (carry >> 32) + (prod1 >> 32) + (prod2 >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,MultiplyMonty,The following statement contains a magic number: carry = (carry >> 32) + (prod1 >> 32) + (prod2 >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,MultiplyMonty,The following statement contains a magic number: carry = (carry >> 32) + (prod1 >> 32) + (prod2 >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,MultiplyMonty,The following statement contains a magic number: aMax = (int)(carry >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,SquareMonty,The following statement contains a magic number: carry = (carry >> 32) + (prod2 >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,SquareMonty,The following statement contains a magic number: carry = (carry >> 32) + (prod2 >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,SquareMonty,The following statement contains a magic number: a[j + 2] = (int)carry;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,SquareMonty,The following statement contains a magic number: carry = (carry >> 32) + (prod1 >> 31) + (prod2 >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,SquareMonty,The following statement contains a magic number: carry = (carry >> 32) + (prod1 >> 31) + (prod2 >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,SquareMonty,The following statement contains a magic number: carry = (carry >> 32) + (prod1 >> 31) + (prod2 >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,SquareMonty,The following statement contains a magic number: aMax = (int)(carry >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,SquareMonty,The following statement contains a magic number: carry >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,SquareMonty,The following statement contains a magic number: a[j + 2] = (int)carry;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,SquareMonty,The following statement contains a magic number: carry >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,SquareMonty,The following statement contains a magic number: a[i + 2] = (int)carry;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,SquareMonty,The following statement contains a magic number: carry = (carry >> 32) + (prod1 >> 32) + (prod2 >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,SquareMonty,The following statement contains a magic number: carry = (carry >> 32) + (prod1 >> 32) + (prod2 >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,SquareMonty,The following statement contains a magic number: carry = (carry >> 32) + (prod1 >> 32) + (prod2 >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,SquareMonty,The following statement contains a magic number: a[j + 2] = (int)carry;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,SquareMonty,The following statement contains a magic number: carry = (carry >> 32) + (prod1 >> 31) + (prod2 >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,SquareMonty,The following statement contains a magic number: carry = (carry >> 32) + (prod1 >> 31) + (prod2 >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,SquareMonty,The following statement contains a magic number: carry = (carry >> 32) + (prod1 >> 31) + (prod2 >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,SquareMonty,The following statement contains a magic number: aMax = (int)(carry >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,MultiplyMontyNIsOne,The following statement contains a magic number: carry = (carry >> 32) + (prod2 >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,MultiplyMontyNIsOne,The following statement contains a magic number: carry = (carry >> 32) + (prod2 >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,Square,The following statement contains a magic number: (uint)magnitude[0] >> 16 == 0
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,NextProbablePrime,The following statement contains a magic number: !n.CheckProbablePrime(100' RandomSource' false)
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ProbablePrime,The following statement contains a magic number: return new BigInteger(bitLength' 100' random);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,Remainder,The following statement contains a magic number: acc = (acc << 32 | posVal) % m;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,Remainder,The following statement contains a magic number: xBitLength = 32 * (x.Length - xStart - 1) + BitLen(x[xStart]);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,Remainder,The following statement contains a magic number: shift < 2
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,LastNBits,The following statement contains a magic number: int excessBits = (numWords << 5) - n;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ShiftLeft,The following statement contains a magic number: int nInts = (int)((uint)n >> 5);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ShiftLeftOneInPlace,The following statement contains a magic number: carry = (int)(val >> 31);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ShiftRightInPlace,The following statement contains a magic number: int nInts = (int)((uint)n >> 5) + start;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ShiftRightInPlace,The following statement contains a magic number: int nBits2 = 32 - nBits;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ShiftRightOneInPlace,The following statement contains a magic number: mag[i] = ((int)((uint)m >> 1)) | (next << 31);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ShiftRight,The following statement contains a magic number: int resultLength = (BitLength - n + 31) >> 5;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ShiftRight,The following statement contains a magic number: int resultLength = (BitLength - n + 31) >> 5;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ShiftRight,The following statement contains a magic number: int numInts = n >> 5;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ShiftRight,The following statement contains a magic number: int numBits = n & 31;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,Subtract,The following statement contains a magic number: borrow = (int)(m >> 63);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToByteArray,The following statement contains a magic number: bytes[--bytesIndex] = (byte)(mag >> 8);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToByteArray,The following statement contains a magic number: bytes[--bytesIndex] = (byte)(mag >> 16);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToByteArray,The following statement contains a magic number: bytes[--bytesIndex] = (byte)(mag >> 24);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToByteArray,The following statement contains a magic number: lastMag >>= 8;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToString,The following statement contains a magic number: return ToString(10);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToString,The following statement contains a magic number: switch (radix)  			{  				case 2:  				case 8:  				case 10:  				case 16:  					break;  				default:  					throw new FormatException("Only bases 2' 8' 10' 16 are allowed");  			}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToString,The following statement contains a magic number: switch (radix)  			{  				case 2:  				case 8:  				case 10:  				case 16:  					break;  				default:  					throw new FormatException("Only bases 2' 8' 10' 16 are allowed");  			}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToString,The following statement contains a magic number: switch (radix)  			{  				case 2:  				case 8:  				case 10:  				case 16:  					break;  				default:  					throw new FormatException("Only bases 2' 8' 10' 16 are allowed");  			}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToString,The following statement contains a magic number: switch (radix)  			{  				case 2:  				case 8:  				case 10:  				case 16:  					break;  				default:  					throw new FormatException("Only bases 2' 8' 10' 16 are allowed");  			}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToString,The following statement contains a magic number: switch (radix)  			{  				case 2:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 2));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 2)' 32);  						}  						break;  					}  				case 8:  					{  						int mask = (1 << 30) - 1;  						BigInteger u = this.Abs();  						int bits = u.BitLength;  						IList S = Platform.CreateArrayList();  						while (bits > 30)  						{  							S.Add(Convert.ToString(u.IntValue & mask' 8));  							u = u.ShiftRight(30);  							bits -= 30;  						}  						sb.Append(Convert.ToString(u.IntValue' 8));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' 10);  						}  						break;  					}  				case 16:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 16));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 16)' 8);  						}  						break;  					}  				// TODO This could work for other radices if there is an alternative to Convert.ToString method  				//default:  				case 10:  					{  						BigInteger q = this.Abs();  						if (q.BitLength < 64)  						{  							sb.Append(Convert.ToString(q.LongValue' radix));  							break;  						}    						// Based on algorithm 1a from chapter 4.4 in Seminumerical Algorithms (Knuth)    						// Work out the largest power of 'rdx' that is a positive 64-bit integer  						// TODO possibly cache power/exponent against radix?  						long limit = Int64.MaxValue / radix;  						long power = radix;  						int exponent = 1;  						while (power <= limit)  						{  							power *= radix;  							++exponent;  						}    						BigInteger bigPower = BigInteger.ValueOf(power);    						IList S = Platform.CreateArrayList();  						while (q.CompareTo(bigPower) >= 0)  						{  							BigInteger[] qr = q.DivideAndRemainder(bigPower);  							S.Add(Convert.ToString(qr[1].LongValue' radix));  							q = qr[0];  						}    						sb.Append(Convert.ToString(q.LongValue' radix));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' exponent);  						}  						break;  					}  			}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToString,The following statement contains a magic number: switch (radix)  			{  				case 2:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 2));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 2)' 32);  						}  						break;  					}  				case 8:  					{  						int mask = (1 << 30) - 1;  						BigInteger u = this.Abs();  						int bits = u.BitLength;  						IList S = Platform.CreateArrayList();  						while (bits > 30)  						{  							S.Add(Convert.ToString(u.IntValue & mask' 8));  							u = u.ShiftRight(30);  							bits -= 30;  						}  						sb.Append(Convert.ToString(u.IntValue' 8));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' 10);  						}  						break;  					}  				case 16:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 16));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 16)' 8);  						}  						break;  					}  				// TODO This could work for other radices if there is an alternative to Convert.ToString method  				//default:  				case 10:  					{  						BigInteger q = this.Abs();  						if (q.BitLength < 64)  						{  							sb.Append(Convert.ToString(q.LongValue' radix));  							break;  						}    						// Based on algorithm 1a from chapter 4.4 in Seminumerical Algorithms (Knuth)    						// Work out the largest power of 'rdx' that is a positive 64-bit integer  						// TODO possibly cache power/exponent against radix?  						long limit = Int64.MaxValue / radix;  						long power = radix;  						int exponent = 1;  						while (power <= limit)  						{  							power *= radix;  							++exponent;  						}    						BigInteger bigPower = BigInteger.ValueOf(power);    						IList S = Platform.CreateArrayList();  						while (q.CompareTo(bigPower) >= 0)  						{  							BigInteger[] qr = q.DivideAndRemainder(bigPower);  							S.Add(Convert.ToString(qr[1].LongValue' radix));  							q = qr[0];  						}    						sb.Append(Convert.ToString(q.LongValue' radix));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' exponent);  						}  						break;  					}  			}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToString,The following statement contains a magic number: switch (radix)  			{  				case 2:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 2));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 2)' 32);  						}  						break;  					}  				case 8:  					{  						int mask = (1 << 30) - 1;  						BigInteger u = this.Abs();  						int bits = u.BitLength;  						IList S = Platform.CreateArrayList();  						while (bits > 30)  						{  							S.Add(Convert.ToString(u.IntValue & mask' 8));  							u = u.ShiftRight(30);  							bits -= 30;  						}  						sb.Append(Convert.ToString(u.IntValue' 8));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' 10);  						}  						break;  					}  				case 16:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 16));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 16)' 8);  						}  						break;  					}  				// TODO This could work for other radices if there is an alternative to Convert.ToString method  				//default:  				case 10:  					{  						BigInteger q = this.Abs();  						if (q.BitLength < 64)  						{  							sb.Append(Convert.ToString(q.LongValue' radix));  							break;  						}    						// Based on algorithm 1a from chapter 4.4 in Seminumerical Algorithms (Knuth)    						// Work out the largest power of 'rdx' that is a positive 64-bit integer  						// TODO possibly cache power/exponent against radix?  						long limit = Int64.MaxValue / radix;  						long power = radix;  						int exponent = 1;  						while (power <= limit)  						{  							power *= radix;  							++exponent;  						}    						BigInteger bigPower = BigInteger.ValueOf(power);    						IList S = Platform.CreateArrayList();  						while (q.CompareTo(bigPower) >= 0)  						{  							BigInteger[] qr = q.DivideAndRemainder(bigPower);  							S.Add(Convert.ToString(qr[1].LongValue' radix));  							q = qr[0];  						}    						sb.Append(Convert.ToString(q.LongValue' radix));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' exponent);  						}  						break;  					}  			}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToString,The following statement contains a magic number: switch (radix)  			{  				case 2:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 2));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 2)' 32);  						}  						break;  					}  				case 8:  					{  						int mask = (1 << 30) - 1;  						BigInteger u = this.Abs();  						int bits = u.BitLength;  						IList S = Platform.CreateArrayList();  						while (bits > 30)  						{  							S.Add(Convert.ToString(u.IntValue & mask' 8));  							u = u.ShiftRight(30);  							bits -= 30;  						}  						sb.Append(Convert.ToString(u.IntValue' 8));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' 10);  						}  						break;  					}  				case 16:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 16));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 16)' 8);  						}  						break;  					}  				// TODO This could work for other radices if there is an alternative to Convert.ToString method  				//default:  				case 10:  					{  						BigInteger q = this.Abs();  						if (q.BitLength < 64)  						{  							sb.Append(Convert.ToString(q.LongValue' radix));  							break;  						}    						// Based on algorithm 1a from chapter 4.4 in Seminumerical Algorithms (Knuth)    						// Work out the largest power of 'rdx' that is a positive 64-bit integer  						// TODO possibly cache power/exponent against radix?  						long limit = Int64.MaxValue / radix;  						long power = radix;  						int exponent = 1;  						while (power <= limit)  						{  							power *= radix;  							++exponent;  						}    						BigInteger bigPower = BigInteger.ValueOf(power);    						IList S = Platform.CreateArrayList();  						while (q.CompareTo(bigPower) >= 0)  						{  							BigInteger[] qr = q.DivideAndRemainder(bigPower);  							S.Add(Convert.ToString(qr[1].LongValue' radix));  							q = qr[0];  						}    						sb.Append(Convert.ToString(q.LongValue' radix));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' exponent);  						}  						break;  					}  			}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToString,The following statement contains a magic number: switch (radix)  			{  				case 2:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 2));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 2)' 32);  						}  						break;  					}  				case 8:  					{  						int mask = (1 << 30) - 1;  						BigInteger u = this.Abs();  						int bits = u.BitLength;  						IList S = Platform.CreateArrayList();  						while (bits > 30)  						{  							S.Add(Convert.ToString(u.IntValue & mask' 8));  							u = u.ShiftRight(30);  							bits -= 30;  						}  						sb.Append(Convert.ToString(u.IntValue' 8));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' 10);  						}  						break;  					}  				case 16:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 16));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 16)' 8);  						}  						break;  					}  				// TODO This could work for other radices if there is an alternative to Convert.ToString method  				//default:  				case 10:  					{  						BigInteger q = this.Abs();  						if (q.BitLength < 64)  						{  							sb.Append(Convert.ToString(q.LongValue' radix));  							break;  						}    						// Based on algorithm 1a from chapter 4.4 in Seminumerical Algorithms (Knuth)    						// Work out the largest power of 'rdx' that is a positive 64-bit integer  						// TODO possibly cache power/exponent against radix?  						long limit = Int64.MaxValue / radix;  						long power = radix;  						int exponent = 1;  						while (power <= limit)  						{  							power *= radix;  							++exponent;  						}    						BigInteger bigPower = BigInteger.ValueOf(power);    						IList S = Platform.CreateArrayList();  						while (q.CompareTo(bigPower) >= 0)  						{  							BigInteger[] qr = q.DivideAndRemainder(bigPower);  							S.Add(Convert.ToString(qr[1].LongValue' radix));  							q = qr[0];  						}    						sb.Append(Convert.ToString(q.LongValue' radix));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' exponent);  						}  						break;  					}  			}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToString,The following statement contains a magic number: switch (radix)  			{  				case 2:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 2));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 2)' 32);  						}  						break;  					}  				case 8:  					{  						int mask = (1 << 30) - 1;  						BigInteger u = this.Abs();  						int bits = u.BitLength;  						IList S = Platform.CreateArrayList();  						while (bits > 30)  						{  							S.Add(Convert.ToString(u.IntValue & mask' 8));  							u = u.ShiftRight(30);  							bits -= 30;  						}  						sb.Append(Convert.ToString(u.IntValue' 8));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' 10);  						}  						break;  					}  				case 16:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 16));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 16)' 8);  						}  						break;  					}  				// TODO This could work for other radices if there is an alternative to Convert.ToString method  				//default:  				case 10:  					{  						BigInteger q = this.Abs();  						if (q.BitLength < 64)  						{  							sb.Append(Convert.ToString(q.LongValue' radix));  							break;  						}    						// Based on algorithm 1a from chapter 4.4 in Seminumerical Algorithms (Knuth)    						// Work out the largest power of 'rdx' that is a positive 64-bit integer  						// TODO possibly cache power/exponent against radix?  						long limit = Int64.MaxValue / radix;  						long power = radix;  						int exponent = 1;  						while (power <= limit)  						{  							power *= radix;  							++exponent;  						}    						BigInteger bigPower = BigInteger.ValueOf(power);    						IList S = Platform.CreateArrayList();  						while (q.CompareTo(bigPower) >= 0)  						{  							BigInteger[] qr = q.DivideAndRemainder(bigPower);  							S.Add(Convert.ToString(qr[1].LongValue' radix));  							q = qr[0];  						}    						sb.Append(Convert.ToString(q.LongValue' radix));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' exponent);  						}  						break;  					}  			}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToString,The following statement contains a magic number: switch (radix)  			{  				case 2:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 2));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 2)' 32);  						}  						break;  					}  				case 8:  					{  						int mask = (1 << 30) - 1;  						BigInteger u = this.Abs();  						int bits = u.BitLength;  						IList S = Platform.CreateArrayList();  						while (bits > 30)  						{  							S.Add(Convert.ToString(u.IntValue & mask' 8));  							u = u.ShiftRight(30);  							bits -= 30;  						}  						sb.Append(Convert.ToString(u.IntValue' 8));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' 10);  						}  						break;  					}  				case 16:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 16));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 16)' 8);  						}  						break;  					}  				// TODO This could work for other radices if there is an alternative to Convert.ToString method  				//default:  				case 10:  					{  						BigInteger q = this.Abs();  						if (q.BitLength < 64)  						{  							sb.Append(Convert.ToString(q.LongValue' radix));  							break;  						}    						// Based on algorithm 1a from chapter 4.4 in Seminumerical Algorithms (Knuth)    						// Work out the largest power of 'rdx' that is a positive 64-bit integer  						// TODO possibly cache power/exponent against radix?  						long limit = Int64.MaxValue / radix;  						long power = radix;  						int exponent = 1;  						while (power <= limit)  						{  							power *= radix;  							++exponent;  						}    						BigInteger bigPower = BigInteger.ValueOf(power);    						IList S = Platform.CreateArrayList();  						while (q.CompareTo(bigPower) >= 0)  						{  							BigInteger[] qr = q.DivideAndRemainder(bigPower);  							S.Add(Convert.ToString(qr[1].LongValue' radix));  							q = qr[0];  						}    						sb.Append(Convert.ToString(q.LongValue' radix));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' exponent);  						}  						break;  					}  			}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToString,The following statement contains a magic number: switch (radix)  			{  				case 2:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 2));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 2)' 32);  						}  						break;  					}  				case 8:  					{  						int mask = (1 << 30) - 1;  						BigInteger u = this.Abs();  						int bits = u.BitLength;  						IList S = Platform.CreateArrayList();  						while (bits > 30)  						{  							S.Add(Convert.ToString(u.IntValue & mask' 8));  							u = u.ShiftRight(30);  							bits -= 30;  						}  						sb.Append(Convert.ToString(u.IntValue' 8));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' 10);  						}  						break;  					}  				case 16:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 16));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 16)' 8);  						}  						break;  					}  				// TODO This could work for other radices if there is an alternative to Convert.ToString method  				//default:  				case 10:  					{  						BigInteger q = this.Abs();  						if (q.BitLength < 64)  						{  							sb.Append(Convert.ToString(q.LongValue' radix));  							break;  						}    						// Based on algorithm 1a from chapter 4.4 in Seminumerical Algorithms (Knuth)    						// Work out the largest power of 'rdx' that is a positive 64-bit integer  						// TODO possibly cache power/exponent against radix?  						long limit = Int64.MaxValue / radix;  						long power = radix;  						int exponent = 1;  						while (power <= limit)  						{  							power *= radix;  							++exponent;  						}    						BigInteger bigPower = BigInteger.ValueOf(power);    						IList S = Platform.CreateArrayList();  						while (q.CompareTo(bigPower) >= 0)  						{  							BigInteger[] qr = q.DivideAndRemainder(bigPower);  							S.Add(Convert.ToString(qr[1].LongValue' radix));  							q = qr[0];  						}    						sb.Append(Convert.ToString(q.LongValue' radix));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' exponent);  						}  						break;  					}  			}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToString,The following statement contains a magic number: switch (radix)  			{  				case 2:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 2));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 2)' 32);  						}  						break;  					}  				case 8:  					{  						int mask = (1 << 30) - 1;  						BigInteger u = this.Abs();  						int bits = u.BitLength;  						IList S = Platform.CreateArrayList();  						while (bits > 30)  						{  							S.Add(Convert.ToString(u.IntValue & mask' 8));  							u = u.ShiftRight(30);  							bits -= 30;  						}  						sb.Append(Convert.ToString(u.IntValue' 8));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' 10);  						}  						break;  					}  				case 16:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 16));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 16)' 8);  						}  						break;  					}  				// TODO This could work for other radices if there is an alternative to Convert.ToString method  				//default:  				case 10:  					{  						BigInteger q = this.Abs();  						if (q.BitLength < 64)  						{  							sb.Append(Convert.ToString(q.LongValue' radix));  							break;  						}    						// Based on algorithm 1a from chapter 4.4 in Seminumerical Algorithms (Knuth)    						// Work out the largest power of 'rdx' that is a positive 64-bit integer  						// TODO possibly cache power/exponent against radix?  						long limit = Int64.MaxValue / radix;  						long power = radix;  						int exponent = 1;  						while (power <= limit)  						{  							power *= radix;  							++exponent;  						}    						BigInteger bigPower = BigInteger.ValueOf(power);    						IList S = Platform.CreateArrayList();  						while (q.CompareTo(bigPower) >= 0)  						{  							BigInteger[] qr = q.DivideAndRemainder(bigPower);  							S.Add(Convert.ToString(qr[1].LongValue' radix));  							q = qr[0];  						}    						sb.Append(Convert.ToString(q.LongValue' radix));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' exponent);  						}  						break;  					}  			}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToString,The following statement contains a magic number: switch (radix)  			{  				case 2:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 2));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 2)' 32);  						}  						break;  					}  				case 8:  					{  						int mask = (1 << 30) - 1;  						BigInteger u = this.Abs();  						int bits = u.BitLength;  						IList S = Platform.CreateArrayList();  						while (bits > 30)  						{  							S.Add(Convert.ToString(u.IntValue & mask' 8));  							u = u.ShiftRight(30);  							bits -= 30;  						}  						sb.Append(Convert.ToString(u.IntValue' 8));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' 10);  						}  						break;  					}  				case 16:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 16));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 16)' 8);  						}  						break;  					}  				// TODO This could work for other radices if there is an alternative to Convert.ToString method  				//default:  				case 10:  					{  						BigInteger q = this.Abs();  						if (q.BitLength < 64)  						{  							sb.Append(Convert.ToString(q.LongValue' radix));  							break;  						}    						// Based on algorithm 1a from chapter 4.4 in Seminumerical Algorithms (Knuth)    						// Work out the largest power of 'rdx' that is a positive 64-bit integer  						// TODO possibly cache power/exponent against radix?  						long limit = Int64.MaxValue / radix;  						long power = radix;  						int exponent = 1;  						while (power <= limit)  						{  							power *= radix;  							++exponent;  						}    						BigInteger bigPower = BigInteger.ValueOf(power);    						IList S = Platform.CreateArrayList();  						while (q.CompareTo(bigPower) >= 0)  						{  							BigInteger[] qr = q.DivideAndRemainder(bigPower);  							S.Add(Convert.ToString(qr[1].LongValue' radix));  							q = qr[0];  						}    						sb.Append(Convert.ToString(q.LongValue' radix));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' exponent);  						}  						break;  					}  			}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToString,The following statement contains a magic number: switch (radix)  			{  				case 2:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 2));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 2)' 32);  						}  						break;  					}  				case 8:  					{  						int mask = (1 << 30) - 1;  						BigInteger u = this.Abs();  						int bits = u.BitLength;  						IList S = Platform.CreateArrayList();  						while (bits > 30)  						{  							S.Add(Convert.ToString(u.IntValue & mask' 8));  							u = u.ShiftRight(30);  							bits -= 30;  						}  						sb.Append(Convert.ToString(u.IntValue' 8));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' 10);  						}  						break;  					}  				case 16:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 16));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 16)' 8);  						}  						break;  					}  				// TODO This could work for other radices if there is an alternative to Convert.ToString method  				//default:  				case 10:  					{  						BigInteger q = this.Abs();  						if (q.BitLength < 64)  						{  							sb.Append(Convert.ToString(q.LongValue' radix));  							break;  						}    						// Based on algorithm 1a from chapter 4.4 in Seminumerical Algorithms (Knuth)    						// Work out the largest power of 'rdx' that is a positive 64-bit integer  						// TODO possibly cache power/exponent against radix?  						long limit = Int64.MaxValue / radix;  						long power = radix;  						int exponent = 1;  						while (power <= limit)  						{  							power *= radix;  							++exponent;  						}    						BigInteger bigPower = BigInteger.ValueOf(power);    						IList S = Platform.CreateArrayList();  						while (q.CompareTo(bigPower) >= 0)  						{  							BigInteger[] qr = q.DivideAndRemainder(bigPower);  							S.Add(Convert.ToString(qr[1].LongValue' radix));  							q = qr[0];  						}    						sb.Append(Convert.ToString(q.LongValue' radix));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' exponent);  						}  						break;  					}  			}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToString,The following statement contains a magic number: switch (radix)  			{  				case 2:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 2));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 2)' 32);  						}  						break;  					}  				case 8:  					{  						int mask = (1 << 30) - 1;  						BigInteger u = this.Abs();  						int bits = u.BitLength;  						IList S = Platform.CreateArrayList();  						while (bits > 30)  						{  							S.Add(Convert.ToString(u.IntValue & mask' 8));  							u = u.ShiftRight(30);  							bits -= 30;  						}  						sb.Append(Convert.ToString(u.IntValue' 8));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' 10);  						}  						break;  					}  				case 16:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 16));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 16)' 8);  						}  						break;  					}  				// TODO This could work for other radices if there is an alternative to Convert.ToString method  				//default:  				case 10:  					{  						BigInteger q = this.Abs();  						if (q.BitLength < 64)  						{  							sb.Append(Convert.ToString(q.LongValue' radix));  							break;  						}    						// Based on algorithm 1a from chapter 4.4 in Seminumerical Algorithms (Knuth)    						// Work out the largest power of 'rdx' that is a positive 64-bit integer  						// TODO possibly cache power/exponent against radix?  						long limit = Int64.MaxValue / radix;  						long power = radix;  						int exponent = 1;  						while (power <= limit)  						{  							power *= radix;  							++exponent;  						}    						BigInteger bigPower = BigInteger.ValueOf(power);    						IList S = Platform.CreateArrayList();  						while (q.CompareTo(bigPower) >= 0)  						{  							BigInteger[] qr = q.DivideAndRemainder(bigPower);  							S.Add(Convert.ToString(qr[1].LongValue' radix));  							q = qr[0];  						}    						sb.Append(Convert.ToString(q.LongValue' radix));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' exponent);  						}  						break;  					}  			}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToString,The following statement contains a magic number: switch (radix)  			{  				case 2:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 2));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 2)' 32);  						}  						break;  					}  				case 8:  					{  						int mask = (1 << 30) - 1;  						BigInteger u = this.Abs();  						int bits = u.BitLength;  						IList S = Platform.CreateArrayList();  						while (bits > 30)  						{  							S.Add(Convert.ToString(u.IntValue & mask' 8));  							u = u.ShiftRight(30);  							bits -= 30;  						}  						sb.Append(Convert.ToString(u.IntValue' 8));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' 10);  						}  						break;  					}  				case 16:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 16));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 16)' 8);  						}  						break;  					}  				// TODO This could work for other radices if there is an alternative to Convert.ToString method  				//default:  				case 10:  					{  						BigInteger q = this.Abs();  						if (q.BitLength < 64)  						{  							sb.Append(Convert.ToString(q.LongValue' radix));  							break;  						}    						// Based on algorithm 1a from chapter 4.4 in Seminumerical Algorithms (Knuth)    						// Work out the largest power of 'rdx' that is a positive 64-bit integer  						// TODO possibly cache power/exponent against radix?  						long limit = Int64.MaxValue / radix;  						long power = radix;  						int exponent = 1;  						while (power <= limit)  						{  							power *= radix;  							++exponent;  						}    						BigInteger bigPower = BigInteger.ValueOf(power);    						IList S = Platform.CreateArrayList();  						while (q.CompareTo(bigPower) >= 0)  						{  							BigInteger[] qr = q.DivideAndRemainder(bigPower);  							S.Add(Convert.ToString(qr[1].LongValue' radix));  							q = qr[0];  						}    						sb.Append(Convert.ToString(q.LongValue' radix));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' exponent);  						}  						break;  					}  			}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToString,The following statement contains a magic number: switch (radix)  			{  				case 2:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 2));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 2)' 32);  						}  						break;  					}  				case 8:  					{  						int mask = (1 << 30) - 1;  						BigInteger u = this.Abs();  						int bits = u.BitLength;  						IList S = Platform.CreateArrayList();  						while (bits > 30)  						{  							S.Add(Convert.ToString(u.IntValue & mask' 8));  							u = u.ShiftRight(30);  							bits -= 30;  						}  						sb.Append(Convert.ToString(u.IntValue' 8));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' 10);  						}  						break;  					}  				case 16:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 16));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 16)' 8);  						}  						break;  					}  				// TODO This could work for other radices if there is an alternative to Convert.ToString method  				//default:  				case 10:  					{  						BigInteger q = this.Abs();  						if (q.BitLength < 64)  						{  							sb.Append(Convert.ToString(q.LongValue' radix));  							break;  						}    						// Based on algorithm 1a from chapter 4.4 in Seminumerical Algorithms (Knuth)    						// Work out the largest power of 'rdx' that is a positive 64-bit integer  						// TODO possibly cache power/exponent against radix?  						long limit = Int64.MaxValue / radix;  						long power = radix;  						int exponent = 1;  						while (power <= limit)  						{  							power *= radix;  							++exponent;  						}    						BigInteger bigPower = BigInteger.ValueOf(power);    						IList S = Platform.CreateArrayList();  						while (q.CompareTo(bigPower) >= 0)  						{  							BigInteger[] qr = q.DivideAndRemainder(bigPower);  							S.Add(Convert.ToString(qr[1].LongValue' radix));  							q = qr[0];  						}    						sb.Append(Convert.ToString(q.LongValue' radix));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' exponent);  						}  						break;  					}  			}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToString,The following statement contains a magic number: switch (radix)  			{  				case 2:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 2));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 2)' 32);  						}  						break;  					}  				case 8:  					{  						int mask = (1 << 30) - 1;  						BigInteger u = this.Abs();  						int bits = u.BitLength;  						IList S = Platform.CreateArrayList();  						while (bits > 30)  						{  							S.Add(Convert.ToString(u.IntValue & mask' 8));  							u = u.ShiftRight(30);  							bits -= 30;  						}  						sb.Append(Convert.ToString(u.IntValue' 8));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' 10);  						}  						break;  					}  				case 16:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 16));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 16)' 8);  						}  						break;  					}  				// TODO This could work for other radices if there is an alternative to Convert.ToString method  				//default:  				case 10:  					{  						BigInteger q = this.Abs();  						if (q.BitLength < 64)  						{  							sb.Append(Convert.ToString(q.LongValue' radix));  							break;  						}    						// Based on algorithm 1a from chapter 4.4 in Seminumerical Algorithms (Knuth)    						// Work out the largest power of 'rdx' that is a positive 64-bit integer  						// TODO possibly cache power/exponent against radix?  						long limit = Int64.MaxValue / radix;  						long power = radix;  						int exponent = 1;  						while (power <= limit)  						{  							power *= radix;  							++exponent;  						}    						BigInteger bigPower = BigInteger.ValueOf(power);    						IList S = Platform.CreateArrayList();  						while (q.CompareTo(bigPower) >= 0)  						{  							BigInteger[] qr = q.DivideAndRemainder(bigPower);  							S.Add(Convert.ToString(qr[1].LongValue' radix));  							q = qr[0];  						}    						sb.Append(Convert.ToString(q.LongValue' radix));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' exponent);  						}  						break;  					}  			}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToString,The following statement contains a magic number: switch (radix)  			{  				case 2:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 2));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 2)' 32);  						}  						break;  					}  				case 8:  					{  						int mask = (1 << 30) - 1;  						BigInteger u = this.Abs();  						int bits = u.BitLength;  						IList S = Platform.CreateArrayList();  						while (bits > 30)  						{  							S.Add(Convert.ToString(u.IntValue & mask' 8));  							u = u.ShiftRight(30);  							bits -= 30;  						}  						sb.Append(Convert.ToString(u.IntValue' 8));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' 10);  						}  						break;  					}  				case 16:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 16));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 16)' 8);  						}  						break;  					}  				// TODO This could work for other radices if there is an alternative to Convert.ToString method  				//default:  				case 10:  					{  						BigInteger q = this.Abs();  						if (q.BitLength < 64)  						{  							sb.Append(Convert.ToString(q.LongValue' radix));  							break;  						}    						// Based on algorithm 1a from chapter 4.4 in Seminumerical Algorithms (Knuth)    						// Work out the largest power of 'rdx' that is a positive 64-bit integer  						// TODO possibly cache power/exponent against radix?  						long limit = Int64.MaxValue / radix;  						long power = radix;  						int exponent = 1;  						while (power <= limit)  						{  							power *= radix;  							++exponent;  						}    						BigInteger bigPower = BigInteger.ValueOf(power);    						IList S = Platform.CreateArrayList();  						while (q.CompareTo(bigPower) >= 0)  						{  							BigInteger[] qr = q.DivideAndRemainder(bigPower);  							S.Add(Convert.ToString(qr[1].LongValue' radix));  							q = qr[0];  						}    						sb.Append(Convert.ToString(q.LongValue' radix));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' exponent);  						}  						break;  					}  			}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToString,The following statement contains a magic number: switch (radix)  			{  				case 2:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 2));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 2)' 32);  						}  						break;  					}  				case 8:  					{  						int mask = (1 << 30) - 1;  						BigInteger u = this.Abs();  						int bits = u.BitLength;  						IList S = Platform.CreateArrayList();  						while (bits > 30)  						{  							S.Add(Convert.ToString(u.IntValue & mask' 8));  							u = u.ShiftRight(30);  							bits -= 30;  						}  						sb.Append(Convert.ToString(u.IntValue' 8));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' 10);  						}  						break;  					}  				case 16:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 16));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 16)' 8);  						}  						break;  					}  				// TODO This could work for other radices if there is an alternative to Convert.ToString method  				//default:  				case 10:  					{  						BigInteger q = this.Abs();  						if (q.BitLength < 64)  						{  							sb.Append(Convert.ToString(q.LongValue' radix));  							break;  						}    						// Based on algorithm 1a from chapter 4.4 in Seminumerical Algorithms (Knuth)    						// Work out the largest power of 'rdx' that is a positive 64-bit integer  						// TODO possibly cache power/exponent against radix?  						long limit = Int64.MaxValue / radix;  						long power = radix;  						int exponent = 1;  						while (power <= limit)  						{  							power *= radix;  							++exponent;  						}    						BigInteger bigPower = BigInteger.ValueOf(power);    						IList S = Platform.CreateArrayList();  						while (q.CompareTo(bigPower) >= 0)  						{  							BigInteger[] qr = q.DivideAndRemainder(bigPower);  							S.Add(Convert.ToString(qr[1].LongValue' radix));  							q = qr[0];  						}    						sb.Append(Convert.ToString(q.LongValue' radix));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' exponent);  						}  						break;  					}  			}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToString,The following statement contains a magic number: switch (radix)  			{  				case 2:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 2));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 2)' 32);  						}  						break;  					}  				case 8:  					{  						int mask = (1 << 30) - 1;  						BigInteger u = this.Abs();  						int bits = u.BitLength;  						IList S = Platform.CreateArrayList();  						while (bits > 30)  						{  							S.Add(Convert.ToString(u.IntValue & mask' 8));  							u = u.ShiftRight(30);  							bits -= 30;  						}  						sb.Append(Convert.ToString(u.IntValue' 8));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' 10);  						}  						break;  					}  				case 16:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 16));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 16)' 8);  						}  						break;  					}  				// TODO This could work for other radices if there is an alternative to Convert.ToString method  				//default:  				case 10:  					{  						BigInteger q = this.Abs();  						if (q.BitLength < 64)  						{  							sb.Append(Convert.ToString(q.LongValue' radix));  							break;  						}    						// Based on algorithm 1a from chapter 4.4 in Seminumerical Algorithms (Knuth)    						// Work out the largest power of 'rdx' that is a positive 64-bit integer  						// TODO possibly cache power/exponent against radix?  						long limit = Int64.MaxValue / radix;  						long power = radix;  						int exponent = 1;  						while (power <= limit)  						{  							power *= radix;  							++exponent;  						}    						BigInteger bigPower = BigInteger.ValueOf(power);    						IList S = Platform.CreateArrayList();  						while (q.CompareTo(bigPower) >= 0)  						{  							BigInteger[] qr = q.DivideAndRemainder(bigPower);  							S.Add(Convert.ToString(qr[1].LongValue' radix));  							q = qr[0];  						}    						sb.Append(Convert.ToString(q.LongValue' radix));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' exponent);  						}  						break;  					}  			}
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,CreateUValueOf,The following statement contains a magic number: int msw = (int)(value >> 32);
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,GetLowestSetBitMaskFirst,The following statement contains a magic number: offset += 32;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,GetLowestSetBitMaskFirst,The following statement contains a magic number: word >>= 8;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,GetLowestSetBitMaskFirst,The following statement contains a magic number: offset += 8;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,TestBit,The following statement contains a magic number: int wordNum = n / 32;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,TestBit,The following statement contains a magic number: return ((word >> (n % 32)) & 1) > 0;
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,FlipExistingBit,The following statement contains a magic number: mag[mag.Length - 1 - (n >> 5)] ^= (1 << (n & 31));
Magic Number,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,FlipExistingBit,The following statement contains a magic number: mag[mag.Length - 1 - (n >> 5)] ^= (1 << (n & 31));
Magic Number,NBitcoin.BouncyCastle.Math.EC.Abc,SimpleBigDecimal,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\abc\SimpleBigDecimal.cs,ToString,The following statement contains a magic number: string fractStr = fract.ToString(2);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Abc,Tnaf,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\abc\Tnaf.cs,ApproximateDivisionByN,The following statement contains a magic number: int _k = (m + 5) / 2 + c;
Magic Number,NBitcoin.BouncyCastle.Math.EC.Abc,Tnaf,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\abc\Tnaf.cs,ApproximateDivisionByN,The following statement contains a magic number: int _k = (m + 5) / 2 + c;
Magic Number,NBitcoin.BouncyCastle.Math.EC.Abc,Tnaf,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\abc\Tnaf.cs,ApproximateDivisionByN,The following statement contains a magic number: BigInteger ns = k.ShiftRight(m - _k - 2 + a);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Abc,Tnaf,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\abc\Tnaf.cs,TauAdicNaf,The following statement contains a magic number: int maxLength = log2Norm > 30 ? log2Norm + 4 : 34;
Magic Number,NBitcoin.BouncyCastle.Math.EC.Abc,Tnaf,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\abc\Tnaf.cs,TauAdicNaf,The following statement contains a magic number: int maxLength = log2Norm > 30 ? log2Norm + 4 : 34;
Magic Number,NBitcoin.BouncyCastle.Math.EC.Abc,Tnaf,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\abc\Tnaf.cs,TauAdicNaf,The following statement contains a magic number: int maxLength = log2Norm > 30 ? log2Norm + 4 : 34;
Magic Number,NBitcoin.BouncyCastle.Math.EC.Abc,Tnaf,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\abc\Tnaf.cs,GetTw,The following statement contains a magic number: return BigInteger.ValueOf(6);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Abc,Tnaf,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\abc\Tnaf.cs,GetTw,The following statement contains a magic number: w == 4
Magic Number,NBitcoin.BouncyCastle.Math.EC.Abc,Tnaf,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\abc\Tnaf.cs,GetSi,The following statement contains a magic number: int index = m + 3 - a;
Magic Number,NBitcoin.BouncyCastle.Math.EC.Abc,Tnaf,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\abc\Tnaf.cs,GetSi,The following statement contains a magic number: int index = fieldSize + 3 - curveA;
Magic Number,NBitcoin.BouncyCastle.Math.EC.Abc,Tnaf,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\abc\Tnaf.cs,GetShiftsForCofactor,The following statement contains a magic number: hi == 2
Magic Number,NBitcoin.BouncyCastle.Math.EC.Abc,Tnaf,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\abc\Tnaf.cs,GetShiftsForCofactor,The following statement contains a magic number: return 2;
Magic Number,NBitcoin.BouncyCastle.Math.EC.Abc,Tnaf,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\abc\Tnaf.cs,GetShiftsForCofactor,The following statement contains a magic number: hi == 4
Magic Number,NBitcoin.BouncyCastle.Math.EC.Abc,Tnaf,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\abc\Tnaf.cs,GetShiftsForCofactor,The following statement contains a magic number: h != null && h.BitLength < 4
Magic Number,NBitcoin.BouncyCastle.Math.EC.Abc,Tnaf,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\abc\Tnaf.cs,PartModReduction,The following statement contains a magic number: BigInteger r0 = k.Subtract(d0.Multiply(q.u)).Subtract( 				BigInteger.ValueOf(2).Multiply(s[1]).Multiply(q.v));
Magic Number,NBitcoin.BouncyCastle.Math.EC.Abc,Tnaf,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\abc\Tnaf.cs,MultiplyRTnaf,The following statement contains a magic number: ZTauElement rho = PartModReduction(k' m' (sbyte)a' s' mu' (sbyte)10);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Abc,Tnaf,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\abc\Tnaf.cs,TauAdicWNaf,The following statement contains a magic number: int maxLength = log2Norm > 30 ? log2Norm + 4 + width : 34 + width;
Magic Number,NBitcoin.BouncyCastle.Math.EC.Abc,Tnaf,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\abc\Tnaf.cs,TauAdicWNaf,The following statement contains a magic number: int maxLength = log2Norm > 30 ? log2Norm + 4 + width : 34 + width;
Magic Number,NBitcoin.BouncyCastle.Math.EC.Abc,Tnaf,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\abc\Tnaf.cs,TauAdicWNaf,The following statement contains a magic number: int maxLength = log2Norm > 30 ? log2Norm + 4 + width : 34 + width;
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Curve,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Curve.cs,SecP256K1Curve,The following statement contains a magic number: this.m_b = FromBigInteger(BigInteger.ValueOf(7));
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Field,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Field.cs,Add,The following statement contains a magic number: Nat.Add33To(8' PInv33' z);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Field,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Field.cs,Add,The following statement contains a magic number: c != 0 || (z[7] == P7 && Nat256.Gte(z' P))
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Field,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Field.cs,AddExt,The following statement contains a magic number: uint c = Nat.Add(16' xx' yy' zz);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Field,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Field.cs,AddExt,The following statement contains a magic number: Nat.IncAt(16' zz' PExtInv.Length);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Field,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Field.cs,AddExt,The following statement contains a magic number: c != 0 || (zz[15] == PExt15 && Nat.Gte(16' zz' PExt))
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Field,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Field.cs,AddExt,The following statement contains a magic number: c != 0 || (zz[15] == PExt15 && Nat.Gte(16' zz' PExt))
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Field,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Field.cs,AddOne,The following statement contains a magic number: uint c = Nat.Inc(8' x' z);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Field,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Field.cs,AddOne,The following statement contains a magic number: Nat.Add33To(8' PInv33' z);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Field,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Field.cs,AddOne,The following statement contains a magic number: c != 0 || (z[7] == P7 && Nat256.Gte(z' P))
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Field,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Field.cs,FromBigInteger,The following statement contains a magic number: z[7] == P7 && Nat256.Gte(z' P)
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Field,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Field.cs,Half,The following statement contains a magic number: Nat.ShiftDownBit(8' x' 0' z);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Field,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Field.cs,MultiplyAddToExt,The following statement contains a magic number: Nat.IncAt(16' zz' PExtInv.Length);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Field,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Field.cs,MultiplyAddToExt,The following statement contains a magic number: c != 0 || (zz[15] == PExt15 && Nat.Gte(16' zz' PExt))
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Field,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Field.cs,MultiplyAddToExt,The following statement contains a magic number: c != 0 || (zz[15] == PExt15 && Nat.Gte(16' zz' PExt))
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Field,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Field.cs,Reduce,The following statement contains a magic number: ulong cc = Nat256.Mul33Add(PInv33' xx' 8' xx' 0' z' 0);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Field,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Field.cs,Reduce,The following statement contains a magic number: Nat.Add33To(8' PInv33' z);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Field,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Field.cs,Reduce,The following statement contains a magic number: c != 0 || (z[7] == P7 && Nat256.Gte(z' P))
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Field,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Field.cs,Reduce32,The following statement contains a magic number: Nat.Add33To(8' PInv33' z);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Field,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Field.cs,Reduce32,The following statement contains a magic number: (x != 0 && Nat256.Mul33WordAdd(PInv33' x' z' 0) != 0) 				|| (z[7] == P7 && Nat256.Gte(z' P))
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Field,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Field.cs,Subtract,The following statement contains a magic number: Nat.Sub33From(8' PInv33' z);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Field,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Field.cs,SubtractExt,The following statement contains a magic number: int c = Nat.Sub(16' xx' yy' zz);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Field,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Field.cs,SubtractExt,The following statement contains a magic number: Nat.DecAt(16' zz' PExtInv.Length);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Field,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Field.cs,Twice,The following statement contains a magic number: uint c = Nat.ShiftUpBit(8' x' 0' z);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Field,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Field.cs,Twice,The following statement contains a magic number: Nat.Add33To(8' PInv33' z);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Field,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Field.cs,Twice,The following statement contains a magic number: c != 0 || (z[7] == P7 && Nat256.Gte(z' P))
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1FieldElement,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1FieldElement.cs,Sqrt,The following statement contains a magic number: SecP256K1Field.SquareN(x3' 3' x6);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1FieldElement,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1FieldElement.cs,Sqrt,The following statement contains a magic number: SecP256K1Field.SquareN(x6' 3' x9);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1FieldElement,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1FieldElement.cs,Sqrt,The following statement contains a magic number: SecP256K1Field.SquareN(x9' 2' x11);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1FieldElement,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1FieldElement.cs,Sqrt,The following statement contains a magic number: SecP256K1Field.SquareN(x11' 11' x22);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1FieldElement,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1FieldElement.cs,Sqrt,The following statement contains a magic number: SecP256K1Field.SquareN(x22' 22' x44);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1FieldElement,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1FieldElement.cs,Sqrt,The following statement contains a magic number: SecP256K1Field.SquareN(x44' 44' x88);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1FieldElement,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1FieldElement.cs,Sqrt,The following statement contains a magic number: SecP256K1Field.SquareN(x88' 88' x176);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1FieldElement,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1FieldElement.cs,Sqrt,The following statement contains a magic number: SecP256K1Field.SquareN(x176' 44' x220);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1FieldElement,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1FieldElement.cs,Sqrt,The following statement contains a magic number: SecP256K1Field.SquareN(x220' 3' x223);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1FieldElement,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1FieldElement.cs,Sqrt,The following statement contains a magic number: SecP256K1Field.SquareN(t1' 23' t1);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1FieldElement,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1FieldElement.cs,Sqrt,The following statement contains a magic number: SecP256K1Field.SquareN(t1' 6' t1);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1FieldElement,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1FieldElement.cs,Sqrt,The following statement contains a magic number: SecP256K1Field.SquareN(t1' 2' t1);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1FieldElement,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1FieldElement.cs,GetHashCode,The following statement contains a magic number: return Q.GetHashCode() ^ Arrays.GetHashCode(x' 0' 8);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Point,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Point.cs,Twice,The following statement contains a magic number: c = Nat.ShiftUpBits(8' S' 2' 0);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Point,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Point.cs,Twice,The following statement contains a magic number: c = Nat.ShiftUpBits(8' S' 2' 0);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Point,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Point.cs,Twice,The following statement contains a magic number: c = Nat.ShiftUpBits(8' T' 3' 0' t1);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Custom.Sec,SecP256K1Point,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\custom\sec\SecP256K1Point.cs,Twice,The following statement contains a magic number: c = Nat.ShiftUpBits(8' T' 3' 0' t1);
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECAlgorithms,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECAlgorithms.cs,SumOfMultiplies,The following statement contains a magic number: switch (count) 			{ 				case 1: 					return ps[0].Multiply(ks[0]); 				case 2: 					return SumOfTwoMultiplies(ps[0]' ks[0]' ps[1]' ks[1]); 				default: 					break; 			}
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECAlgorithms,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECAlgorithms.cs,ImplShamirsTrickJsf,The following statement contains a magic number: ECPoint[] table = new ECPoint[] { 			points[3].Negate()' points[2].Negate()' points[1].Negate()' 			points[0].Negate()' infinity' points[0]' 			points[1]' points[2]' points[3] };
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECAlgorithms,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECAlgorithms.cs,ImplShamirsTrickJsf,The following statement contains a magic number: ECPoint[] table = new ECPoint[] { 			points[3].Negate()' points[2].Negate()' points[1].Negate()' 			points[0].Negate()' infinity' points[0]' 			points[1]' points[2]' points[3] };
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECAlgorithms,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECAlgorithms.cs,ImplShamirsTrickJsf,The following statement contains a magic number: ECPoint[] table = new ECPoint[] { 			points[3].Negate()' points[2].Negate()' points[1].Negate()' 			points[0].Negate()' infinity' points[0]' 			points[1]' points[2]' points[3] };
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECAlgorithms,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECAlgorithms.cs,ImplShamirsTrickJsf,The following statement contains a magic number: ECPoint[] table = new ECPoint[] { 			points[3].Negate()' points[2].Negate()' points[1].Negate()' 			points[0].Negate()' infinity' points[0]' 			points[1]' points[2]' points[3] };
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECAlgorithms,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECAlgorithms.cs,ImplShamirsTrickJsf,The following statement contains a magic number: int kDigit = ((jsfi << 24) >> 28)' lDigit = ((jsfi << 28) >> 28);
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECAlgorithms,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECAlgorithms.cs,ImplShamirsTrickJsf,The following statement contains a magic number: int kDigit = ((jsfi << 24) >> 28)' lDigit = ((jsfi << 28) >> 28);
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECAlgorithms,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECAlgorithms.cs,ImplShamirsTrickJsf,The following statement contains a magic number: int kDigit = ((jsfi << 24) >> 28)' lDigit = ((jsfi << 28) >> 28);
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECAlgorithms,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECAlgorithms.cs,ImplShamirsTrickJsf,The following statement contains a magic number: int kDigit = ((jsfi << 24) >> 28)' lDigit = ((jsfi << 28) >> 28);
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECAlgorithms,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECAlgorithms.cs,ImplShamirsTrickJsf,The following statement contains a magic number: int index = 4 + (kDigit * 3) + lDigit;
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECAlgorithms,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECAlgorithms.cs,ImplShamirsTrickJsf,The following statement contains a magic number: int index = 4 + (kDigit * 3) + lDigit;
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECAlgorithms,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECAlgorithms.cs,ImplShamirsTrickWNaf,The following statement contains a magic number: int widthP = System.Math.Max(2' System.Math.Min(16' WNafUtilities.GetWindowSize(k.BitLength)));
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECAlgorithms,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECAlgorithms.cs,ImplShamirsTrickWNaf,The following statement contains a magic number: int widthP = System.Math.Max(2' System.Math.Min(16' WNafUtilities.GetWindowSize(k.BitLength)));
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECAlgorithms,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECAlgorithms.cs,ImplShamirsTrickWNaf,The following statement contains a magic number: int widthQ = System.Math.Max(2' System.Math.Min(16' WNafUtilities.GetWindowSize(l.BitLength)));
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECAlgorithms,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECAlgorithms.cs,ImplShamirsTrickWNaf,The following statement contains a magic number: int widthQ = System.Math.Max(2' System.Math.Min(16' WNafUtilities.GetWindowSize(l.BitLength)));
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECAlgorithms,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECAlgorithms.cs,ImplShamirsTrickWNaf,The following statement contains a magic number: int width = System.Math.Max(2' System.Math.Min(16' WNafUtilities.GetWindowSize(System.Math.Max(k.BitLength' l.BitLength))));
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECAlgorithms,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECAlgorithms.cs,ImplShamirsTrickWNaf,The following statement contains a magic number: int width = System.Math.Max(2' System.Math.Min(16' WNafUtilities.GetWindowSize(System.Math.Max(k.BitLength' l.BitLength))));
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECAlgorithms,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECAlgorithms.cs,ImplSumOfMultiplies,The following statement contains a magic number: int width = System.Math.Max(2' System.Math.Min(16' WNafUtilities.GetWindowSize(ki.BitLength)));
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECAlgorithms,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECAlgorithms.cs,ImplSumOfMultiplies,The following statement contains a magic number: int width = System.Math.Max(2' System.Math.Min(16' WNafUtilities.GetWindowSize(ki.BitLength)));
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECAlgorithms,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECAlgorithms.cs,ImplSumOfMultiplies,The following statement contains a magic number: int width = System.Math.Max(2' System.Math.Min(16' WNafUtilities.GetWindowSize(System.Math.Max(kj0.BitLength' kj1.BitLength))));
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECAlgorithms,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECAlgorithms.cs,ImplSumOfMultiplies,The following statement contains a magic number: int width = System.Math.Max(2' System.Math.Min(16' WNafUtilities.GetWindowSize(System.Math.Max(kj0.BitLength' kj1.BitLength))));
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECCurve,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECCurve.cs,SetPreCompInfo,The following statement contains a magic number: point.m_preCompTable = table = Platform.CreateHashtable(4);
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECCurve,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECCurve.cs,DecodePoint,The following statement contains a magic number: int expectedLength = (FieldSize + 7) / 8;
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECCurve,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECCurve.cs,DecodePoint,The following statement contains a magic number: int expectedLength = (FieldSize + 7) / 8;
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECCurve,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECCurve.cs,DecodePoint,The following statement contains a magic number: switch (type) 			{ 				case 0x00: // infinity 					{ 						if (encoded.Length != 1) 							throw new ArgumentException("Incorrect length for infinity encoding"' "encoded");  						p = Infinity; 						break; 					}  				case 0x02: // compressed 				case 0x03: // compressed 					{ 						if (encoded.Length != (expectedLength + 1)) 							throw new ArgumentException("Incorrect length for compressed encoding"' "encoded");  						int yTilde = type & 1; 						BigInteger X = new BigInteger(1' encoded' 1' expectedLength);  						p = DecompressPoint(yTilde' X); 						if (!p.SatisfiesCofactor()) 							throw new ArgumentException("Invalid point");  						break; 					}  				case 0x04: // uncompressed 					{ 						if (encoded.Length != (2 * expectedLength + 1)) 							throw new ArgumentException("Incorrect length for uncompressed encoding"' "encoded");  						BigInteger X = new BigInteger(1' encoded' 1' expectedLength); 						BigInteger Y = new BigInteger(1' encoded' 1 + expectedLength' expectedLength);  						p = ValidatePoint(X' Y); 						break; 					}  				case 0x06: // hybrid 				case 0x07: // hybrid 					{ 						if (encoded.Length != (2 * expectedLength + 1)) 							throw new ArgumentException("Incorrect length for hybrid encoding"' "encoded");  						BigInteger X = new BigInteger(1' encoded' 1' expectedLength); 						BigInteger Y = new BigInteger(1' encoded' 1 + expectedLength' expectedLength);  						if (Y.TestBit(0) != (type == 0x07)) 							throw new ArgumentException("Inconsistent Y coordinate in hybrid encoding"' "encoded");  						p = ValidatePoint(X' Y); 						break; 					}  				default: 					throw new FormatException("Invalid point encoding " + type); 			}
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECCurve,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECCurve.cs,DecodePoint,The following statement contains a magic number: switch (type) 			{ 				case 0x00: // infinity 					{ 						if (encoded.Length != 1) 							throw new ArgumentException("Incorrect length for infinity encoding"' "encoded");  						p = Infinity; 						break; 					}  				case 0x02: // compressed 				case 0x03: // compressed 					{ 						if (encoded.Length != (expectedLength + 1)) 							throw new ArgumentException("Incorrect length for compressed encoding"' "encoded");  						int yTilde = type & 1; 						BigInteger X = new BigInteger(1' encoded' 1' expectedLength);  						p = DecompressPoint(yTilde' X); 						if (!p.SatisfiesCofactor()) 							throw new ArgumentException("Invalid point");  						break; 					}  				case 0x04: // uncompressed 					{ 						if (encoded.Length != (2 * expectedLength + 1)) 							throw new ArgumentException("Incorrect length for uncompressed encoding"' "encoded");  						BigInteger X = new BigInteger(1' encoded' 1' expectedLength); 						BigInteger Y = new BigInteger(1' encoded' 1 + expectedLength' expectedLength);  						p = ValidatePoint(X' Y); 						break; 					}  				case 0x06: // hybrid 				case 0x07: // hybrid 					{ 						if (encoded.Length != (2 * expectedLength + 1)) 							throw new ArgumentException("Incorrect length for hybrid encoding"' "encoded");  						BigInteger X = new BigInteger(1' encoded' 1' expectedLength); 						BigInteger Y = new BigInteger(1' encoded' 1 + expectedLength' expectedLength);  						if (Y.TestBit(0) != (type == 0x07)) 							throw new ArgumentException("Inconsistent Y coordinate in hybrid encoding"' "encoded");  						p = ValidatePoint(X' Y); 						break; 					}  				default: 					throw new FormatException("Invalid point encoding " + type); 			}
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECFieldElement,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECFieldElement.cs,ToString,The following statement contains a magic number: return this.ToBigInteger().ToString(16);
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECFieldElement,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECFieldElement.cs,GetEncoded,The following statement contains a magic number: return BigIntegers.AsUnsignedByteArray((FieldSize + 7) / 8' ToBigInteger());
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECFieldElement,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECFieldElement.cs,GetEncoded,The following statement contains a magic number: return BigIntegers.AsUnsignedByteArray((FieldSize + 7) / 8' ToBigInteger());
Magic Number,NBitcoin.BouncyCastle.Math.EC,FpFieldElement,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECFieldElement.cs,CalculateResidue,The following statement contains a magic number: BigInteger firstWord = p.ShiftRight(bitLength - 64);
Magic Number,NBitcoin.BouncyCastle.Math.EC,FpFieldElement,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECFieldElement.cs,CalculateResidue,The following statement contains a magic number: (bitLength & 7) == 0
Magic Number,NBitcoin.BouncyCastle.Math.EC,FpFieldElement,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECFieldElement.cs,CalculateResidue,The following statement contains a magic number: bitLength >= 96
Magic Number,NBitcoin.BouncyCastle.Math.EC,FpFieldElement,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECFieldElement.cs,Sqrt,The following statement contains a magic number: BigInteger e = q.ShiftRight(2).Add(BigInteger.One);
Magic Number,NBitcoin.BouncyCastle.Math.EC,FpFieldElement,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECFieldElement.cs,Sqrt,The following statement contains a magic number: BigInteger t1 = x.ModPow(q.ShiftRight(3)' q);
Magic Number,NBitcoin.BouncyCastle.Math.EC,FpFieldElement,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECFieldElement.cs,Sqrt,The following statement contains a magic number: BigInteger t4 = BigInteger.Two.ModPow(q.ShiftRight(2)' q);
Magic Number,NBitcoin.BouncyCastle.Math.EC,FpFieldElement,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECFieldElement.cs,Sqrt,The following statement contains a magic number: q.TestBit(2)
Magic Number,NBitcoin.BouncyCastle.Math.EC,FpFieldElement,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECFieldElement.cs,ModInverse,The following statement contains a magic number: int len = (bits + 31) >> 5;
Magic Number,NBitcoin.BouncyCastle.Math.EC,FpFieldElement,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECFieldElement.cs,ModInverse,The following statement contains a magic number: int len = (bits + 31) >> 5;
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECPoint.cs,GetHashCode,The following statement contains a magic number: hc ^= p.XCoord.GetHashCode() * 17;
Magic Number,NBitcoin.BouncyCastle.Math.EC,ECPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECPoint.cs,GetHashCode,The following statement contains a magic number: hc ^= p.YCoord.GetHashCode() * 257;
Magic Number,NBitcoin.BouncyCastle.Math.EC,FpPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECPoint.cs,Twice,The following statement contains a magic number: switch (coord) 			{ 				case ECCurve.COORD_AFFINE: 					{ 						ECFieldElement X1Squared = X1.Square(); 						ECFieldElement gamma = Three(X1Squared).Add(this.Curve.A).Divide(Two(Y1)); 						ECFieldElement X3 = gamma.Square().Subtract(Two(X1)); 						ECFieldElement Y3 = gamma.Multiply(X1.Subtract(X3)).Subtract(Y1);  						return new FpPoint(Curve' X3' Y3' IsCompressed); 					}  				case ECCurve.COORD_HOMOGENEOUS: 					{ 						ECFieldElement Z1 = this.RawZCoords[0];  						bool Z1IsOne = Z1.IsOne;  						// TODO Optimize for small negative a4 and -3 						ECFieldElement w = curve.A; 						if (!w.IsZero && !Z1IsOne) 						{ 							w = w.Multiply(Z1.Square()); 						} 						w = w.Add(Three(X1.Square()));  						ECFieldElement s = Z1IsOne ? Y1 : Y1.Multiply(Z1); 						ECFieldElement t = Z1IsOne ? Y1.Square() : s.Multiply(Y1); 						ECFieldElement B = X1.Multiply(t); 						ECFieldElement _4B = Four(B); 						ECFieldElement h = w.Square().Subtract(Two(_4B));  						ECFieldElement _2s = Two(s); 						ECFieldElement X3 = h.Multiply(_2s); 						ECFieldElement _2t = Two(t); 						ECFieldElement Y3 = _4B.Subtract(h).Multiply(w).Subtract(Two(_2t.Square())); 						ECFieldElement _4sSquared = Z1IsOne ? Two(_2t) : _2s.Square(); 						ECFieldElement Z3 = Two(_4sSquared).Multiply(s);  						return new FpPoint(curve' X3' Y3' new ECFieldElement[] { Z3 }' IsCompressed); 					}  				case ECCurve.COORD_JACOBIAN: 					{ 						ECFieldElement Z1 = this.RawZCoords[0];  						bool Z1IsOne = Z1.IsOne;  						ECFieldElement Y1Squared = Y1.Square(); 						ECFieldElement T = Y1Squared.Square();  						ECFieldElement a4 = curve.A; 						ECFieldElement a4Neg = a4.Negate();  						ECFieldElement M' S; 						if (a4Neg.ToBigInteger().Equals(BigInteger.ValueOf(3))) 						{ 							ECFieldElement Z1Squared = Z1IsOne ? Z1 : Z1.Square(); 							M = Three(X1.Add(Z1Squared).Multiply(X1.Subtract(Z1Squared))); 							S = Four(Y1Squared.Multiply(X1)); 						} 						else 						{ 							ECFieldElement X1Squared = X1.Square(); 							M = Three(X1Squared); 							if (Z1IsOne) 							{ 								M = M.Add(a4); 							} 							else if (!a4.IsZero) 							{ 								ECFieldElement Z1Squared = Z1IsOne ? Z1 : Z1.Square(); 								ECFieldElement Z1Pow4 = Z1Squared.Square(); 								if (a4Neg.BitLength < a4.BitLength) 								{ 									M = M.Subtract(Z1Pow4.Multiply(a4Neg)); 								} 								else 								{ 									M = M.Add(Z1Pow4.Multiply(a4)); 								} 							} 							//S = two(doubleProductFromSquares(X1' Y1Squared' X1Squared' T)); 							S = Four(X1.Multiply(Y1Squared)); 						}  						ECFieldElement X3 = M.Square().Subtract(Two(S)); 						ECFieldElement Y3 = S.Subtract(X3).Multiply(M).Subtract(Eight(T));  						ECFieldElement Z3 = Two(Y1); 						if (!Z1IsOne) 						{ 							Z3 = Z3.Multiply(Z1); 						}  						// Alternative calculation of Z3 using fast square 						//ECFieldElement Z3 = doubleProductFromSquares(Y1' Z1' Y1Squared' Z1Squared);  						return new FpPoint(curve' X3' Y3' new ECFieldElement[] { Z3 }' IsCompressed); 					}  				case ECCurve.COORD_JACOBIAN_MODIFIED: 					{ 						return TwiceJacobianModified(true); 					}  				default: 					{ 						throw new InvalidOperationException("unsupported coordinate system"); 					} 			}
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,LongArray,The following statement contains a magic number: int intLen = (barrLen + 7) / 8;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,LongArray,The following statement contains a magic number: int intLen = (barrLen + 7) / 8;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,LongArray,The following statement contains a magic number: int rem = barrLen % 8 + barrStart;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,LongArray,The following statement contains a magic number: temp <<= 8;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,LongArray,The following statement contains a magic number: temp <<= 8;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,LongArray,The following statement contains a magic number: i < 8
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Degree,The following statement contains a magic number: return (i << 6) + BitLength(w);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,DegreeFrom,The following statement contains a magic number: int i = (int)(((uint)limit + 62) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,DegreeFrom,The following statement contains a magic number: int i = (int)(((uint)limit + 62) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,DegreeFrom,The following statement contains a magic number: return (i << 6) + BitLength(w);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,BitLength,The following statement contains a magic number: int u = (int)((ulong)w >> 32)' b;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,BitLength,The following statement contains a magic number: int t = (int)((uint)u >> 16)' k;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,BitLength,The following statement contains a magic number: t = (int)((uint)u >> 8);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,BitLength,The following statement contains a magic number: k = (t == 0) ? BitLengths[u] : 8 + BitLengths[t];
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ToBigInteger,The following statement contains a magic number: byte[] temp = new byte[8];
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ToBigInteger,The following statement contains a magic number: byte thisByte = (byte)((ulong)highestInt >> (8 * j));
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ToBigInteger,The following statement contains a magic number: int barrLen = 8 * (usedLen - 1) + barrI;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ToBigInteger,The following statement contains a magic number: barr[barrI++] = (byte)((ulong)mi >> (8 * j));
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ShiftUp,The following statement contains a magic number: int shiftInv = 64 - shift;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ShiftUp,The following statement contains a magic number: int shiftInv = 64 - shift;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,AddShiftedByBitsSafe,The following statement contains a magic number: int otherLen = (int)((uint)(otherDegree + 63) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,AddShiftedByBitsSafe,The following statement contains a magic number: int otherLen = (int)((uint)(otherDegree + 63) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,AddShiftedByBitsSafe,The following statement contains a magic number: int words = (int)((uint)bits >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,AddShiftedUp,The following statement contains a magic number: int shiftInv = 64 - shift;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,AddShiftedDown,The following statement contains a magic number: int shiftInv = 64 - shift;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,FlipWord,The following statement contains a magic number: int n = off + (int)((uint)bit >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,TestBit,The following statement contains a magic number: int theInt = (int)((uint)n >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,FlipBit,The following statement contains a magic number: int theInt = (int)((uint)n >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyLD,The following statement contains a magic number: int aLen = (int)((uint)(aDeg + 63) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyLD,The following statement contains a magic number: int aLen = (int)((uint)(aDeg + 63) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyLD,The following statement contains a magic number: int bLen = (int)((uint)(bDeg + 63) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyLD,The following statement contains a magic number: int bLen = (int)((uint)(bDeg + 63) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyLD,The following statement contains a magic number: int cLen = (int)((uint)(aDeg + bDeg + 62) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyLD,The following statement contains a magic number: int cLen = (int)((uint)(aDeg + bDeg + 62) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyLD,The following statement contains a magic number: int bMax = (int)((uint)(bDeg + 7 + 63) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyLD,The following statement contains a magic number: int bMax = (int)((uint)(bDeg + 7 + 63) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyLD,The following statement contains a magic number: int bMax = (int)((uint)(bDeg + 7 + 63) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyLD,The following statement contains a magic number: int[] ti = new int[16];
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyLD,The following statement contains a magic number: long[] T0 = new long[bMax << 4];
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyLD,The following statement contains a magic number: i < 16
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyLD,The following statement contains a magic number: ShiftUp(T0' 0' T1' 0' T0.Length' 4);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyLD,The following statement contains a magic number: int v = (int)((uint)aVal >> 4) & MASK;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyLD,The following statement contains a magic number: ShiftUp(c' 0' cLen' 8);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyLD,The following statement contains a magic number: int v = (int)((uint)aVal >> 4) & MASK;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyLD,The following statement contains a magic number: ShiftUp(c' 0' cLen' 8);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiply,The following statement contains a magic number: int aLen = (int)((uint)(aDeg + 63) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiply,The following statement contains a magic number: int aLen = (int)((uint)(aDeg + 63) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiply,The following statement contains a magic number: int bLen = (int)((uint)(bDeg + 63) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiply,The following statement contains a magic number: int bLen = (int)((uint)(bDeg + 63) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiply,The following statement contains a magic number: int cLen = (int)((uint)(aDeg + bDeg + 62) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiply,The following statement contains a magic number: int cLen = (int)((uint)(aDeg + bDeg + 62) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiply,The following statement contains a magic number: int bMax = (int)((uint)(bDeg + 7 + 63) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiply,The following statement contains a magic number: int bMax = (int)((uint)(bDeg + 7 + 63) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiply,The following statement contains a magic number: int bMax = (int)((uint)(bDeg + 7 + 63) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiply,The following statement contains a magic number: int[] ti = new int[16];
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiply,The following statement contains a magic number: long[] T0 = new long[bMax << 4];
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiply,The following statement contains a magic number: i < 16
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiply,The following statement contains a magic number: ShiftUp(T0' 0' T1' 0' T0.Length' 4);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiply,The following statement contains a magic number: long[] c = new long[cLen << 3];
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiply,The following statement contains a magic number: aVal = (long)((ulong)aVal >> 4);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiply,The following statement contains a magic number: aVal = (long)((ulong)aVal >> 4);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiply,The following statement contains a magic number: AddShiftedUp(c' cOff - cLen' c' cOff' cLen' 8);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyAlt,The following statement contains a magic number: int aLen = (int)((uint)(aDeg + 63) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyAlt,The following statement contains a magic number: int aLen = (int)((uint)(aDeg + 63) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyAlt,The following statement contains a magic number: int bLen = (int)((uint)(bDeg + 63) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyAlt,The following statement contains a magic number: int bLen = (int)((uint)(bDeg + 63) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyAlt,The following statement contains a magic number: int cLen = (int)((uint)(aDeg + bDeg + 62) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyAlt,The following statement contains a magic number: int cLen = (int)((uint)(aDeg + bDeg + 62) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyAlt,The following statement contains a magic number: width = 4;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyAlt,The following statement contains a magic number: positions = 16;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyAlt,The following statement contains a magic number: top = 64;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyAlt,The following statement contains a magic number: banks = 8;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyAlt,The following statement contains a magic number: int shifts = top < 64 ? positions : positions - 1;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyAlt,The following statement contains a magic number: int bMax = (int)((uint)(bDeg + shifts + 63) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyAlt,The following statement contains a magic number: int bMax = (int)((uint)(bDeg + shifts + 63) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyAlt,The following statement contains a magic number: k >= 64
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModMultiplyAlt,The following statement contains a magic number: k = 64 - width;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Multiply,The following statement contains a magic number: int aLen = (int)((uint)(aDeg + 63) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Multiply,The following statement contains a magic number: int aLen = (int)((uint)(aDeg + 63) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Multiply,The following statement contains a magic number: int bLen = (int)((uint)(bDeg + 63) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Multiply,The following statement contains a magic number: int bLen = (int)((uint)(bDeg + 63) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Multiply,The following statement contains a magic number: int cLen = (int)((uint)(aDeg + bDeg + 62) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Multiply,The following statement contains a magic number: int cLen = (int)((uint)(aDeg + bDeg + 62) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Multiply,The following statement contains a magic number: int bMax = (int)((uint)(bDeg + 7 + 63) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Multiply,The following statement contains a magic number: int bMax = (int)((uint)(bDeg + 7 + 63) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Multiply,The following statement contains a magic number: int bMax = (int)((uint)(bDeg + 7 + 63) >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Multiply,The following statement contains a magic number: int[] ti = new int[16];
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Multiply,The following statement contains a magic number: long[] T0 = new long[bMax << 4];
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Multiply,The following statement contains a magic number: i < 16
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Multiply,The following statement contains a magic number: ShiftUp(T0' 0' T1' 0' T0.Length' 4);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Multiply,The following statement contains a magic number: long[] c = new long[cLen << 3];
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Multiply,The following statement contains a magic number: aVal = (long)((ulong)aVal >> 4);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Multiply,The following statement contains a magic number: aVal = (long)((ulong)aVal >> 4);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Multiply,The following statement contains a magic number: AddShiftedUp(c' cOff - cLen' c' cOff' cLen' 8);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ReduceInPlace,The following statement contains a magic number: int mLen = (m + 63) >> 6;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ReduceInPlace,The following statement contains a magic number: int mLen = (m + 63) >> 6;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ReduceInPlace,The following statement contains a magic number: int numBits = System.Math.Min(len << 6' (m << 1) - 1);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ReduceInPlace,The following statement contains a magic number: int excessBits = (len << 6) - numBits;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ReduceInPlace,The following statement contains a magic number: excessBits -= 64;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ReduceInPlace,The following statement contains a magic number: excessBits >= 64
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ReduceInPlace,The following statement contains a magic number: int kLen = ks.Length' kMax = ks[kLen - 1]' kNext = kLen > 1 ? ks[kLen - 2] : 0;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ReduceInPlace,The following statement contains a magic number: int wordWiseLimit = System.Math.Max(m' kMax + 64);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ReduceInPlace,The following statement contains a magic number: int vectorableWords = (excessBits + System.Math.Min(numBits - wordWiseLimit' m - kNext)) >> 6;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ReduceInPlace,The following statement contains a magic number: numBits = vectorWiseWords << 6;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ReduceWordWise,The following statement contains a magic number: int toPos = (int)((uint)toBit >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ReduceWordWise,The following statement contains a magic number: ReduceWord(buf' off' (len << 6)' word' m' ks);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ReduceVectorWise,The following statement contains a magic number: int baseBit = (words << 6) - m;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,FlipVector,The following statement contains a magic number: xOff += (int)((uint)bits >> 6);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModSquare,The following statement contains a magic number: r[pos++] = Interleave2_32to64((int)((ulong)mi >> 32));
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModSquareN,The following statement contains a magic number: int mLen = (m + 63) >> 6;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModSquareN,The following statement contains a magic number: int mLen = (m + 63) >> 6;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Square,The following statement contains a magic number: r[pos++] = Interleave2_32to64((int)((ulong)mi >> 32));
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,SquareInPlace,The following statement contains a magic number: x[--pos] = Interleave2_32to64((int)((ulong)xVal >> 32));
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave,The following statement contains a magic number: switch (width) 			{ 				case 3: 					Interleave3(x' xOff' z' zOff' count); 					break; 				case 5: 					Interleave5(x' xOff' z' zOff' count); 					break; 				case 7: 					Interleave7(x' xOff' z' zOff' count); 					break; 				default: 					Interleave2_n(x' xOff' z' zOff' count' BitLengths[width] - 1); 					break; 			}
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave,The following statement contains a magic number: switch (width) 			{ 				case 3: 					Interleave3(x' xOff' z' zOff' count); 					break; 				case 5: 					Interleave5(x' xOff' z' zOff' count); 					break; 				case 7: 					Interleave7(x' xOff' z' zOff' count); 					break; 				default: 					Interleave2_n(x' xOff' z' zOff' count' BitLengths[width] - 1); 					break; 			}
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave,The following statement contains a magic number: switch (width) 			{ 				case 3: 					Interleave3(x' xOff' z' zOff' count); 					break; 				case 5: 					Interleave5(x' xOff' z' zOff' count); 					break; 				case 7: 					Interleave7(x' xOff' z' zOff' count); 					break; 				default: 					Interleave2_n(x' xOff' z' zOff' count' BitLengths[width] - 1); 					break; 			}
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave3,The following statement contains a magic number: long z = x & (1L << 63);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave3,The following statement contains a magic number: return z 				| Interleave3_21to63((int)x & 0x1FFFFF) 				| Interleave3_21to63((int)((ulong)x >> 21) & 0x1FFFFF) << 1 				| Interleave3_21to63((int)((ulong)x >> 42) & 0x1FFFFF) << 2;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave3,The following statement contains a magic number: return z 				| Interleave3_21to63((int)x & 0x1FFFFF) 				| Interleave3_21to63((int)((ulong)x >> 21) & 0x1FFFFF) << 1 				| Interleave3_21to63((int)((ulong)x >> 42) & 0x1FFFFF) << 2;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave3,The following statement contains a magic number: return z 				| Interleave3_21to63((int)x & 0x1FFFFF) 				| Interleave3_21to63((int)((ulong)x >> 21) & 0x1FFFFF) << 1 				| Interleave3_21to63((int)((ulong)x >> 42) & 0x1FFFFF) << 2;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave3_21to63,The following statement contains a magic number: int r21 = INTERLEAVE3_TABLE[((uint)x >> 7) & 0x7F];
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave3_21to63,The following statement contains a magic number: int r42 = INTERLEAVE3_TABLE[(uint)x >> 14];
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave3_21to63,The following statement contains a magic number: return (r42 & 0xFFFFFFFFL) << 42 | (r21 & 0xFFFFFFFFL) << 21 | (r00 & 0xFFFFFFFFL);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave3_21to63,The following statement contains a magic number: return (r42 & 0xFFFFFFFFL) << 42 | (r21 & 0xFFFFFFFFL) << 21 | (r00 & 0xFFFFFFFFL);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave5,The following statement contains a magic number: return Interleave3_13to65((int)x & 0x1FFF) 				| Interleave3_13to65((int)((ulong)x >> 13) & 0x1FFF) << 1 				| Interleave3_13to65((int)((ulong)x >> 26) & 0x1FFF) << 2 				| Interleave3_13to65((int)((ulong)x >> 39) & 0x1FFF) << 3 				| Interleave3_13to65((int)((ulong)x >> 52) & 0x1FFF) << 4;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave5,The following statement contains a magic number: return Interleave3_13to65((int)x & 0x1FFF) 				| Interleave3_13to65((int)((ulong)x >> 13) & 0x1FFF) << 1 				| Interleave3_13to65((int)((ulong)x >> 26) & 0x1FFF) << 2 				| Interleave3_13to65((int)((ulong)x >> 39) & 0x1FFF) << 3 				| Interleave3_13to65((int)((ulong)x >> 52) & 0x1FFF) << 4;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave5,The following statement contains a magic number: return Interleave3_13to65((int)x & 0x1FFF) 				| Interleave3_13to65((int)((ulong)x >> 13) & 0x1FFF) << 1 				| Interleave3_13to65((int)((ulong)x >> 26) & 0x1FFF) << 2 				| Interleave3_13to65((int)((ulong)x >> 39) & 0x1FFF) << 3 				| Interleave3_13to65((int)((ulong)x >> 52) & 0x1FFF) << 4;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave5,The following statement contains a magic number: return Interleave3_13to65((int)x & 0x1FFF) 				| Interleave3_13to65((int)((ulong)x >> 13) & 0x1FFF) << 1 				| Interleave3_13to65((int)((ulong)x >> 26) & 0x1FFF) << 2 				| Interleave3_13to65((int)((ulong)x >> 39) & 0x1FFF) << 3 				| Interleave3_13to65((int)((ulong)x >> 52) & 0x1FFF) << 4;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave5,The following statement contains a magic number: return Interleave3_13to65((int)x & 0x1FFF) 				| Interleave3_13to65((int)((ulong)x >> 13) & 0x1FFF) << 1 				| Interleave3_13to65((int)((ulong)x >> 26) & 0x1FFF) << 2 				| Interleave3_13to65((int)((ulong)x >> 39) & 0x1FFF) << 3 				| Interleave3_13to65((int)((ulong)x >> 52) & 0x1FFF) << 4;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave5,The following statement contains a magic number: return Interleave3_13to65((int)x & 0x1FFF) 				| Interleave3_13to65((int)((ulong)x >> 13) & 0x1FFF) << 1 				| Interleave3_13to65((int)((ulong)x >> 26) & 0x1FFF) << 2 				| Interleave3_13to65((int)((ulong)x >> 39) & 0x1FFF) << 3 				| Interleave3_13to65((int)((ulong)x >> 52) & 0x1FFF) << 4;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave5,The following statement contains a magic number: return Interleave3_13to65((int)x & 0x1FFF) 				| Interleave3_13to65((int)((ulong)x >> 13) & 0x1FFF) << 1 				| Interleave3_13to65((int)((ulong)x >> 26) & 0x1FFF) << 2 				| Interleave3_13to65((int)((ulong)x >> 39) & 0x1FFF) << 3 				| Interleave3_13to65((int)((ulong)x >> 52) & 0x1FFF) << 4;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave3_13to65,The following statement contains a magic number: int r35 = INTERLEAVE5_TABLE[(uint)x >> 7];
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave3_13to65,The following statement contains a magic number: return (r35 & 0xFFFFFFFFL) << 35 | (r00 & 0xFFFFFFFFL);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave7,The following statement contains a magic number: long z = x & (1L << 63);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave7,The following statement contains a magic number: return z 				| INTERLEAVE7_TABLE[(int)x & 0x1FF] 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 9) & 0x1FF] << 1 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 18) & 0x1FF] << 2 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 27) & 0x1FF] << 3 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 36) & 0x1FF] << 4 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 45) & 0x1FF] << 5 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 54) & 0x1FF] << 6;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave7,The following statement contains a magic number: return z 				| INTERLEAVE7_TABLE[(int)x & 0x1FF] 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 9) & 0x1FF] << 1 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 18) & 0x1FF] << 2 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 27) & 0x1FF] << 3 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 36) & 0x1FF] << 4 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 45) & 0x1FF] << 5 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 54) & 0x1FF] << 6;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave7,The following statement contains a magic number: return z 				| INTERLEAVE7_TABLE[(int)x & 0x1FF] 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 9) & 0x1FF] << 1 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 18) & 0x1FF] << 2 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 27) & 0x1FF] << 3 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 36) & 0x1FF] << 4 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 45) & 0x1FF] << 5 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 54) & 0x1FF] << 6;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave7,The following statement contains a magic number: return z 				| INTERLEAVE7_TABLE[(int)x & 0x1FF] 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 9) & 0x1FF] << 1 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 18) & 0x1FF] << 2 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 27) & 0x1FF] << 3 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 36) & 0x1FF] << 4 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 45) & 0x1FF] << 5 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 54) & 0x1FF] << 6;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave7,The following statement contains a magic number: return z 				| INTERLEAVE7_TABLE[(int)x & 0x1FF] 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 9) & 0x1FF] << 1 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 18) & 0x1FF] << 2 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 27) & 0x1FF] << 3 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 36) & 0x1FF] << 4 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 45) & 0x1FF] << 5 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 54) & 0x1FF] << 6;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave7,The following statement contains a magic number: return z 				| INTERLEAVE7_TABLE[(int)x & 0x1FF] 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 9) & 0x1FF] << 1 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 18) & 0x1FF] << 2 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 27) & 0x1FF] << 3 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 36) & 0x1FF] << 4 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 45) & 0x1FF] << 5 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 54) & 0x1FF] << 6;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave7,The following statement contains a magic number: return z 				| INTERLEAVE7_TABLE[(int)x & 0x1FF] 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 9) & 0x1FF] << 1 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 18) & 0x1FF] << 2 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 27) & 0x1FF] << 3 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 36) & 0x1FF] << 4 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 45) & 0x1FF] << 5 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 54) & 0x1FF] << 6;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave7,The following statement contains a magic number: return z 				| INTERLEAVE7_TABLE[(int)x & 0x1FF] 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 9) & 0x1FF] << 1 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 18) & 0x1FF] << 2 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 27) & 0x1FF] << 3 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 36) & 0x1FF] << 4 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 45) & 0x1FF] << 5 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 54) & 0x1FF] << 6;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave7,The following statement contains a magic number: return z 				| INTERLEAVE7_TABLE[(int)x & 0x1FF] 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 9) & 0x1FF] << 1 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 18) & 0x1FF] << 2 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 27) & 0x1FF] << 3 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 36) & 0x1FF] << 4 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 45) & 0x1FF] << 5 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 54) & 0x1FF] << 6;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave7,The following statement contains a magic number: return z 				| INTERLEAVE7_TABLE[(int)x & 0x1FF] 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 9) & 0x1FF] << 1 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 18) & 0x1FF] << 2 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 27) & 0x1FF] << 3 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 36) & 0x1FF] << 4 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 45) & 0x1FF] << 5 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 54) & 0x1FF] << 6;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave7,The following statement contains a magic number: return z 				| INTERLEAVE7_TABLE[(int)x & 0x1FF] 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 9) & 0x1FF] << 1 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 18) & 0x1FF] << 2 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 27) & 0x1FF] << 3 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 36) & 0x1FF] << 4 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 45) & 0x1FF] << 5 				| INTERLEAVE7_TABLE[(int)((ulong)x >> 54) & 0x1FF] << 6;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave2_n,The following statement contains a magic number: rounds -= 2;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave2_n,The following statement contains a magic number: x = Interleave4_16to64((int)x & 0xFFFF) 					| Interleave4_16to64((int)((ulong)x >> 16) & 0xFFFF) << 1 					| Interleave4_16to64((int)((ulong)x >> 32) & 0xFFFF) << 2 					| Interleave4_16to64((int)((ulong)x >> 48) & 0xFFFF) << 3;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave2_n,The following statement contains a magic number: x = Interleave4_16to64((int)x & 0xFFFF) 					| Interleave4_16to64((int)((ulong)x >> 16) & 0xFFFF) << 1 					| Interleave4_16to64((int)((ulong)x >> 32) & 0xFFFF) << 2 					| Interleave4_16to64((int)((ulong)x >> 48) & 0xFFFF) << 3;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave2_n,The following statement contains a magic number: x = Interleave4_16to64((int)x & 0xFFFF) 					| Interleave4_16to64((int)((ulong)x >> 16) & 0xFFFF) << 1 					| Interleave4_16to64((int)((ulong)x >> 32) & 0xFFFF) << 2 					| Interleave4_16to64((int)((ulong)x >> 48) & 0xFFFF) << 3;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave2_n,The following statement contains a magic number: x = Interleave4_16to64((int)x & 0xFFFF) 					| Interleave4_16to64((int)((ulong)x >> 16) & 0xFFFF) << 1 					| Interleave4_16to64((int)((ulong)x >> 32) & 0xFFFF) << 2 					| Interleave4_16to64((int)((ulong)x >> 48) & 0xFFFF) << 3;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave2_n,The following statement contains a magic number: x = Interleave4_16to64((int)x & 0xFFFF) 					| Interleave4_16to64((int)((ulong)x >> 16) & 0xFFFF) << 1 					| Interleave4_16to64((int)((ulong)x >> 32) & 0xFFFF) << 2 					| Interleave4_16to64((int)((ulong)x >> 48) & 0xFFFF) << 3;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave2_n,The following statement contains a magic number: x = Interleave2_32to64((int)x) | Interleave2_32to64((int)((ulong)x >> 32)) << 1;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave4_16to64,The following statement contains a magic number: int r32 = INTERLEAVE4_TABLE[(uint)x >> 8];
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave4_16to64,The following statement contains a magic number: return (r32 & 0xFFFFFFFFL) << 32 | (r00 & 0xFFFFFFFFL);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave2_32to64,The following statement contains a magic number: int r00 = INTERLEAVE2_TABLE[x & 0xFF] | INTERLEAVE2_TABLE[((uint)x >> 8) & 0xFF] << 16;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave2_32to64,The following statement contains a magic number: int r00 = INTERLEAVE2_TABLE[x & 0xFF] | INTERLEAVE2_TABLE[((uint)x >> 8) & 0xFF] << 16;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave2_32to64,The following statement contains a magic number: int r32 = INTERLEAVE2_TABLE[((uint)x >> 16) & 0xFF] | INTERLEAVE2_TABLE[(uint)x >> 24] << 16;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave2_32to64,The following statement contains a magic number: int r32 = INTERLEAVE2_TABLE[((uint)x >> 16) & 0xFF] | INTERLEAVE2_TABLE[(uint)x >> 24] << 16;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave2_32to64,The following statement contains a magic number: int r32 = INTERLEAVE2_TABLE[((uint)x >> 16) & 0xFF] | INTERLEAVE2_TABLE[(uint)x >> 24] << 16;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,Interleave2_32to64,The following statement contains a magic number: return (r32 & 0xFFFFFFFFL) << 32 | (r00 & 0xFFFFFFFFL);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModInverse,The following statement contains a magic number: int t = (m + 63) >> 6;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ModInverse,The following statement contains a magic number: int t = (m + 63) >> 6;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,GetHashCode,The following statement contains a magic number: hash *= 31;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,GetHashCode,The following statement contains a magic number: hash *= 31;
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,GetHashCode,The following statement contains a magic number: hash ^= (int)((ulong)mi >> 32);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ToString,The following statement contains a magic number: StringBuilder sb = new StringBuilder(Convert.ToString(m_ints[--i]' 2));
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ToString,The following statement contains a magic number: string s = Convert.ToString(m_ints[i]' 2);
Magic Number,NBitcoin.BouncyCastle.Math.EC,LongArray,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\LongArray.cs,ToString,The following statement contains a magic number: len < 64
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,FixedPointCombMultiplier,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\FixedPointCombMultiplier.cs,GetWidthForCombSize,The following statement contains a magic number: return combSize > 257 ? 6 : 5;
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,FixedPointCombMultiplier,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\FixedPointCombMultiplier.cs,GetWidthForCombSize,The following statement contains a magic number: return combSize > 257 ? 6 : 5;
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,FixedPointCombMultiplier,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\FixedPointCombMultiplier.cs,GetWidthForCombSize,The following statement contains a magic number: return combSize > 257 ? 6 : 5;
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafL2RMultiplier,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafL2RMultiplier.cs,MultiplyPositive,The following statement contains a magic number: int width = System.Math.Max(2' System.Math.Min(16' GetWindowSize(k.BitLength)));
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafL2RMultiplier,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafL2RMultiplier.cs,MultiplyPositive,The following statement contains a magic number: int width = System.Math.Max(2' System.Math.Min(16' GetWindowSize(k.BitLength)));
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafL2RMultiplier,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafL2RMultiplier.cs,MultiplyPositive,The following statement contains a magic number: int digit = wi >> 16' zeroes = wi & 0xFFFF;
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafL2RMultiplier,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafL2RMultiplier.cs,MultiplyPositive,The following statement contains a magic number: (n << 2) < (1 << width)
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafL2RMultiplier,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafL2RMultiplier.cs,MultiplyPositive,The following statement contains a magic number: int digit = wi >> 16' zeroes = wi & 0xFFFF;
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,GenerateCompactNaf,The following statement contains a magic number: (k.BitLength >> 16) != 0
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,GenerateCompactNaf,The following statement contains a magic number: naf[length++] = (digit << 16) | zeroes;
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,GenerateCompactNaf,The following statement contains a magic number: naf[length++] = (1 << 16) | zeroes;
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,GenerateCompactWindowNaf,The following statement contains a magic number: width == 2
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,GenerateCompactWindowNaf,The following statement contains a magic number: width < 2 || width > 16
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,GenerateCompactWindowNaf,The following statement contains a magic number: width < 2 || width > 16
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,GenerateCompactWindowNaf,The following statement contains a magic number: (k.BitLength >> 16) != 0
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,GenerateCompactWindowNaf,The following statement contains a magic number: wnaf[length++] = (digit << 16) | zeroes;
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,GenerateJsf,The following statement contains a magic number: int n0 = ((int)((uint)k0.IntValue >> offset) + d0) & 7;
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,GenerateJsf,The following statement contains a magic number: int n1 = ((int)((uint)k1.IntValue >> offset) + d1) & 7;
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,GenerateJsf,The following statement contains a magic number: u0 -= (n0 & 2);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,GenerateJsf,The following statement contains a magic number: (n0 + u0) == 4 && (n1 & 3) == 2
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,GenerateJsf,The following statement contains a magic number: (n0 + u0) == 4 && (n1 & 3) == 2
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,GenerateJsf,The following statement contains a magic number: (n0 + u0) == 4 && (n1 & 3) == 2
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,GenerateJsf,The following statement contains a magic number: u1 -= (n1 & 2);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,GenerateJsf,The following statement contains a magic number: (n1 + u1) == 4 && (n0 & 3) == 2
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,GenerateJsf,The following statement contains a magic number: (n1 + u1) == 4 && (n0 & 3) == 2
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,GenerateJsf,The following statement contains a magic number: (n1 + u1) == 4 && (n0 & 3) == 2
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,GenerateJsf,The following statement contains a magic number: k0 = k0.ShiftRight(30);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,GenerateJsf,The following statement contains a magic number: k1 = k1.ShiftRight(30);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,GenerateJsf,The following statement contains a magic number: ++offset == 30
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,GenerateJsf,The following statement contains a magic number: jsf[j++] = (byte)((u0 << 4) | (u1 & 0xF));
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,GenerateWindowNaf,The following statement contains a magic number: width == 2
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,GenerateWindowNaf,The following statement contains a magic number: width < 2 || width > 8
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,GenerateWindowNaf,The following statement contains a magic number: width < 2 || width > 8
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,GetWindowSize,The following statement contains a magic number: return w + 2;
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,Precompute,The following statement contains a magic number: int iniPreCompLen = 0' reqPreCompLen = 1 << System.Math.Max(0' width - 2);
Magic Number,NBitcoin.BouncyCastle.Math.EC.Multiplier,WTauNafMultiplier,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WTauNafMultiplier.cs,MultiplyPositive,The following statement contains a magic number: ZTauElement rho = Tnaf.PartModReduction(k' m' a' s' mu' (sbyte)10);
Magic Number,NBitcoin.BouncyCastle.Math.Field,FiniteFields,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\field\FiniteFields.cs,GetPrimeField,The following statement contains a magic number: characteristic.SignValue <= 0 || bitLength < 2
Magic Number,NBitcoin.BouncyCastle.Math.Field,FiniteFields,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\field\FiniteFields.cs,GetPrimeField,The following statement contains a magic number: switch (characteristic.IntValue)  				{  					case 2:  						return GF_2;  					case 3:  						return GF_3;  				}
Magic Number,NBitcoin.BouncyCastle.Math.Field,FiniteFields,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\field\FiniteFields.cs,GetPrimeField,The following statement contains a magic number: switch (characteristic.IntValue)  				{  					case 2:  						return GF_2;  					case 3:  						return GF_3;  				}
Magic Number,NBitcoin.BouncyCastle.Math.Field,FiniteFields,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\field\FiniteFields.cs,GetPrimeField,The following statement contains a magic number: bitLength < 3
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Mod,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Mod.cs,Random,The following statement contains a magic number: m |= m >> 2;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Mod,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Mod.cs,Random,The following statement contains a magic number: m |= m >> 4;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Mod,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Mod.cs,Random,The following statement contains a magic number: m |= m >> 8;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Mod,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Mod.cs,Random,The following statement contains a magic number: m |= m >> 16;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Mod,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Mod.cs,Random,The following statement contains a magic number: byte[] bytes = new byte[len << 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Mod,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Mod.cs,InversionStep,The following statement contains a magic number: count += 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Add,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Add33At,The following statement contains a magic number: Debug.Assert(zPos <= (len - 2));
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Add33At,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Add33At,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Add33At,The following statement contains a magic number: return c == 0 ? 0 : IncAt(len' z' zPos + 2);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Add33At,The following statement contains a magic number: Debug.Assert(zPos <= (len - 2));
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Add33At,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Add33At,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Add33At,The following statement contains a magic number: return c == 0 ? 0 : IncAt(len' z' zOff' zPos + 2);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Add33To,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Add33To,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Add33To,The following statement contains a magic number: return c == 0 ? 0 : IncAt(len' z' 2);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Add33To,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Add33To,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Add33To,The following statement contains a magic number: return c == 0 ? 0 : IncAt(len' z' zOff' 2);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,AddBothTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,AddBothTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,AddDWordAt,The following statement contains a magic number: Debug.Assert(zPos <= (len - 2));
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,AddDWordAt,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,AddDWordAt,The following statement contains a magic number: c += (ulong)z[zPos + 1] + (x >> 32);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,AddDWordAt,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,AddDWordAt,The following statement contains a magic number: return c == 0 ? 0 : IncAt(len' z' zPos + 2);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,AddDWordAt,The following statement contains a magic number: Debug.Assert(zPos <= (len - 2));
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,AddDWordAt,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,AddDWordAt,The following statement contains a magic number: c += (ulong)z[zOff + zPos + 1] + (x >> 32);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,AddDWordAt,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,AddDWordAt,The following statement contains a magic number: return c == 0 ? 0 : IncAt(len' z' zOff' zPos + 2);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,AddDWordTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,AddDWordTo,The following statement contains a magic number: c += (ulong)z[1] + (x >> 32);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,AddDWordTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,AddDWordTo,The following statement contains a magic number: return c == 0 ? 0 : IncAt(len' z' 2);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,AddDWordTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,AddDWordTo,The following statement contains a magic number: c += (ulong)z[zOff + 1] + (x >> 32);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,AddDWordTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,AddDWordTo,The following statement contains a magic number: return c == 0 ? 0 : IncAt(len' z' zOff' 2);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,AddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,AddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,AddWordAt,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,AddWordAt,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,AddWordTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,AddWordTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,FromBigInteger,The following statement contains a magic number: int len = (bits + 31) >> 5;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,FromBigInteger,The following statement contains a magic number: int len = (bits + 31) >> 5;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,FromBigInteger,The following statement contains a magic number: x = x.ShiftRight(32);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,GetBit,The following statement contains a magic number: int w = bit >> 5;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,GetBit,The following statement contains a magic number: int b = bit & 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Mul31BothAdd,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,MulWord,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,MulWord,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,MulWordAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,MulWordDwordAddAt,The following statement contains a magic number: Debug.Assert(zPos <= (len - 3));
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,MulWordDwordAddAt,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,MulWordDwordAddAt,The following statement contains a magic number: c += xVal * (y >> 32) + z[zPos + 1];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,MulWordDwordAddAt,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,MulWordDwordAddAt,The following statement contains a magic number: c += (ulong)z[zPos + 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,MulWordDwordAddAt,The following statement contains a magic number: z[zPos + 2] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,MulWordDwordAddAt,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,MulWordDwordAddAt,The following statement contains a magic number: return c == 0 ? 0 : IncAt(len' z' zPos + 3);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftDownBit,The following statement contains a magic number: z[i] = (next >> 1) | (c << 31);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftDownBit,The following statement contains a magic number: return c << 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftDownBit,The following statement contains a magic number: z[zOff + i] = (next >> 1) | (c << 31);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftDownBit,The following statement contains a magic number: return c << 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftDownBit,The following statement contains a magic number: z[i] = (next >> 1) | (c << 31);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftDownBit,The following statement contains a magic number: return c << 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftDownBit,The following statement contains a magic number: z[zOff + i] = (next >> 1) | (c << 31);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftDownBit,The following statement contains a magic number: return c << 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftDownBits,The following statement contains a magic number: Debug.Assert(bits > 0 && bits < 32);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftDownBits,The following statement contains a magic number: Debug.Assert(bits > 0 && bits < 32);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftDownBits,The following statement contains a magic number: Debug.Assert(bits > 0 && bits < 32);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftDownBits,The following statement contains a magic number: Debug.Assert(bits > 0 && bits < 32);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftUpBit,The following statement contains a magic number: z[i] = (next << 1) | (c >> 31);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftUpBit,The following statement contains a magic number: return c >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftUpBit,The following statement contains a magic number: z[zOff + i] = (next << 1) | (c >> 31);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftUpBit,The following statement contains a magic number: return c >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftUpBit,The following statement contains a magic number: z[i] = (next << 1) | (c >> 31);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftUpBit,The following statement contains a magic number: return c >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftUpBit,The following statement contains a magic number: z[zOff + i] = (next << 1) | (c >> 31);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftUpBit,The following statement contains a magic number: return c >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftUpBit64,The following statement contains a magic number: z[zOff + i] = (next << 1) | (c >> 63);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftUpBit64,The following statement contains a magic number: return c >> 63;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftUpBits,The following statement contains a magic number: Debug.Assert(bits > 0 && bits < 32);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftUpBits,The following statement contains a magic number: Debug.Assert(bits > 0 && bits < 32);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftUpBits64,The following statement contains a magic number: Debug.Assert(bits > 0 && bits < 64);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftUpBits,The following statement contains a magic number: Debug.Assert(bits > 0 && bits < 32);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftUpBits,The following statement contains a magic number: Debug.Assert(bits > 0 && bits < 32);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ShiftUpBits64,The following statement contains a magic number: Debug.Assert(bits > 0 && bits < 64);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Square,The following statement contains a magic number: zz[--k] = (c << 31) | (uint)(p >> 33);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Square,The following statement contains a magic number: zz[--k] = (c << 31) | (uint)(p >> 33);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Square,The following statement contains a magic number: ShiftUpBit(extLen' zz' x[0] << 31);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Square,The following statement contains a magic number: zz[zzOff + --k] = (c << 31) | (uint)(p >> 33);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Square,The following statement contains a magic number: zz[zzOff + --k] = (c << 31) | (uint)(p >> 33);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Square,The following statement contains a magic number: ShiftUpBit(extLen' zz' zzOff' x[xOff] << 31);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SquareWordAdd,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SquareWordAdd,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Sub,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Sub,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Sub33At,The following statement contains a magic number: Debug.Assert(zPos <= (len - 2));
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Sub33At,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Sub33At,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Sub33At,The following statement contains a magic number: return c == 0 ? 0 : DecAt(len' z' zPos + 2);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Sub33At,The following statement contains a magic number: Debug.Assert(zPos <= (len - 2));
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Sub33At,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Sub33At,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Sub33At,The following statement contains a magic number: return c == 0 ? 0 : DecAt(len' z' zOff' zPos + 2);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Sub33From,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Sub33From,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Sub33From,The following statement contains a magic number: return c == 0 ? 0 : DecAt(len' z' 2);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Sub33From,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Sub33From,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,Sub33From,The following statement contains a magic number: return c == 0 ? 0 : DecAt(len' z' zOff' 2);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SubBothFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SubBothFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SubDWordAt,The following statement contains a magic number: Debug.Assert(zPos <= (len - 2));
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SubDWordAt,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SubDWordAt,The following statement contains a magic number: c += (long)z[zPos + 1] - (long)(x >> 32);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SubDWordAt,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SubDWordAt,The following statement contains a magic number: return c == 0 ? 0 : DecAt(len' z' zPos + 2);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SubDWordAt,The following statement contains a magic number: Debug.Assert(zPos <= (len - 2));
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SubDWordAt,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SubDWordAt,The following statement contains a magic number: c += (long)z[zOff + zPos + 1] - (long)(x >> 32);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SubDWordAt,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SubDWordAt,The following statement contains a magic number: return c == 0 ? 0 : DecAt(len' z' zOff' zPos + 2);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SubDWordFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SubDWordFrom,The following statement contains a magic number: c += (long)z[1] - (long)(x >> 32);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SubDWordFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SubDWordFrom,The following statement contains a magic number: return c == 0 ? 0 : DecAt(len' z' 2);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SubDWordFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SubDWordFrom,The following statement contains a magic number: c += (long)z[zOff + 1] - (long)(x >> 32);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SubDWordFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SubDWordFrom,The following statement contains a magic number: return c == 0 ? 0 : DecAt(len' z' zOff' 2);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SubFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SubFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SubWordAt,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SubWordAt,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SubWordFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,SubWordFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ToBigInteger,The following statement contains a magic number: byte[] bs = new byte[len << 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat.cs,ToBigInteger,The following statement contains a magic number: Pack.UInt32_To_BE(x_i' bs' (len - 1 - i) << 2);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c += (ulong)x[2] + y[2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c += (ulong)x[2] + y[2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: z[2] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c += (ulong)x[3] + y[3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c += (ulong)x[3] + y[3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: z[3] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c += (ulong)x[4] + y[4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c += (ulong)x[4] + y[4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: z[4] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c += (ulong)x[5] + y[5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c += (ulong)x[5] + y[5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: z[5] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c += (ulong)x[6] + y[6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c += (ulong)x[6] + y[6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: z[6] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c += (ulong)x[7] + y[7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c += (ulong)x[7] + y[7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: z[7] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c += (ulong)x[xOff + 2] + y[yOff + 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c += (ulong)x[xOff + 2] + y[yOff + 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: z[zOff + 2] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c += (ulong)x[xOff + 3] + y[yOff + 3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c += (ulong)x[xOff + 3] + y[yOff + 3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: z[zOff + 3] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c += (ulong)x[xOff + 4] + y[yOff + 4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c += (ulong)x[xOff + 4] + y[yOff + 4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: z[zOff + 4] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c += (ulong)x[xOff + 5] + y[yOff + 5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c += (ulong)x[xOff + 5] + y[yOff + 5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: z[zOff + 5] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c += (ulong)x[xOff + 6] + y[yOff + 6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c += (ulong)x[xOff + 6] + y[yOff + 6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: z[zOff + 6] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c += (ulong)x[xOff + 7] + y[yOff + 7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c += (ulong)x[xOff + 7] + y[yOff + 7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: z[zOff + 7] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Add,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[2] + y[2] + z[2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[2] + y[2] + z[2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[2] + y[2] + z[2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: z[2] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[3] + y[3] + z[3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[3] + y[3] + z[3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[3] + y[3] + z[3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: z[3] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[4] + y[4] + z[4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[4] + y[4] + z[4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[4] + y[4] + z[4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: z[4] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[5] + y[5] + z[5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[5] + y[5] + z[5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[5] + y[5] + z[5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: z[5] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[6] + y[6] + z[6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[6] + y[6] + z[6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[6] + y[6] + z[6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: z[6] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[7] + y[7] + z[7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[7] + y[7] + z[7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[7] + y[7] + z[7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: z[7] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[xOff + 2] + y[yOff + 2] + z[zOff + 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[xOff + 2] + y[yOff + 2] + z[zOff + 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[xOff + 2] + y[yOff + 2] + z[zOff + 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: z[zOff + 2] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[xOff + 3] + y[yOff + 3] + z[zOff + 3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[xOff + 3] + y[yOff + 3] + z[zOff + 3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[xOff + 3] + y[yOff + 3] + z[zOff + 3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: z[zOff + 3] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[xOff + 4] + y[yOff + 4] + z[zOff + 4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[xOff + 4] + y[yOff + 4] + z[zOff + 4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[xOff + 4] + y[yOff + 4] + z[zOff + 4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: z[zOff + 4] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[xOff + 5] + y[yOff + 5] + z[zOff + 5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[xOff + 5] + y[yOff + 5] + z[zOff + 5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[xOff + 5] + y[yOff + 5] + z[zOff + 5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: z[zOff + 5] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[xOff + 6] + y[yOff + 6] + z[zOff + 6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[xOff + 6] + y[yOff + 6] + z[zOff + 6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[xOff + 6] + y[yOff + 6] + z[zOff + 6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: z[zOff + 6] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[xOff + 7] + y[yOff + 7] + z[zOff + 7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[xOff + 7] + y[yOff + 7] + z[zOff + 7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c += (ulong)x[xOff + 7] + y[yOff + 7] + z[zOff + 7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: z[zOff + 7] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddBothTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c += (ulong)x[2] + z[2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c += (ulong)x[2] + z[2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: z[2] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c += (ulong)x[3] + z[3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c += (ulong)x[3] + z[3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: z[3] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c += (ulong)x[4] + z[4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c += (ulong)x[4] + z[4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: z[4] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c += (ulong)x[5] + z[5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c += (ulong)x[5] + z[5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: z[5] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c += (ulong)x[6] + z[6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c += (ulong)x[6] + z[6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: z[6] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c += (ulong)x[7] + z[7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c += (ulong)x[7] + z[7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: z[7] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c += (ulong)x[xOff + 2] + z[zOff + 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c += (ulong)x[xOff + 2] + z[zOff + 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: z[zOff + 2] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c += (ulong)x[xOff + 3] + z[zOff + 3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c += (ulong)x[xOff + 3] + z[zOff + 3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: z[zOff + 3] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c += (ulong)x[xOff + 4] + z[zOff + 4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c += (ulong)x[xOff + 4] + z[zOff + 4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: z[zOff + 4] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c += (ulong)x[xOff + 5] + z[zOff + 5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c += (ulong)x[xOff + 5] + z[zOff + 5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: z[zOff + 5] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c += (ulong)x[xOff + 6] + z[zOff + 6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c += (ulong)x[xOff + 6] + z[zOff + 6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: z[zOff + 6] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c += (ulong)x[xOff + 7] + z[zOff + 7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c += (ulong)x[xOff + 7] + z[zOff + 7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: z[zOff + 7] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: c += (ulong)u[uOff + 2] + v[vOff + 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: c += (ulong)u[uOff + 2] + v[vOff + 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: u[uOff + 2] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: v[vOff + 2] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: c += (ulong)u[uOff + 3] + v[vOff + 3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: c += (ulong)u[uOff + 3] + v[vOff + 3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: u[uOff + 3] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: v[vOff + 3] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: c += (ulong)u[uOff + 4] + v[vOff + 4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: c += (ulong)u[uOff + 4] + v[vOff + 4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: u[uOff + 4] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: v[vOff + 4] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: c += (ulong)u[uOff + 5] + v[vOff + 5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: c += (ulong)u[uOff + 5] + v[vOff + 5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: u[uOff + 5] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: v[vOff + 5] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: c += (ulong)u[uOff + 6] + v[vOff + 6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: c += (ulong)u[uOff + 6] + v[vOff + 6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: u[uOff + 6] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: v[vOff + 6] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: c += (ulong)u[uOff + 7] + v[vOff + 7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: c += (ulong)u[uOff + 7] + v[vOff + 7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: u[uOff + 7] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: v[vOff + 7] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,AddToEachOther,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Copy,The following statement contains a magic number: z[2] = x[2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Copy,The following statement contains a magic number: z[2] = x[2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Copy,The following statement contains a magic number: z[3] = x[3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Copy,The following statement contains a magic number: z[3] = x[3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Copy,The following statement contains a magic number: z[4] = x[4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Copy,The following statement contains a magic number: z[4] = x[4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Copy,The following statement contains a magic number: z[5] = x[5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Copy,The following statement contains a magic number: z[5] = x[5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Copy,The following statement contains a magic number: z[6] = x[6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Copy,The following statement contains a magic number: z[6] = x[6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Copy,The following statement contains a magic number: z[7] = x[7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Copy,The following statement contains a magic number: z[7] = x[7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Copy64,The following statement contains a magic number: z[2] = x[2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Copy64,The following statement contains a magic number: z[2] = x[2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Copy64,The following statement contains a magic number: z[3] = x[3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Copy64,The following statement contains a magic number: z[3] = x[3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Create,The following statement contains a magic number: return new uint[8];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Create64,The following statement contains a magic number: return new ulong[4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,CreateExt,The following statement contains a magic number: return new uint[16];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,CreateExt64,The following statement contains a magic number: return new ulong[8];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,FromBigInteger,The following statement contains a magic number: x.SignValue < 0 || x.BitLength > 256
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,FromBigInteger,The following statement contains a magic number: x = x.ShiftRight(32);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,FromBigInteger64,The following statement contains a magic number: x.SignValue < 0 || x.BitLength > 256
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,FromBigInteger64,The following statement contains a magic number: x = x.ShiftRight(64);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,GetBit,The following statement contains a magic number: (bit & 255) != bit
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,GetBit,The following statement contains a magic number: int w = bit >> 5;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,GetBit,The following statement contains a magic number: int b = bit & 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,IsOne,The following statement contains a magic number: i < 8
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,IsOne64,The following statement contains a magic number: i < 4
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,IsZero,The following statement contains a magic number: i < 8
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,IsZero64,The following statement contains a magic number: i < 4
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: ulong y_2 = y[2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: ulong y_3 = y[3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: ulong y_4 = y[4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: ulong y_5 = y[5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: ulong y_6 = y[6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: ulong y_7 = y[7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: zz[2] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: zz[3] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: zz[4] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: zz[5] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: zz[6] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: zz[7] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: zz[8] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c += x_i * y_2 + zz[i + 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: zz[i + 2] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c += x_i * y_3 + zz[i + 3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: zz[i + 3] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c += x_i * y_4 + zz[i + 4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: zz[i + 4] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c += x_i * y_5 + zz[i + 5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: zz[i + 5] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c += x_i * y_6 + zz[i + 6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: zz[i + 6] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c += x_i * y_7 + zz[i + 7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: zz[i + 7] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: zz[i + 8] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: i < 8
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: ulong y_2 = y[yOff + 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: ulong y_3 = y[yOff + 3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: ulong y_4 = y[yOff + 4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: ulong y_5 = y[yOff + 5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: ulong y_6 = y[yOff + 6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: ulong y_7 = y[yOff + 7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: zz[zzOff + 2] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: zz[zzOff + 3] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: zz[zzOff + 4] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: zz[zzOff + 5] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: zz[zzOff + 6] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: zz[zzOff + 7] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: zz[zzOff + 8] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c += x_i * y_2 + zz[zzOff + 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: zz[zzOff + 2] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c += x_i * y_3 + zz[zzOff + 3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: zz[zzOff + 3] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c += x_i * y_4 + zz[zzOff + 4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: zz[zzOff + 4] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c += x_i * y_5 + zz[zzOff + 5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: zz[zzOff + 5] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c += x_i * y_6 + zz[zzOff + 6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: zz[zzOff + 6] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c += x_i * y_7 + zz[zzOff + 7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: zz[zzOff + 7] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: zz[zzOff + 8] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul,The following statement contains a magic number: i < 8
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: ulong y_2 = y[2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: ulong y_3 = y[3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: ulong y_4 = y[4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: ulong y_5 = y[5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: ulong y_6 = y[6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: ulong y_7 = y[7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: c += x_i * y_2 + zz[i + 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: zz[i + 2] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: c += x_i * y_3 + zz[i + 3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: zz[i + 3] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: c += x_i * y_4 + zz[i + 4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: zz[i + 4] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: c += x_i * y_5 + zz[i + 5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: zz[i + 5] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: c += x_i * y_6 + zz[i + 6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: zz[i + 6] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: c += x_i * y_7 + zz[i + 7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: zz[i + 7] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: c += zc + zz[i + 8];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: zz[i + 8] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: zc = c >> 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: i < 8
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: ulong y_2 = y[yOff + 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: ulong y_3 = y[yOff + 3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: ulong y_4 = y[yOff + 4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: ulong y_5 = y[yOff + 5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: ulong y_6 = y[yOff + 6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: ulong y_7 = y[yOff + 7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: c += x_i * y_2 + zz[zzOff + 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: zz[zzOff + 2] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: c += x_i * y_3 + zz[zzOff + 3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: zz[zzOff + 3] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: c += x_i * y_4 + zz[zzOff + 4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: zz[zzOff + 4] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: c += x_i * y_5 + zz[zzOff + 5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: zz[zzOff + 5] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: c += x_i * y_6 + zz[zzOff + 6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: zz[zzOff + 6] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: c += x_i * y_7 + zz[zzOff + 7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: zz[zzOff + 7] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: c += zc + zz[zzOff + 8];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: zz[zzOff + 8] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: zc = c >> 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulAddTo,The following statement contains a magic number: i < 8
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33Add,The following statement contains a magic number: Debug.Assert(w >> 31 == 0);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33Add,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33Add,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33Add,The following statement contains a magic number: ulong x2 = x[xOff + 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33Add,The following statement contains a magic number: c += wVal * x2 + x1 + y[yOff + 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33Add,The following statement contains a magic number: z[zOff + 2] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33Add,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33Add,The following statement contains a magic number: ulong x3 = x[xOff + 3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33Add,The following statement contains a magic number: c += wVal * x3 + x2 + y[yOff + 3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33Add,The following statement contains a magic number: z[zOff + 3] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33Add,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33Add,The following statement contains a magic number: ulong x4 = x[xOff + 4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33Add,The following statement contains a magic number: c += wVal * x4 + x3 + y[yOff + 4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33Add,The following statement contains a magic number: z[zOff + 4] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33Add,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33Add,The following statement contains a magic number: ulong x5 = x[xOff + 5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33Add,The following statement contains a magic number: c += wVal * x5 + x4 + y[yOff + 5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33Add,The following statement contains a magic number: z[zOff + 5] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33Add,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33Add,The following statement contains a magic number: ulong x6 = x[xOff + 6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33Add,The following statement contains a magic number: c += wVal * x6 + x5 + y[yOff + 6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33Add,The following statement contains a magic number: z[zOff + 6] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33Add,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33Add,The following statement contains a magic number: ulong x7 = x[xOff + 7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33Add,The following statement contains a magic number: c += wVal * x7 + x6 + y[yOff + 7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33Add,The following statement contains a magic number: z[zOff + 7] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33Add,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWord,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWord,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWord,The following statement contains a magic number: c += xVal * (ulong)z[2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWord,The following statement contains a magic number: z[2] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWord,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWord,The following statement contains a magic number: c += xVal * (ulong)z[3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWord,The following statement contains a magic number: z[3] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWord,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWord,The following statement contains a magic number: c += xVal * (ulong)z[4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWord,The following statement contains a magic number: z[4] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWord,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWord,The following statement contains a magic number: c += xVal * (ulong)z[5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWord,The following statement contains a magic number: z[5] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWord,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWord,The following statement contains a magic number: c += xVal * (ulong)z[6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWord,The following statement contains a magic number: z[6] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWord,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWord,The following statement contains a magic number: c += xVal * (ulong)z[7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWord,The following statement contains a magic number: z[7] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWord,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWordAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWordAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWordAddTo,The following statement contains a magic number: c += xVal * (ulong)z[2] + y[2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWordAddTo,The following statement contains a magic number: c += xVal * (ulong)z[2] + y[2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWordAddTo,The following statement contains a magic number: z[2] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWordAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWordAddTo,The following statement contains a magic number: c += xVal * (ulong)z[3] + y[3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWordAddTo,The following statement contains a magic number: c += xVal * (ulong)z[3] + y[3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWordAddTo,The following statement contains a magic number: z[3] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWordAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWordAddTo,The following statement contains a magic number: c += xVal * (ulong)z[4] + y[4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWordAddTo,The following statement contains a magic number: c += xVal * (ulong)z[4] + y[4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWordAddTo,The following statement contains a magic number: z[4] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWordAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWordAddTo,The following statement contains a magic number: c += xVal * (ulong)z[5] + y[5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWordAddTo,The following statement contains a magic number: c += xVal * (ulong)z[5] + y[5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWordAddTo,The following statement contains a magic number: z[5] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWordAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWordAddTo,The following statement contains a magic number: c += xVal * (ulong)z[6] + y[6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWordAddTo,The following statement contains a magic number: c += xVal * (ulong)z[6] + y[6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWordAddTo,The following statement contains a magic number: z[6] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWordAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWordAddTo,The following statement contains a magic number: c += xVal * (ulong)z[7] + y[7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWordAddTo,The following statement contains a magic number: c += xVal * (ulong)z[7] + y[7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWordAddTo,The following statement contains a magic number: z[7] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulByWordAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordAddTo,The following statement contains a magic number: c += xVal * y[yOff + 2] + z[zOff + 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordAddTo,The following statement contains a magic number: c += xVal * y[yOff + 2] + z[zOff + 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordAddTo,The following statement contains a magic number: z[zOff + 2] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordAddTo,The following statement contains a magic number: c += xVal * y[yOff + 3] + z[zOff + 3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordAddTo,The following statement contains a magic number: c += xVal * y[yOff + 3] + z[zOff + 3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordAddTo,The following statement contains a magic number: z[zOff + 3] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordAddTo,The following statement contains a magic number: c += xVal * y[yOff + 4] + z[zOff + 4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordAddTo,The following statement contains a magic number: c += xVal * y[yOff + 4] + z[zOff + 4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordAddTo,The following statement contains a magic number: z[zOff + 4] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordAddTo,The following statement contains a magic number: c += xVal * y[yOff + 5] + z[zOff + 5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordAddTo,The following statement contains a magic number: c += xVal * y[yOff + 5] + z[zOff + 5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordAddTo,The following statement contains a magic number: z[zOff + 5] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordAddTo,The following statement contains a magic number: c += xVal * y[yOff + 6] + z[zOff + 6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordAddTo,The following statement contains a magic number: c += xVal * y[yOff + 6] + z[zOff + 6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordAddTo,The following statement contains a magic number: z[zOff + 6] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordAddTo,The following statement contains a magic number: c += xVal * y[yOff + 7] + z[zOff + 7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordAddTo,The following statement contains a magic number: c += xVal * y[yOff + 7] + z[zOff + 7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordAddTo,The following statement contains a magic number: z[zOff + 7] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordAddTo,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33DWordAdd,The following statement contains a magic number: Debug.Assert(x >> 31 == 0);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33DWordAdd,The following statement contains a magic number: Debug.Assert(zOff <= 4);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33DWordAdd,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33DWordAdd,The following statement contains a magic number: ulong y01 = y >> 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33DWordAdd,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33DWordAdd,The following statement contains a magic number: c += y01 + z[zOff + 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33DWordAdd,The following statement contains a magic number: z[zOff + 2] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33DWordAdd,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33DWordAdd,The following statement contains a magic number: c += z[zOff + 3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33DWordAdd,The following statement contains a magic number: z[zOff + 3] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33DWordAdd,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33DWordAdd,The following statement contains a magic number: return c == 0 ? 0 : Nat.IncAt(8' z' zOff' 4);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33DWordAdd,The following statement contains a magic number: return c == 0 ? 0 : Nat.IncAt(8' z' zOff' 4);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33WordAdd,The following statement contains a magic number: Debug.Assert(x >> 31 == 0);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33WordAdd,The following statement contains a magic number: Debug.Assert(zOff <= 5);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33WordAdd,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33WordAdd,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33WordAdd,The following statement contains a magic number: c += z[zOff + 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33WordAdd,The following statement contains a magic number: z[zOff + 2] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33WordAdd,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33WordAdd,The following statement contains a magic number: return c == 0 ? 0 : Nat.IncAt(8' z' zOff' 3);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Mul33WordAdd,The following statement contains a magic number: return c == 0 ? 0 : Nat.IncAt(8' z' zOff' 3);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordDwordAdd,The following statement contains a magic number: Debug.Assert(zOff <= 5);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordDwordAdd,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordDwordAdd,The following statement contains a magic number: c += xVal * (y >> 32) + z[zOff + 1];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordDwordAdd,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordDwordAdd,The following statement contains a magic number: c += z[zOff + 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordDwordAdd,The following statement contains a magic number: z[zOff + 2] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordDwordAdd,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordDwordAdd,The following statement contains a magic number: return c == 0 ? 0 : Nat.IncAt(8' z' zOff' 3);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWordDwordAdd,The following statement contains a magic number: return c == 0 ? 0 : Nat.IncAt(8' z' zOff' 3);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,MulWord,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: int i = 7' j = 16;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: int i = 7' j = 16;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: do 				{ 					ulong xVal = x[i--]; 					ulong p = xVal * xVal; 					zz[--j] = (c << 31) | (uint)(p >> 33); 					zz[--j] = (uint)(p >> 1); 					c = (uint)p; 				} 				while (i > 0);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: do 				{ 					ulong xVal = x[i--]; 					ulong p = xVal * xVal; 					zz[--j] = (c << 31) | (uint)(p >> 33); 					zz[--j] = (uint)(p >> 1); 					c = (uint)p; 				} 				while (i > 0);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_1 = (ulong)(c << 31) | (p >> 33);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_1 = (ulong)(c << 31) | (p >> 33);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: c = (uint)(p >> 32) & 1;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong zz_2 = zz[2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: c = w >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_2 += zz_1 >> 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong x_2 = x[2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong zz_3 = zz[3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong zz_4 = zz[4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz[2] = (w << 1) | c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: c = w >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_3 += (zz_2 >> 32) + x_2 * x_1;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_4 += zz_3 >> 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong x_3 = x[3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong zz_5 = zz[5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong zz_6 = zz[6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz[3] = (w << 1) | c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: c = w >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_4 += (zz_3 >> 32) + x_3 * x_1;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_5 += (zz_4 >> 32) + x_3 * x_2;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_6 += zz_5 >> 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong x_4 = x[4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong zz_7 = zz[7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong zz_8 = zz[8];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz[4] = (w << 1) | c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: c = w >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_5 += (zz_4 >> 32) + x_4 * x_1;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_6 += (zz_5 >> 32) + x_4 * x_2;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_7 += (zz_6 >> 32) + x_4 * x_3;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_8 += zz_7 >> 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong x_5 = x[5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong zz_9 = zz[9];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong zz_10 = zz[10];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz[5] = (w << 1) | c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: c = w >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_6 += (zz_5 >> 32) + x_5 * x_1;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_7 += (zz_6 >> 32) + x_5 * x_2;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_8 += (zz_7 >> 32) + x_5 * x_3;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_9 += (zz_8 >> 32) + x_5 * x_4;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_10 += zz_9 >> 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong x_6 = x[6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong zz_11 = zz[11];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong zz_12 = zz[12];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz[6] = (w << 1) | c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: c = w >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_7 += (zz_6 >> 32) + x_6 * x_1;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_8 += (zz_7 >> 32) + x_6 * x_2;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_9 += (zz_8 >> 32) + x_6 * x_3;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_10 += (zz_9 >> 32) + x_6 * x_4;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_11 += (zz_10 >> 32) + x_6 * x_5;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_12 += zz_11 >> 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong x_7 = x[7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong zz_13 = zz[13];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong zz_14 = zz[14];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz[7] = (w << 1) | c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: c = w >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_8 += (zz_7 >> 32) + x_7 * x_1;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_9 += (zz_8 >> 32) + x_7 * x_2;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_10 += (zz_9 >> 32) + x_7 * x_3;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_11 += (zz_10 >> 32) + x_7 * x_4;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_12 += (zz_11 >> 32) + x_7 * x_5;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_13 += (zz_12 >> 32) + x_7 * x_6;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_14 += zz_13 >> 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz[8] = (w << 1) | c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: c = w >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz[9] = (w << 1) | c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: c = w >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz[10] = (w << 1) | c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: c = w >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz[11] = (w << 1) | c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: c = w >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz[12] = (w << 1) | c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: c = w >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz[13] = (w << 1) | c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: c = w >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz[14] = (w << 1) | c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: c = w >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: w = zz[15] + (uint)(zz_14 >> 32);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: w = zz[15] + (uint)(zz_14 >> 32);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz[15] = (w << 1) | c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: int i = 7' j = 16;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: int i = 7' j = 16;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: do 				{ 					ulong xVal = x[xOff + i--]; 					ulong p = xVal * xVal; 					zz[zzOff + --j] = (c << 31) | (uint)(p >> 33); 					zz[zzOff + --j] = (uint)(p >> 1); 					c = (uint)p; 				} 				while (i > 0);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: do 				{ 					ulong xVal = x[xOff + i--]; 					ulong p = xVal * xVal; 					zz[zzOff + --j] = (c << 31) | (uint)(p >> 33); 					zz[zzOff + --j] = (uint)(p >> 1); 					c = (uint)p; 				} 				while (i > 0);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_1 = (ulong)(c << 31) | (p >> 33);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_1 = (ulong)(c << 31) | (p >> 33);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: c = (uint)(p >> 32) & 1;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong zz_2 = zz[zzOff + 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: c = w >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_2 += zz_1 >> 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong x_2 = x[xOff + 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong zz_3 = zz[zzOff + 3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong zz_4 = zz[zzOff + 4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz[zzOff + 2] = (w << 1) | c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: c = w >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_3 += (zz_2 >> 32) + x_2 * x_1;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_4 += zz_3 >> 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong x_3 = x[xOff + 3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong zz_5 = zz[zzOff + 5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong zz_6 = zz[zzOff + 6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz[zzOff + 3] = (w << 1) | c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: c = w >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_4 += (zz_3 >> 32) + x_3 * x_1;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_5 += (zz_4 >> 32) + x_3 * x_2;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_6 += zz_5 >> 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong x_4 = x[xOff + 4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong zz_7 = zz[zzOff + 7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong zz_8 = zz[zzOff + 8];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz[zzOff + 4] = (w << 1) | c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: c = w >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_5 += (zz_4 >> 32) + x_4 * x_1;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_6 += (zz_5 >> 32) + x_4 * x_2;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_7 += (zz_6 >> 32) + x_4 * x_3;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_8 += zz_7 >> 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong x_5 = x[xOff + 5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong zz_9 = zz[zzOff + 9];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong zz_10 = zz[zzOff + 10];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz[zzOff + 5] = (w << 1) | c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: c = w >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_6 += (zz_5 >> 32) + x_5 * x_1;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_7 += (zz_6 >> 32) + x_5 * x_2;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_8 += (zz_7 >> 32) + x_5 * x_3;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_9 += (zz_8 >> 32) + x_5 * x_4;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_10 += zz_9 >> 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong x_6 = x[xOff + 6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong zz_11 = zz[zzOff + 11];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong zz_12 = zz[zzOff + 12];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz[zzOff + 6] = (w << 1) | c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: c = w >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_7 += (zz_6 >> 32) + x_6 * x_1;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_8 += (zz_7 >> 32) + x_6 * x_2;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_9 += (zz_8 >> 32) + x_6 * x_3;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_10 += (zz_9 >> 32) + x_6 * x_4;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_11 += (zz_10 >> 32) + x_6 * x_5;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_12 += zz_11 >> 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong x_7 = x[xOff + 7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong zz_13 = zz[zzOff + 13];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: ulong zz_14 = zz[zzOff + 14];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz[zzOff + 7] = (w << 1) | c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: c = w >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_8 += (zz_7 >> 32) + x_7 * x_1;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_9 += (zz_8 >> 32) + x_7 * x_2;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_10 += (zz_9 >> 32) + x_7 * x_3;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_11 += (zz_10 >> 32) + x_7 * x_4;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_12 += (zz_11 >> 32) + x_7 * x_5;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_13 += (zz_12 >> 32) + x_7 * x_6;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz_14 += zz_13 >> 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz[zzOff + 8] = (w << 1) | c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: c = w >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz[zzOff + 9] = (w << 1) | c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: c = w >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz[zzOff + 10] = (w << 1) | c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: c = w >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz[zzOff + 11] = (w << 1) | c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: c = w >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz[zzOff + 12] = (w << 1) | c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: c = w >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz[zzOff + 13] = (w << 1) | c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: c = w >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz[zzOff + 14] = (w << 1) | c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: c = w >> 31;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: w = zz[zzOff + 15] + (uint)(zz_14 >> 32);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: w = zz[zzOff + 15] + (uint)(zz_14 >> 32);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Square,The following statement contains a magic number: zz[zzOff + 15] = (w << 1) | c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c += (long)x[2] - y[2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c += (long)x[2] - y[2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: z[2] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c += (long)x[3] - y[3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c += (long)x[3] - y[3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: z[3] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c += (long)x[4] - y[4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c += (long)x[4] - y[4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: z[4] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c += (long)x[5] - y[5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c += (long)x[5] - y[5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: z[5] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c += (long)x[6] - y[6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c += (long)x[6] - y[6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: z[6] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c += (long)x[7] - y[7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c += (long)x[7] - y[7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: z[7] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c += (long)x[xOff + 2] - y[yOff + 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c += (long)x[xOff + 2] - y[yOff + 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: z[zOff + 2] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c += (long)x[xOff + 3] - y[yOff + 3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c += (long)x[xOff + 3] - y[yOff + 3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: z[zOff + 3] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c += (long)x[xOff + 4] - y[yOff + 4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c += (long)x[xOff + 4] - y[yOff + 4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: z[zOff + 4] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c += (long)x[xOff + 5] - y[yOff + 5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c += (long)x[xOff + 5] - y[yOff + 5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: z[zOff + 5] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c += (long)x[xOff + 6] - y[yOff + 6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c += (long)x[xOff + 6] - y[yOff + 6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: z[zOff + 6] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c += (long)x[xOff + 7] - y[yOff + 7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c += (long)x[xOff + 7] - y[yOff + 7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: z[zOff + 7] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Sub,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: c += (long)z[2] - x[2] - y[2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: c += (long)z[2] - x[2] - y[2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: c += (long)z[2] - x[2] - y[2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: z[2] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: c += (long)z[3] - x[3] - y[3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: c += (long)z[3] - x[3] - y[3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: c += (long)z[3] - x[3] - y[3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: z[3] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: c += (long)z[4] - x[4] - y[4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: c += (long)z[4] - x[4] - y[4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: c += (long)z[4] - x[4] - y[4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: z[4] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: c += (long)z[5] - x[5] - y[5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: c += (long)z[5] - x[5] - y[5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: c += (long)z[5] - x[5] - y[5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: z[5] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: c += (long)z[6] - x[6] - y[6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: c += (long)z[6] - x[6] - y[6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: c += (long)z[6] - x[6] - y[6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: z[6] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: c += (long)z[7] - x[7] - y[7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: c += (long)z[7] - x[7] - y[7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: c += (long)z[7] - x[7] - y[7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: z[7] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubBothFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c += (long)z[2] - x[2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c += (long)z[2] - x[2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: z[2] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c += (long)z[3] - x[3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c += (long)z[3] - x[3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: z[3] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c += (long)z[4] - x[4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c += (long)z[4] - x[4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: z[4] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c += (long)z[5] - x[5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c += (long)z[5] - x[5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: z[5] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c += (long)z[6] - x[6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c += (long)z[6] - x[6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: z[6] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c += (long)z[7] - x[7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c += (long)z[7] - x[7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: z[7] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c += (long)z[zOff + 2] - x[xOff + 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c += (long)z[zOff + 2] - x[xOff + 2];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: z[zOff + 2] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c += (long)z[zOff + 3] - x[xOff + 3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c += (long)z[zOff + 3] - x[xOff + 3];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: z[zOff + 3] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c += (long)z[zOff + 4] - x[xOff + 4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c += (long)z[zOff + 4] - x[xOff + 4];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: z[zOff + 4] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c += (long)z[zOff + 5] - x[xOff + 5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c += (long)z[zOff + 5] - x[xOff + 5];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: z[zOff + 5] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c += (long)z[zOff + 6] - x[xOff + 6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c += (long)z[zOff + 6] - x[xOff + 6];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: z[zOff + 6] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c += (long)z[zOff + 7] - x[xOff + 7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c += (long)z[zOff + 7] - x[xOff + 7];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: z[zOff + 7] = (uint)c;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,SubFrom,The following statement contains a magic number: c >>= 32;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,ToBigInteger,The following statement contains a magic number: byte[] bs = new byte[32];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,ToBigInteger,The following statement contains a magic number: Pack.UInt32_To_BE(x_i' bs' (7 - i) << 2);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,ToBigInteger,The following statement contains a magic number: Pack.UInt32_To_BE(x_i' bs' (7 - i) << 2);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,ToBigInteger,The following statement contains a magic number: i < 8
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,ToBigInteger64,The following statement contains a magic number: byte[] bs = new byte[32];
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,ToBigInteger64,The following statement contains a magic number: Pack.UInt64_To_BE(x_i' bs' (3 - i) << 3);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,ToBigInteger64,The following statement contains a magic number: Pack.UInt64_To_BE(x_i' bs' (3 - i) << 3);
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,ToBigInteger64,The following statement contains a magic number: i < 4
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Zero,The following statement contains a magic number: z[2] = 0;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Zero,The following statement contains a magic number: z[3] = 0;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Zero,The following statement contains a magic number: z[4] = 0;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Zero,The following statement contains a magic number: z[5] = 0;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Zero,The following statement contains a magic number: z[6] = 0;
Magic Number,NBitcoin.BouncyCastle.Math.Raw,Nat256,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\raw\Nat256.cs,Zero,The following statement contains a magic number: z[7] = 0;
Magic Number,NBitcoin.BouncyCastle.Utilities,Arrays,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\util\Arrays.cs,GetHashCode,The following statement contains a magic number: hc *= 257;
Magic Number,NBitcoin.BouncyCastle.Utilities,Arrays,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\util\Arrays.cs,GetHashCode,The following statement contains a magic number: hc *= 257;
Magic Number,NBitcoin.BouncyCastle.Utilities,Arrays,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\util\Arrays.cs,GetHashCode,The following statement contains a magic number: hc *= 257;
Magic Number,NBitcoin.BouncyCastle.Utilities,Arrays,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\util\Arrays.cs,GetHashCode,The following statement contains a magic number: hc *= 257;
Magic Number,NBitcoin.BouncyCastle.Utilities,Arrays,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\util\Arrays.cs,GetHashCode,The following statement contains a magic number: hc *= 257;
Magic Number,NBitcoin.BouncyCastle.Utilities,Arrays,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\util\Arrays.cs,GetHashCode,The following statement contains a magic number: hc *= 257;
Magic Number,NBitcoin.BouncyCastle.Utilities,Arrays,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\util\Arrays.cs,GetHashCode,The following statement contains a magic number: hc *= 257;
Magic Number,NBitcoin.BouncyCastle.Utilities,Arrays,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\util\Arrays.cs,GetHashCode,The following statement contains a magic number: hc *= 257;
Magic Number,NBitcoin.BouncyCastle.Utilities,Arrays,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\util\Arrays.cs,GetHashCode,The following statement contains a magic number: hc ^= (int)(di >> 32);
Magic Number,NBitcoin.BouncyCastle.Utilities,Arrays,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\util\Arrays.cs,GetHashCode,The following statement contains a magic number: hc *= 257;
Magic Number,NBitcoin.BouncyCastle.Utilities,Arrays,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\util\Arrays.cs,GetHashCode,The following statement contains a magic number: hc *= 257;
Magic Number,NBitcoin.BouncyCastle.Utilities,Arrays,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\util\Arrays.cs,GetHashCode,The following statement contains a magic number: hc ^= (int)(di >> 32);
Magic Number,NBitcoin.BouncyCastle.Utilities,BigIntegers,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\util\BigIntegers.cs,CreateRandomInRange,The following statement contains a magic number: min.BitLength > max.BitLength / 2
Magic Number,NBitcoin.BouncyCastle.Utilities.Encoders,Hex,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\util\encoders\Hex.cs,Encode,The following statement contains a magic number: MemoryStream bOut = new MemoryStream(length * 2);
Magic Number,NBitcoin.BouncyCastle.Utilities.Encoders,Hex,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\util\encoders\Hex.cs,Decode,The following statement contains a magic number: MemoryStream bOut = new MemoryStream((data.Length + 1) / 2);
Magic Number,NBitcoin.BouncyCastle.Utilities.Encoders,Hex,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\util\encoders\Hex.cs,Decode,The following statement contains a magic number: MemoryStream bOut = new MemoryStream((data.Length + 1) / 2);
Magic Number,NBitcoin.BouncyCastle.Utilities.Encoders,HexEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\util\encoders\HexEncoder.cs,Encode,The following statement contains a magic number: outStream.WriteByte(encodingTable[v >> 4]);
Magic Number,NBitcoin.BouncyCastle.Utilities.Encoders,HexEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\util\encoders\HexEncoder.cs,Encode,The following statement contains a magic number: return length * 2;
Magic Number,NBitcoin.BouncyCastle.Utilities.Encoders,HexEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\util\encoders\HexEncoder.cs,Decode,The following statement contains a magic number: outStream.WriteByte((byte)((b1 << 4) | b2));
Magic Number,NBitcoin.BouncyCastle.Utilities.Encoders,HexEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\util\encoders\HexEncoder.cs,DecodeString,The following statement contains a magic number: outStream.WriteByte((byte)((b1 << 4) | b2));
Magic Number,NBitcoin.BuilderExtensions,P2PKHBuilderExtension,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BuilderExtensions\P2PKHBuilderExtension.cs,EstimateScriptSigSize,The following statement contains a magic number: return 107;
Magic Number,NBitcoin.Crypto,AesWrapper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\AES.cs,Initialize,The following statement contains a magic number: _inner.KeySize = key.Length * 8;
Magic Number,NBitcoin.Crypto,Pbkdf2,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Pbkdf2.cs,Pbkdf2,The following statement contains a magic number: NBitcoin.Crypto.Internal.Check.Length("salt"' salt' 0' int.MaxValue - 4);
Magic Number,NBitcoin.Crypto,Pbkdf2,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Pbkdf2.cs,Pbkdf2,The following statement contains a magic number: hmacAlgorithm.HashSize == 0 || hmacAlgorithm.HashSize % 8 != 0
Magic Number,NBitcoin.Crypto,Pbkdf2,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Pbkdf2.cs,Pbkdf2,The following statement contains a magic number: int hmacLength = hmacAlgorithm.HashSize / 8;
Magic Number,NBitcoin.Crypto,Pbkdf2,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Pbkdf2.cs,Pbkdf2,The following statement contains a magic number: _saltBuffer = new byte[salt.Length + 4];
Magic Number,NBitcoin.Crypto,Pbkdf2,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Pbkdf2.cs,ComputeBlock,The following statement contains a magic number: BitPacking.BEBytesFromUInt32(pos' _saltBuffer' _saltBuffer.Length - 4);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,R,The following statement contains a magic number: return (a << b) | (a >> (32 - b));
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: rounds < 2 || rounds > 20 || (rounds & 1) == 1
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: rounds < 2 || rounds > 20 || (rounds & 1) == 1
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: uint x2 = input[inputOffset + 2];
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: uint x3 = input[inputOffset + 3];
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: uint x4 = input[inputOffset + 4];
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: uint x5 = input[inputOffset + 5];
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: uint x6 = input[inputOffset + 6];
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: uint x7 = input[inputOffset + 7];
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: uint x8 = input[inputOffset + 8];
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: uint x9 = input[inputOffset + 9];
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: uint x10 = input[inputOffset + 10];
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: uint x11 = input[inputOffset + 11];
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: uint x12 = input[inputOffset + 12];
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: uint x13 = input[inputOffset + 13];
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: uint x14 = input[inputOffset + 14];
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: uint x15 = input[inputOffset + 15];
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x4 ^= R(x0 + x12' 7);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x8 ^= R(x4 + x0' 9);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x12 ^= R(x8 + x4' 13);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x0 ^= R(x12 + x8' 18);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x9 ^= R(x5 + x1' 7);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x13 ^= R(x9 + x5' 9);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x1 ^= R(x13 + x9' 13);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x5 ^= R(x1 + x13' 18);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x14 ^= R(x10 + x6' 7);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x2 ^= R(x14 + x10' 9);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x6 ^= R(x2 + x14' 13);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x10 ^= R(x6 + x2' 18);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x3 ^= R(x15 + x11' 7);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x7 ^= R(x3 + x15' 9);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x11 ^= R(x7 + x3' 13);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x15 ^= R(x11 + x7' 18);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x1 ^= R(x0 + x3' 7);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x2 ^= R(x1 + x0' 9);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x3 ^= R(x2 + x1' 13);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x0 ^= R(x3 + x2' 18);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x6 ^= R(x5 + x4' 7);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x7 ^= R(x6 + x5' 9);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x4 ^= R(x7 + x6' 13);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x5 ^= R(x4 + x7' 18);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x11 ^= R(x10 + x9' 7);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x8 ^= R(x11 + x10' 9);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x9 ^= R(x8 + x11' 13);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x10 ^= R(x9 + x8' 18);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x12 ^= R(x15 + x14' 7);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x13 ^= R(x12 + x15' 9);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x14 ^= R(x13 + x12' 13);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: x15 ^= R(x14 + x13' 18);
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: output[outputOffset + 2] = input[inputOffset + 2] + x2;
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: output[outputOffset + 2] = input[inputOffset + 2] + x2;
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: output[outputOffset + 3] = input[inputOffset + 3] + x3;
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: output[outputOffset + 3] = input[inputOffset + 3] + x3;
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: output[outputOffset + 4] = input[inputOffset + 4] + x4;
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: output[outputOffset + 4] = input[inputOffset + 4] + x4;
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: output[outputOffset + 5] = input[inputOffset + 5] + x5;
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: output[outputOffset + 5] = input[inputOffset + 5] + x5;
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: output[outputOffset + 6] = input[inputOffset + 6] + x6;
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: output[outputOffset + 6] = input[inputOffset + 6] + x6;
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: output[outputOffset + 7] = input[inputOffset + 7] + x7;
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: output[outputOffset + 7] = input[inputOffset + 7] + x7;
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: output[outputOffset + 8] = input[inputOffset + 8] + x8;
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: output[outputOffset + 8] = input[inputOffset + 8] + x8;
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: output[outputOffset + 9] = input[inputOffset + 9] + x9;
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: output[outputOffset + 9] = input[inputOffset + 9] + x9;
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: output[outputOffset + 10] = input[inputOffset + 10] + x10;
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: output[outputOffset + 10] = input[inputOffset + 10] + x10;
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: output[outputOffset + 11] = input[inputOffset + 11] + x11;
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: output[outputOffset + 11] = input[inputOffset + 11] + x11;
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: output[outputOffset + 12] = input[inputOffset + 12] + x12;
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: output[outputOffset + 12] = input[inputOffset + 12] + x12;
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: output[outputOffset + 13] = input[inputOffset + 13] + x13;
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: output[outputOffset + 13] = input[inputOffset + 13] + x13;
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: output[outputOffset + 14] = input[inputOffset + 14] + x14;
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: output[outputOffset + 14] = input[inputOffset + 14] + x14;
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: output[outputOffset + 15] = input[inputOffset + 15] + x15;
Magic Number,NBitcoin.Crypto,Salsa20Core,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\Salsa20Core.cs,Compute,The following statement contains a magic number: output[outputOffset + 15] = input[inputOffset + 15] + x15;
Magic Number,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,MFcrypt,The following statement contains a magic number: int MFLen = blockSize * 128;
Magic Number,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,MFcrypt,The following statement contains a magic number: Check.Range("blockSize"' blockSize' 1' int.MaxValue / 128);
Magic Number,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,MFcrypt,The following statement contains a magic number: uint[] B0 = new uint[B.Length / 4];
Magic Number,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,MFcrypt,The following statement contains a magic number: B0[i] = BitPacking.UInt32FromLEBytes(B' i * 4);
Magic Number,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,MFcrypt,The following statement contains a magic number: BitPacking.LEBytesFromUInt32(B0[i]' B' i * 4);
Magic Number,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,ThreadSMixCalls,The following statement contains a magic number: ThreadStart workerThread = delegate ()  			{  				while (true)  				{  					int j = Interlocked.Increment(ref current) - 1;  					if (j >= parallel)  					{  						break;  					}    					SMix(B0' j * MFLen / 4' B0' j * MFLen / 4' (uint)cost' blockSize);  				}  			};
Magic Number,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,ThreadSMixCalls,The following statement contains a magic number: ThreadStart workerThread = delegate ()  			{  				while (true)  				{  					int j = Interlocked.Increment(ref current) - 1;  					if (j >= parallel)  					{  						break;  					}    					SMix(B0' j * MFLen / 4' B0' j * MFLen / 4' (uint)cost' blockSize);  				}  			};
Magic Number,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,ThreadSMixCalls,The following statement contains a magic number: (threads[i] = new Thread(workerThread' 8192 * 16)).Start();
Magic Number,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,ThreadSMixCalls,The following statement contains a magic number: (threads[i] = new Thread(workerThread' 8192 * 16)).Start();
Magic Number,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,SMix,The following statement contains a magic number: int Bs = 16 * 2 * r;
Magic Number,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,SMix,The following statement contains a magic number: int Bs = 16 * 2 * r;
Magic Number,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,SMix,The following statement contains a magic number: uint[] scratch1 = new uint[16];
Magic Number,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,SMix,The following statement contains a magic number: uint[] scratchX = new uint[16]' scratchY = new uint[Bs];
Magic Number,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,SMix,The following statement contains a magic number: uint j = x[Bs - 16] & Nmask;
Magic Number,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,BlockMix,The following statement contains a magic number: int k = Boffset' m = 0' n = 16 * r;
Magic Number,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,BlockMix,The following statement contains a magic number: Array.Copy(B' (2 * r - 1) * 16' x' 0' 16);
Magic Number,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,BlockMix,The following statement contains a magic number: Array.Copy(B' (2 * r - 1) * 16' x' 0' 16);
Magic Number,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,BlockMix,The following statement contains a magic number: Array.Copy(B' (2 * r - 1) * 16' x' 0' 16);
Magic Number,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,BlockMix,The following statement contains a magic number: Salsa20Core.Compute(8' scratch' 0' x' 0);
Magic Number,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,BlockMix,The following statement contains a magic number: Array.Copy(x' 0' y' m' 16);
Magic Number,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,BlockMix,The following statement contains a magic number: k += 16;
Magic Number,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,BlockMix,The following statement contains a magic number: Salsa20Core.Compute(8' scratch' 0' x' 0);
Magic Number,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,BlockMix,The following statement contains a magic number: Array.Copy(x' 0' y' m + n' 16);
Magic Number,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,BlockMix,The following statement contains a magic number: k += 16;
Magic Number,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,BlockMix,The following statement contains a magic number: m += 16;
Magic Number,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,BitcoinComputeDerivedKey,The following statement contains a magic number: return NBitcoin.Crypto.SCrypt.ComputeDerivedKey(password' salt' 16384' 8' 8' 8' outputCount);
Magic Number,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,BitcoinComputeDerivedKey,The following statement contains a magic number: return NBitcoin.Crypto.SCrypt.ComputeDerivedKey(password' salt' 16384' 8' 8' 8' outputCount);
Magic Number,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,BitcoinComputeDerivedKey,The following statement contains a magic number: return NBitcoin.Crypto.SCrypt.ComputeDerivedKey(password' salt' 16384' 8' 8' 8' outputCount);
Magic Number,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,BitcoinComputeDerivedKey,The following statement contains a magic number: return NBitcoin.Crypto.SCrypt.ComputeDerivedKey(password' salt' 16384' 8' 8' 8' outputCount);
Magic Number,NBitcoin.Crypto,SCrypt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\SCrypt.cs,BitcoinComputeDerivedKey2,The following statement contains a magic number: return NBitcoin.Crypto.SCrypt.ComputeDerivedKey(password' salt' 1024' 1' 1' 1' outputCount);
Magic Number,NBitcoin.Crypto,ECDSASignature,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\ECDSASignature.cs,ECDSASignature,The following statement contains a magic number: seq == null || seq.Count != 2
Magic Number,NBitcoin.Crypto,ECDSASignature,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\ECDSASignature.cs,ECDSASignature,The following statement contains a magic number: seq == null || seq.Count != 2
Magic Number,NBitcoin.Crypto,ECDSASignature,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\ECDSASignature.cs,ToDER,The following statement contains a magic number: MemoryStream bos = new MemoryStream(72);
Magic Number,NBitcoin.Crypto,ECKey,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\ECKey.cs,RecoverFromSignature,The following statement contains a magic number: var i = NBitcoin.BouncyCastle.Math.BigInteger.ValueOf((long)recId / 2);
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,RIPEMD160,The following statement contains a magic number: byte[] rv = new byte[20];
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SHA1,The following statement contains a magic number: byte[] rv = new byte[20];
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,rotl32,The following statement contains a magic number: return (x << r) | (x >> (32 - r));
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,fmix,The following statement contains a magic number: h ^= h >> 16;
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,fmix,The following statement contains a magic number: h ^= h >> 13;
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,fmix,The following statement contains a magic number: h ^= h >> 16;
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,MurmurHash3,The following statement contains a magic number: byte[] chunk = reader.ReadBytes(4);
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,MurmurHash3,The following statement contains a magic number: switch (chunk.Length)  					{  						case 4:  							/* Get four bytes from the input into an uint */  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16  							| chunk[3] << 24);    							/* bitmagic hash */  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;    							h1 ^= k1;  							h1 = rotl32(h1' 13);  							h1 = h1 * 5 + 0xe6546b64;  							break;  						case 3:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 2:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 1:  							k1 = (uint)(chunk[0]);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  					}
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,MurmurHash3,The following statement contains a magic number: switch (chunk.Length)  					{  						case 4:  							/* Get four bytes from the input into an uint */  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16  							| chunk[3] << 24);    							/* bitmagic hash */  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;    							h1 ^= k1;  							h1 = rotl32(h1' 13);  							h1 = h1 * 5 + 0xe6546b64;  							break;  						case 3:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 2:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 1:  							k1 = (uint)(chunk[0]);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  					}
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,MurmurHash3,The following statement contains a magic number: switch (chunk.Length)  					{  						case 4:  							/* Get four bytes from the input into an uint */  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16  							| chunk[3] << 24);    							/* bitmagic hash */  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;    							h1 ^= k1;  							h1 = rotl32(h1' 13);  							h1 = h1 * 5 + 0xe6546b64;  							break;  						case 3:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 2:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 1:  							k1 = (uint)(chunk[0]);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  					}
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,MurmurHash3,The following statement contains a magic number: switch (chunk.Length)  					{  						case 4:  							/* Get four bytes from the input into an uint */  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16  							| chunk[3] << 24);    							/* bitmagic hash */  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;    							h1 ^= k1;  							h1 = rotl32(h1' 13);  							h1 = h1 * 5 + 0xe6546b64;  							break;  						case 3:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 2:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 1:  							k1 = (uint)(chunk[0]);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  					}
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,MurmurHash3,The following statement contains a magic number: switch (chunk.Length)  					{  						case 4:  							/* Get four bytes from the input into an uint */  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16  							| chunk[3] << 24);    							/* bitmagic hash */  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;    							h1 ^= k1;  							h1 = rotl32(h1' 13);  							h1 = h1 * 5 + 0xe6546b64;  							break;  						case 3:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 2:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 1:  							k1 = (uint)(chunk[0]);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  					}
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,MurmurHash3,The following statement contains a magic number: switch (chunk.Length)  					{  						case 4:  							/* Get four bytes from the input into an uint */  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16  							| chunk[3] << 24);    							/* bitmagic hash */  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;    							h1 ^= k1;  							h1 = rotl32(h1' 13);  							h1 = h1 * 5 + 0xe6546b64;  							break;  						case 3:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 2:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 1:  							k1 = (uint)(chunk[0]);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  					}
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,MurmurHash3,The following statement contains a magic number: switch (chunk.Length)  					{  						case 4:  							/* Get four bytes from the input into an uint */  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16  							| chunk[3] << 24);    							/* bitmagic hash */  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;    							h1 ^= k1;  							h1 = rotl32(h1' 13);  							h1 = h1 * 5 + 0xe6546b64;  							break;  						case 3:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 2:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 1:  							k1 = (uint)(chunk[0]);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  					}
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,MurmurHash3,The following statement contains a magic number: switch (chunk.Length)  					{  						case 4:  							/* Get four bytes from the input into an uint */  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16  							| chunk[3] << 24);    							/* bitmagic hash */  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;    							h1 ^= k1;  							h1 = rotl32(h1' 13);  							h1 = h1 * 5 + 0xe6546b64;  							break;  						case 3:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 2:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 1:  							k1 = (uint)(chunk[0]);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  					}
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,MurmurHash3,The following statement contains a magic number: switch (chunk.Length)  					{  						case 4:  							/* Get four bytes from the input into an uint */  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16  							| chunk[3] << 24);    							/* bitmagic hash */  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;    							h1 ^= k1;  							h1 = rotl32(h1' 13);  							h1 = h1 * 5 + 0xe6546b64;  							break;  						case 3:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 2:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 1:  							k1 = (uint)(chunk[0]);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  					}
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,MurmurHash3,The following statement contains a magic number: switch (chunk.Length)  					{  						case 4:  							/* Get four bytes from the input into an uint */  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16  							| chunk[3] << 24);    							/* bitmagic hash */  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;    							h1 ^= k1;  							h1 = rotl32(h1' 13);  							h1 = h1 * 5 + 0xe6546b64;  							break;  						case 3:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 2:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 1:  							k1 = (uint)(chunk[0]);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  					}
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,MurmurHash3,The following statement contains a magic number: switch (chunk.Length)  					{  						case 4:  							/* Get four bytes from the input into an uint */  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16  							| chunk[3] << 24);    							/* bitmagic hash */  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;    							h1 ^= k1;  							h1 = rotl32(h1' 13);  							h1 = h1 * 5 + 0xe6546b64;  							break;  						case 3:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 2:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 1:  							k1 = (uint)(chunk[0]);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  					}
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,MurmurHash3,The following statement contains a magic number: switch (chunk.Length)  					{  						case 4:  							/* Get four bytes from the input into an uint */  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16  							| chunk[3] << 24);    							/* bitmagic hash */  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;    							h1 ^= k1;  							h1 = rotl32(h1' 13);  							h1 = h1 * 5 + 0xe6546b64;  							break;  						case 3:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 2:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 1:  							k1 = (uint)(chunk[0]);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  					}
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,MurmurHash3,The following statement contains a magic number: switch (chunk.Length)  					{  						case 4:  							/* Get four bytes from the input into an uint */  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16  							| chunk[3] << 24);    							/* bitmagic hash */  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;    							h1 ^= k1;  							h1 = rotl32(h1' 13);  							h1 = h1 * 5 + 0xe6546b64;  							break;  						case 3:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 2:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 1:  							k1 = (uint)(chunk[0]);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  					}
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,MurmurHash3,The following statement contains a magic number: switch (chunk.Length)  					{  						case 4:  							/* Get four bytes from the input into an uint */  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16  							| chunk[3] << 24);    							/* bitmagic hash */  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;    							h1 ^= k1;  							h1 = rotl32(h1' 13);  							h1 = h1 * 5 + 0xe6546b64;  							break;  						case 3:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 2:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 1:  							k1 = (uint)(chunk[0]);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  					}
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,MurmurHash3,The following statement contains a magic number: switch (chunk.Length)  					{  						case 4:  							/* Get four bytes from the input into an uint */  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16  							| chunk[3] << 24);    							/* bitmagic hash */  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;    							h1 ^= k1;  							h1 = rotl32(h1' 13);  							h1 = h1 * 5 + 0xe6546b64;  							break;  						case 3:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 2:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 1:  							k1 = (uint)(chunk[0]);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  					}
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,MurmurHash3,The following statement contains a magic number: switch (chunk.Length)  					{  						case 4:  							/* Get four bytes from the input into an uint */  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16  							| chunk[3] << 24);    							/* bitmagic hash */  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;    							h1 ^= k1;  							h1 = rotl32(h1' 13);  							h1 = h1 * 5 + 0xe6546b64;  							break;  						case 3:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 2:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 1:  							k1 = (uint)(chunk[0]);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  					}
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,MurmurHash3,The following statement contains a magic number: switch (chunk.Length)  					{  						case 4:  							/* Get four bytes from the input into an uint */  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16  							| chunk[3] << 24);    							/* bitmagic hash */  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;    							h1 ^= k1;  							h1 = rotl32(h1' 13);  							h1 = h1 * 5 + 0xe6546b64;  							break;  						case 3:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 2:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 1:  							k1 = (uint)(chunk[0]);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  					}
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,MurmurHash3,The following statement contains a magic number: switch (chunk.Length)  					{  						case 4:  							/* Get four bytes from the input into an uint */  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16  							| chunk[3] << 24);    							/* bitmagic hash */  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;    							h1 ^= k1;  							h1 = rotl32(h1' 13);  							h1 = h1 * 5 + 0xe6546b64;  							break;  						case 3:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 2:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 1:  							k1 = (uint)(chunk[0]);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  					}
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,MurmurHash3,The following statement contains a magic number: chunk = reader.ReadBytes(4);
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,BIP32Hash,The following statement contains a magic number: byte[] num = new byte[4];
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,BIP32Hash,The following statement contains a magic number: num[0] = (byte)((nChild >> 24) & 0xFF);
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,BIP32Hash,The following statement contains a magic number: num[1] = (byte)((nChild >> 16) & 0xFF);
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,BIP32Hash,The following statement contains a magic number: num[2] = (byte)((nChild >> 8) & 0xFF);
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,BIP32Hash,The following statement contains a magic number: num[2] = (byte)((nChild >> 8) & 0xFF);
Magic Number,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,BIP32Hash,The following statement contains a magic number: num[3] = (byte)((nChild >> 0) & 0xFF);
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: count += 8;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: t |= ((ulong)((data[offset++]))) << (int)(8 * (c % 8));
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: t |= ((ulong)((data[offset++]))) << (int)(8 * (c % 8));
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Write,The following statement contains a magic number: (c & 7) == 0
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: ulong t = tmp | (((ulong)count) << 56);
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: d = GetULong(val' 2);
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: d = GetULong(val' 3);
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 ^= ((ulong)4) << 59;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 ^= ((ulong)4) << 59;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v0 ^= ((ulong)4) << 59;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v0 ^= ((ulong)4) << 59;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 13 | v1 >> 51;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 16 | v3 >> 48;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v0 = v0 << 32 | v0 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v1 = v1 << 17 | v1 >> 47;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v3 = v3 << 21 | v3 >> 43;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The following statement contains a magic number: v2 = v2 << 32 | v2 >> 32;
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,GetULong,The following statement contains a magic number: switch (position)  				{  					case 0:  						return (ulong)val.pn0 + (ulong)((ulong)val.pn1 << 32);  					case 1:  						return (ulong)val.pn2 + (ulong)((ulong)val.pn3 << 32);  					case 2:  						return (ulong)val.pn4 + (ulong)((ulong)val.pn5 << 32);  					case 3:  						return (ulong)val.pn6 + (ulong)((ulong)val.pn7 << 32);  					default:  						throw new ArgumentOutOfRangeException("position should be less than 4"' "position");  				}
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,GetULong,The following statement contains a magic number: switch (position)  				{  					case 0:  						return (ulong)val.pn0 + (ulong)((ulong)val.pn1 << 32);  					case 1:  						return (ulong)val.pn2 + (ulong)((ulong)val.pn3 << 32);  					case 2:  						return (ulong)val.pn4 + (ulong)((ulong)val.pn5 << 32);  					case 3:  						return (ulong)val.pn6 + (ulong)((ulong)val.pn7 << 32);  					default:  						throw new ArgumentOutOfRangeException("position should be less than 4"' "position");  				}
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,GetULong,The following statement contains a magic number: switch (position)  				{  					case 0:  						return (ulong)val.pn0 + (ulong)((ulong)val.pn1 << 32);  					case 1:  						return (ulong)val.pn2 + (ulong)((ulong)val.pn3 << 32);  					case 2:  						return (ulong)val.pn4 + (ulong)((ulong)val.pn5 << 32);  					case 3:  						return (ulong)val.pn6 + (ulong)((ulong)val.pn7 << 32);  					default:  						throw new ArgumentOutOfRangeException("position should be less than 4"' "position");  				}
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,GetULong,The following statement contains a magic number: switch (position)  				{  					case 0:  						return (ulong)val.pn0 + (ulong)((ulong)val.pn1 << 32);  					case 1:  						return (ulong)val.pn2 + (ulong)((ulong)val.pn3 << 32);  					case 2:  						return (ulong)val.pn4 + (ulong)((ulong)val.pn5 << 32);  					case 3:  						return (ulong)val.pn6 + (ulong)((ulong)val.pn7 << 32);  					default:  						throw new ArgumentOutOfRangeException("position should be less than 4"' "position");  				}
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,GetULong,The following statement contains a magic number: switch (position)  				{  					case 0:  						return (ulong)val.pn0 + (ulong)((ulong)val.pn1 << 32);  					case 1:  						return (ulong)val.pn2 + (ulong)((ulong)val.pn3 << 32);  					case 2:  						return (ulong)val.pn4 + (ulong)((ulong)val.pn5 << 32);  					case 3:  						return (ulong)val.pn6 + (ulong)((ulong)val.pn7 << 32);  					default:  						throw new ArgumentOutOfRangeException("position should be less than 4"' "position");  				}
Magic Number,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,GetULong,The following statement contains a magic number: switch (position)  				{  					case 0:  						return (ulong)val.pn0 + (ulong)((ulong)val.pn1 << 32);  					case 1:  						return (ulong)val.pn2 + (ulong)((ulong)val.pn3 << 32);  					case 2:  						return (ulong)val.pn4 + (ulong)((ulong)val.pn5 << 32);  					case 3:  						return (ulong)val.pn6 + (ulong)((ulong)val.pn7 << 32);  					default:  						throw new ArgumentOutOfRangeException("position should be less than 4"' "position");  				}
Magic Number,NBitcoin.Crypto,HashStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\HashStream.cs,GetHash,The following statement contains a magic number: Buffer.BlockCopy(sha.Hash' 0' _Buffer' 0' 32);
Magic Number,NBitcoin.Crypto,HashStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\HashStream.cs,GetHash,The following statement contains a magic number: sha.TransformFinalBlock(_Buffer' 0' 32);
Magic Number,NBitcoin.Crypto,FuncBufferedHashStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\HashStream.cs,GetHash,The following statement contains a magic number: return new uint256(_CalculateHash(data' offset' length)' 0' 32);
Magic Number,NBitcoin.Crypto,SchnorrBlinding,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\SchnorrBlindSignature.cs,VerifySignature,The following statement contains a magic number: var c = new BigInteger(1' Hashes.SHA256(message.ToBytes(false).Concat(Utils.BigIntegerToBytes(t' 32))));
Magic Number,NBitcoin.Crypto,Requester,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\SchnorrBlindSignature.cs,Requester,The following statement contains a magic number: _k.Init(BigInteger.Arbitrary(256)' new SecureRandom());
Magic Number,NBitcoin.Crypto,Requester,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\SchnorrBlindSignature.cs,BlindMessage,The following statement contains a magic number: _c = new BigInteger(1' Hashes.SHA256(message.ToBytes(false).Concat(Utils.BigIntegerToBytes(t' 32))));
Magic Number,NBitcoin.Crypto,Requester,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\SchnorrBlindSignature.cs,BlindMessage,The following statement contains a magic number: return new uint256(Utils.BigIntegerToBytes(cp' 32));
Magic Number,NBitcoin.Crypto,Signer,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\SchnorrBlindSignature.cs,Sign,The following statement contains a magic number: return new uint256(Utils.BigIntegerToBytes(sp' 32));
Magic Number,NBitcoin.Crypto,SchnorrSignature,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\SchnorrSignature.cs,SchnorrSignature,The following statement contains a magic number: bytes.Length != 64
Magic Number,NBitcoin.Crypto,SchnorrSignature,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\SchnorrSignature.cs,SchnorrSignature,The following statement contains a magic number: R = new BigInteger(1' bytes' 0' 32);
Magic Number,NBitcoin.Crypto,SchnorrSignature,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\SchnorrSignature.cs,SchnorrSignature,The following statement contains a magic number: S = new BigInteger(1' bytes' 32' 32);
Magic Number,NBitcoin.Crypto,SchnorrSignature,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\SchnorrSignature.cs,SchnorrSignature,The following statement contains a magic number: S = new BigInteger(1' bytes' 32' 32);
Magic Number,NBitcoin.Crypto,SchnorrSignature,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\SchnorrSignature.cs,ToBytes,The following statement contains a magic number: return Utils.BigIntegerToBytes(R' 32).Concat(Utils.BigIntegerToBytes(S' 32));
Magic Number,NBitcoin.Crypto,SchnorrSignature,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\SchnorrSignature.cs,ToBytes,The following statement contains a magic number: return Utils.BigIntegerToBytes(R' 32).Concat(Utils.BigIntegerToBytes(S' 32));
Magic Number,NBitcoin.Crypto,SchnorrSigner,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\SchnorrSignature.cs,Sign,The following statement contains a magic number: var k = new BigInteger(1' Hashes.SHA256(Utils.BigIntegerToBytes(secret' 32).Concat(m.ToBytes(false))));
Magic Number,NBitcoin.Crypto,SchnorrSigner,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\SchnorrSignature.cs,Sign,The following statement contains a magic number: var keyPrefixedM = Utils.BigIntegerToBytes(Xr' 32).Concat(P.GetEncoded(true)' m.ToBytes(false));
Magic Number,NBitcoin.Crypto,SchnorrSigner,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\SchnorrSignature.cs,Verify,The following statement contains a magic number: var e = new BigInteger(1' Hashes.SHA256(Utils.BigIntegerToBytes(sig.R' 32).Concat(pubkey.ToBytes()' m.ToBytes(false)))).Mod(Secp256k1.N);
Magic Number,NBitcoin.Crypto,SchnorrSigner,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\SchnorrSignature.cs,BatchVerify,The following statement contains a magic number: var e = new BigInteger(1' Hashes.SHA256(Utils.BigIntegerToBytes(sig.R' 32).Concat(pubkeys[i].ToBytes()' m[i].ToBytes(false)))).Mod(Secp256k1.N);
Magic Number,NBitcoin.Crypto,SchnorrSigner,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\SchnorrSignature.cs,BatchVerify,The following statement contains a magic number: var c = sig.R.Pow(3).Add(BigInteger.ValueOf(7)).Mod(PP);
Magic Number,NBitcoin.Crypto,SchnorrSigner,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\SchnorrSignature.cs,BatchVerify,The following statement contains a magic number: var c = sig.R.Pow(3).Add(BigInteger.ValueOf(7)).Mod(PP);
Magic Number,NBitcoin.Crypto,SchnorrSigner,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\SchnorrSignature.cs,BatchVerify,The following statement contains a magic number: var y = c.ModPow(PP.Add(BigInteger.One).Divide(BigInteger.ValueOf(4))' PP);
Magic Number,NBitcoin.Crypto.Internal,BitMath,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\BitMath.cs,ReverseBits,The following statement contains a magic number: byte reversed = (byte)((((ulong)value * 0x80200802) & 0x884422110) * 0x101010101 >> 32);
Magic Number,NBitcoin.Crypto.Internal,BitPacking,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\BitPacking.cs,UInt24FromLEBytes,The following statement contains a magic number: return  				(uint)bytes[offset + 2] << 16 |  				(uint)bytes[offset + 1] << 8 |  				(uint)bytes[offset + 0];
Magic Number,NBitcoin.Crypto.Internal,BitPacking,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\BitPacking.cs,UInt24FromLEBytes,The following statement contains a magic number: return  				(uint)bytes[offset + 2] << 16 |  				(uint)bytes[offset + 1] << 8 |  				(uint)bytes[offset + 0];
Magic Number,NBitcoin.Crypto.Internal,BitPacking,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\BitPacking.cs,UInt24FromLEBytes,The following statement contains a magic number: return  				(uint)bytes[offset + 2] << 16 |  				(uint)bytes[offset + 1] << 8 |  				(uint)bytes[offset + 0];
Magic Number,NBitcoin.Crypto.Internal,BitPacking,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\BitPacking.cs,UInt32FromLEBytes,The following statement contains a magic number: return  				(uint)bytes[offset + 3] << 24 |  				UInt24FromLEBytes(bytes' offset);
Magic Number,NBitcoin.Crypto.Internal,BitPacking,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\BitPacking.cs,UInt32FromLEBytes,The following statement contains a magic number: return  				(uint)bytes[offset + 3] << 24 |  				UInt24FromLEBytes(bytes' offset);
Magic Number,NBitcoin.Crypto.Internal,BitPacking,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\BitPacking.cs,BEBytesFromUInt32,The following statement contains a magic number: bytes[offset + 0] = (byte)(value >> 24);
Magic Number,NBitcoin.Crypto.Internal,BitPacking,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\BitPacking.cs,BEBytesFromUInt32,The following statement contains a magic number: bytes[offset + 1] = (byte)(value >> 16);
Magic Number,NBitcoin.Crypto.Internal,BitPacking,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\BitPacking.cs,BEBytesFromUInt32,The following statement contains a magic number: bytes[offset + 2] = (byte)(value >> 8);
Magic Number,NBitcoin.Crypto.Internal,BitPacking,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\BitPacking.cs,BEBytesFromUInt32,The following statement contains a magic number: bytes[offset + 2] = (byte)(value >> 8);
Magic Number,NBitcoin.Crypto.Internal,BitPacking,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\BitPacking.cs,BEBytesFromUInt32,The following statement contains a magic number: bytes[offset + 3] = (byte)(value);
Magic Number,NBitcoin.Crypto.Internal,BitPacking,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\BitPacking.cs,LEBytesFromUInt24,The following statement contains a magic number: bytes[offset + 2] = (byte)(value >> 16);
Magic Number,NBitcoin.Crypto.Internal,BitPacking,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\BitPacking.cs,LEBytesFromUInt24,The following statement contains a magic number: bytes[offset + 2] = (byte)(value >> 16);
Magic Number,NBitcoin.Crypto.Internal,BitPacking,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\BitPacking.cs,LEBytesFromUInt24,The following statement contains a magic number: bytes[offset + 1] = (byte)(value >> 8);
Magic Number,NBitcoin.Crypto.Internal,BitPacking,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\BitPacking.cs,LEBytesFromUInt32,The following statement contains a magic number: bytes[offset + 3] = (byte)(value >> 24);
Magic Number,NBitcoin.Crypto.Internal,BitPacking,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Cryptsharp\BitPacking.cs,LEBytesFromUInt32,The following statement contains a magic number: bytes[offset + 3] = (byte)(value >> 24);
Magic Number,NBitcoin.DataEncoders,Base32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Base32Encoder.cs,EncodeData,The following statement contains a magic number: var str = new char[((count + 4) / 5) * 8];
Magic Number,NBitcoin.DataEncoders,Base32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Base32Encoder.cs,EncodeData,The following statement contains a magic number: var str = new char[((count + 4) / 5) * 8];
Magic Number,NBitcoin.DataEncoders,Base32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Base32Encoder.cs,EncodeData,The following statement contains a magic number: var str = new char[((count + 4) / 5) * 8];
Magic Number,NBitcoin.DataEncoders,Base32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Base32Encoder.cs,EncodeData,The following statement contains a magic number: ConvertBits(c => str[stri++] = pbase32[c]' data' offset' count' 8' 5' true);
Magic Number,NBitcoin.DataEncoders,Base32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Base32Encoder.cs,EncodeData,The following statement contains a magic number: ConvertBits(c => str[stri++] = pbase32[c]' data' offset' count' 8' 5' true);
Magic Number,NBitcoin.DataEncoders,Base32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Base32Encoder.cs,EncodeData,The following statement contains a magic number: stri % 8 != 0
Magic Number,NBitcoin.DataEncoders,Base32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Base32Encoder.cs,DecodeData,The following statement contains a magic number: Span<byte> val = encoded.Length < 100 ? stackalloc byte[encoded.Length] : new byte[encoded.Length];
Magic Number,NBitcoin.DataEncoders,Base32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Base32Encoder.cs,DecodeData,The following statement contains a magic number: var ret = new byte[(encoded.Length * 5) / 8];
Magic Number,NBitcoin.DataEncoders,Base32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Base32Encoder.cs,DecodeData,The following statement contains a magic number: var ret = new byte[(encoded.Length * 5) / 8];
Magic Number,NBitcoin.DataEncoders,Base32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Base32Encoder.cs,DecodeData,The following statement contains a magic number: bool valid = ConvertBits((c) => ret[reti++] = c' val' 0' val.Length' 5' 8' false);
Magic Number,NBitcoin.DataEncoders,Base32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Base32Encoder.cs,DecodeData,The following statement contains a magic number: bool valid = ConvertBits((c) => ret[reti++] = c' val' 0' val.Length' 5' 8' false);
Magic Number,NBitcoin.DataEncoders,Base32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Base32Encoder.cs,DecodeData,The following statement contains a magic number: valid = valid && p % 8 == 0 && p - q < 8;
Magic Number,NBitcoin.DataEncoders,Base32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Base32Encoder.cs,DecodeData,The following statement contains a magic number: valid = valid && p % 8 == 0 && p - q < 8;
Magic Number,NBitcoin.DataEncoders,Base58CheckEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Base58Encoder.cs,IsMaybeEncoded,The following statement contains a magic number: return base.IsMaybeEncoded(str) && str.Length > 4;
Magic Number,NBitcoin.DataEncoders,Base58CheckEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Base58Encoder.cs,EncodeData,The following statement contains a magic number: var toEncode = new byte[count + 4];
Magic Number,NBitcoin.DataEncoders,Base58CheckEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Base58Encoder.cs,EncodeData,The following statement contains a magic number: Buffer.BlockCopy(hash' 0' toEncode' count' 4);
Magic Number,NBitcoin.DataEncoders,Base58CheckEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Base58Encoder.cs,DecodeData,The following statement contains a magic number: vchRet.Length < 4
Magic Number,NBitcoin.DataEncoders,Base58CheckEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Base58Encoder.cs,DecodeData,The following statement contains a magic number: var calculatedHash = CalculateHash(vchRet' 0' vchRet.Length - 4);
Magic Number,NBitcoin.DataEncoders,Base58CheckEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Base58Encoder.cs,DecodeData,The following statement contains a magic number: !Utils.ArrayEqual(calculatedHash' 0' vchRet' vchRet.Length - 4' 4)
Magic Number,NBitcoin.DataEncoders,Base58CheckEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Base58Encoder.cs,DecodeData,The following statement contains a magic number: !Utils.ArrayEqual(calculatedHash' 0' vchRet' vchRet.Length - 4' 4)
Magic Number,NBitcoin.DataEncoders,Base58CheckEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Base58Encoder.cs,DecodeData,The following statement contains a magic number: vchRet = vchRet.SafeSubarray(0' vchRet.Length - 4);
Magic Number,NBitcoin.DataEncoders,Base58Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Base58Encoder.cs,DecodeData,The following statement contains a magic number: vchTmp.Length >= 2 && vchTmp[vchTmp.Length - 1] == 0 && vchTmp[vchTmp.Length - 2] >= 0x80
Magic Number,NBitcoin.DataEncoders,Base58Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Base58Encoder.cs,DecodeData,The following statement contains a magic number: vchTmp.Length >= 2 && vchTmp[vchTmp.Length - 1] == 0 && vchTmp[vchTmp.Length - 2] >= 0x80
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,syndrome,The following statement contains a magic number: return (uint)(low ^ (low << 10) ^ (low << 20) ^  			  (((residue >> 5) & 1) != 0 ? 0x31edd3c4 : 0) ^  			  (((residue >> 6) & 1) != 0 ? 0x335f86a8 : 0) ^  			  (((residue >> 7) & 1) != 0 ? 0x363b8870 : 0) ^  			  (((residue >> 8) & 1) != 0 ? 0x3e6390c9 : 0) ^  			  (((residue >> 9) & 1) != 0 ? 0x2ec72192 : 0) ^  			  (((residue >> 10) & 1) != 0 ? 0x1046f79d : 0) ^  			  (((residue >> 11) & 1) != 0 ? 0x208d4e33 : 0) ^  			  (((residue >> 12) & 1) != 0 ? 0x130ebd6f : 0) ^  			  (((residue >> 13) & 1) != 0 ? 0x2499fade : 0) ^  			  (((residue >> 14) & 1) != 0 ? 0x1b27d4b5 : 0) ^  			  (((residue >> 15) & 1) != 0 ? 0x04be1eb4 : 0) ^  			  (((residue >> 16) & 1) != 0 ? 0x0968b861 : 0) ^  			  (((residue >> 17) & 1) != 0 ? 0x1055f0c2 : 0) ^  			  (((residue >> 18) & 1) != 0 ? 0x20ab4584 : 0) ^  			  (((residue >> 19) & 1) != 0 ? 0x1342af08 : 0) ^  			  (((residue >> 20) & 1) != 0 ? 0x24f1f318 : 0) ^  			  (((residue >> 21) & 1) != 0 ? 0x1be34739 : 0) ^  			  (((residue >> 22) & 1) != 0 ? 0x35562f7b : 0) ^  			  (((residue >> 23) & 1) != 0 ? 0x3a3c5bff : 0) ^  			  (((residue >> 24) & 1) != 0 ? 0x266c96f7 : 0) ^  			  (((residue >> 25) & 1) != 0 ? 0x25c78b65 : 0) ^  			  (((residue >> 26) & 1) != 0 ? 0x1b1f13ea : 0) ^  			  (((residue >> 27) & 1) != 0 ? 0x34baa2f4 : 0) ^  			  (((residue >> 28) & 1) != 0 ? 0x3b61c0e1 : 0) ^  			  (((residue >> 29) & 1) != 0 ? 0x265325c2 : 0));
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,syndrome,The following statement contains a magic number: return (uint)(low ^ (low << 10) ^ (low << 20) ^  			  (((residue >> 5) & 1) != 0 ? 0x31edd3c4 : 0) ^  			  (((residue >> 6) & 1) != 0 ? 0x335f86a8 : 0) ^  			  (((residue >> 7) & 1) != 0 ? 0x363b8870 : 0) ^  			  (((residue >> 8) & 1) != 0 ? 0x3e6390c9 : 0) ^  			  (((residue >> 9) & 1) != 0 ? 0x2ec72192 : 0) ^  			  (((residue >> 10) & 1) != 0 ? 0x1046f79d : 0) ^  			  (((residue >> 11) & 1) != 0 ? 0x208d4e33 : 0) ^  			  (((residue >> 12) & 1) != 0 ? 0x130ebd6f : 0) ^  			  (((residue >> 13) & 1) != 0 ? 0x2499fade : 0) ^  			  (((residue >> 14) & 1) != 0 ? 0x1b27d4b5 : 0) ^  			  (((residue >> 15) & 1) != 0 ? 0x04be1eb4 : 0) ^  			  (((residue >> 16) & 1) != 0 ? 0x0968b861 : 0) ^  			  (((residue >> 17) & 1) != 0 ? 0x1055f0c2 : 0) ^  			  (((residue >> 18) & 1) != 0 ? 0x20ab4584 : 0) ^  			  (((residue >> 19) & 1) != 0 ? 0x1342af08 : 0) ^  			  (((residue >> 20) & 1) != 0 ? 0x24f1f318 : 0) ^  			  (((residue >> 21) & 1) != 0 ? 0x1be34739 : 0) ^  			  (((residue >> 22) & 1) != 0 ? 0x35562f7b : 0) ^  			  (((residue >> 23) & 1) != 0 ? 0x3a3c5bff : 0) ^  			  (((residue >> 24) & 1) != 0 ? 0x266c96f7 : 0) ^  			  (((residue >> 25) & 1) != 0 ? 0x25c78b65 : 0) ^  			  (((residue >> 26) & 1) != 0 ? 0x1b1f13ea : 0) ^  			  (((residue >> 27) & 1) != 0 ? 0x34baa2f4 : 0) ^  			  (((residue >> 28) & 1) != 0 ? 0x3b61c0e1 : 0) ^  			  (((residue >> 29) & 1) != 0 ? 0x265325c2 : 0));
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,syndrome,The following statement contains a magic number: return (uint)(low ^ (low << 10) ^ (low << 20) ^  			  (((residue >> 5) & 1) != 0 ? 0x31edd3c4 : 0) ^  			  (((residue >> 6) & 1) != 0 ? 0x335f86a8 : 0) ^  			  (((residue >> 7) & 1) != 0 ? 0x363b8870 : 0) ^  			  (((residue >> 8) & 1) != 0 ? 0x3e6390c9 : 0) ^  			  (((residue >> 9) & 1) != 0 ? 0x2ec72192 : 0) ^  			  (((residue >> 10) & 1) != 0 ? 0x1046f79d : 0) ^  			  (((residue >> 11) & 1) != 0 ? 0x208d4e33 : 0) ^  			  (((residue >> 12) & 1) != 0 ? 0x130ebd6f : 0) ^  			  (((residue >> 13) & 1) != 0 ? 0x2499fade : 0) ^  			  (((residue >> 14) & 1) != 0 ? 0x1b27d4b5 : 0) ^  			  (((residue >> 15) & 1) != 0 ? 0x04be1eb4 : 0) ^  			  (((residue >> 16) & 1) != 0 ? 0x0968b861 : 0) ^  			  (((residue >> 17) & 1) != 0 ? 0x1055f0c2 : 0) ^  			  (((residue >> 18) & 1) != 0 ? 0x20ab4584 : 0) ^  			  (((residue >> 19) & 1) != 0 ? 0x1342af08 : 0) ^  			  (((residue >> 20) & 1) != 0 ? 0x24f1f318 : 0) ^  			  (((residue >> 21) & 1) != 0 ? 0x1be34739 : 0) ^  			  (((residue >> 22) & 1) != 0 ? 0x35562f7b : 0) ^  			  (((residue >> 23) & 1) != 0 ? 0x3a3c5bff : 0) ^  			  (((residue >> 24) & 1) != 0 ? 0x266c96f7 : 0) ^  			  (((residue >> 25) & 1) != 0 ? 0x25c78b65 : 0) ^  			  (((residue >> 26) & 1) != 0 ? 0x1b1f13ea : 0) ^  			  (((residue >> 27) & 1) != 0 ? 0x34baa2f4 : 0) ^  			  (((residue >> 28) & 1) != 0 ? 0x3b61c0e1 : 0) ^  			  (((residue >> 29) & 1) != 0 ? 0x265325c2 : 0));
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,syndrome,The following statement contains a magic number: return (uint)(low ^ (low << 10) ^ (low << 20) ^  			  (((residue >> 5) & 1) != 0 ? 0x31edd3c4 : 0) ^  			  (((residue >> 6) & 1) != 0 ? 0x335f86a8 : 0) ^  			  (((residue >> 7) & 1) != 0 ? 0x363b8870 : 0) ^  			  (((residue >> 8) & 1) != 0 ? 0x3e6390c9 : 0) ^  			  (((residue >> 9) & 1) != 0 ? 0x2ec72192 : 0) ^  			  (((residue >> 10) & 1) != 0 ? 0x1046f79d : 0) ^  			  (((residue >> 11) & 1) != 0 ? 0x208d4e33 : 0) ^  			  (((residue >> 12) & 1) != 0 ? 0x130ebd6f : 0) ^  			  (((residue >> 13) & 1) != 0 ? 0x2499fade : 0) ^  			  (((residue >> 14) & 1) != 0 ? 0x1b27d4b5 : 0) ^  			  (((residue >> 15) & 1) != 0 ? 0x04be1eb4 : 0) ^  			  (((residue >> 16) & 1) != 0 ? 0x0968b861 : 0) ^  			  (((residue >> 17) & 1) != 0 ? 0x1055f0c2 : 0) ^  			  (((residue >> 18) & 1) != 0 ? 0x20ab4584 : 0) ^  			  (((residue >> 19) & 1) != 0 ? 0x1342af08 : 0) ^  			  (((residue >> 20) & 1) != 0 ? 0x24f1f318 : 0) ^  			  (((residue >> 21) & 1) != 0 ? 0x1be34739 : 0) ^  			  (((residue >> 22) & 1) != 0 ? 0x35562f7b : 0) ^  			  (((residue >> 23) & 1) != 0 ? 0x3a3c5bff : 0) ^  			  (((residue >> 24) & 1) != 0 ? 0x266c96f7 : 0) ^  			  (((residue >> 25) & 1) != 0 ? 0x25c78b65 : 0) ^  			  (((residue >> 26) & 1) != 0 ? 0x1b1f13ea : 0) ^  			  (((residue >> 27) & 1) != 0 ? 0x34baa2f4 : 0) ^  			  (((residue >> 28) & 1) != 0 ? 0x3b61c0e1 : 0) ^  			  (((residue >> 29) & 1) != 0 ? 0x265325c2 : 0));
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,syndrome,The following statement contains a magic number: return (uint)(low ^ (low << 10) ^ (low << 20) ^  			  (((residue >> 5) & 1) != 0 ? 0x31edd3c4 : 0) ^  			  (((residue >> 6) & 1) != 0 ? 0x335f86a8 : 0) ^  			  (((residue >> 7) & 1) != 0 ? 0x363b8870 : 0) ^  			  (((residue >> 8) & 1) != 0 ? 0x3e6390c9 : 0) ^  			  (((residue >> 9) & 1) != 0 ? 0x2ec72192 : 0) ^  			  (((residue >> 10) & 1) != 0 ? 0x1046f79d : 0) ^  			  (((residue >> 11) & 1) != 0 ? 0x208d4e33 : 0) ^  			  (((residue >> 12) & 1) != 0 ? 0x130ebd6f : 0) ^  			  (((residue >> 13) & 1) != 0 ? 0x2499fade : 0) ^  			  (((residue >> 14) & 1) != 0 ? 0x1b27d4b5 : 0) ^  			  (((residue >> 15) & 1) != 0 ? 0x04be1eb4 : 0) ^  			  (((residue >> 16) & 1) != 0 ? 0x0968b861 : 0) ^  			  (((residue >> 17) & 1) != 0 ? 0x1055f0c2 : 0) ^  			  (((residue >> 18) & 1) != 0 ? 0x20ab4584 : 0) ^  			  (((residue >> 19) & 1) != 0 ? 0x1342af08 : 0) ^  			  (((residue >> 20) & 1) != 0 ? 0x24f1f318 : 0) ^  			  (((residue >> 21) & 1) != 0 ? 0x1be34739 : 0) ^  			  (((residue >> 22) & 1) != 0 ? 0x35562f7b : 0) ^  			  (((residue >> 23) & 1) != 0 ? 0x3a3c5bff : 0) ^  			  (((residue >> 24) & 1) != 0 ? 0x266c96f7 : 0) ^  			  (((residue >> 25) & 1) != 0 ? 0x25c78b65 : 0) ^  			  (((residue >> 26) & 1) != 0 ? 0x1b1f13ea : 0) ^  			  (((residue >> 27) & 1) != 0 ? 0x34baa2f4 : 0) ^  			  (((residue >> 28) & 1) != 0 ? 0x3b61c0e1 : 0) ^  			  (((residue >> 29) & 1) != 0 ? 0x265325c2 : 0));
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,syndrome,The following statement contains a magic number: return (uint)(low ^ (low << 10) ^ (low << 20) ^  			  (((residue >> 5) & 1) != 0 ? 0x31edd3c4 : 0) ^  			  (((residue >> 6) & 1) != 0 ? 0x335f86a8 : 0) ^  			  (((residue >> 7) & 1) != 0 ? 0x363b8870 : 0) ^  			  (((residue >> 8) & 1) != 0 ? 0x3e6390c9 : 0) ^  			  (((residue >> 9) & 1) != 0 ? 0x2ec72192 : 0) ^  			  (((residue >> 10) & 1) != 0 ? 0x1046f79d : 0) ^  			  (((residue >> 11) & 1) != 0 ? 0x208d4e33 : 0) ^  			  (((residue >> 12) & 1) != 0 ? 0x130ebd6f : 0) ^  			  (((residue >> 13) & 1) != 0 ? 0x2499fade : 0) ^  			  (((residue >> 14) & 1) != 0 ? 0x1b27d4b5 : 0) ^  			  (((residue >> 15) & 1) != 0 ? 0x04be1eb4 : 0) ^  			  (((residue >> 16) & 1) != 0 ? 0x0968b861 : 0) ^  			  (((residue >> 17) & 1) != 0 ? 0x1055f0c2 : 0) ^  			  (((residue >> 18) & 1) != 0 ? 0x20ab4584 : 0) ^  			  (((residue >> 19) & 1) != 0 ? 0x1342af08 : 0) ^  			  (((residue >> 20) & 1) != 0 ? 0x24f1f318 : 0) ^  			  (((residue >> 21) & 1) != 0 ? 0x1be34739 : 0) ^  			  (((residue >> 22) & 1) != 0 ? 0x35562f7b : 0) ^  			  (((residue >> 23) & 1) != 0 ? 0x3a3c5bff : 0) ^  			  (((residue >> 24) & 1) != 0 ? 0x266c96f7 : 0) ^  			  (((residue >> 25) & 1) != 0 ? 0x25c78b65 : 0) ^  			  (((residue >> 26) & 1) != 0 ? 0x1b1f13ea : 0) ^  			  (((residue >> 27) & 1) != 0 ? 0x34baa2f4 : 0) ^  			  (((residue >> 28) & 1) != 0 ? 0x3b61c0e1 : 0) ^  			  (((residue >> 29) & 1) != 0 ? 0x265325c2 : 0));
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,syndrome,The following statement contains a magic number: return (uint)(low ^ (low << 10) ^ (low << 20) ^  			  (((residue >> 5) & 1) != 0 ? 0x31edd3c4 : 0) ^  			  (((residue >> 6) & 1) != 0 ? 0x335f86a8 : 0) ^  			  (((residue >> 7) & 1) != 0 ? 0x363b8870 : 0) ^  			  (((residue >> 8) & 1) != 0 ? 0x3e6390c9 : 0) ^  			  (((residue >> 9) & 1) != 0 ? 0x2ec72192 : 0) ^  			  (((residue >> 10) & 1) != 0 ? 0x1046f79d : 0) ^  			  (((residue >> 11) & 1) != 0 ? 0x208d4e33 : 0) ^  			  (((residue >> 12) & 1) != 0 ? 0x130ebd6f : 0) ^  			  (((residue >> 13) & 1) != 0 ? 0x2499fade : 0) ^  			  (((residue >> 14) & 1) != 0 ? 0x1b27d4b5 : 0) ^  			  (((residue >> 15) & 1) != 0 ? 0x04be1eb4 : 0) ^  			  (((residue >> 16) & 1) != 0 ? 0x0968b861 : 0) ^  			  (((residue >> 17) & 1) != 0 ? 0x1055f0c2 : 0) ^  			  (((residue >> 18) & 1) != 0 ? 0x20ab4584 : 0) ^  			  (((residue >> 19) & 1) != 0 ? 0x1342af08 : 0) ^  			  (((residue >> 20) & 1) != 0 ? 0x24f1f318 : 0) ^  			  (((residue >> 21) & 1) != 0 ? 0x1be34739 : 0) ^  			  (((residue >> 22) & 1) != 0 ? 0x35562f7b : 0) ^  			  (((residue >> 23) & 1) != 0 ? 0x3a3c5bff : 0) ^  			  (((residue >> 24) & 1) != 0 ? 0x266c96f7 : 0) ^  			  (((residue >> 25) & 1) != 0 ? 0x25c78b65 : 0) ^  			  (((residue >> 26) & 1) != 0 ? 0x1b1f13ea : 0) ^  			  (((residue >> 27) & 1) != 0 ? 0x34baa2f4 : 0) ^  			  (((residue >> 28) & 1) != 0 ? 0x3b61c0e1 : 0) ^  			  (((residue >> 29) & 1) != 0 ? 0x265325c2 : 0));
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,syndrome,The following statement contains a magic number: return (uint)(low ^ (low << 10) ^ (low << 20) ^  			  (((residue >> 5) & 1) != 0 ? 0x31edd3c4 : 0) ^  			  (((residue >> 6) & 1) != 0 ? 0x335f86a8 : 0) ^  			  (((residue >> 7) & 1) != 0 ? 0x363b8870 : 0) ^  			  (((residue >> 8) & 1) != 0 ? 0x3e6390c9 : 0) ^  			  (((residue >> 9) & 1) != 0 ? 0x2ec72192 : 0) ^  			  (((residue >> 10) & 1) != 0 ? 0x1046f79d : 0) ^  			  (((residue >> 11) & 1) != 0 ? 0x208d4e33 : 0) ^  			  (((residue >> 12) & 1) != 0 ? 0x130ebd6f : 0) ^  			  (((residue >> 13) & 1) != 0 ? 0x2499fade : 0) ^  			  (((residue >> 14) & 1) != 0 ? 0x1b27d4b5 : 0) ^  			  (((residue >> 15) & 1) != 0 ? 0x04be1eb4 : 0) ^  			  (((residue >> 16) & 1) != 0 ? 0x0968b861 : 0) ^  			  (((residue >> 17) & 1) != 0 ? 0x1055f0c2 : 0) ^  			  (((residue >> 18) & 1) != 0 ? 0x20ab4584 : 0) ^  			  (((residue >> 19) & 1) != 0 ? 0x1342af08 : 0) ^  			  (((residue >> 20) & 1) != 0 ? 0x24f1f318 : 0) ^  			  (((residue >> 21) & 1) != 0 ? 0x1be34739 : 0) ^  			  (((residue >> 22) & 1) != 0 ? 0x35562f7b : 0) ^  			  (((residue >> 23) & 1) != 0 ? 0x3a3c5bff : 0) ^  			  (((residue >> 24) & 1) != 0 ? 0x266c96f7 : 0) ^  			  (((residue >> 25) & 1) != 0 ? 0x25c78b65 : 0) ^  			  (((residue >> 26) & 1) != 0 ? 0x1b1f13ea : 0) ^  			  (((residue >> 27) & 1) != 0 ? 0x34baa2f4 : 0) ^  			  (((residue >> 28) & 1) != 0 ? 0x3b61c0e1 : 0) ^  			  (((residue >> 29) & 1) != 0 ? 0x265325c2 : 0));
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,syndrome,The following statement contains a magic number: return (uint)(low ^ (low << 10) ^ (low << 20) ^  			  (((residue >> 5) & 1) != 0 ? 0x31edd3c4 : 0) ^  			  (((residue >> 6) & 1) != 0 ? 0x335f86a8 : 0) ^  			  (((residue >> 7) & 1) != 0 ? 0x363b8870 : 0) ^  			  (((residue >> 8) & 1) != 0 ? 0x3e6390c9 : 0) ^  			  (((residue >> 9) & 1) != 0 ? 0x2ec72192 : 0) ^  			  (((residue >> 10) & 1) != 0 ? 0x1046f79d : 0) ^  			  (((residue >> 11) & 1) != 0 ? 0x208d4e33 : 0) ^  			  (((residue >> 12) & 1) != 0 ? 0x130ebd6f : 0) ^  			  (((residue >> 13) & 1) != 0 ? 0x2499fade : 0) ^  			  (((residue >> 14) & 1) != 0 ? 0x1b27d4b5 : 0) ^  			  (((residue >> 15) & 1) != 0 ? 0x04be1eb4 : 0) ^  			  (((residue >> 16) & 1) != 0 ? 0x0968b861 : 0) ^  			  (((residue >> 17) & 1) != 0 ? 0x1055f0c2 : 0) ^  			  (((residue >> 18) & 1) != 0 ? 0x20ab4584 : 0) ^  			  (((residue >> 19) & 1) != 0 ? 0x1342af08 : 0) ^  			  (((residue >> 20) & 1) != 0 ? 0x24f1f318 : 0) ^  			  (((residue >> 21) & 1) != 0 ? 0x1be34739 : 0) ^  			  (((residue >> 22) & 1) != 0 ? 0x35562f7b : 0) ^  			  (((residue >> 23) & 1) != 0 ? 0x3a3c5bff : 0) ^  			  (((residue >> 24) & 1) != 0 ? 0x266c96f7 : 0) ^  			  (((residue >> 25) & 1) != 0 ? 0x25c78b65 : 0) ^  			  (((residue >> 26) & 1) != 0 ? 0x1b1f13ea : 0) ^  			  (((residue >> 27) & 1) != 0 ? 0x34baa2f4 : 0) ^  			  (((residue >> 28) & 1) != 0 ? 0x3b61c0e1 : 0) ^  			  (((residue >> 29) & 1) != 0 ? 0x265325c2 : 0));
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,syndrome,The following statement contains a magic number: return (uint)(low ^ (low << 10) ^ (low << 20) ^  			  (((residue >> 5) & 1) != 0 ? 0x31edd3c4 : 0) ^  			  (((residue >> 6) & 1) != 0 ? 0x335f86a8 : 0) ^  			  (((residue >> 7) & 1) != 0 ? 0x363b8870 : 0) ^  			  (((residue >> 8) & 1) != 0 ? 0x3e6390c9 : 0) ^  			  (((residue >> 9) & 1) != 0 ? 0x2ec72192 : 0) ^  			  (((residue >> 10) & 1) != 0 ? 0x1046f79d : 0) ^  			  (((residue >> 11) & 1) != 0 ? 0x208d4e33 : 0) ^  			  (((residue >> 12) & 1) != 0 ? 0x130ebd6f : 0) ^  			  (((residue >> 13) & 1) != 0 ? 0x2499fade : 0) ^  			  (((residue >> 14) & 1) != 0 ? 0x1b27d4b5 : 0) ^  			  (((residue >> 15) & 1) != 0 ? 0x04be1eb4 : 0) ^  			  (((residue >> 16) & 1) != 0 ? 0x0968b861 : 0) ^  			  (((residue >> 17) & 1) != 0 ? 0x1055f0c2 : 0) ^  			  (((residue >> 18) & 1) != 0 ? 0x20ab4584 : 0) ^  			  (((residue >> 19) & 1) != 0 ? 0x1342af08 : 0) ^  			  (((residue >> 20) & 1) != 0 ? 0x24f1f318 : 0) ^  			  (((residue >> 21) & 1) != 0 ? 0x1be34739 : 0) ^  			  (((residue >> 22) & 1) != 0 ? 0x35562f7b : 0) ^  			  (((residue >> 23) & 1) != 0 ? 0x3a3c5bff : 0) ^  			  (((residue >> 24) & 1) != 0 ? 0x266c96f7 : 0) ^  			  (((residue >> 25) & 1) != 0 ? 0x25c78b65 : 0) ^  			  (((residue >> 26) & 1) != 0 ? 0x1b1f13ea : 0) ^  			  (((residue >> 27) & 1) != 0 ? 0x34baa2f4 : 0) ^  			  (((residue >> 28) & 1) != 0 ? 0x3b61c0e1 : 0) ^  			  (((residue >> 29) & 1) != 0 ? 0x265325c2 : 0));
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,syndrome,The following statement contains a magic number: return (uint)(low ^ (low << 10) ^ (low << 20) ^  			  (((residue >> 5) & 1) != 0 ? 0x31edd3c4 : 0) ^  			  (((residue >> 6) & 1) != 0 ? 0x335f86a8 : 0) ^  			  (((residue >> 7) & 1) != 0 ? 0x363b8870 : 0) ^  			  (((residue >> 8) & 1) != 0 ? 0x3e6390c9 : 0) ^  			  (((residue >> 9) & 1) != 0 ? 0x2ec72192 : 0) ^  			  (((residue >> 10) & 1) != 0 ? 0x1046f79d : 0) ^  			  (((residue >> 11) & 1) != 0 ? 0x208d4e33 : 0) ^  			  (((residue >> 12) & 1) != 0 ? 0x130ebd6f : 0) ^  			  (((residue >> 13) & 1) != 0 ? 0x2499fade : 0) ^  			  (((residue >> 14) & 1) != 0 ? 0x1b27d4b5 : 0) ^  			  (((residue >> 15) & 1) != 0 ? 0x04be1eb4 : 0) ^  			  (((residue >> 16) & 1) != 0 ? 0x0968b861 : 0) ^  			  (((residue >> 17) & 1) != 0 ? 0x1055f0c2 : 0) ^  			  (((residue >> 18) & 1) != 0 ? 0x20ab4584 : 0) ^  			  (((residue >> 19) & 1) != 0 ? 0x1342af08 : 0) ^  			  (((residue >> 20) & 1) != 0 ? 0x24f1f318 : 0) ^  			  (((residue >> 21) & 1) != 0 ? 0x1be34739 : 0) ^  			  (((residue >> 22) & 1) != 0 ? 0x35562f7b : 0) ^  			  (((residue >> 23) & 1) != 0 ? 0x3a3c5bff : 0) ^  			  (((residue >> 24) & 1) != 0 ? 0x266c96f7 : 0) ^  			  (((residue >> 25) & 1) != 0 ? 0x25c78b65 : 0) ^  			  (((residue >> 26) & 1) != 0 ? 0x1b1f13ea : 0) ^  			  (((residue >> 27) & 1) != 0 ? 0x34baa2f4 : 0) ^  			  (((residue >> 28) & 1) != 0 ? 0x3b61c0e1 : 0) ^  			  (((residue >> 29) & 1) != 0 ? 0x265325c2 : 0));
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,syndrome,The following statement contains a magic number: return (uint)(low ^ (low << 10) ^ (low << 20) ^  			  (((residue >> 5) & 1) != 0 ? 0x31edd3c4 : 0) ^  			  (((residue >> 6) & 1) != 0 ? 0x335f86a8 : 0) ^  			  (((residue >> 7) & 1) != 0 ? 0x363b8870 : 0) ^  			  (((residue >> 8) & 1) != 0 ? 0x3e6390c9 : 0) ^  			  (((residue >> 9) & 1) != 0 ? 0x2ec72192 : 0) ^  			  (((residue >> 10) & 1) != 0 ? 0x1046f79d : 0) ^  			  (((residue >> 11) & 1) != 0 ? 0x208d4e33 : 0) ^  			  (((residue >> 12) & 1) != 0 ? 0x130ebd6f : 0) ^  			  (((residue >> 13) & 1) != 0 ? 0x2499fade : 0) ^  			  (((residue >> 14) & 1) != 0 ? 0x1b27d4b5 : 0) ^  			  (((residue >> 15) & 1) != 0 ? 0x04be1eb4 : 0) ^  			  (((residue >> 16) & 1) != 0 ? 0x0968b861 : 0) ^  			  (((residue >> 17) & 1) != 0 ? 0x1055f0c2 : 0) ^  			  (((residue >> 18) & 1) != 0 ? 0x20ab4584 : 0) ^  			  (((residue >> 19) & 1) != 0 ? 0x1342af08 : 0) ^  			  (((residue >> 20) & 1) != 0 ? 0x24f1f318 : 0) ^  			  (((residue >> 21) & 1) != 0 ? 0x1be34739 : 0) ^  			  (((residue >> 22) & 1) != 0 ? 0x35562f7b : 0) ^  			  (((residue >> 23) & 1) != 0 ? 0x3a3c5bff : 0) ^  			  (((residue >> 24) & 1) != 0 ? 0x266c96f7 : 0) ^  			  (((residue >> 25) & 1) != 0 ? 0x25c78b65 : 0) ^  			  (((residue >> 26) & 1) != 0 ? 0x1b1f13ea : 0) ^  			  (((residue >> 27) & 1) != 0 ? 0x34baa2f4 : 0) ^  			  (((residue >> 28) & 1) != 0 ? 0x3b61c0e1 : 0) ^  			  (((residue >> 29) & 1) != 0 ? 0x265325c2 : 0));
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,syndrome,The following statement contains a magic number: return (uint)(low ^ (low << 10) ^ (low << 20) ^  			  (((residue >> 5) & 1) != 0 ? 0x31edd3c4 : 0) ^  			  (((residue >> 6) & 1) != 0 ? 0x335f86a8 : 0) ^  			  (((residue >> 7) & 1) != 0 ? 0x363b8870 : 0) ^  			  (((residue >> 8) & 1) != 0 ? 0x3e6390c9 : 0) ^  			  (((residue >> 9) & 1) != 0 ? 0x2ec72192 : 0) ^  			  (((residue >> 10) & 1) != 0 ? 0x1046f79d : 0) ^  			  (((residue >> 11) & 1) != 0 ? 0x208d4e33 : 0) ^  			  (((residue >> 12) & 1) != 0 ? 0x130ebd6f : 0) ^  			  (((residue >> 13) & 1) != 0 ? 0x2499fade : 0) ^  			  (((residue >> 14) & 1) != 0 ? 0x1b27d4b5 : 0) ^  			  (((residue >> 15) & 1) != 0 ? 0x04be1eb4 : 0) ^  			  (((residue >> 16) & 1) != 0 ? 0x0968b861 : 0) ^  			  (((residue >> 17) & 1) != 0 ? 0x1055f0c2 : 0) ^  			  (((residue >> 18) & 1) != 0 ? 0x20ab4584 : 0) ^  			  (((residue >> 19) & 1) != 0 ? 0x1342af08 : 0) ^  			  (((residue >> 20) & 1) != 0 ? 0x24f1f318 : 0) ^  			  (((residue >> 21) & 1) != 0 ? 0x1be34739 : 0) ^  			  (((residue >> 22) & 1) != 0 ? 0x35562f7b : 0) ^  			  (((residue >> 23) & 1) != 0 ? 0x3a3c5bff : 0) ^  			  (((residue >> 24) & 1) != 0 ? 0x266c96f7 : 0) ^  			  (((residue >> 25) & 1) != 0 ? 0x25c78b65 : 0) ^  			  (((residue >> 26) & 1) != 0 ? 0x1b1f13ea : 0) ^  			  (((residue >> 27) & 1) != 0 ? 0x34baa2f4 : 0) ^  			  (((residue >> 28) & 1) != 0 ? 0x3b61c0e1 : 0) ^  			  (((residue >> 29) & 1) != 0 ? 0x265325c2 : 0));
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,syndrome,The following statement contains a magic number: return (uint)(low ^ (low << 10) ^ (low << 20) ^  			  (((residue >> 5) & 1) != 0 ? 0x31edd3c4 : 0) ^  			  (((residue >> 6) & 1) != 0 ? 0x335f86a8 : 0) ^  			  (((residue >> 7) & 1) != 0 ? 0x363b8870 : 0) ^  			  (((residue >> 8) & 1) != 0 ? 0x3e6390c9 : 0) ^  			  (((residue >> 9) & 1) != 0 ? 0x2ec72192 : 0) ^  			  (((residue >> 10) & 1) != 0 ? 0x1046f79d : 0) ^  			  (((residue >> 11) & 1) != 0 ? 0x208d4e33 : 0) ^  			  (((residue >> 12) & 1) != 0 ? 0x130ebd6f : 0) ^  			  (((residue >> 13) & 1) != 0 ? 0x2499fade : 0) ^  			  (((residue >> 14) & 1) != 0 ? 0x1b27d4b5 : 0) ^  			  (((residue >> 15) & 1) != 0 ? 0x04be1eb4 : 0) ^  			  (((residue >> 16) & 1) != 0 ? 0x0968b861 : 0) ^  			  (((residue >> 17) & 1) != 0 ? 0x1055f0c2 : 0) ^  			  (((residue >> 18) & 1) != 0 ? 0x20ab4584 : 0) ^  			  (((residue >> 19) & 1) != 0 ? 0x1342af08 : 0) ^  			  (((residue >> 20) & 1) != 0 ? 0x24f1f318 : 0) ^  			  (((residue >> 21) & 1) != 0 ? 0x1be34739 : 0) ^  			  (((residue >> 22) & 1) != 0 ? 0x35562f7b : 0) ^  			  (((residue >> 23) & 1) != 0 ? 0x3a3c5bff : 0) ^  			  (((residue >> 24) & 1) != 0 ? 0x266c96f7 : 0) ^  			  (((residue >> 25) & 1) != 0 ? 0x25c78b65 : 0) ^  			  (((residue >> 26) & 1) != 0 ? 0x1b1f13ea : 0) ^  			  (((residue >> 27) & 1) != 0 ? 0x34baa2f4 : 0) ^  			  (((residue >> 28) & 1) != 0 ? 0x3b61c0e1 : 0) ^  			  (((residue >> 29) & 1) != 0 ? 0x265325c2 : 0));
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,syndrome,The following statement contains a magic number: return (uint)(low ^ (low << 10) ^ (low << 20) ^  			  (((residue >> 5) & 1) != 0 ? 0x31edd3c4 : 0) ^  			  (((residue >> 6) & 1) != 0 ? 0x335f86a8 : 0) ^  			  (((residue >> 7) & 1) != 0 ? 0x363b8870 : 0) ^  			  (((residue >> 8) & 1) != 0 ? 0x3e6390c9 : 0) ^  			  (((residue >> 9) & 1) != 0 ? 0x2ec72192 : 0) ^  			  (((residue >> 10) & 1) != 0 ? 0x1046f79d : 0) ^  			  (((residue >> 11) & 1) != 0 ? 0x208d4e33 : 0) ^  			  (((residue >> 12) & 1) != 0 ? 0x130ebd6f : 0) ^  			  (((residue >> 13) & 1) != 0 ? 0x2499fade : 0) ^  			  (((residue >> 14) & 1) != 0 ? 0x1b27d4b5 : 0) ^  			  (((residue >> 15) & 1) != 0 ? 0x04be1eb4 : 0) ^  			  (((residue >> 16) & 1) != 0 ? 0x0968b861 : 0) ^  			  (((residue >> 17) & 1) != 0 ? 0x1055f0c2 : 0) ^  			  (((residue >> 18) & 1) != 0 ? 0x20ab4584 : 0) ^  			  (((residue >> 19) & 1) != 0 ? 0x1342af08 : 0) ^  			  (((residue >> 20) & 1) != 0 ? 0x24f1f318 : 0) ^  			  (((residue >> 21) & 1) != 0 ? 0x1be34739 : 0) ^  			  (((residue >> 22) & 1) != 0 ? 0x35562f7b : 0) ^  			  (((residue >> 23) & 1) != 0 ? 0x3a3c5bff : 0) ^  			  (((residue >> 24) & 1) != 0 ? 0x266c96f7 : 0) ^  			  (((residue >> 25) & 1) != 0 ? 0x25c78b65 : 0) ^  			  (((residue >> 26) & 1) != 0 ? 0x1b1f13ea : 0) ^  			  (((residue >> 27) & 1) != 0 ? 0x34baa2f4 : 0) ^  			  (((residue >> 28) & 1) != 0 ? 0x3b61c0e1 : 0) ^  			  (((residue >> 29) & 1) != 0 ? 0x265325c2 : 0));
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,syndrome,The following statement contains a magic number: return (uint)(low ^ (low << 10) ^ (low << 20) ^  			  (((residue >> 5) & 1) != 0 ? 0x31edd3c4 : 0) ^  			  (((residue >> 6) & 1) != 0 ? 0x335f86a8 : 0) ^  			  (((residue >> 7) & 1) != 0 ? 0x363b8870 : 0) ^  			  (((residue >> 8) & 1) != 0 ? 0x3e6390c9 : 0) ^  			  (((residue >> 9) & 1) != 0 ? 0x2ec72192 : 0) ^  			  (((residue >> 10) & 1) != 0 ? 0x1046f79d : 0) ^  			  (((residue >> 11) & 1) != 0 ? 0x208d4e33 : 0) ^  			  (((residue >> 12) & 1) != 0 ? 0x130ebd6f : 0) ^  			  (((residue >> 13) & 1) != 0 ? 0x2499fade : 0) ^  			  (((residue >> 14) & 1) != 0 ? 0x1b27d4b5 : 0) ^  			  (((residue >> 15) & 1) != 0 ? 0x04be1eb4 : 0) ^  			  (((residue >> 16) & 1) != 0 ? 0x0968b861 : 0) ^  			  (((residue >> 17) & 1) != 0 ? 0x1055f0c2 : 0) ^  			  (((residue >> 18) & 1) != 0 ? 0x20ab4584 : 0) ^  			  (((residue >> 19) & 1) != 0 ? 0x1342af08 : 0) ^  			  (((residue >> 20) & 1) != 0 ? 0x24f1f318 : 0) ^  			  (((residue >> 21) & 1) != 0 ? 0x1be34739 : 0) ^  			  (((residue >> 22) & 1) != 0 ? 0x35562f7b : 0) ^  			  (((residue >> 23) & 1) != 0 ? 0x3a3c5bff : 0) ^  			  (((residue >> 24) & 1) != 0 ? 0x266c96f7 : 0) ^  			  (((residue >> 25) & 1) != 0 ? 0x25c78b65 : 0) ^  			  (((residue >> 26) & 1) != 0 ? 0x1b1f13ea : 0) ^  			  (((residue >> 27) & 1) != 0 ? 0x34baa2f4 : 0) ^  			  (((residue >> 28) & 1) != 0 ? 0x3b61c0e1 : 0) ^  			  (((residue >> 29) & 1) != 0 ? 0x265325c2 : 0));
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,syndrome,The following statement contains a magic number: return (uint)(low ^ (low << 10) ^ (low << 20) ^  			  (((residue >> 5) & 1) != 0 ? 0x31edd3c4 : 0) ^  			  (((residue >> 6) & 1) != 0 ? 0x335f86a8 : 0) ^  			  (((residue >> 7) & 1) != 0 ? 0x363b8870 : 0) ^  			  (((residue >> 8) & 1) != 0 ? 0x3e6390c9 : 0) ^  			  (((residue >> 9) & 1) != 0 ? 0x2ec72192 : 0) ^  			  (((residue >> 10) & 1) != 0 ? 0x1046f79d : 0) ^  			  (((residue >> 11) & 1) != 0 ? 0x208d4e33 : 0) ^  			  (((residue >> 12) & 1) != 0 ? 0x130ebd6f : 0) ^  			  (((residue >> 13) & 1) != 0 ? 0x2499fade : 0) ^  			  (((residue >> 14) & 1) != 0 ? 0x1b27d4b5 : 0) ^  			  (((residue >> 15) & 1) != 0 ? 0x04be1eb4 : 0) ^  			  (((residue >> 16) & 1) != 0 ? 0x0968b861 : 0) ^  			  (((residue >> 17) & 1) != 0 ? 0x1055f0c2 : 0) ^  			  (((residue >> 18) & 1) != 0 ? 0x20ab4584 : 0) ^  			  (((residue >> 19) & 1) != 0 ? 0x1342af08 : 0) ^  			  (((residue >> 20) & 1) != 0 ? 0x24f1f318 : 0) ^  			  (((residue >> 21) & 1) != 0 ? 0x1be34739 : 0) ^  			  (((residue >> 22) & 1) != 0 ? 0x35562f7b : 0) ^  			  (((residue >> 23) & 1) != 0 ? 0x3a3c5bff : 0) ^  			  (((residue >> 24) & 1) != 0 ? 0x266c96f7 : 0) ^  			  (((residue >> 25) & 1) != 0 ? 0x25c78b65 : 0) ^  			  (((residue >> 26) & 1) != 0 ? 0x1b1f13ea : 0) ^  			  (((residue >> 27) & 1) != 0 ? 0x34baa2f4 : 0) ^  			  (((residue >> 28) & 1) != 0 ? 0x3b61c0e1 : 0) ^  			  (((residue >> 29) & 1) != 0 ? 0x265325c2 : 0));
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,syndrome,The following statement contains a magic number: return (uint)(low ^ (low << 10) ^ (low << 20) ^  			  (((residue >> 5) & 1) != 0 ? 0x31edd3c4 : 0) ^  			  (((residue >> 6) & 1) != 0 ? 0x335f86a8 : 0) ^  			  (((residue >> 7) & 1) != 0 ? 0x363b8870 : 0) ^  			  (((residue >> 8) & 1) != 0 ? 0x3e6390c9 : 0) ^  			  (((residue >> 9) & 1) != 0 ? 0x2ec72192 : 0) ^  			  (((residue >> 10) & 1) != 0 ? 0x1046f79d : 0) ^  			  (((residue >> 11) & 1) != 0 ? 0x208d4e33 : 0) ^  			  (((residue >> 12) & 1) != 0 ? 0x130ebd6f : 0) ^  			  (((residue >> 13) & 1) != 0 ? 0x2499fade : 0) ^  			  (((residue >> 14) & 1) != 0 ? 0x1b27d4b5 : 0) ^  			  (((residue >> 15) & 1) != 0 ? 0x04be1eb4 : 0) ^  			  (((residue >> 16) & 1) != 0 ? 0x0968b861 : 0) ^  			  (((residue >> 17) & 1) != 0 ? 0x1055f0c2 : 0) ^  			  (((residue >> 18) & 1) != 0 ? 0x20ab4584 : 0) ^  			  (((residue >> 19) & 1) != 0 ? 0x1342af08 : 0) ^  			  (((residue >> 20) & 1) != 0 ? 0x24f1f318 : 0) ^  			  (((residue >> 21) & 1) != 0 ? 0x1be34739 : 0) ^  			  (((residue >> 22) & 1) != 0 ? 0x35562f7b : 0) ^  			  (((residue >> 23) & 1) != 0 ? 0x3a3c5bff : 0) ^  			  (((residue >> 24) & 1) != 0 ? 0x266c96f7 : 0) ^  			  (((residue >> 25) & 1) != 0 ? 0x25c78b65 : 0) ^  			  (((residue >> 26) & 1) != 0 ? 0x1b1f13ea : 0) ^  			  (((residue >> 27) & 1) != 0 ? 0x34baa2f4 : 0) ^  			  (((residue >> 28) & 1) != 0 ? 0x3b61c0e1 : 0) ^  			  (((residue >> 29) & 1) != 0 ? 0x265325c2 : 0));
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,syndrome,The following statement contains a magic number: return (uint)(low ^ (low << 10) ^ (low << 20) ^  			  (((residue >> 5) & 1) != 0 ? 0x31edd3c4 : 0) ^  			  (((residue >> 6) & 1) != 0 ? 0x335f86a8 : 0) ^  			  (((residue >> 7) & 1) != 0 ? 0x363b8870 : 0) ^  			  (((residue >> 8) & 1) != 0 ? 0x3e6390c9 : 0) ^  			  (((residue >> 9) & 1) != 0 ? 0x2ec72192 : 0) ^  			  (((residue >> 10) & 1) != 0 ? 0x1046f79d : 0) ^  			  (((residue >> 11) & 1) != 0 ? 0x208d4e33 : 0) ^  			  (((residue >> 12) & 1) != 0 ? 0x130ebd6f : 0) ^  			  (((residue >> 13) & 1) != 0 ? 0x2499fade : 0) ^  			  (((residue >> 14) & 1) != 0 ? 0x1b27d4b5 : 0) ^  			  (((residue >> 15) & 1) != 0 ? 0x04be1eb4 : 0) ^  			  (((residue >> 16) & 1) != 0 ? 0x0968b861 : 0) ^  			  (((residue >> 17) & 1) != 0 ? 0x1055f0c2 : 0) ^  			  (((residue >> 18) & 1) != 0 ? 0x20ab4584 : 0) ^  			  (((residue >> 19) & 1) != 0 ? 0x1342af08 : 0) ^  			  (((residue >> 20) & 1) != 0 ? 0x24f1f318 : 0) ^  			  (((residue >> 21) & 1) != 0 ? 0x1be34739 : 0) ^  			  (((residue >> 22) & 1) != 0 ? 0x35562f7b : 0) ^  			  (((residue >> 23) & 1) != 0 ? 0x3a3c5bff : 0) ^  			  (((residue >> 24) & 1) != 0 ? 0x266c96f7 : 0) ^  			  (((residue >> 25) & 1) != 0 ? 0x25c78b65 : 0) ^  			  (((residue >> 26) & 1) != 0 ? 0x1b1f13ea : 0) ^  			  (((residue >> 27) & 1) != 0 ? 0x34baa2f4 : 0) ^  			  (((residue >> 28) & 1) != 0 ? 0x3b61c0e1 : 0) ^  			  (((residue >> 29) & 1) != 0 ? 0x265325c2 : 0));
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,syndrome,The following statement contains a magic number: return (uint)(low ^ (low << 10) ^ (low << 20) ^  			  (((residue >> 5) & 1) != 0 ? 0x31edd3c4 : 0) ^  			  (((residue >> 6) & 1) != 0 ? 0x335f86a8 : 0) ^  			  (((residue >> 7) & 1) != 0 ? 0x363b8870 : 0) ^  			  (((residue >> 8) & 1) != 0 ? 0x3e6390c9 : 0) ^  			  (((residue >> 9) & 1) != 0 ? 0x2ec72192 : 0) ^  			  (((residue >> 10) & 1) != 0 ? 0x1046f79d : 0) ^  			  (((residue >> 11) & 1) != 0 ? 0x208d4e33 : 0) ^  			  (((residue >> 12) & 1) != 0 ? 0x130ebd6f : 0) ^  			  (((residue >> 13) & 1) != 0 ? 0x2499fade : 0) ^  			  (((residue >> 14) & 1) != 0 ? 0x1b27d4b5 : 0) ^  			  (((residue >> 15) & 1) != 0 ? 0x04be1eb4 : 0) ^  			  (((residue >> 16) & 1) != 0 ? 0x0968b861 : 0) ^  			  (((residue >> 17) & 1) != 0 ? 0x1055f0c2 : 0) ^  			  (((residue >> 18) & 1) != 0 ? 0x20ab4584 : 0) ^  			  (((residue >> 19) & 1) != 0 ? 0x1342af08 : 0) ^  			  (((residue >> 20) & 1) != 0 ? 0x24f1f318 : 0) ^  			  (((residue >> 21) & 1) != 0 ? 0x1be34739 : 0) ^  			  (((residue >> 22) & 1) != 0 ? 0x35562f7b : 0) ^  			  (((residue >> 23) & 1) != 0 ? 0x3a3c5bff : 0) ^  			  (((residue >> 24) & 1) != 0 ? 0x266c96f7 : 0) ^  			  (((residue >> 25) & 1) != 0 ? 0x25c78b65 : 0) ^  			  (((residue >> 26) & 1) != 0 ? 0x1b1f13ea : 0) ^  			  (((residue >> 27) & 1) != 0 ? 0x34baa2f4 : 0) ^  			  (((residue >> 28) & 1) != 0 ? 0x3b61c0e1 : 0) ^  			  (((residue >> 29) & 1) != 0 ? 0x265325c2 : 0));
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,syndrome,The following statement contains a magic number: return (uint)(low ^ (low << 10) ^ (low << 20) ^  			  (((residue >> 5) & 1) != 0 ? 0x31edd3c4 : 0) ^  			  (((residue >> 6) & 1) != 0 ? 0x335f86a8 : 0) ^  			  (((residue >> 7) & 1) != 0 ? 0x363b8870 : 0) ^  			  (((residue >> 8) & 1) != 0 ? 0x3e6390c9 : 0) ^  			  (((residue >> 9) & 1) != 0 ? 0x2ec72192 : 0) ^  			  (((residue >> 10) & 1) != 0 ? 0x1046f79d : 0) ^  			  (((residue >> 11) & 1) != 0 ? 0x208d4e33 : 0) ^  			  (((residue >> 12) & 1) != 0 ? 0x130ebd6f : 0) ^  			  (((residue >> 13) & 1) != 0 ? 0x2499fade : 0) ^  			  (((residue >> 14) & 1) != 0 ? 0x1b27d4b5 : 0) ^  			  (((residue >> 15) & 1) != 0 ? 0x04be1eb4 : 0) ^  			  (((residue >> 16) & 1) != 0 ? 0x0968b861 : 0) ^  			  (((residue >> 17) & 1) != 0 ? 0x1055f0c2 : 0) ^  			  (((residue >> 18) & 1) != 0 ? 0x20ab4584 : 0) ^  			  (((residue >> 19) & 1) != 0 ? 0x1342af08 : 0) ^  			  (((residue >> 20) & 1) != 0 ? 0x24f1f318 : 0) ^  			  (((residue >> 21) & 1) != 0 ? 0x1be34739 : 0) ^  			  (((residue >> 22) & 1) != 0 ? 0x35562f7b : 0) ^  			  (((residue >> 23) & 1) != 0 ? 0x3a3c5bff : 0) ^  			  (((residue >> 24) & 1) != 0 ? 0x266c96f7 : 0) ^  			  (((residue >> 25) & 1) != 0 ? 0x25c78b65 : 0) ^  			  (((residue >> 26) & 1) != 0 ? 0x1b1f13ea : 0) ^  			  (((residue >> 27) & 1) != 0 ? 0x34baa2f4 : 0) ^  			  (((residue >> 28) & 1) != 0 ? 0x3b61c0e1 : 0) ^  			  (((residue >> 29) & 1) != 0 ? 0x265325c2 : 0));
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,syndrome,The following statement contains a magic number: return (uint)(low ^ (low << 10) ^ (low << 20) ^  			  (((residue >> 5) & 1) != 0 ? 0x31edd3c4 : 0) ^  			  (((residue >> 6) & 1) != 0 ? 0x335f86a8 : 0) ^  			  (((residue >> 7) & 1) != 0 ? 0x363b8870 : 0) ^  			  (((residue >> 8) & 1) != 0 ? 0x3e6390c9 : 0) ^  			  (((residue >> 9) & 1) != 0 ? 0x2ec72192 : 0) ^  			  (((residue >> 10) & 1) != 0 ? 0x1046f79d : 0) ^  			  (((residue >> 11) & 1) != 0 ? 0x208d4e33 : 0) ^  			  (((residue >> 12) & 1) != 0 ? 0x130ebd6f : 0) ^  			  (((residue >> 13) & 1) != 0 ? 0x2499fade : 0) ^  			  (((residue >> 14) & 1) != 0 ? 0x1b27d4b5 : 0) ^  			  (((residue >> 15) & 1) != 0 ? 0x04be1eb4 : 0) ^  			  (((residue >> 16) & 1) != 0 ? 0x0968b861 : 0) ^  			  (((residue >> 17) & 1) != 0 ? 0x1055f0c2 : 0) ^  			  (((residue >> 18) & 1) != 0 ? 0x20ab4584 : 0) ^  			  (((residue >> 19) & 1) != 0 ? 0x1342af08 : 0) ^  			  (((residue >> 20) & 1) != 0 ? 0x24f1f318 : 0) ^  			  (((residue >> 21) & 1) != 0 ? 0x1be34739 : 0) ^  			  (((residue >> 22) & 1) != 0 ? 0x35562f7b : 0) ^  			  (((residue >> 23) & 1) != 0 ? 0x3a3c5bff : 0) ^  			  (((residue >> 24) & 1) != 0 ? 0x266c96f7 : 0) ^  			  (((residue >> 25) & 1) != 0 ? 0x25c78b65 : 0) ^  			  (((residue >> 26) & 1) != 0 ? 0x1b1f13ea : 0) ^  			  (((residue >> 27) & 1) != 0 ? 0x34baa2f4 : 0) ^  			  (((residue >> 28) & 1) != 0 ? 0x3b61c0e1 : 0) ^  			  (((residue >> 29) & 1) != 0 ? 0x265325c2 : 0));
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,syndrome,The following statement contains a magic number: return (uint)(low ^ (low << 10) ^ (low << 20) ^  			  (((residue >> 5) & 1) != 0 ? 0x31edd3c4 : 0) ^  			  (((residue >> 6) & 1) != 0 ? 0x335f86a8 : 0) ^  			  (((residue >> 7) & 1) != 0 ? 0x363b8870 : 0) ^  			  (((residue >> 8) & 1) != 0 ? 0x3e6390c9 : 0) ^  			  (((residue >> 9) & 1) != 0 ? 0x2ec72192 : 0) ^  			  (((residue >> 10) & 1) != 0 ? 0x1046f79d : 0) ^  			  (((residue >> 11) & 1) != 0 ? 0x208d4e33 : 0) ^  			  (((residue >> 12) & 1) != 0 ? 0x130ebd6f : 0) ^  			  (((residue >> 13) & 1) != 0 ? 0x2499fade : 0) ^  			  (((residue >> 14) & 1) != 0 ? 0x1b27d4b5 : 0) ^  			  (((residue >> 15) & 1) != 0 ? 0x04be1eb4 : 0) ^  			  (((residue >> 16) & 1) != 0 ? 0x0968b861 : 0) ^  			  (((residue >> 17) & 1) != 0 ? 0x1055f0c2 : 0) ^  			  (((residue >> 18) & 1) != 0 ? 0x20ab4584 : 0) ^  			  (((residue >> 19) & 1) != 0 ? 0x1342af08 : 0) ^  			  (((residue >> 20) & 1) != 0 ? 0x24f1f318 : 0) ^  			  (((residue >> 21) & 1) != 0 ? 0x1be34739 : 0) ^  			  (((residue >> 22) & 1) != 0 ? 0x35562f7b : 0) ^  			  (((residue >> 23) & 1) != 0 ? 0x3a3c5bff : 0) ^  			  (((residue >> 24) & 1) != 0 ? 0x266c96f7 : 0) ^  			  (((residue >> 25) & 1) != 0 ? 0x25c78b65 : 0) ^  			  (((residue >> 26) & 1) != 0 ? 0x1b1f13ea : 0) ^  			  (((residue >> 27) & 1) != 0 ? 0x34baa2f4 : 0) ^  			  (((residue >> 28) & 1) != 0 ? 0x3b61c0e1 : 0) ^  			  (((residue >> 29) & 1) != 0 ? 0x265325c2 : 0));
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,syndrome,The following statement contains a magic number: return (uint)(low ^ (low << 10) ^ (low << 20) ^  			  (((residue >> 5) & 1) != 0 ? 0x31edd3c4 : 0) ^  			  (((residue >> 6) & 1) != 0 ? 0x335f86a8 : 0) ^  			  (((residue >> 7) & 1) != 0 ? 0x363b8870 : 0) ^  			  (((residue >> 8) & 1) != 0 ? 0x3e6390c9 : 0) ^  			  (((residue >> 9) & 1) != 0 ? 0x2ec72192 : 0) ^  			  (((residue >> 10) & 1) != 0 ? 0x1046f79d : 0) ^  			  (((residue >> 11) & 1) != 0 ? 0x208d4e33 : 0) ^  			  (((residue >> 12) & 1) != 0 ? 0x130ebd6f : 0) ^  			  (((residue >> 13) & 1) != 0 ? 0x2499fade : 0) ^  			  (((residue >> 14) & 1) != 0 ? 0x1b27d4b5 : 0) ^  			  (((residue >> 15) & 1) != 0 ? 0x04be1eb4 : 0) ^  			  (((residue >> 16) & 1) != 0 ? 0x0968b861 : 0) ^  			  (((residue >> 17) & 1) != 0 ? 0x1055f0c2 : 0) ^  			  (((residue >> 18) & 1) != 0 ? 0x20ab4584 : 0) ^  			  (((residue >> 19) & 1) != 0 ? 0x1342af08 : 0) ^  			  (((residue >> 20) & 1) != 0 ? 0x24f1f318 : 0) ^  			  (((residue >> 21) & 1) != 0 ? 0x1be34739 : 0) ^  			  (((residue >> 22) & 1) != 0 ? 0x35562f7b : 0) ^  			  (((residue >> 23) & 1) != 0 ? 0x3a3c5bff : 0) ^  			  (((residue >> 24) & 1) != 0 ? 0x266c96f7 : 0) ^  			  (((residue >> 25) & 1) != 0 ? 0x25c78b65 : 0) ^  			  (((residue >> 26) & 1) != 0 ? 0x1b1f13ea : 0) ^  			  (((residue >> 27) & 1) != 0 ? 0x34baa2f4 : 0) ^  			  (((residue >> 28) & 1) != 0 ? 0x3b61c0e1 : 0) ^  			  (((residue >> 29) & 1) != 0 ? 0x265325c2 : 0));
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,syndrome,The following statement contains a magic number: return (uint)(low ^ (low << 10) ^ (low << 20) ^  			  (((residue >> 5) & 1) != 0 ? 0x31edd3c4 : 0) ^  			  (((residue >> 6) & 1) != 0 ? 0x335f86a8 : 0) ^  			  (((residue >> 7) & 1) != 0 ? 0x363b8870 : 0) ^  			  (((residue >> 8) & 1) != 0 ? 0x3e6390c9 : 0) ^  			  (((residue >> 9) & 1) != 0 ? 0x2ec72192 : 0) ^  			  (((residue >> 10) & 1) != 0 ? 0x1046f79d : 0) ^  			  (((residue >> 11) & 1) != 0 ? 0x208d4e33 : 0) ^  			  (((residue >> 12) & 1) != 0 ? 0x130ebd6f : 0) ^  			  (((residue >> 13) & 1) != 0 ? 0x2499fade : 0) ^  			  (((residue >> 14) & 1) != 0 ? 0x1b27d4b5 : 0) ^  			  (((residue >> 15) & 1) != 0 ? 0x04be1eb4 : 0) ^  			  (((residue >> 16) & 1) != 0 ? 0x0968b861 : 0) ^  			  (((residue >> 17) & 1) != 0 ? 0x1055f0c2 : 0) ^  			  (((residue >> 18) & 1) != 0 ? 0x20ab4584 : 0) ^  			  (((residue >> 19) & 1) != 0 ? 0x1342af08 : 0) ^  			  (((residue >> 20) & 1) != 0 ? 0x24f1f318 : 0) ^  			  (((residue >> 21) & 1) != 0 ? 0x1be34739 : 0) ^  			  (((residue >> 22) & 1) != 0 ? 0x35562f7b : 0) ^  			  (((residue >> 23) & 1) != 0 ? 0x3a3c5bff : 0) ^  			  (((residue >> 24) & 1) != 0 ? 0x266c96f7 : 0) ^  			  (((residue >> 25) & 1) != 0 ? 0x25c78b65 : 0) ^  			  (((residue >> 26) & 1) != 0 ? 0x1b1f13ea : 0) ^  			  (((residue >> 27) & 1) != 0 ? 0x34baa2f4 : 0) ^  			  (((residue >> 28) & 1) != 0 ? 0x3b61c0e1 : 0) ^  			  (((residue >> 29) & 1) != 0 ? 0x265325c2 : 0));
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,syndrome,The following statement contains a magic number: return (uint)(low ^ (low << 10) ^ (low << 20) ^  			  (((residue >> 5) & 1) != 0 ? 0x31edd3c4 : 0) ^  			  (((residue >> 6) & 1) != 0 ? 0x335f86a8 : 0) ^  			  (((residue >> 7) & 1) != 0 ? 0x363b8870 : 0) ^  			  (((residue >> 8) & 1) != 0 ? 0x3e6390c9 : 0) ^  			  (((residue >> 9) & 1) != 0 ? 0x2ec72192 : 0) ^  			  (((residue >> 10) & 1) != 0 ? 0x1046f79d : 0) ^  			  (((residue >> 11) & 1) != 0 ? 0x208d4e33 : 0) ^  			  (((residue >> 12) & 1) != 0 ? 0x130ebd6f : 0) ^  			  (((residue >> 13) & 1) != 0 ? 0x2499fade : 0) ^  			  (((residue >> 14) & 1) != 0 ? 0x1b27d4b5 : 0) ^  			  (((residue >> 15) & 1) != 0 ? 0x04be1eb4 : 0) ^  			  (((residue >> 16) & 1) != 0 ? 0x0968b861 : 0) ^  			  (((residue >> 17) & 1) != 0 ? 0x1055f0c2 : 0) ^  			  (((residue >> 18) & 1) != 0 ? 0x20ab4584 : 0) ^  			  (((residue >> 19) & 1) != 0 ? 0x1342af08 : 0) ^  			  (((residue >> 20) & 1) != 0 ? 0x24f1f318 : 0) ^  			  (((residue >> 21) & 1) != 0 ? 0x1be34739 : 0) ^  			  (((residue >> 22) & 1) != 0 ? 0x35562f7b : 0) ^  			  (((residue >> 23) & 1) != 0 ? 0x3a3c5bff : 0) ^  			  (((residue >> 24) & 1) != 0 ? 0x266c96f7 : 0) ^  			  (((residue >> 25) & 1) != 0 ? 0x25c78b65 : 0) ^  			  (((residue >> 26) & 1) != 0 ? 0x1b1f13ea : 0) ^  			  (((residue >> 27) & 1) != 0 ? 0x34baa2f4 : 0) ^  			  (((residue >> 28) & 1) != 0 ? 0x3b61c0e1 : 0) ^  			  (((residue >> 29) & 1) != 0 ? 0x265325c2 : 0));
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,syndrome,The following statement contains a magic number: return (uint)(low ^ (low << 10) ^ (low << 20) ^  			  (((residue >> 5) & 1) != 0 ? 0x31edd3c4 : 0) ^  			  (((residue >> 6) & 1) != 0 ? 0x335f86a8 : 0) ^  			  (((residue >> 7) & 1) != 0 ? 0x363b8870 : 0) ^  			  (((residue >> 8) & 1) != 0 ? 0x3e6390c9 : 0) ^  			  (((residue >> 9) & 1) != 0 ? 0x2ec72192 : 0) ^  			  (((residue >> 10) & 1) != 0 ? 0x1046f79d : 0) ^  			  (((residue >> 11) & 1) != 0 ? 0x208d4e33 : 0) ^  			  (((residue >> 12) & 1) != 0 ? 0x130ebd6f : 0) ^  			  (((residue >> 13) & 1) != 0 ? 0x2499fade : 0) ^  			  (((residue >> 14) & 1) != 0 ? 0x1b27d4b5 : 0) ^  			  (((residue >> 15) & 1) != 0 ? 0x04be1eb4 : 0) ^  			  (((residue >> 16) & 1) != 0 ? 0x0968b861 : 0) ^  			  (((residue >> 17) & 1) != 0 ? 0x1055f0c2 : 0) ^  			  (((residue >> 18) & 1) != 0 ? 0x20ab4584 : 0) ^  			  (((residue >> 19) & 1) != 0 ? 0x1342af08 : 0) ^  			  (((residue >> 20) & 1) != 0 ? 0x24f1f318 : 0) ^  			  (((residue >> 21) & 1) != 0 ? 0x1be34739 : 0) ^  			  (((residue >> 22) & 1) != 0 ? 0x35562f7b : 0) ^  			  (((residue >> 23) & 1) != 0 ? 0x3a3c5bff : 0) ^  			  (((residue >> 24) & 1) != 0 ? 0x266c96f7 : 0) ^  			  (((residue >> 25) & 1) != 0 ? 0x25c78b65 : 0) ^  			  (((residue >> 26) & 1) != 0 ? 0x1b1f13ea : 0) ^  			  (((residue >> 27) & 1) != 0 ? 0x34baa2f4 : 0) ^  			  (((residue >> 28) & 1) != 0 ? 0x3b61c0e1 : 0) ^  			  (((residue >> 29) & 1) != 0 ? 0x265325c2 : 0));
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,locate_errors,The following statement contains a magic number: var s1 = (syn >> 10) & 0x3FF;
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,locate_errors,The following statement contains a magic number: var s2 = syn >> 20;
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,locate_errors,The following statement contains a magic number: var p1 = (l_s1 - l_s0 + 1023) % 1023;
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,locate_errors,The following statement contains a magic number: var p1 = (l_s1 - l_s0 + 1023) % 1023;
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,locate_errors,The following statement contains a magic number: var l_e1 = l_s0 + (1023 - 997) * p1;
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,locate_errors,The following statement contains a magic number: var l_e1 = l_s0 + (1023 - 997) * p1;
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,locate_errors,The following statement contains a magic number: (l_e1 % 33) != 0
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,locate_errors,The following statement contains a magic number: l_s0 != -1 && l_s1 != -1 && l_s2 != -1 && (2 * l_s1 - l_s2 - l_s0 + 2046) % 1023 == 0
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,locate_errors,The following statement contains a magic number: l_s0 != -1 && l_s1 != -1 && l_s2 != -1 && (2 * l_s1 - l_s2 - l_s0 + 2046) % 1023 == 0
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,locate_errors,The following statement contains a magic number: l_s0 != -1 && l_s1 != -1 && l_s2 != -1 && (2 * l_s1 - l_s2 - l_s0 + 2046) % 1023 == 0
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,locate_errors,The following statement contains a magic number: var s2_s1p1 = s2 ^ (s1 == 0 ? 0 : GF1024_EXP[(l_s1 + p1) % 1023]);
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,locate_errors,The following statement contains a magic number: var s1_s0p1 = s1 ^ (s0 == 0 ? 0 : GF1024_EXP[(l_s0 + p1) % 1023]);
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,locate_errors,The following statement contains a magic number: var p2 = (GF1024_LOG[s2_s1p1] - l_s1_s0p1 + 1023) % 1023;
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,locate_errors,The following statement contains a magic number: var p2 = (GF1024_LOG[s2_s1p1] - l_s1_s0p1 + 1023) % 1023;
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,locate_errors,The following statement contains a magic number: var s1_s0p2 = s1 ^ (s0 == 0 ? 0 : GF1024_EXP[(l_s0 + p2) % 1023]);
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,locate_errors,The following statement contains a magic number: var inv_p1_p2 = 1023 - GF1024_LOG[GF1024_EXP[p1] ^ GF1024_EXP[p2]];
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,locate_errors,The following statement contains a magic number: var l_e2 = l_s1_s0p1 + inv_p1_p2 + (1023 - 997) * p2;
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,locate_errors,The following statement contains a magic number: var l_e2 = l_s1_s0p1 + inv_p1_p2 + (1023 - 997) * p2;
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,locate_errors,The following statement contains a magic number: (l_e2 % 33) != 0
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,locate_errors,The following statement contains a magic number: var l_e1 = GF1024_LOG[s1_s0p2] + inv_p1_p2 + (1023 - 997) * p1;
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,locate_errors,The following statement contains a magic number: var l_e1 = GF1024_LOG[s1_s0p2] + inv_p1_p2 + (1023 - 997) * p1;
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,locate_errors,The following statement contains a magic number: (l_e1 % 33) != 0
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,Bech32Encoder,The following statement contains a magic number: _HrpExpand = new byte[(2 * len) + 1];
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,Bech32Encoder,The following statement contains a magic number: _HrpExpand[i] = (byte)(hrp[i] >> 5);
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,Bech32Encoder,The following statement contains a magic number: _HrpExpand[i + len + 1] = (byte)(hrp[i] & 31);
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,Polymod,The following statement contains a magic number: var top = chk >> 25;
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,Polymod,The following statement contains a magic number: chk = value ^ ((chk & 0x1ffffff) << 5);
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,Polymod,The following statement contains a magic number: Enumerable.Range(0' 5)
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,VerifyChecksum,The following statement contains a magic number: epos[ep] = bechStringLen - epos[ep] - (epos[ep] >= data.Length ? 2 : 1);
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,CreateChecksum,The following statement contains a magic number: var values = new byte[_HrpExpand.Length + count + 6];
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,CreateChecksum,The following statement contains a magic number: var ret = new byte[6];
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,CreateChecksum,The following statement contains a magic number: ret[i] = (byte)((polymod >> 5 * (5 - i)) & 31);
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,CreateChecksum,The following statement contains a magic number: ret[i] = (byte)((polymod >> 5 * (5 - i)) & 31);
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,CreateChecksum,The following statement contains a magic number: ret[i] = (byte)((polymod >> 5 * (5 - i)) & 31);
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,CreateChecksum,The following statement contains a magic number: Enumerable.Range(0' 6)
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,EncodeData,The following statement contains a magic number: var combined = new byte[_Hrp.Length + 1 + count + 6];
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,EncodeData,The following statement contains a magic number: combined[combinedOffset] = 49;
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,EncodeData,The following statement contains a magic number: Array.Copy(checkSum' 0' combined' combinedOffset' 6);
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,EncodeData,The following statement contains a magic number: combinedOffset += 6;
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,EncodeData,The following statement contains a magic number: i < count + 6
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,DecodeDataCore,The following statement contains a magic number: buffer.Any(b => b < 33 || b > 126)
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,DecodeDataCore,The following statement contains a magic number: buffer.Any(b => b < 33 || b > 126)
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,DecodeDataCore,The following statement contains a magic number: pos < 1 || pos + 7 > encoded.Length || encoded.Length > 90
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,DecodeDataCore,The following statement contains a magic number: pos < 1 || pos + 7 > encoded.Length || encoded.Length > 90
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,DecodeDataCore,The following statement contains a magic number: return data.Take(data.Length - 6).ToArray();
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,Decode,The following statement contains a magic number: var decoded = ConvertBits(data.Skip(1)' 5' 8' false);
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,Decode,The following statement contains a magic number: var decoded = ConvertBits(data.Skip(1)' 5' 8' false);
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,Decode,The following statement contains a magic number: decoded.Length < 2 || decoded.Length > 40
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,Decode,The following statement contains a magic number: decoded.Length < 2 || decoded.Length > 40
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,Decode,The following statement contains a magic number: witnessVerion > 16
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,Decode,The following statement contains a magic number: witnessVerion == 0 && decoded.Length != 20 && decoded.Length != 32
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,Decode,The following statement contains a magic number: witnessVerion == 0 && decoded.Length != 20 && decoded.Length != 32
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,Encode,The following statement contains a magic number: var data = (new[] { witnessVerion }).Concat(ConvertBits(witnessProgramm' 8' 5));
Magic Number,NBitcoin.DataEncoders,Bech32Encoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Bech32Encoder.cs,Encode,The following statement contains a magic number: var data = (new[] { witnessVerion }).Concat(ConvertBits(witnessProgramm' 8' 5));
Magic Number,NBitcoin.DataEncoders,HexEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\HexEncoder.cs,EncodeData,The following statement contains a magic number: return string.Create(2 * count + spaces' (offset' count' data)' CreateHexString);
Magic Number,NBitcoin.DataEncoders,HexEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\HexEncoder.cs,DecodeData,The following statement contains a magic number: encoded.Length % 2 == 1
Magic Number,NBitcoin.DataEncoders,HexEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\HexEncoder.cs,DecodeData,The following statement contains a magic number: var result = new byte[encoded.Length / 2];
Magic Number,NBitcoin.DataEncoders,HexEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\HexEncoder.cs,DecodeData,The following statement contains a magic number: result[j] = (byte)(((uint)a << 4) | (uint)b);
Magic Number,NBitcoin.DataEncoders,HexEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\HexEncoder.cs,HexEncoder,The following statement contains a magic number: var hexValues = new byte[] { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 14' 15'  																   10' 11' 12' 13' 14' 15};
Magic Number,NBitcoin.DataEncoders,HexEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\HexEncoder.cs,HexEncoder,The following statement contains a magic number: var hexValues = new byte[] { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 14' 15'  																   10' 11' 12' 13' 14' 15};
Magic Number,NBitcoin.DataEncoders,HexEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\HexEncoder.cs,HexEncoder,The following statement contains a magic number: var hexValues = new byte[] { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 14' 15'  																   10' 11' 12' 13' 14' 15};
Magic Number,NBitcoin.DataEncoders,HexEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\HexEncoder.cs,HexEncoder,The following statement contains a magic number: var hexValues = new byte[] { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 14' 15'  																   10' 11' 12' 13' 14' 15};
Magic Number,NBitcoin.DataEncoders,HexEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\HexEncoder.cs,HexEncoder,The following statement contains a magic number: var hexValues = new byte[] { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 14' 15'  																   10' 11' 12' 13' 14' 15};
Magic Number,NBitcoin.DataEncoders,HexEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\HexEncoder.cs,HexEncoder,The following statement contains a magic number: var hexValues = new byte[] { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 14' 15'  																   10' 11' 12' 13' 14' 15};
Magic Number,NBitcoin.DataEncoders,HexEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\HexEncoder.cs,HexEncoder,The following statement contains a magic number: var hexValues = new byte[] { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 14' 15'  																   10' 11' 12' 13' 14' 15};
Magic Number,NBitcoin.DataEncoders,HexEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\HexEncoder.cs,HexEncoder,The following statement contains a magic number: var hexValues = new byte[] { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 14' 15'  																   10' 11' 12' 13' 14' 15};
Magic Number,NBitcoin.DataEncoders,HexEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\HexEncoder.cs,HexEncoder,The following statement contains a magic number: var hexValues = new byte[] { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 14' 15'  																   10' 11' 12' 13' 14' 15};
Magic Number,NBitcoin.DataEncoders,HexEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\HexEncoder.cs,HexEncoder,The following statement contains a magic number: var hexValues = new byte[] { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 14' 15'  																   10' 11' 12' 13' 14' 15};
Magic Number,NBitcoin.DataEncoders,HexEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\HexEncoder.cs,HexEncoder,The following statement contains a magic number: var hexValues = new byte[] { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 14' 15'  																   10' 11' 12' 13' 14' 15};
Magic Number,NBitcoin.DataEncoders,HexEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\HexEncoder.cs,HexEncoder,The following statement contains a magic number: var hexValues = new byte[] { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 14' 15'  																   10' 11' 12' 13' 14' 15};
Magic Number,NBitcoin.DataEncoders,HexEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\HexEncoder.cs,HexEncoder,The following statement contains a magic number: var hexValues = new byte[] { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 14' 15'  																   10' 11' 12' 13' 14' 15};
Magic Number,NBitcoin.DataEncoders,HexEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\HexEncoder.cs,HexEncoder,The following statement contains a magic number: var hexValues = new byte[] { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 14' 15'  																   10' 11' 12' 13' 14' 15};
Magic Number,NBitcoin.DataEncoders,HexEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\HexEncoder.cs,HexEncoder,The following statement contains a magic number: var hexValues = new byte[] { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 14' 15'  																   10' 11' 12' 13' 14' 15};
Magic Number,NBitcoin.DataEncoders,HexEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\HexEncoder.cs,HexEncoder,The following statement contains a magic number: var hexValues = new byte[] { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 14' 15'  																   10' 11' 12' 13' 14' 15};
Magic Number,NBitcoin.DataEncoders,HexEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\HexEncoder.cs,HexEncoder,The following statement contains a magic number: var hexValues = new byte[] { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 14' 15'  																   10' 11' 12' 13' 14' 15};
Magic Number,NBitcoin.DataEncoders,HexEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\HexEncoder.cs,HexEncoder,The following statement contains a magic number: var hexValues = new byte[] { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 14' 15'  																   10' 11' 12' 13' 14' 15};
Magic Number,NBitcoin.DataEncoders,HexEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\HexEncoder.cs,HexEncoder,The following statement contains a magic number: var hexValues = new byte[] { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 14' 15'  																   10' 11' 12' 13' 14' 15};
Magic Number,NBitcoin.DataEncoders,HexEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\HexEncoder.cs,HexEncoder,The following statement contains a magic number: var hexValues = new byte[] { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 14' 15'  																   10' 11' 12' 13' 14' 15};
Magic Number,NBitcoin.DataEncoders,HexEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\HexEncoder.cs,IsValid,The following statement contains a magic number: return str.ToCharArray().All(c => IsDigit(c) != -1) && str.Length % 2 == 0;
Magic Number,NBitcoin.OpenAsset,AssetMoney,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\AssetMoney.cs,Pow10,The following statement contains a magic number: dec = dec * 10;
Magic Number,NBitcoin.OpenAsset,CachedColoredTransactionRepository,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\CachedColoredTransactionRepository.cs,CachedColoredTransactionRepository,The following statement contains a magic number: MaxCachedTransactions = 1000;
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,ReadLEB128,The following statement contains a magic number: (value & 128uL) == 0uL
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,ReadLEB128,The following statement contains a magic number: value &= 127uL;
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,ReadLEB128,The following statement contains a magic number: value |= (chunk & 127uL) << 7;
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,ReadLEB128,The following statement contains a magic number: value |= (chunk & 127uL) << 7;
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,ReadLEB128,The following statement contains a magic number: (chunk & 128uL) == 0uL
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,ReadLEB128,The following statement contains a magic number: value |= (chunk & 127uL) << 14;
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,ReadLEB128,The following statement contains a magic number: value |= (chunk & 127uL) << 14;
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,ReadLEB128,The following statement contains a magic number: (chunk & 128uL) == 0uL
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,ReadLEB128,The following statement contains a magic number: value |= (chunk & 127uL) << 21;
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,ReadLEB128,The following statement contains a magic number: value |= (chunk & 127uL) << 21;
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,ReadLEB128,The following statement contains a magic number: (chunk & 128uL) == 0uL
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,ReadLEB128,The following statement contains a magic number: value |= (chunk & 127uL) << 28;
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,ReadLEB128,The following statement contains a magic number: value |= (chunk & 127uL) << 28;
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,ReadLEB128,The following statement contains a magic number: (chunk & 128uL) == 0uL
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,ReadLEB128,The following statement contains a magic number: value |= (chunk & 127uL) << 35;
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,ReadLEB128,The following statement contains a magic number: value |= (chunk & 127uL) << 35;
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,ReadLEB128,The following statement contains a magic number: (chunk & 128uL) == 0uL
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,ReadLEB128,The following statement contains a magic number: value |= (chunk & 127uL) << 42;
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,ReadLEB128,The following statement contains a magic number: value |= (chunk & 127uL) << 42;
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,ReadLEB128,The following statement contains a magic number: (chunk & 128uL) == 0uL
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,ReadLEB128,The following statement contains a magic number: value |= (chunk & 127uL) << 49;
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,ReadLEB128,The following statement contains a magic number: value |= (chunk & 127uL) << 49;
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,ReadLEB128,The following statement contains a magic number: (chunk & 128uL) == 0uL
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,ReadLEB128,The following statement contains a magic number: value |= (chunk & 127uL) << 56;
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,ReadLEB128,The following statement contains a magic number: value |= (chunk & 127uL) << 56;
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,ReadLEB128,The following statement contains a magic number: (chunk & 128uL) == 0uL
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,ReadLEB128,The following statement contains a magic number: value |= chunk << 63;
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,ReadLEB128,The following statement contains a magic number: (chunk & 18446744073709551614uL) != 0uL
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,WriteLEB128,The following statement contains a magic number: byte[] bytes = new byte[10];
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,WriteLEB128,The following statement contains a magic number: bytes[ioIndex++] = (byte)((value & 127uL) | 128uL);
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,WriteLEB128,The following statement contains a magic number: bytes[ioIndex++] = (byte)((value & 127uL) | 128uL);
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,WriteLEB128,The following statement contains a magic number: bytes[bytes.Length - 1] &= 127;
Magic Number,NBitcoin.OpenAsset,ColorMarker,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\OpenAsset\ColorMarker.cs,GetMetadataUrl,The following statement contains a magic number: Uri.TryCreate(result.Substring(2)' UriKind.Absolute' out uri);
Magic Number,NBitcoin.Payment,BitcoinUrlBuilder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\BitcoinUrlBuilder.cs,BitcoinUrlBuilder,The following statement contains a magic number: uri = uri.Remove(0' 2);
Magic Number,NBitcoin.Payment,PaymentACK,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentACK.cs,Load,The following statement contains a magic number: switch (key)  				{  					case 1:  						var bytes = reader.ReadBytes();  						ack.Payment = PaymentMessage.Load(bytes' network);  						break;  					case 2:  						ack.Memo = reader.ReadString();  						break;  					default:  						break;  				}
Magic Number,NBitcoin.Payment,PaymentACK,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentACK.cs,WriteTo,The following statement contains a magic number: proto.WriteKey(2' ProtobufReaderWriter.PROTOBUF_LENDELIM);
Magic Number,NBitcoin.Payment,PaymentMessage,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentACK.cs,Load,The following statement contains a magic number: switch (key)  				{  					case 1:  						message.MerchantData = proto.ReadBytes();  						break;  					case 2:  						var tx = network.Consensus.ConsensusFactory.CreateTransaction();  						tx.ReadWrite(proto.ReadBytes()' network);  						message.Transactions.Add(tx);  						break;  					case 3:  						message.RefundTo.Add(PaymentOutput.Load(proto.ReadBytes()));  						break;  					case 4:  						message.Memo = proto.ReadString();  						break;  					default:  						break;  				}
Magic Number,NBitcoin.Payment,PaymentMessage,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentACK.cs,Load,The following statement contains a magic number: switch (key)  				{  					case 1:  						message.MerchantData = proto.ReadBytes();  						break;  					case 2:  						var tx = network.Consensus.ConsensusFactory.CreateTransaction();  						tx.ReadWrite(proto.ReadBytes()' network);  						message.Transactions.Add(tx);  						break;  					case 3:  						message.RefundTo.Add(PaymentOutput.Load(proto.ReadBytes()));  						break;  					case 4:  						message.Memo = proto.ReadString();  						break;  					default:  						break;  				}
Magic Number,NBitcoin.Payment,PaymentMessage,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentACK.cs,Load,The following statement contains a magic number: switch (key)  				{  					case 1:  						message.MerchantData = proto.ReadBytes();  						break;  					case 2:  						var tx = network.Consensus.ConsensusFactory.CreateTransaction();  						tx.ReadWrite(proto.ReadBytes()' network);  						message.Transactions.Add(tx);  						break;  					case 3:  						message.RefundTo.Add(PaymentOutput.Load(proto.ReadBytes()));  						break;  					case 4:  						message.Memo = proto.ReadString();  						break;  					default:  						break;  				}
Magic Number,NBitcoin.Payment,PaymentMessage,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentACK.cs,WriteTo,The following statement contains a magic number: proto.WriteKey(2' ProtobufReaderWriter.PROTOBUF_LENDELIM);
Magic Number,NBitcoin.Payment,PaymentMessage,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentACK.cs,WriteTo,The following statement contains a magic number: proto.WriteKey(3' ProtobufReaderWriter.PROTOBUF_LENDELIM);
Magic Number,NBitcoin.Payment,PaymentMessage,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentACK.cs,WriteTo,The following statement contains a magic number: proto.WriteKey(4' ProtobufReaderWriter.PROTOBUF_LENDELIM);
Magic Number,NBitcoin.Payment,PaymentOutput,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentRequest.cs,Load,The following statement contains a magic number: switch (key)  				{  					case 1:  						output.Amount = Money.Satoshis(reader.ReadULong());  						break;  					case 2:  						output.Script = Script.FromBytesUnsafe(reader.ReadBytes());  						break;  					default:  						break;  				}
Magic Number,NBitcoin.Payment,PaymentOutput,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentRequest.cs,Write,The following statement contains a magic number: writer.WriteKey(2' ProtobufReaderWriter.PROTOBUF_LENDELIM);
Magic Number,NBitcoin.Payment,PaymentDetails,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentRequest.cs,Load,The following statement contains a magic number: switch (key)  				{  					case 1:  						var network = reader.ReadString();  						result.Network = network.Equals("main"' StringComparison.OrdinalIgnoreCase) ? Network.Main :  										 network.Equals("test"' StringComparison.OrdinalIgnoreCase) ? Network.TestNet :  										 network.Equals("regtest"' StringComparison.OrdinalIgnoreCase) ? Network.RegTest : null;  						if (result.Network == null)  							throw new NotSupportedException("Invalid network");  						break;  					case 2:  						result.Outputs.Add(PaymentOutput.Load(reader.ReadBytes()));  						break;  					case 3:  						result.Time = Utils.UnixTimeToDateTime(reader.ReadULong());  						break;  					case 4:  						result.Expires = Utils.UnixTimeToDateTime(reader.ReadULong());  						break;  					case 5:  						result.Memo = reader.ReadString();  						break;  					case 6:  						result.PaymentUrl = new Uri(reader.ReadString());  						break;  					case 7:  						result.MerchantData = reader.ReadBytes();  						break;  					default:  						break;  				}
Magic Number,NBitcoin.Payment,PaymentDetails,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentRequest.cs,Load,The following statement contains a magic number: switch (key)  				{  					case 1:  						var network = reader.ReadString();  						result.Network = network.Equals("main"' StringComparison.OrdinalIgnoreCase) ? Network.Main :  										 network.Equals("test"' StringComparison.OrdinalIgnoreCase) ? Network.TestNet :  										 network.Equals("regtest"' StringComparison.OrdinalIgnoreCase) ? Network.RegTest : null;  						if (result.Network == null)  							throw new NotSupportedException("Invalid network");  						break;  					case 2:  						result.Outputs.Add(PaymentOutput.Load(reader.ReadBytes()));  						break;  					case 3:  						result.Time = Utils.UnixTimeToDateTime(reader.ReadULong());  						break;  					case 4:  						result.Expires = Utils.UnixTimeToDateTime(reader.ReadULong());  						break;  					case 5:  						result.Memo = reader.ReadString();  						break;  					case 6:  						result.PaymentUrl = new Uri(reader.ReadString());  						break;  					case 7:  						result.MerchantData = reader.ReadBytes();  						break;  					default:  						break;  				}
Magic Number,NBitcoin.Payment,PaymentDetails,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentRequest.cs,Load,The following statement contains a magic number: switch (key)  				{  					case 1:  						var network = reader.ReadString();  						result.Network = network.Equals("main"' StringComparison.OrdinalIgnoreCase) ? Network.Main :  										 network.Equals("test"' StringComparison.OrdinalIgnoreCase) ? Network.TestNet :  										 network.Equals("regtest"' StringComparison.OrdinalIgnoreCase) ? Network.RegTest : null;  						if (result.Network == null)  							throw new NotSupportedException("Invalid network");  						break;  					case 2:  						result.Outputs.Add(PaymentOutput.Load(reader.ReadBytes()));  						break;  					case 3:  						result.Time = Utils.UnixTimeToDateTime(reader.ReadULong());  						break;  					case 4:  						result.Expires = Utils.UnixTimeToDateTime(reader.ReadULong());  						break;  					case 5:  						result.Memo = reader.ReadString();  						break;  					case 6:  						result.PaymentUrl = new Uri(reader.ReadString());  						break;  					case 7:  						result.MerchantData = reader.ReadBytes();  						break;  					default:  						break;  				}
Magic Number,NBitcoin.Payment,PaymentDetails,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentRequest.cs,Load,The following statement contains a magic number: switch (key)  				{  					case 1:  						var network = reader.ReadString();  						result.Network = network.Equals("main"' StringComparison.OrdinalIgnoreCase) ? Network.Main :  										 network.Equals("test"' StringComparison.OrdinalIgnoreCase) ? Network.TestNet :  										 network.Equals("regtest"' StringComparison.OrdinalIgnoreCase) ? Network.RegTest : null;  						if (result.Network == null)  							throw new NotSupportedException("Invalid network");  						break;  					case 2:  						result.Outputs.Add(PaymentOutput.Load(reader.ReadBytes()));  						break;  					case 3:  						result.Time = Utils.UnixTimeToDateTime(reader.ReadULong());  						break;  					case 4:  						result.Expires = Utils.UnixTimeToDateTime(reader.ReadULong());  						break;  					case 5:  						result.Memo = reader.ReadString();  						break;  					case 6:  						result.PaymentUrl = new Uri(reader.ReadString());  						break;  					case 7:  						result.MerchantData = reader.ReadBytes();  						break;  					default:  						break;  				}
Magic Number,NBitcoin.Payment,PaymentDetails,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentRequest.cs,Load,The following statement contains a magic number: switch (key)  				{  					case 1:  						var network = reader.ReadString();  						result.Network = network.Equals("main"' StringComparison.OrdinalIgnoreCase) ? Network.Main :  										 network.Equals("test"' StringComparison.OrdinalIgnoreCase) ? Network.TestNet :  										 network.Equals("regtest"' StringComparison.OrdinalIgnoreCase) ? Network.RegTest : null;  						if (result.Network == null)  							throw new NotSupportedException("Invalid network");  						break;  					case 2:  						result.Outputs.Add(PaymentOutput.Load(reader.ReadBytes()));  						break;  					case 3:  						result.Time = Utils.UnixTimeToDateTime(reader.ReadULong());  						break;  					case 4:  						result.Expires = Utils.UnixTimeToDateTime(reader.ReadULong());  						break;  					case 5:  						result.Memo = reader.ReadString();  						break;  					case 6:  						result.PaymentUrl = new Uri(reader.ReadString());  						break;  					case 7:  						result.MerchantData = reader.ReadBytes();  						break;  					default:  						break;  				}
Magic Number,NBitcoin.Payment,PaymentDetails,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentRequest.cs,Load,The following statement contains a magic number: switch (key)  				{  					case 1:  						var network = reader.ReadString();  						result.Network = network.Equals("main"' StringComparison.OrdinalIgnoreCase) ? Network.Main :  										 network.Equals("test"' StringComparison.OrdinalIgnoreCase) ? Network.TestNet :  										 network.Equals("regtest"' StringComparison.OrdinalIgnoreCase) ? Network.RegTest : null;  						if (result.Network == null)  							throw new NotSupportedException("Invalid network");  						break;  					case 2:  						result.Outputs.Add(PaymentOutput.Load(reader.ReadBytes()));  						break;  					case 3:  						result.Time = Utils.UnixTimeToDateTime(reader.ReadULong());  						break;  					case 4:  						result.Expires = Utils.UnixTimeToDateTime(reader.ReadULong());  						break;  					case 5:  						result.Memo = reader.ReadString();  						break;  					case 6:  						result.PaymentUrl = new Uri(reader.ReadString());  						break;  					case 7:  						result.MerchantData = reader.ReadBytes();  						break;  					default:  						break;  				}
Magic Number,NBitcoin.Payment,PaymentDetails,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentRequest.cs,WriteTo,The following statement contains a magic number: writer.WriteKey(2' ProtobufReaderWriter.PROTOBUF_LENDELIM);
Magic Number,NBitcoin.Payment,PaymentDetails,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentRequest.cs,WriteTo,The following statement contains a magic number: writer.WriteKey(3' ProtobufReaderWriter.PROTOBUF_VARINT);
Magic Number,NBitcoin.Payment,PaymentDetails,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentRequest.cs,WriteTo,The following statement contains a magic number: writer.WriteKey(4' ProtobufReaderWriter.PROTOBUF_VARINT);
Magic Number,NBitcoin.Payment,PaymentDetails,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentRequest.cs,WriteTo,The following statement contains a magic number: writer.WriteKey(5' ProtobufReaderWriter.PROTOBUF_LENDELIM);
Magic Number,NBitcoin.Payment,PaymentDetails,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentRequest.cs,WriteTo,The following statement contains a magic number: writer.WriteKey(6' ProtobufReaderWriter.PROTOBUF_LENDELIM);
Magic Number,NBitcoin.Payment,PaymentDetails,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentRequest.cs,WriteTo,The following statement contains a magic number: writer.WriteKey(7' ProtobufReaderWriter.PROTOBUF_LENDELIM);
Magic Number,NBitcoin.Payment,PaymentRequest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentRequest.cs,Load,The following statement contains a magic number: switch (key)  				{  					case 1:  						req.DetailsVersion = (uint)reader.ReadULong();  						break;  					case 2:  						req.PKIType = ToPKIType(reader.ReadString());  						break;  					case 3:  						var bytes = reader.ReadBytes();  						ProtobufReaderWriter certs = new ProtobufReaderWriter(new MemoryStream(bytes));  						int k;  						while (certs.TryReadKey(out k))  						{  							if (firstCert)  							{  								req.MerchantCertificate = certs.ReadBytes();  								firstCert = false;  							}  							else  								req.AdditionalCertificates.Add(certs.ReadBytes());  						}  						break;  					case 4:  						req._PaymentDetails = PaymentDetails.Load(reader.ReadBytes());  						break;  					case 5:  						record.Activated = false;  						req.Signature = reader.ReadBytes();  						signatureLoaded = req.Signature.Length != 0;  						record.Activated = true;  						record.RecordBytes(new byte[0]);  						break;  					default:  						break;  				}
Magic Number,NBitcoin.Payment,PaymentRequest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentRequest.cs,Load,The following statement contains a magic number: switch (key)  				{  					case 1:  						req.DetailsVersion = (uint)reader.ReadULong();  						break;  					case 2:  						req.PKIType = ToPKIType(reader.ReadString());  						break;  					case 3:  						var bytes = reader.ReadBytes();  						ProtobufReaderWriter certs = new ProtobufReaderWriter(new MemoryStream(bytes));  						int k;  						while (certs.TryReadKey(out k))  						{  							if (firstCert)  							{  								req.MerchantCertificate = certs.ReadBytes();  								firstCert = false;  							}  							else  								req.AdditionalCertificates.Add(certs.ReadBytes());  						}  						break;  					case 4:  						req._PaymentDetails = PaymentDetails.Load(reader.ReadBytes());  						break;  					case 5:  						record.Activated = false;  						req.Signature = reader.ReadBytes();  						signatureLoaded = req.Signature.Length != 0;  						record.Activated = true;  						record.RecordBytes(new byte[0]);  						break;  					default:  						break;  				}
Magic Number,NBitcoin.Payment,PaymentRequest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentRequest.cs,Load,The following statement contains a magic number: switch (key)  				{  					case 1:  						req.DetailsVersion = (uint)reader.ReadULong();  						break;  					case 2:  						req.PKIType = ToPKIType(reader.ReadString());  						break;  					case 3:  						var bytes = reader.ReadBytes();  						ProtobufReaderWriter certs = new ProtobufReaderWriter(new MemoryStream(bytes));  						int k;  						while (certs.TryReadKey(out k))  						{  							if (firstCert)  							{  								req.MerchantCertificate = certs.ReadBytes();  								firstCert = false;  							}  							else  								req.AdditionalCertificates.Add(certs.ReadBytes());  						}  						break;  					case 4:  						req._PaymentDetails = PaymentDetails.Load(reader.ReadBytes());  						break;  					case 5:  						record.Activated = false;  						req.Signature = reader.ReadBytes();  						signatureLoaded = req.Signature.Length != 0;  						record.Activated = true;  						record.RecordBytes(new byte[0]);  						break;  					default:  						break;  				}
Magic Number,NBitcoin.Payment,PaymentRequest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentRequest.cs,Load,The following statement contains a magic number: switch (key)  				{  					case 1:  						req.DetailsVersion = (uint)reader.ReadULong();  						break;  					case 2:  						req.PKIType = ToPKIType(reader.ReadString());  						break;  					case 3:  						var bytes = reader.ReadBytes();  						ProtobufReaderWriter certs = new ProtobufReaderWriter(new MemoryStream(bytes));  						int k;  						while (certs.TryReadKey(out k))  						{  							if (firstCert)  							{  								req.MerchantCertificate = certs.ReadBytes();  								firstCert = false;  							}  							else  								req.AdditionalCertificates.Add(certs.ReadBytes());  						}  						break;  					case 4:  						req._PaymentDetails = PaymentDetails.Load(reader.ReadBytes());  						break;  					case 5:  						record.Activated = false;  						req.Signature = reader.ReadBytes();  						signatureLoaded = req.Signature.Length != 0;  						record.Activated = true;  						record.RecordBytes(new byte[0]);  						break;  					default:  						break;  				}
Magic Number,NBitcoin.Payment,PaymentRequest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentRequest.cs,WriteTo,The following statement contains a magic number: writer.WriteKey(2' ProtobufReaderWriter.PROTOBUF_LENDELIM);
Magic Number,NBitcoin.Payment,PaymentRequest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentRequest.cs,WriteTo,The following statement contains a magic number: writer.WriteKey(3' ProtobufReaderWriter.PROTOBUF_LENDELIM);
Magic Number,NBitcoin.Payment,PaymentRequest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentRequest.cs,WriteTo,The following statement contains a magic number: writer.WriteKey(4' ProtobufReaderWriter.PROTOBUF_LENDELIM);
Magic Number,NBitcoin.Payment,PaymentRequest,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\PaymentRequest.cs,WriteTo,The following statement contains a magic number: writer.WriteKey(5' ProtobufReaderWriter.PROTOBUF_LENDELIM);
Magic Number,NBitcoin.Payment,UriHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\UriHelper.cs,DecodeQueryParameters,The following statement contains a magic number: return uri  					.Split(new[] { '&' }' StringSplitOptions.RemoveEmptyEntries)  					.Select(kvp => kvp.Split(new[] { '=' }' StringSplitOptions.RemoveEmptyEntries))  					.ToDictionary(kvp => kvp[0]'  									kvp => kvp.Length > 2 ?  										System.Web.NBitcoin.HttpUtility.UrlDecode(string.Join("="' kvp' 1' kvp.Length - 1)) :  									(kvp.Length > 1 ? System.Web.NBitcoin.HttpUtility.UrlDecode(kvp[1]) : ""));
Magic Number,System.Web.Util,HttpEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\HttpEncoder.cs,UrlEncodeChar,The following statement contains a magic number: idx = i >> 12;
Magic Number,System.Web.Util,HttpEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\HttpEncoder.cs,UrlEncodeChar,The following statement contains a magic number: idx = (i >> 8) & 0x0F;
Magic Number,System.Web.Util,HttpEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\HttpEncoder.cs,UrlEncodeChar,The following statement contains a magic number: idx = (i >> 4) & 0x0F;
Magic Number,System.Web.Util,HttpEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\HttpEncoder.cs,UrlEncodeChar,The following statement contains a magic number: c > 255
Magic Number,System.Web.Util,HttpEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\HttpEncoder.cs,UrlEncodeChar,The following statement contains a magic number: isUnicode && c > 127
Magic Number,System.Web.Util,HttpEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\HttpEncoder.cs,UrlEncodeChar,The following statement contains a magic number: int idx = ((int)c) >> 4;
Magic Number,System.Web.NBitcoin,HttpUtility,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\HttpUtility.cs,WriteCharBytes,The following statement contains a magic number: ch > 255
Magic Number,System.Web.NBitcoin,HttpUtility,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\HttpUtility.cs,UrlDecode,The following statement contains a magic number: xchar = GetChar(s' i + 2' 4);
Magic Number,System.Web.NBitcoin,HttpUtility,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\HttpUtility.cs,UrlDecode,The following statement contains a magic number: xchar = GetChar(s' i + 2' 4);
Magic Number,System.Web.NBitcoin,HttpUtility,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\HttpUtility.cs,UrlDecode,The following statement contains a magic number: i += 5;
Magic Number,System.Web.NBitcoin,HttpUtility,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\HttpUtility.cs,UrlDecode,The following statement contains a magic number: s[i + 1] == 'u' && i + 5 < len
Magic Number,System.Web.NBitcoin,HttpUtility,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\HttpUtility.cs,UrlDecode,The following statement contains a magic number: ch == '%' && i + 2 < len && s[i + 1] != '%'
Magic Number,System.Web.NBitcoin,HttpUtility,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\HttpUtility.cs,GetInt,The following statement contains a magic number: return c - 'a' + 10;
Magic Number,System.Web.NBitcoin,HttpUtility,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\HttpUtility.cs,GetInt,The following statement contains a magic number: return c - 'A' + 10;
Magic Number,System.Web.NBitcoin,HttpUtility,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\HttpUtility.cs,GetChar,The following statement contains a magic number: c > 127
Magic Number,System.Web.NBitcoin,HttpUtility,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Payment\HttpUtility.cs,GetChar,The following statement contains a magic number: val = (val << 4) + current;
Magic Number,NBitcoin.Policy,StandardTransactionPolicy,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Policy\StandardTransactionPolicy.cs,StandardTransactionPolicy,The following statement contains a magic number: MaxTransactionSize = 100000;
Magic Number,NBitcoin.Policy,StandardTransactionPolicy,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Policy\StandardTransactionPolicy.cs,StandardTransactionPolicy,The following statement contains a magic number: MaxTxFee = new FeeRate(Money.Coins(0.1m));
Magic Number,NBitcoin.Policy,StandardTransactionPolicy,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Policy\StandardTransactionPolicy.cs,StandardTransactionPolicy,The following statement contains a magic number: MinRelayTxFee = new FeeRate(Money.Satoshis(1000)' 1000);
Magic Number,NBitcoin.Policy,StandardTransactionPolicy,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Policy\StandardTransactionPolicy.cs,StandardTransactionPolicy,The following statement contains a magic number: MinRelayTxFee = new FeeRate(Money.Satoshis(1000)' 1000);
Magic Number,NBitcoin.Protobuf,ProtobufReaderWriter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protobuf\ProtobufReaderWriter.cs,TryReadULong,The following statement contains a magic number: varInt += (ulong)(b & 0x7f) << 7 * i++;
Magic Number,NBitcoin.Protobuf,ProtobufReaderWriter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protobuf\ProtobufReaderWriter.cs,WriteULong,The following statement contains a magic number: byte[] ioBuffer = new byte[10];
Magic Number,NBitcoin.Protobuf,ProtobufReaderWriter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protobuf\ProtobufReaderWriter.cs,WriteKey,The following statement contains a magic number: ulong v = (ulong)((key << 3) | type);
Magic Number,NBitcoin.Protobuf,ProtobufReaderWriter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protobuf\ProtobufReaderWriter.cs,TryReadKey,The following statement contains a magic number: key = (int)(key >> 3);
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,LoadPeerFile,The following statement contains a magic number: data = new byte[fs.Length - 32];
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,LoadPeerFile,The following statement contains a magic number: hash = new byte[32];
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,LoadPeerFile,The following statement contains a magic number: fs.Read(hash' 0' 32);
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Clear,The following statement contains a magic number: nKey = new uint256(RandomUtils.GetBytes(32));
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,ReadWrite,The following statement contains a magic number: !stream.Serializing && nKeySize != 32
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,ReadWrite,The following statement contains a magic number: int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,ReadWrite,The following statement contains a magic number: nUBuckets ^= (1 << 30);
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Add_,The following statement contains a magic number: bool fCurrentlyOnline = (DateTimeOffset.UtcNow - addr.Time < TimeSpan.FromSeconds(24 * 60 * 60));
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Add_,The following statement contains a magic number: bool fCurrentlyOnline = (DateTimeOffset.UtcNow - addr.Time < TimeSpan.FromSeconds(24 * 60 * 60));
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Add_,The following statement contains a magic number: bool fCurrentlyOnline = (DateTimeOffset.UtcNow - addr.Time < TimeSpan.FromSeconds(24 * 60 * 60));
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Add_,The following statement contains a magic number: var nUpdateInterval = TimeSpan.FromSeconds(fCurrentlyOnline ? 60 * 60 : 24 * 60 * 60);
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Add_,The following statement contains a magic number: var nUpdateInterval = TimeSpan.FromSeconds(fCurrentlyOnline ? 60 * 60 : 24 * 60 * 60);
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Add_,The following statement contains a magic number: var nUpdateInterval = TimeSpan.FromSeconds(fCurrentlyOnline ? 60 * 60 : 24 * 60 * 60);
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Add_,The following statement contains a magic number: var nUpdateInterval = TimeSpan.FromSeconds(fCurrentlyOnline ? 60 * 60 : 24 * 60 * 60);
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Add_,The following statement contains a magic number: var nUpdateInterval = TimeSpan.FromSeconds(fCurrentlyOnline ? 60 * 60 : 24 * 60 * 60);
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Add_,The following statement contains a magic number: nFactor *= 2;
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Check_,The following statement contains a magic number: return -7;
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Check_,The following statement contains a magic number: return -2;
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Check_,The following statement contains a magic number: return -5;
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Check_,The following statement contains a magic number: return -14;
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Check_,The following statement contains a magic number: return -6;
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Check_,The following statement contains a magic number: return -8;
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Check_,The following statement contains a magic number: return -9;
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Check_,The following statement contains a magic number: return -10;
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Check_,The following statement contains a magic number: return -11;
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Check_,The following statement contains a magic number: return -17;
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Check_,The following statement contains a magic number: return -18;
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Check_,The following statement contains a magic number: return -12;
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Check_,The following statement contains a magic number: return -19;
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Check_,The following statement contains a magic number: return -13;
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Check_,The following statement contains a magic number: return -15;
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Check_,The following statement contains a magic number: return -16;
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Connected_,The following statement contains a magic number: var nUpdateInterval = TimeSpan.FromSeconds(20 * 60);
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Connected_,The following statement contains a magic number: var nUpdateInterval = TimeSpan.FromSeconds(20 * 60);
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Select_,The following statement contains a magic number: GetRandInt(1 << 30) < fChanceFactor * info.Chance * (1 << 30)
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Select_,The following statement contains a magic number: GetRandInt(1 << 30) < fChanceFactor * info.Chance * (1 << 30)
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Select_,The following statement contains a magic number: fChanceFactor *= 1.2;
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,Select_,The following statement contains a magic number: nTried > 0 && (nNew == 0 || GetRandInt(2) == 0)
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,GetAddr_,The following statement contains a magic number: int nNodes = ADDRMAN_GETADDR_MAX_PCT * vRandom.Count / 100;
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,DiscoverPeers,The following statement contains a magic number: backoff = backoff == TimeSpan.Zero ? TimeSpan.FromSeconds(1.0) : TimeSpan.FromSeconds(backoff.TotalSeconds * 2);
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,DiscoverPeers,The following statement contains a magic number: backoff = TimeSpan.FromSeconds(10.0);
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,DiscoverPeers,The following statement contains a magic number: Parallel.ForEach(peers' new ParallelOptions()  						{  							MaxDegreeOfParallelism = 5'  							CancellationToken = loopCancel'  						}' p =>  						{  							using (CancellationTokenSource timeout = new CancellationTokenSource(TimeSpan.FromSeconds(5)))  							using (var cancelConnection = CancellationTokenSource.CreateLinkedTokenSource(timeout.Token' loopCancel))  							{  								Node n = null;  								try  								{  									var param2 = parameters.Clone();  									param2.ConnectCancellation = cancelConnection.Token;  									var addrman = param2.TemplateBehaviors.Find<AddressManagerBehavior>();  									param2.TemplateBehaviors.Clear();  									param2.TemplateBehaviors.Add(addrman);  									n = Node.Connect(network' p.Endpoint' param2);  									n.VersionHandshake(cancelConnection.Token);  									n.MessageReceived += (s' a) =>  									{  										var addr = (a.Message.Payload as AddrPayload);  										if (addr != null)  										{  											Interlocked.Add(ref found' addr.Addresses.Length);  											backoff = TimeSpan.FromSeconds(0);  											if (found >= peerToFind)  												peerTableFull.Cancel();  										}  									};  									n.SendMessageAsync(new GetAddrPayload());  									loopCancel.WaitHandle.WaitOne(2000);  								}  								catch  								{  								}  								finally  								{  									if (n != null)  										n.DisconnectAsync();  								}  							}  							if (found >= peerToFind)  								peerTableFull.Cancel();  							else  								Logs.NodeServer.LogInformation("Need {neededPeerCount} more peers"' (-found + peerToFind));  						});
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,DiscoverPeers,The following statement contains a magic number: Parallel.ForEach(peers' new ParallelOptions()  						{  							MaxDegreeOfParallelism = 5'  							CancellationToken = loopCancel'  						}' p =>  						{  							using (CancellationTokenSource timeout = new CancellationTokenSource(TimeSpan.FromSeconds(5)))  							using (var cancelConnection = CancellationTokenSource.CreateLinkedTokenSource(timeout.Token' loopCancel))  							{  								Node n = null;  								try  								{  									var param2 = parameters.Clone();  									param2.ConnectCancellation = cancelConnection.Token;  									var addrman = param2.TemplateBehaviors.Find<AddressManagerBehavior>();  									param2.TemplateBehaviors.Clear();  									param2.TemplateBehaviors.Add(addrman);  									n = Node.Connect(network' p.Endpoint' param2);  									n.VersionHandshake(cancelConnection.Token);  									n.MessageReceived += (s' a) =>  									{  										var addr = (a.Message.Payload as AddrPayload);  										if (addr != null)  										{  											Interlocked.Add(ref found' addr.Addresses.Length);  											backoff = TimeSpan.FromSeconds(0);  											if (found >= peerToFind)  												peerTableFull.Cancel();  										}  									};  									n.SendMessageAsync(new GetAddrPayload());  									loopCancel.WaitHandle.WaitOne(2000);  								}  								catch  								{  								}  								finally  								{  									if (n != null)  										n.DisconnectAsync();  								}  							}  							if (found >= peerToFind)  								peerTableFull.Cancel();  							else  								Logs.NodeServer.LogInformation("Need {neededPeerCount} more peers"' (-found + peerToFind));  						});
Magic Number,NBitcoin.Protocol,AddressManager,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,DiscoverPeers,The following statement contains a magic number: Parallel.ForEach(peers' new ParallelOptions()  						{  							MaxDegreeOfParallelism = 5'  							CancellationToken = loopCancel'  						}' p =>  						{  							using (CancellationTokenSource timeout = new CancellationTokenSource(TimeSpan.FromSeconds(5)))  							using (var cancelConnection = CancellationTokenSource.CreateLinkedTokenSource(timeout.Token' loopCancel))  							{  								Node n = null;  								try  								{  									var param2 = parameters.Clone();  									param2.ConnectCancellation = cancelConnection.Token;  									var addrman = param2.TemplateBehaviors.Find<AddressManagerBehavior>();  									param2.TemplateBehaviors.Clear();  									param2.TemplateBehaviors.Add(addrman);  									n = Node.Connect(network' p.Endpoint' param2);  									n.VersionHandshake(cancelConnection.Token);  									n.MessageReceived += (s' a) =>  									{  										var addr = (a.Message.Payload as AddrPayload);  										if (addr != null)  										{  											Interlocked.Add(ref found' addr.Addresses.Length);  											backoff = TimeSpan.FromSeconds(0);  											if (found >= peerToFind)  												peerTableFull.Cancel();  										}  									};  									n.SendMessageAsync(new GetAddrPayload());  									loopCancel.WaitHandle.WaitOne(2000);  								}  								catch  								{  								}  								finally  								{  									if (n != null)  										n.DisconnectAsync();  								}  							}  							if (found >= peerToFind)  								peerTableFull.Cancel();  							else  								Logs.NodeServer.LogInformation("Need {neededPeerCount} more peers"' (-found + peerToFind));  						});
Magic Number,NBitcoin.Protocol,AddressInfo,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,_IsTerrible,The following statement contains a magic number: nLastTry != 0 && LastTry >= now - TimeSpan.FromSeconds(60)
Magic Number,NBitcoin.Protocol,AddressInfo,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,_IsTerrible,The following statement contains a magic number: Address.Time > now + TimeSpan.FromSeconds(10 * 60)
Magic Number,NBitcoin.Protocol,AddressInfo,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,_IsTerrible,The following statement contains a magic number: Address.Time > now + TimeSpan.FromSeconds(10 * 60)
Magic Number,NBitcoin.Protocol,AddressInfo,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,_IsTerrible,The following statement contains a magic number: Address.ntime == 0 || now - Address.Time > TimeSpan.FromSeconds(ADDRMAN_HORIZON_DAYS * 24 * 60 * 60)
Magic Number,NBitcoin.Protocol,AddressInfo,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,_IsTerrible,The following statement contains a magic number: Address.ntime == 0 || now - Address.Time > TimeSpan.FromSeconds(ADDRMAN_HORIZON_DAYS * 24 * 60 * 60)
Magic Number,NBitcoin.Protocol,AddressInfo,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,_IsTerrible,The following statement contains a magic number: Address.ntime == 0 || now - Address.Time > TimeSpan.FromSeconds(ADDRMAN_HORIZON_DAYS * 24 * 60 * 60)
Magic Number,NBitcoin.Protocol,AddressInfo,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,_IsTerrible,The following statement contains a magic number: now - LastSuccess > TimeSpan.FromSeconds(ADDRMAN_MIN_FAIL_DAYS * 24 * 60 * 60) && nAttempts >= AddressManager.ADDRMAN_MAX_FAILURES
Magic Number,NBitcoin.Protocol,AddressInfo,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,_IsTerrible,The following statement contains a magic number: now - LastSuccess > TimeSpan.FromSeconds(ADDRMAN_MIN_FAIL_DAYS * 24 * 60 * 60) && nAttempts >= AddressManager.ADDRMAN_MAX_FAILURES
Magic Number,NBitcoin.Protocol,AddressInfo,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,_IsTerrible,The following statement contains a magic number: now - LastSuccess > TimeSpan.FromSeconds(ADDRMAN_MIN_FAIL_DAYS * 24 * 60 * 60) && nAttempts >= AddressManager.ADDRMAN_MAX_FAILURES
Magic Number,NBitcoin.Protocol,AddressInfo,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,GetChance,The following statement contains a magic number: fChance *= 0.01;
Magic Number,NBitcoin.Protocol,AddressInfo,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,GetChance,The following statement contains a magic number: nSinceLastTry < TimeSpan.FromSeconds(60 * 10)
Magic Number,NBitcoin.Protocol,AddressInfo,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,GetChance,The following statement contains a magic number: nSinceLastTry < TimeSpan.FromSeconds(60 * 10)
Magic Number,NBitcoin.Protocol,AddressInfo,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,GetChance,The following statement contains a magic number: fChance *= Math.Pow(0.66' Math.Min(nAttempts' 8));
Magic Number,NBitcoin.Protocol,AddressInfo,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\AddressManager.cs,GetChance,The following statement contains a magic number: fChance *= Math.Pow(0.66' Math.Min(nAttempts' 8));
Magic Number,NBitcoin.Protocol,NetworkAddress,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\NetworkAddress.cs,Adjust,The following statement contains a magic number: ntime = nNow - 5 * 24 * 60 * 60;
Magic Number,NBitcoin.Protocol,NetworkAddress,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\NetworkAddress.cs,Adjust,The following statement contains a magic number: ntime = nNow - 5 * 24 * 60 * 60;
Magic Number,NBitcoin.Protocol,NetworkAddress,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\NetworkAddress.cs,Adjust,The following statement contains a magic number: ntime = nNow - 5 * 24 * 60 * 60;
Magic Number,NBitcoin.Protocol,NetworkAddress,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\NetworkAddress.cs,Adjust,The following statement contains a magic number: ntime = nNow - 5 * 24 * 60 * 60;
Magic Number,NBitcoin.Protocol,NetworkAddress,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\NetworkAddress.cs,Adjust,The following statement contains a magic number: ntime <= 100000000 || ntime > nNow + 10 * 60
Magic Number,NBitcoin.Protocol,NetworkAddress,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\NetworkAddress.cs,Adjust,The following statement contains a magic number: ntime <= 100000000 || ntime > nNow + 10 * 60
Magic Number,NBitcoin.Protocol,NetworkAddress,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\NetworkAddress.cs,Adjust,The following statement contains a magic number: ntime <= 100000000 || ntime > nNow + 10 * 60
Magic Number,NBitcoin.Protocol,NetworkAddress,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\NetworkAddress.cs,GetKey,The following statement contains a magic number: var vKey = new byte[18];
Magic Number,NBitcoin.Protocol,NetworkAddress,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\NetworkAddress.cs,GetKey,The following statement contains a magic number: Array.Copy(ip' vKey' 16);
Magic Number,NBitcoin.Protocol,NetworkAddress,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\NetworkAddress.cs,GetKey,The following statement contains a magic number: vKey[16] = (byte)(port / 0x100);
Magic Number,NBitcoin.Protocol,NetworkAddress,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\NetworkAddress.cs,GetKey,The following statement contains a magic number: vKey[17] = (byte)(port & 0x0FF);
Magic Number,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,Connect,The following statement contains a magic number: addrman.Count == 0 || DateTimeOffset.UtcNow - start > TimeSpan.FromSeconds(60)
Magic Number,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,Connect,The following statement contains a magic number: parameters.ConnectCancellation.WaitHandle.WaitOne((int)TimeSpan.FromSeconds(60).TotalMilliseconds);
Magic Number,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,Connect,The following statement contains a magic number: groupFail > 50
Magic Number,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,Connect,The following statement contains a magic number: parameters.ConnectCancellation.WaitHandle.WaitOne(1000);
Magic Number,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,Connect,The following statement contains a magic number: var timeout = new CancellationTokenSource(5000);
Magic Number,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,GetBlocks,The following statement contains a magic number: int simultaneous = 70;
Magic Number,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,GetBlocks,The following statement contains a magic number: simultaneous *= 2;
Magic Number,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,GetBlocks,The following statement contains a magic number: maxQueued < 10
Magic Number,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,GetBlocks,The following statement contains a magic number: simultaneous = Math.Max(10' simultaneous);
Magic Number,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,GetBlocks,The following statement contains a magic number: simultaneous = Math.Min(10000' simultaneous);
Magic Number,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,GetMempoolTransactions,The following statement contains a magic number: CancellationTokenSource timeout = new CancellationTokenSource(TimeSpan.FromSeconds(10.0));
Magic Number,NBitcoin.Protocol,Node,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Node.cs,GetMempoolTransactions,The following statement contains a magic number: txIds.Partition(500)
Magic Number,NBitcoin.Protocol,NodeConnectionParameters,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\NodeConnectionParameters.cs,NodeConnectionParameters,The following statement contains a magic number: this.SocketSettings.ReceiveBufferSize = 1048576;
Magic Number,NBitcoin.Protocol,NodeConnectionParameters,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\NodeConnectionParameters.cs,NodeConnectionParameters,The following statement contains a magic number: this.SocketSettings.SendBufferSize = 1048576;
Magic Number,NBitcoin.Protocol,NodeServer,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\NodeServer.cs,NodeServer,The following statement contains a magic number: MaxConnections = 125;
Magic Number,NBitcoin.Protocol,NodeServer,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\NodeServer.cs,EndAccept,The following statement contains a magic number: cancel.CancelAfter(TimeSpan.FromSeconds(10));
Magic Number,NBitcoin.Protocol,NodeServer,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\NodeServer.cs,ProcessMessageCore,The following statement contains a magic number: cancel.CancelAfter(TimeSpan.FromSeconds(10.0));
Magic Number,NBitcoin.Protocol,NodesGroup,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\NodesGroup.cs,NodesGroup,The following statement contains a magic number: MaximumNodeConnection = 8;
Magic Number,NBitcoin.Protocol,NodesGroup,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\NodesGroup.cs,StartConnecting,The following statement contains a magic number: Task.Factory.StartNew(() =>  			{  				if (Monitor.TryEnter(cs))  				{  					_Connecting = true;  					try  					{  						while (!_Disconnect.IsCancellationRequested && _ConnectedNodes.Count < MaximumNodeConnection)  						{  							Logs.NodeServer.LogInformation("Connected nodes {connectedNodeCount} / {maximumNodeCount} "' _ConnectedNodes.Count' MaximumNodeConnection);  							var parameters = _ConnectionParameters.Clone();  							parameters.TemplateBehaviors.Add(new NodesGroupBehavior(this));  							parameters.ConnectCancellation = _Disconnect.Token;  							var addrman = AddressManagerBehavior.GetAddrman(parameters);    							if (addrman == null)  							{  								addrman = _DefaultAddressManager;  								AddressManagerBehavior.SetAddrman(parameters' addrman);  							}    							Node node = null;  							try  							{  								var groupSelector = CustomGroupSelector != null ? CustomGroupSelector :  									AllowSameGroup ? WellKnownGroupSelectors.ByRandom : null;  								node = Node.Connect(_Network' parameters' _ConnectedNodes.Select(n => n.RemoteSocketEndpoint as IPEndPoint).Where(e => e != null).ToArray()' groupSelector);  								using (var timeout = CancellationTokenSource.CreateLinkedTokenSource(_Disconnect.Token))  								{  									timeout.CancelAfter(5000);  									node.VersionHandshake(_Requirements' timeout.Token);  									Logs.NodeServer.LogInformation("Node successfully connected to and handshaked");  								}  							}  							catch (OperationCanceledException ex)  							{  								if (_Disconnect.Token.IsCancellationRequested)  									break;  								Logs.NodeServer.LogError(default' ex' "Timeout for picked node");  								if (node != null)  									node.DisconnectAsync("Handshake timeout"' ex);  							}  							catch (Exception ex)  							{  								Logs.NodeServer.LogError(default' ex' "Error while connecting to node");  								if (node != null)  									node.DisconnectAsync("Error while connecting"' ex);  							}    						}  					}  					finally  					{  						Monitor.Exit(cs);  						_Connecting = false;  					}  				}  			}' TaskCreationOptions.LongRunning);
Magic Number,NBitcoin.Protocol,NodesGroup,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\NodesGroup.cs,Purge,The following statement contains a magic number: Task.Factory.StartNew(() =>  			{  				var initialNodes = _ConnectedNodes.ToDictionary(n => n);  				while (!_Disconnect.IsCancellationRequested && initialNodes.Count != 0)  				{  					var node = initialNodes.First();  					node.Value.Disconnect(reason);  					initialNodes.Remove(node.Value);  					_Disconnect.Token.WaitHandle.WaitOne(5000);  				}  			});
Magic Number,NBitcoin.Protocol,CmpctBlockPayload,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Payloads\CmpctBlockPayload.cs,ReadWriteCore,The following statement contains a magic number: shottxidsCount = Math.Min(1000UL + (ulong)shottxidsCount' (ulong)shorttxids_size);
Magic Number,NBitcoin.Protocol,CmpctBlockPayload,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Payloads\CmpctBlockPayload.cs,ReadWriteCore,The following statement contains a magic number: _ShortIds.Add(((ulong)(msb) << 32) | (ulong)(lsb));
Magic Number,NBitcoin.Protocol,CmpctBlockPayload,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Payloads\CmpctBlockPayload.cs,ReadWriteCore,The following statement contains a magic number: indicesCount = Math.Min(1000UL + (ulong)indicesCount' (ulong)txn_size);
Magic Number,NBitcoin.Protocol,GetBlockTxnPayload,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Payloads\GetBlockTxnPayload.cs,ReadWriteCore,The following statement contains a magic number: indicesCount = Math.Min(1000UL + (ulong)indicesCount' (ulong)indexes_size);
Magic Number,NBitcoin.Protocol,NotFoundPayload,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Payloads\NotFoundPayload.cs,ReadWriteCore,The following statement contains a magic number: stream.MaxArraySize = 5000;
Magic Number,NBitcoin.Protocol,VersionPayload,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Payloads\VersionPayload.cs,ReadWriteCore,The following statement contains a magic number: version >= 70001
Magic Number,NBitcoin.Protocol,VersionPayload,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Payloads\VersionPayload.cs,ReadWriteCore,The following statement contains a magic number: version >= 106
Magic Number,NBitcoin.Protocol,SocketSettings,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\SocketSettings.cs,SetSocketProperties,The following statement contains a magic number: socket.ReceiveBufferSize = Math.Min(v' 1048576);
Magic Number,NBitcoin.Protocol,SocketSettings,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\SocketSettings.cs,SetSocketProperties,The following statement contains a magic number: socket.SendBufferSize = Math.Min(v2' 1048576);
Magic Number,NBitcoin.Protocol,CompactVarInt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\VarInt.cs,ReadWrite,The following statement contains a magic number: Span<byte> tmp = stackalloc byte[(_Size * 8 + 6) / 7];
Magic Number,NBitcoin.Protocol,CompactVarInt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\VarInt.cs,ReadWrite,The following statement contains a magic number: Span<byte> tmp = stackalloc byte[(_Size * 8 + 6) / 7];
Magic Number,NBitcoin.Protocol,CompactVarInt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\VarInt.cs,ReadWrite,The following statement contains a magic number: Span<byte> tmp = stackalloc byte[(_Size * 8 + 6) / 7];
Magic Number,NBitcoin.Protocol,CompactVarInt,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\VarInt.cs,ReadWrite,The following statement contains a magic number: n = (n >> 7) - 1;
Magic Number,NBitcoin.Protocol.Behaviors,AddressManagerBehavior,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Behaviors\AddressManagerBehavior.cs,AttachedNode_MessageReceived,The following statement contains a magic number: node.SendMessageAsync(new AddrPayload(AddressManager.GetAddr().Take(1000).ToArray()));
Magic Number,NBitcoin.Protocol.Behaviors,BroadcastHubBehavior,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Behaviors\BroadcastTransactionBehavior.cs,AnnounceAll,The following statement contains a magic number: broadcasted.Value.State == BroadcastState.NotSent ||  				   (DateTime.UtcNow - broadcasted.Value.AnnouncedTime) < TimeSpan.FromMinutes(5.0)
Magic Number,NBitcoin.Protocol.Behaviors,BroadcastHubBehavior,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Behaviors\BroadcastTransactionBehavior.cs,AttachCore,The following statement contains a magic number: _Flush = new Timer(o =>  			{  				AnnounceAll();  			}' null' 0' (int)TimeSpan.FromMinutes(10).TotalMilliseconds);
Magic Number,NBitcoin.Protocol.Behaviors,ChainBehavior,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Behaviors\ChainBehavior.cs,AttachCore,The following statement contains a magic number: _Refresh = new Timer(o =>  			{  				if (AutoSync)  					TrySync();  			}' null' 0' (int)TimeSpan.FromMinutes(10).TotalMilliseconds);
Magic Number,NBitcoin.Protocol.Behaviors,ChainBehavior,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Behaviors\ChainBehavior.cs,Intercept,The following statement contains a magic number: header.HashBlock == getheaders.HashStop || headers.Headers.Count == 2000
Magic Number,NBitcoin.Protocol.Behaviors,PingPongBehavior,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Behaviors\PingPongBehavior.cs,PingPongBehavior,The following statement contains a magic number: TimeoutInterval = TimeSpan.FromMinutes(20.0);
Magic Number,NBitcoin.Protocol.Behaviors,PingPongBehavior,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Behaviors\PingPongBehavior.cs,PingPongBehavior,The following statement contains a magic number: PingInterval = TimeSpan.FromMinutes(2.0);
Magic Number,NBitcoin.Protocol.Behaviors,SlimChainBehavior,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Behaviors\SlimChainBehavior.cs,AttachCore,The following statement contains a magic number: _Refresh = new Timer(o => 			{ 				TrySync(); 			}' null' 0' (int)TimeSpan.FromMinutes(10).TotalMilliseconds);
Magic Number,NBitcoin.Protocol.Behaviors,SocksSettingsBehavior,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Protocol\Behaviors\SocksSettingsBehavior.cs,GenerateCredentials,The following statement contains a magic number: var identity = new string(Enumerable.Repeat(chars' 21) 			.Select(s => s[(int)(RandomUtils.GetUInt32() % s.Length)]).ToArray());
Magic Number,NBitcoin.RPC,RestClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RestClient.cs,GetWebResponse,The following statement contains a magic number: throw new RestApiException(Encoding.UTF8.GetString(buffer' 0' buffer.Length - 2)' exception);
Magic Number,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,GetRPCAuth,The following statement contains a magic number: var salt = Encoders.Hex.EncodeData(RandomUtils.GetBytes(16));
Magic Number,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,GetAddedNodeInfoAsync,The following statement contains a magic number: return obj.Select(entry => new AddedNodeInfo  			{  				AddedNode = Utils.ParseEndpoint((string)entry["addednode"]' 8333)'  				Connected = (bool)entry["connected"]'  				Addresses = entry["addresses"].Select(x => new NodeAddressInfo  				{  					Address = Utils.ParseEndpoint((string)x["address"]' 8333) as IPEndPoint'  					Connected = (bool)x["connected"]  				})  			}).ToArray();
Magic Number,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,GetAddedNodeInfoAsync,The following statement contains a magic number: return obj.Select(entry => new AddedNodeInfo  			{  				AddedNode = Utils.ParseEndpoint((string)entry["addednode"]' 8333)'  				Connected = (bool)entry["connected"]'  				Addresses = entry["addresses"].Select(x => new NodeAddressInfo  				{  					Address = Utils.ParseEndpoint((string)x["address"]' 8333) as IPEndPoint'  					Connected = (bool)x["connected"]  				})  			}).ToArray();
Magic Number,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,GetAddedNodeInfoAync,The following statement contains a magic number: return e.Select(entry => new AddedNodeInfo  				{  					AddedNode = Utils.ParseEndpoint((string)entry["addednode"]' 8333)'  					Connected = (bool)entry["connected"]'  					Addresses = entry["addresses"].Select(x => new NodeAddressInfo  					{  						Address = Utils.ParseEndpoint((string)x["address"]' 8333) as IPEndPoint'  						Connected = (bool)x["connected"]  					})  				}).FirstOrDefault();
Magic Number,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,GetAddedNodeInfoAync,The following statement contains a magic number: return e.Select(entry => new AddedNodeInfo  				{  					AddedNode = Utils.ParseEndpoint((string)entry["addednode"]' 8333)'  					Connected = (bool)entry["connected"]'  					Addresses = entry["addresses"].Select(x => new NodeAddressInfo  					{  						Address = Utils.ParseEndpoint((string)x["address"]' 8333) as IPEndPoint'  						Connected = (bool)x["connected"]  					})  				}).FirstOrDefault();
Magic Number,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,TestMempoolAcceptAsync,The following statement contains a magic number: rejectedReason = rejected.Substring(separatorIdx + 2);
Magic Number,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,GetRawTransactionAsync,The following statement contains a magic number: List<object> args = new List<object>(3);
Magic Number,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,FundRawTransactionOptionsToJson,The following statement contains a magic number: jOptions.Add(new JProperty("feeRate"' options.FeeRate.GetFee(1000).ToDecimal(MoneyUnit.BTC)));
Magic Number,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,ToHex,The following statement contains a magic number: return Encoders.Hex.EncodeData(tx.ToBytes(70012 - 1));
Magic Number,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,ListAddressGroupings,The following statement contains a magic number: grouping.Account = group[0].Count() > 2 ? group[0][2].ToString() : null;
Magic Number,NBitcoin.RPC,RPCClient,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCClient.cs,ListAddressGroupings,The following statement contains a magic number: grouping.Account = group[0].Count() > 2 ? group[0][2].ToString() : null;
Magic Number,NBitcoin.RPC,RPCCredentialString,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\RPCCredentialString.cs,TryParseAuth,The following statement contains a magic number: parts.Length >= 2
Magic Number,NBitcoin.Scripting,ScriptExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptExtensions.cs,ToTokens,The following statement contains a magic number: switch (op.Code) 				{ 					case OpcodeType.OP_BOOLAND: 						result.Add(ScriptToken.BoolAnd); 						break; 					case OpcodeType.OP_BOOLOR: 						result.Add(ScriptToken.BoolOr); 						break; 					case OpcodeType.OP_EQUAL: 						result.Add(ScriptToken.Equal); 						break; 					case OpcodeType.OP_EQUALVERIFY: 						result.Add(ScriptToken.EqualVerify); 						break; 					case OpcodeType.OP_CHECKSIG: 						result.Add(ScriptToken.CheckSig); 						break; 					case OpcodeType.OP_CHECKSIGVERIFY: 						result.Add(ScriptToken.CheckSigVerify); 						break; 					case OpcodeType.OP_CHECKMULTISIG: 						result.Add(ScriptToken.CheckMultiSig); 						break; 					case OpcodeType.OP_CHECKMULTISIGVERIFY: 						result.Add(ScriptToken.CheckMultiSigVerify); 						break; 					case OpcodeType.OP_CHECKSEQUENCEVERIFY: 						result.Add(ScriptToken.CheckSequenceVerify); 						break; 					case OpcodeType.OP_FROMALTSTACK: 						result.Add(ScriptToken.FromAltStack); 						break; 					case OpcodeType.OP_TOALTSTACK: 						result.Add(ScriptToken.ToAltStack); 						break; 					case OpcodeType.OP_DROP: 						result.Add(ScriptToken.Drop); 						break; 					case OpcodeType.OP_DUP: 						result.Add(ScriptToken.Dup); 						break; 					case OpcodeType.OP_IF: 						result.Add(ScriptToken.If); 						break; 					case OpcodeType.OP_IFDUP: 						result.Add(ScriptToken.IfDup); 						break; 					case OpcodeType.OP_NOTIF: 						result.Add(ScriptToken.NotIf); 						break; 					case OpcodeType.OP_ELSE: 						result.Add(ScriptToken.Else); 						break; 					case OpcodeType.OP_ENDIF: 						result.Add(ScriptToken.EndIf); 						break; 					case OpcodeType.OP_0NOTEQUAL: 						result.Add(ScriptToken.ZeroNotEqual); 						break; 					case OpcodeType.OP_SIZE: 						result.Add(ScriptToken.Size); 						break; 					case OpcodeType.OP_SWAP: 						result.Add(ScriptToken.Swap); 						break; 					case OpcodeType.OP_VERIFY: 						result.Add(ScriptToken.Verify); 						break; 					case OpcodeType.OP_HASH160: 						result.Add(ScriptToken.Hash160); 						break; 					case OpcodeType.OP_SHA256: 						result.Add(ScriptToken.Sha256); 						break; 					case OpcodeType.OP_ADD: 						result.Add(ScriptToken.Add); 						break; 					case OpcodeType.OP_0: 						result.Add(new ScriptToken.Number(0u)); 						break; 					case OpcodeType.OP_1: 						result.Add(new ScriptToken.Number(1u)); 						break; 					case OpcodeType.OP_2: 						result.Add(new ScriptToken.Number(2u)); 						break; 					case OpcodeType.OP_3: 						result.Add(new ScriptToken.Number(3u)); 						break; 					case OpcodeType.OP_4: 						result.Add(new ScriptToken.Number(4u)); 						break; 					case OpcodeType.OP_5: 						result.Add(new ScriptToken.Number(5u)); 						break; 					case OpcodeType.OP_6: 						result.Add(new ScriptToken.Number(6u)); 						break; 					case OpcodeType.OP_7: 						result.Add(new ScriptToken.Number(7u)); 						break; 					case OpcodeType.OP_8: 						result.Add(new ScriptToken.Number(8u)); 						break; 					case OpcodeType.OP_9: 						result.Add(new ScriptToken.Number(9u)); 						break; 					case OpcodeType.OP_10: 						result.Add(new ScriptToken.Number(10u)); 						break; 					case OpcodeType.OP_11: 						result.Add(new ScriptToken.Number(11u)); 						break; 					case OpcodeType.OP_12: 						result.Add(new ScriptToken.Number(12u)); 						break; 					case OpcodeType.OP_13: 						result.Add(new ScriptToken.Number(13u)); 						break; 					case OpcodeType.OP_14: 						result.Add(new ScriptToken.Number(14u)); 						break; 					case OpcodeType.OP_15: 						result.Add(new ScriptToken.Number(15u)); 						break; 					case OpcodeType.OP_16: 						result.Add(new ScriptToken.Number(16u)); 						break; 					default: 						if ((byte)0x01 <= (byte)op.Code && (byte)op.Code < (byte)0x48) 							result.Add(GetItem(op)); 						else if ((byte)0x48 <= (byte)op.Code) 							throw new ParsingException($"Miniscript does not support pushdata bigger than 33. Got {op}"); 						else 							throw new ParsingException($"Unknown Opcode to Miniscript {op.Name}"); 						break; 				}
Magic Number,NBitcoin.Scripting,ScriptExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptExtensions.cs,ToTokens,The following statement contains a magic number: switch (op.Code) 				{ 					case OpcodeType.OP_BOOLAND: 						result.Add(ScriptToken.BoolAnd); 						break; 					case OpcodeType.OP_BOOLOR: 						result.Add(ScriptToken.BoolOr); 						break; 					case OpcodeType.OP_EQUAL: 						result.Add(ScriptToken.Equal); 						break; 					case OpcodeType.OP_EQUALVERIFY: 						result.Add(ScriptToken.EqualVerify); 						break; 					case OpcodeType.OP_CHECKSIG: 						result.Add(ScriptToken.CheckSig); 						break; 					case OpcodeType.OP_CHECKSIGVERIFY: 						result.Add(ScriptToken.CheckSigVerify); 						break; 					case OpcodeType.OP_CHECKMULTISIG: 						result.Add(ScriptToken.CheckMultiSig); 						break; 					case OpcodeType.OP_CHECKMULTISIGVERIFY: 						result.Add(ScriptToken.CheckMultiSigVerify); 						break; 					case OpcodeType.OP_CHECKSEQUENCEVERIFY: 						result.Add(ScriptToken.CheckSequenceVerify); 						break; 					case OpcodeType.OP_FROMALTSTACK: 						result.Add(ScriptToken.FromAltStack); 						break; 					case OpcodeType.OP_TOALTSTACK: 						result.Add(ScriptToken.ToAltStack); 						break; 					case OpcodeType.OP_DROP: 						result.Add(ScriptToken.Drop); 						break; 					case OpcodeType.OP_DUP: 						result.Add(ScriptToken.Dup); 						break; 					case OpcodeType.OP_IF: 						result.Add(ScriptToken.If); 						break; 					case OpcodeType.OP_IFDUP: 						result.Add(ScriptToken.IfDup); 						break; 					case OpcodeType.OP_NOTIF: 						result.Add(ScriptToken.NotIf); 						break; 					case OpcodeType.OP_ELSE: 						result.Add(ScriptToken.Else); 						break; 					case OpcodeType.OP_ENDIF: 						result.Add(ScriptToken.EndIf); 						break; 					case OpcodeType.OP_0NOTEQUAL: 						result.Add(ScriptToken.ZeroNotEqual); 						break; 					case OpcodeType.OP_SIZE: 						result.Add(ScriptToken.Size); 						break; 					case OpcodeType.OP_SWAP: 						result.Add(ScriptToken.Swap); 						break; 					case OpcodeType.OP_VERIFY: 						result.Add(ScriptToken.Verify); 						break; 					case OpcodeType.OP_HASH160: 						result.Add(ScriptToken.Hash160); 						break; 					case OpcodeType.OP_SHA256: 						result.Add(ScriptToken.Sha256); 						break; 					case OpcodeType.OP_ADD: 						result.Add(ScriptToken.Add); 						break; 					case OpcodeType.OP_0: 						result.Add(new ScriptToken.Number(0u)); 						break; 					case OpcodeType.OP_1: 						result.Add(new ScriptToken.Number(1u)); 						break; 					case OpcodeType.OP_2: 						result.Add(new ScriptToken.Number(2u)); 						break; 					case OpcodeType.OP_3: 						result.Add(new ScriptToken.Number(3u)); 						break; 					case OpcodeType.OP_4: 						result.Add(new ScriptToken.Number(4u)); 						break; 					case OpcodeType.OP_5: 						result.Add(new ScriptToken.Number(5u)); 						break; 					case OpcodeType.OP_6: 						result.Add(new ScriptToken.Number(6u)); 						break; 					case OpcodeType.OP_7: 						result.Add(new ScriptToken.Number(7u)); 						break; 					case OpcodeType.OP_8: 						result.Add(new ScriptToken.Number(8u)); 						break; 					case OpcodeType.OP_9: 						result.Add(new ScriptToken.Number(9u)); 						break; 					case OpcodeType.OP_10: 						result.Add(new ScriptToken.Number(10u)); 						break; 					case OpcodeType.OP_11: 						result.Add(new ScriptToken.Number(11u)); 						break; 					case OpcodeType.OP_12: 						result.Add(new ScriptToken.Number(12u)); 						break; 					case OpcodeType.OP_13: 						result.Add(new ScriptToken.Number(13u)); 						break; 					case OpcodeType.OP_14: 						result.Add(new ScriptToken.Number(14u)); 						break; 					case OpcodeType.OP_15: 						result.Add(new ScriptToken.Number(15u)); 						break; 					case OpcodeType.OP_16: 						result.Add(new ScriptToken.Number(16u)); 						break; 					default: 						if ((byte)0x01 <= (byte)op.Code && (byte)op.Code < (byte)0x48) 							result.Add(GetItem(op)); 						else if ((byte)0x48 <= (byte)op.Code) 							throw new ParsingException($"Miniscript does not support pushdata bigger than 33. Got {op}"); 						else 							throw new ParsingException($"Unknown Opcode to Miniscript {op.Name}"); 						break; 				}
Magic Number,NBitcoin.Scripting,ScriptExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptExtensions.cs,ToTokens,The following statement contains a magic number: switch (op.Code) 				{ 					case OpcodeType.OP_BOOLAND: 						result.Add(ScriptToken.BoolAnd); 						break; 					case OpcodeType.OP_BOOLOR: 						result.Add(ScriptToken.BoolOr); 						break; 					case OpcodeType.OP_EQUAL: 						result.Add(ScriptToken.Equal); 						break; 					case OpcodeType.OP_EQUALVERIFY: 						result.Add(ScriptToken.EqualVerify); 						break; 					case OpcodeType.OP_CHECKSIG: 						result.Add(ScriptToken.CheckSig); 						break; 					case OpcodeType.OP_CHECKSIGVERIFY: 						result.Add(ScriptToken.CheckSigVerify); 						break; 					case OpcodeType.OP_CHECKMULTISIG: 						result.Add(ScriptToken.CheckMultiSig); 						break; 					case OpcodeType.OP_CHECKMULTISIGVERIFY: 						result.Add(ScriptToken.CheckMultiSigVerify); 						break; 					case OpcodeType.OP_CHECKSEQUENCEVERIFY: 						result.Add(ScriptToken.CheckSequenceVerify); 						break; 					case OpcodeType.OP_FROMALTSTACK: 						result.Add(ScriptToken.FromAltStack); 						break; 					case OpcodeType.OP_TOALTSTACK: 						result.Add(ScriptToken.ToAltStack); 						break; 					case OpcodeType.OP_DROP: 						result.Add(ScriptToken.Drop); 						break; 					case OpcodeType.OP_DUP: 						result.Add(ScriptToken.Dup); 						break; 					case OpcodeType.OP_IF: 						result.Add(ScriptToken.If); 						break; 					case OpcodeType.OP_IFDUP: 						result.Add(ScriptToken.IfDup); 						break; 					case OpcodeType.OP_NOTIF: 						result.Add(ScriptToken.NotIf); 						break; 					case OpcodeType.OP_ELSE: 						result.Add(ScriptToken.Else); 						break; 					case OpcodeType.OP_ENDIF: 						result.Add(ScriptToken.EndIf); 						break; 					case OpcodeType.OP_0NOTEQUAL: 						result.Add(ScriptToken.ZeroNotEqual); 						break; 					case OpcodeType.OP_SIZE: 						result.Add(ScriptToken.Size); 						break; 					case OpcodeType.OP_SWAP: 						result.Add(ScriptToken.Swap); 						break; 					case OpcodeType.OP_VERIFY: 						result.Add(ScriptToken.Verify); 						break; 					case OpcodeType.OP_HASH160: 						result.Add(ScriptToken.Hash160); 						break; 					case OpcodeType.OP_SHA256: 						result.Add(ScriptToken.Sha256); 						break; 					case OpcodeType.OP_ADD: 						result.Add(ScriptToken.Add); 						break; 					case OpcodeType.OP_0: 						result.Add(new ScriptToken.Number(0u)); 						break; 					case OpcodeType.OP_1: 						result.Add(new ScriptToken.Number(1u)); 						break; 					case OpcodeType.OP_2: 						result.Add(new ScriptToken.Number(2u)); 						break; 					case OpcodeType.OP_3: 						result.Add(new ScriptToken.Number(3u)); 						break; 					case OpcodeType.OP_4: 						result.Add(new ScriptToken.Number(4u)); 						break; 					case OpcodeType.OP_5: 						result.Add(new ScriptToken.Number(5u)); 						break; 					case OpcodeType.OP_6: 						result.Add(new ScriptToken.Number(6u)); 						break; 					case OpcodeType.OP_7: 						result.Add(new ScriptToken.Number(7u)); 						break; 					case OpcodeType.OP_8: 						result.Add(new ScriptToken.Number(8u)); 						break; 					case OpcodeType.OP_9: 						result.Add(new ScriptToken.Number(9u)); 						break; 					case OpcodeType.OP_10: 						result.Add(new ScriptToken.Number(10u)); 						break; 					case OpcodeType.OP_11: 						result.Add(new ScriptToken.Number(11u)); 						break; 					case OpcodeType.OP_12: 						result.Add(new ScriptToken.Number(12u)); 						break; 					case OpcodeType.OP_13: 						result.Add(new ScriptToken.Number(13u)); 						break; 					case OpcodeType.OP_14: 						result.Add(new ScriptToken.Number(14u)); 						break; 					case OpcodeType.OP_15: 						result.Add(new ScriptToken.Number(15u)); 						break; 					case OpcodeType.OP_16: 						result.Add(new ScriptToken.Number(16u)); 						break; 					default: 						if ((byte)0x01 <= (byte)op.Code && (byte)op.Code < (byte)0x48) 							result.Add(GetItem(op)); 						else if ((byte)0x48 <= (byte)op.Code) 							throw new ParsingException($"Miniscript does not support pushdata bigger than 33. Got {op}"); 						else 							throw new ParsingException($"Unknown Opcode to Miniscript {op.Name}"); 						break; 				}
Magic Number,NBitcoin.Scripting,ScriptExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptExtensions.cs,ToTokens,The following statement contains a magic number: switch (op.Code) 				{ 					case OpcodeType.OP_BOOLAND: 						result.Add(ScriptToken.BoolAnd); 						break; 					case OpcodeType.OP_BOOLOR: 						result.Add(ScriptToken.BoolOr); 						break; 					case OpcodeType.OP_EQUAL: 						result.Add(ScriptToken.Equal); 						break; 					case OpcodeType.OP_EQUALVERIFY: 						result.Add(ScriptToken.EqualVerify); 						break; 					case OpcodeType.OP_CHECKSIG: 						result.Add(ScriptToken.CheckSig); 						break; 					case OpcodeType.OP_CHECKSIGVERIFY: 						result.Add(ScriptToken.CheckSigVerify); 						break; 					case OpcodeType.OP_CHECKMULTISIG: 						result.Add(ScriptToken.CheckMultiSig); 						break; 					case OpcodeType.OP_CHECKMULTISIGVERIFY: 						result.Add(ScriptToken.CheckMultiSigVerify); 						break; 					case OpcodeType.OP_CHECKSEQUENCEVERIFY: 						result.Add(ScriptToken.CheckSequenceVerify); 						break; 					case OpcodeType.OP_FROMALTSTACK: 						result.Add(ScriptToken.FromAltStack); 						break; 					case OpcodeType.OP_TOALTSTACK: 						result.Add(ScriptToken.ToAltStack); 						break; 					case OpcodeType.OP_DROP: 						result.Add(ScriptToken.Drop); 						break; 					case OpcodeType.OP_DUP: 						result.Add(ScriptToken.Dup); 						break; 					case OpcodeType.OP_IF: 						result.Add(ScriptToken.If); 						break; 					case OpcodeType.OP_IFDUP: 						result.Add(ScriptToken.IfDup); 						break; 					case OpcodeType.OP_NOTIF: 						result.Add(ScriptToken.NotIf); 						break; 					case OpcodeType.OP_ELSE: 						result.Add(ScriptToken.Else); 						break; 					case OpcodeType.OP_ENDIF: 						result.Add(ScriptToken.EndIf); 						break; 					case OpcodeType.OP_0NOTEQUAL: 						result.Add(ScriptToken.ZeroNotEqual); 						break; 					case OpcodeType.OP_SIZE: 						result.Add(ScriptToken.Size); 						break; 					case OpcodeType.OP_SWAP: 						result.Add(ScriptToken.Swap); 						break; 					case OpcodeType.OP_VERIFY: 						result.Add(ScriptToken.Verify); 						break; 					case OpcodeType.OP_HASH160: 						result.Add(ScriptToken.Hash160); 						break; 					case OpcodeType.OP_SHA256: 						result.Add(ScriptToken.Sha256); 						break; 					case OpcodeType.OP_ADD: 						result.Add(ScriptToken.Add); 						break; 					case OpcodeType.OP_0: 						result.Add(new ScriptToken.Number(0u)); 						break; 					case OpcodeType.OP_1: 						result.Add(new ScriptToken.Number(1u)); 						break; 					case OpcodeType.OP_2: 						result.Add(new ScriptToken.Number(2u)); 						break; 					case OpcodeType.OP_3: 						result.Add(new ScriptToken.Number(3u)); 						break; 					case OpcodeType.OP_4: 						result.Add(new ScriptToken.Number(4u)); 						break; 					case OpcodeType.OP_5: 						result.Add(new ScriptToken.Number(5u)); 						break; 					case OpcodeType.OP_6: 						result.Add(new ScriptToken.Number(6u)); 						break; 					case OpcodeType.OP_7: 						result.Add(new ScriptToken.Number(7u)); 						break; 					case OpcodeType.OP_8: 						result.Add(new ScriptToken.Number(8u)); 						break; 					case OpcodeType.OP_9: 						result.Add(new ScriptToken.Number(9u)); 						break; 					case OpcodeType.OP_10: 						result.Add(new ScriptToken.Number(10u)); 						break; 					case OpcodeType.OP_11: 						result.Add(new ScriptToken.Number(11u)); 						break; 					case OpcodeType.OP_12: 						result.Add(new ScriptToken.Number(12u)); 						break; 					case OpcodeType.OP_13: 						result.Add(new ScriptToken.Number(13u)); 						break; 					case OpcodeType.OP_14: 						result.Add(new ScriptToken.Number(14u)); 						break; 					case OpcodeType.OP_15: 						result.Add(new ScriptToken.Number(15u)); 						break; 					case OpcodeType.OP_16: 						result.Add(new ScriptToken.Number(16u)); 						break; 					default: 						if ((byte)0x01 <= (byte)op.Code && (byte)op.Code < (byte)0x48) 							result.Add(GetItem(op)); 						else if ((byte)0x48 <= (byte)op.Code) 							throw new ParsingException($"Miniscript does not support pushdata bigger than 33. Got {op}"); 						else 							throw new ParsingException($"Unknown Opcode to Miniscript {op.Name}"); 						break; 				}
Magic Number,NBitcoin.Scripting,ScriptExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptExtensions.cs,ToTokens,The following statement contains a magic number: switch (op.Code) 				{ 					case OpcodeType.OP_BOOLAND: 						result.Add(ScriptToken.BoolAnd); 						break; 					case OpcodeType.OP_BOOLOR: 						result.Add(ScriptToken.BoolOr); 						break; 					case OpcodeType.OP_EQUAL: 						result.Add(ScriptToken.Equal); 						break; 					case OpcodeType.OP_EQUALVERIFY: 						result.Add(ScriptToken.EqualVerify); 						break; 					case OpcodeType.OP_CHECKSIG: 						result.Add(ScriptToken.CheckSig); 						break; 					case OpcodeType.OP_CHECKSIGVERIFY: 						result.Add(ScriptToken.CheckSigVerify); 						break; 					case OpcodeType.OP_CHECKMULTISIG: 						result.Add(ScriptToken.CheckMultiSig); 						break; 					case OpcodeType.OP_CHECKMULTISIGVERIFY: 						result.Add(ScriptToken.CheckMultiSigVerify); 						break; 					case OpcodeType.OP_CHECKSEQUENCEVERIFY: 						result.Add(ScriptToken.CheckSequenceVerify); 						break; 					case OpcodeType.OP_FROMALTSTACK: 						result.Add(ScriptToken.FromAltStack); 						break; 					case OpcodeType.OP_TOALTSTACK: 						result.Add(ScriptToken.ToAltStack); 						break; 					case OpcodeType.OP_DROP: 						result.Add(ScriptToken.Drop); 						break; 					case OpcodeType.OP_DUP: 						result.Add(ScriptToken.Dup); 						break; 					case OpcodeType.OP_IF: 						result.Add(ScriptToken.If); 						break; 					case OpcodeType.OP_IFDUP: 						result.Add(ScriptToken.IfDup); 						break; 					case OpcodeType.OP_NOTIF: 						result.Add(ScriptToken.NotIf); 						break; 					case OpcodeType.OP_ELSE: 						result.Add(ScriptToken.Else); 						break; 					case OpcodeType.OP_ENDIF: 						result.Add(ScriptToken.EndIf); 						break; 					case OpcodeType.OP_0NOTEQUAL: 						result.Add(ScriptToken.ZeroNotEqual); 						break; 					case OpcodeType.OP_SIZE: 						result.Add(ScriptToken.Size); 						break; 					case OpcodeType.OP_SWAP: 						result.Add(ScriptToken.Swap); 						break; 					case OpcodeType.OP_VERIFY: 						result.Add(ScriptToken.Verify); 						break; 					case OpcodeType.OP_HASH160: 						result.Add(ScriptToken.Hash160); 						break; 					case OpcodeType.OP_SHA256: 						result.Add(ScriptToken.Sha256); 						break; 					case OpcodeType.OP_ADD: 						result.Add(ScriptToken.Add); 						break; 					case OpcodeType.OP_0: 						result.Add(new ScriptToken.Number(0u)); 						break; 					case OpcodeType.OP_1: 						result.Add(new ScriptToken.Number(1u)); 						break; 					case OpcodeType.OP_2: 						result.Add(new ScriptToken.Number(2u)); 						break; 					case OpcodeType.OP_3: 						result.Add(new ScriptToken.Number(3u)); 						break; 					case OpcodeType.OP_4: 						result.Add(new ScriptToken.Number(4u)); 						break; 					case OpcodeType.OP_5: 						result.Add(new ScriptToken.Number(5u)); 						break; 					case OpcodeType.OP_6: 						result.Add(new ScriptToken.Number(6u)); 						break; 					case OpcodeType.OP_7: 						result.Add(new ScriptToken.Number(7u)); 						break; 					case OpcodeType.OP_8: 						result.Add(new ScriptToken.Number(8u)); 						break; 					case OpcodeType.OP_9: 						result.Add(new ScriptToken.Number(9u)); 						break; 					case OpcodeType.OP_10: 						result.Add(new ScriptToken.Number(10u)); 						break; 					case OpcodeType.OP_11: 						result.Add(new ScriptToken.Number(11u)); 						break; 					case OpcodeType.OP_12: 						result.Add(new ScriptToken.Number(12u)); 						break; 					case OpcodeType.OP_13: 						result.Add(new ScriptToken.Number(13u)); 						break; 					case OpcodeType.OP_14: 						result.Add(new ScriptToken.Number(14u)); 						break; 					case OpcodeType.OP_15: 						result.Add(new ScriptToken.Number(15u)); 						break; 					case OpcodeType.OP_16: 						result.Add(new ScriptToken.Number(16u)); 						break; 					default: 						if ((byte)0x01 <= (byte)op.Code && (byte)op.Code < (byte)0x48) 							result.Add(GetItem(op)); 						else if ((byte)0x48 <= (byte)op.Code) 							throw new ParsingException($"Miniscript does not support pushdata bigger than 33. Got {op}"); 						else 							throw new ParsingException($"Unknown Opcode to Miniscript {op.Name}"); 						break; 				}
Magic Number,NBitcoin.Scripting,ScriptExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptExtensions.cs,ToTokens,The following statement contains a magic number: switch (op.Code) 				{ 					case OpcodeType.OP_BOOLAND: 						result.Add(ScriptToken.BoolAnd); 						break; 					case OpcodeType.OP_BOOLOR: 						result.Add(ScriptToken.BoolOr); 						break; 					case OpcodeType.OP_EQUAL: 						result.Add(ScriptToken.Equal); 						break; 					case OpcodeType.OP_EQUALVERIFY: 						result.Add(ScriptToken.EqualVerify); 						break; 					case OpcodeType.OP_CHECKSIG: 						result.Add(ScriptToken.CheckSig); 						break; 					case OpcodeType.OP_CHECKSIGVERIFY: 						result.Add(ScriptToken.CheckSigVerify); 						break; 					case OpcodeType.OP_CHECKMULTISIG: 						result.Add(ScriptToken.CheckMultiSig); 						break; 					case OpcodeType.OP_CHECKMULTISIGVERIFY: 						result.Add(ScriptToken.CheckMultiSigVerify); 						break; 					case OpcodeType.OP_CHECKSEQUENCEVERIFY: 						result.Add(ScriptToken.CheckSequenceVerify); 						break; 					case OpcodeType.OP_FROMALTSTACK: 						result.Add(ScriptToken.FromAltStack); 						break; 					case OpcodeType.OP_TOALTSTACK: 						result.Add(ScriptToken.ToAltStack); 						break; 					case OpcodeType.OP_DROP: 						result.Add(ScriptToken.Drop); 						break; 					case OpcodeType.OP_DUP: 						result.Add(ScriptToken.Dup); 						break; 					case OpcodeType.OP_IF: 						result.Add(ScriptToken.If); 						break; 					case OpcodeType.OP_IFDUP: 						result.Add(ScriptToken.IfDup); 						break; 					case OpcodeType.OP_NOTIF: 						result.Add(ScriptToken.NotIf); 						break; 					case OpcodeType.OP_ELSE: 						result.Add(ScriptToken.Else); 						break; 					case OpcodeType.OP_ENDIF: 						result.Add(ScriptToken.EndIf); 						break; 					case OpcodeType.OP_0NOTEQUAL: 						result.Add(ScriptToken.ZeroNotEqual); 						break; 					case OpcodeType.OP_SIZE: 						result.Add(ScriptToken.Size); 						break; 					case OpcodeType.OP_SWAP: 						result.Add(ScriptToken.Swap); 						break; 					case OpcodeType.OP_VERIFY: 						result.Add(ScriptToken.Verify); 						break; 					case OpcodeType.OP_HASH160: 						result.Add(ScriptToken.Hash160); 						break; 					case OpcodeType.OP_SHA256: 						result.Add(ScriptToken.Sha256); 						break; 					case OpcodeType.OP_ADD: 						result.Add(ScriptToken.Add); 						break; 					case OpcodeType.OP_0: 						result.Add(new ScriptToken.Number(0u)); 						break; 					case OpcodeType.OP_1: 						result.Add(new ScriptToken.Number(1u)); 						break; 					case OpcodeType.OP_2: 						result.Add(new ScriptToken.Number(2u)); 						break; 					case OpcodeType.OP_3: 						result.Add(new ScriptToken.Number(3u)); 						break; 					case OpcodeType.OP_4: 						result.Add(new ScriptToken.Number(4u)); 						break; 					case OpcodeType.OP_5: 						result.Add(new ScriptToken.Number(5u)); 						break; 					case OpcodeType.OP_6: 						result.Add(new ScriptToken.Number(6u)); 						break; 					case OpcodeType.OP_7: 						result.Add(new ScriptToken.Number(7u)); 						break; 					case OpcodeType.OP_8: 						result.Add(new ScriptToken.Number(8u)); 						break; 					case OpcodeType.OP_9: 						result.Add(new ScriptToken.Number(9u)); 						break; 					case OpcodeType.OP_10: 						result.Add(new ScriptToken.Number(10u)); 						break; 					case OpcodeType.OP_11: 						result.Add(new ScriptToken.Number(11u)); 						break; 					case OpcodeType.OP_12: 						result.Add(new ScriptToken.Number(12u)); 						break; 					case OpcodeType.OP_13: 						result.Add(new ScriptToken.Number(13u)); 						break; 					case OpcodeType.OP_14: 						result.Add(new ScriptToken.Number(14u)); 						break; 					case OpcodeType.OP_15: 						result.Add(new ScriptToken.Number(15u)); 						break; 					case OpcodeType.OP_16: 						result.Add(new ScriptToken.Number(16u)); 						break; 					default: 						if ((byte)0x01 <= (byte)op.Code && (byte)op.Code < (byte)0x48) 							result.Add(GetItem(op)); 						else if ((byte)0x48 <= (byte)op.Code) 							throw new ParsingException($"Miniscript does not support pushdata bigger than 33. Got {op}"); 						else 							throw new ParsingException($"Unknown Opcode to Miniscript {op.Name}"); 						break; 				}
Magic Number,NBitcoin.Scripting,ScriptExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptExtensions.cs,ToTokens,The following statement contains a magic number: switch (op.Code) 				{ 					case OpcodeType.OP_BOOLAND: 						result.Add(ScriptToken.BoolAnd); 						break; 					case OpcodeType.OP_BOOLOR: 						result.Add(ScriptToken.BoolOr); 						break; 					case OpcodeType.OP_EQUAL: 						result.Add(ScriptToken.Equal); 						break; 					case OpcodeType.OP_EQUALVERIFY: 						result.Add(ScriptToken.EqualVerify); 						break; 					case OpcodeType.OP_CHECKSIG: 						result.Add(ScriptToken.CheckSig); 						break; 					case OpcodeType.OP_CHECKSIGVERIFY: 						result.Add(ScriptToken.CheckSigVerify); 						break; 					case OpcodeType.OP_CHECKMULTISIG: 						result.Add(ScriptToken.CheckMultiSig); 						break; 					case OpcodeType.OP_CHECKMULTISIGVERIFY: 						result.Add(ScriptToken.CheckMultiSigVerify); 						break; 					case OpcodeType.OP_CHECKSEQUENCEVERIFY: 						result.Add(ScriptToken.CheckSequenceVerify); 						break; 					case OpcodeType.OP_FROMALTSTACK: 						result.Add(ScriptToken.FromAltStack); 						break; 					case OpcodeType.OP_TOALTSTACK: 						result.Add(ScriptToken.ToAltStack); 						break; 					case OpcodeType.OP_DROP: 						result.Add(ScriptToken.Drop); 						break; 					case OpcodeType.OP_DUP: 						result.Add(ScriptToken.Dup); 						break; 					case OpcodeType.OP_IF: 						result.Add(ScriptToken.If); 						break; 					case OpcodeType.OP_IFDUP: 						result.Add(ScriptToken.IfDup); 						break; 					case OpcodeType.OP_NOTIF: 						result.Add(ScriptToken.NotIf); 						break; 					case OpcodeType.OP_ELSE: 						result.Add(ScriptToken.Else); 						break; 					case OpcodeType.OP_ENDIF: 						result.Add(ScriptToken.EndIf); 						break; 					case OpcodeType.OP_0NOTEQUAL: 						result.Add(ScriptToken.ZeroNotEqual); 						break; 					case OpcodeType.OP_SIZE: 						result.Add(ScriptToken.Size); 						break; 					case OpcodeType.OP_SWAP: 						result.Add(ScriptToken.Swap); 						break; 					case OpcodeType.OP_VERIFY: 						result.Add(ScriptToken.Verify); 						break; 					case OpcodeType.OP_HASH160: 						result.Add(ScriptToken.Hash160); 						break; 					case OpcodeType.OP_SHA256: 						result.Add(ScriptToken.Sha256); 						break; 					case OpcodeType.OP_ADD: 						result.Add(ScriptToken.Add); 						break; 					case OpcodeType.OP_0: 						result.Add(new ScriptToken.Number(0u)); 						break; 					case OpcodeType.OP_1: 						result.Add(new ScriptToken.Number(1u)); 						break; 					case OpcodeType.OP_2: 						result.Add(new ScriptToken.Number(2u)); 						break; 					case OpcodeType.OP_3: 						result.Add(new ScriptToken.Number(3u)); 						break; 					case OpcodeType.OP_4: 						result.Add(new ScriptToken.Number(4u)); 						break; 					case OpcodeType.OP_5: 						result.Add(new ScriptToken.Number(5u)); 						break; 					case OpcodeType.OP_6: 						result.Add(new ScriptToken.Number(6u)); 						break; 					case OpcodeType.OP_7: 						result.Add(new ScriptToken.Number(7u)); 						break; 					case OpcodeType.OP_8: 						result.Add(new ScriptToken.Number(8u)); 						break; 					case OpcodeType.OP_9: 						result.Add(new ScriptToken.Number(9u)); 						break; 					case OpcodeType.OP_10: 						result.Add(new ScriptToken.Number(10u)); 						break; 					case OpcodeType.OP_11: 						result.Add(new ScriptToken.Number(11u)); 						break; 					case OpcodeType.OP_12: 						result.Add(new ScriptToken.Number(12u)); 						break; 					case OpcodeType.OP_13: 						result.Add(new ScriptToken.Number(13u)); 						break; 					case OpcodeType.OP_14: 						result.Add(new ScriptToken.Number(14u)); 						break; 					case OpcodeType.OP_15: 						result.Add(new ScriptToken.Number(15u)); 						break; 					case OpcodeType.OP_16: 						result.Add(new ScriptToken.Number(16u)); 						break; 					default: 						if ((byte)0x01 <= (byte)op.Code && (byte)op.Code < (byte)0x48) 							result.Add(GetItem(op)); 						else if ((byte)0x48 <= (byte)op.Code) 							throw new ParsingException($"Miniscript does not support pushdata bigger than 33. Got {op}"); 						else 							throw new ParsingException($"Unknown Opcode to Miniscript {op.Name}"); 						break; 				}
Magic Number,NBitcoin.Scripting,ScriptExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptExtensions.cs,ToTokens,The following statement contains a magic number: switch (op.Code) 				{ 					case OpcodeType.OP_BOOLAND: 						result.Add(ScriptToken.BoolAnd); 						break; 					case OpcodeType.OP_BOOLOR: 						result.Add(ScriptToken.BoolOr); 						break; 					case OpcodeType.OP_EQUAL: 						result.Add(ScriptToken.Equal); 						break; 					case OpcodeType.OP_EQUALVERIFY: 						result.Add(ScriptToken.EqualVerify); 						break; 					case OpcodeType.OP_CHECKSIG: 						result.Add(ScriptToken.CheckSig); 						break; 					case OpcodeType.OP_CHECKSIGVERIFY: 						result.Add(ScriptToken.CheckSigVerify); 						break; 					case OpcodeType.OP_CHECKMULTISIG: 						result.Add(ScriptToken.CheckMultiSig); 						break; 					case OpcodeType.OP_CHECKMULTISIGVERIFY: 						result.Add(ScriptToken.CheckMultiSigVerify); 						break; 					case OpcodeType.OP_CHECKSEQUENCEVERIFY: 						result.Add(ScriptToken.CheckSequenceVerify); 						break; 					case OpcodeType.OP_FROMALTSTACK: 						result.Add(ScriptToken.FromAltStack); 						break; 					case OpcodeType.OP_TOALTSTACK: 						result.Add(ScriptToken.ToAltStack); 						break; 					case OpcodeType.OP_DROP: 						result.Add(ScriptToken.Drop); 						break; 					case OpcodeType.OP_DUP: 						result.Add(ScriptToken.Dup); 						break; 					case OpcodeType.OP_IF: 						result.Add(ScriptToken.If); 						break; 					case OpcodeType.OP_IFDUP: 						result.Add(ScriptToken.IfDup); 						break; 					case OpcodeType.OP_NOTIF: 						result.Add(ScriptToken.NotIf); 						break; 					case OpcodeType.OP_ELSE: 						result.Add(ScriptToken.Else); 						break; 					case OpcodeType.OP_ENDIF: 						result.Add(ScriptToken.EndIf); 						break; 					case OpcodeType.OP_0NOTEQUAL: 						result.Add(ScriptToken.ZeroNotEqual); 						break; 					case OpcodeType.OP_SIZE: 						result.Add(ScriptToken.Size); 						break; 					case OpcodeType.OP_SWAP: 						result.Add(ScriptToken.Swap); 						break; 					case OpcodeType.OP_VERIFY: 						result.Add(ScriptToken.Verify); 						break; 					case OpcodeType.OP_HASH160: 						result.Add(ScriptToken.Hash160); 						break; 					case OpcodeType.OP_SHA256: 						result.Add(ScriptToken.Sha256); 						break; 					case OpcodeType.OP_ADD: 						result.Add(ScriptToken.Add); 						break; 					case OpcodeType.OP_0: 						result.Add(new ScriptToken.Number(0u)); 						break; 					case OpcodeType.OP_1: 						result.Add(new ScriptToken.Number(1u)); 						break; 					case OpcodeType.OP_2: 						result.Add(new ScriptToken.Number(2u)); 						break; 					case OpcodeType.OP_3: 						result.Add(new ScriptToken.Number(3u)); 						break; 					case OpcodeType.OP_4: 						result.Add(new ScriptToken.Number(4u)); 						break; 					case OpcodeType.OP_5: 						result.Add(new ScriptToken.Number(5u)); 						break; 					case OpcodeType.OP_6: 						result.Add(new ScriptToken.Number(6u)); 						break; 					case OpcodeType.OP_7: 						result.Add(new ScriptToken.Number(7u)); 						break; 					case OpcodeType.OP_8: 						result.Add(new ScriptToken.Number(8u)); 						break; 					case OpcodeType.OP_9: 						result.Add(new ScriptToken.Number(9u)); 						break; 					case OpcodeType.OP_10: 						result.Add(new ScriptToken.Number(10u)); 						break; 					case OpcodeType.OP_11: 						result.Add(new ScriptToken.Number(11u)); 						break; 					case OpcodeType.OP_12: 						result.Add(new ScriptToken.Number(12u)); 						break; 					case OpcodeType.OP_13: 						result.Add(new ScriptToken.Number(13u)); 						break; 					case OpcodeType.OP_14: 						result.Add(new ScriptToken.Number(14u)); 						break; 					case OpcodeType.OP_15: 						result.Add(new ScriptToken.Number(15u)); 						break; 					case OpcodeType.OP_16: 						result.Add(new ScriptToken.Number(16u)); 						break; 					default: 						if ((byte)0x01 <= (byte)op.Code && (byte)op.Code < (byte)0x48) 							result.Add(GetItem(op)); 						else if ((byte)0x48 <= (byte)op.Code) 							throw new ParsingException($"Miniscript does not support pushdata bigger than 33. Got {op}"); 						else 							throw new ParsingException($"Unknown Opcode to Miniscript {op.Name}"); 						break; 				}
Magic Number,NBitcoin.Scripting,ScriptExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptExtensions.cs,ToTokens,The following statement contains a magic number: switch (op.Code) 				{ 					case OpcodeType.OP_BOOLAND: 						result.Add(ScriptToken.BoolAnd); 						break; 					case OpcodeType.OP_BOOLOR: 						result.Add(ScriptToken.BoolOr); 						break; 					case OpcodeType.OP_EQUAL: 						result.Add(ScriptToken.Equal); 						break; 					case OpcodeType.OP_EQUALVERIFY: 						result.Add(ScriptToken.EqualVerify); 						break; 					case OpcodeType.OP_CHECKSIG: 						result.Add(ScriptToken.CheckSig); 						break; 					case OpcodeType.OP_CHECKSIGVERIFY: 						result.Add(ScriptToken.CheckSigVerify); 						break; 					case OpcodeType.OP_CHECKMULTISIG: 						result.Add(ScriptToken.CheckMultiSig); 						break; 					case OpcodeType.OP_CHECKMULTISIGVERIFY: 						result.Add(ScriptToken.CheckMultiSigVerify); 						break; 					case OpcodeType.OP_CHECKSEQUENCEVERIFY: 						result.Add(ScriptToken.CheckSequenceVerify); 						break; 					case OpcodeType.OP_FROMALTSTACK: 						result.Add(ScriptToken.FromAltStack); 						break; 					case OpcodeType.OP_TOALTSTACK: 						result.Add(ScriptToken.ToAltStack); 						break; 					case OpcodeType.OP_DROP: 						result.Add(ScriptToken.Drop); 						break; 					case OpcodeType.OP_DUP: 						result.Add(ScriptToken.Dup); 						break; 					case OpcodeType.OP_IF: 						result.Add(ScriptToken.If); 						break; 					case OpcodeType.OP_IFDUP: 						result.Add(ScriptToken.IfDup); 						break; 					case OpcodeType.OP_NOTIF: 						result.Add(ScriptToken.NotIf); 						break; 					case OpcodeType.OP_ELSE: 						result.Add(ScriptToken.Else); 						break; 					case OpcodeType.OP_ENDIF: 						result.Add(ScriptToken.EndIf); 						break; 					case OpcodeType.OP_0NOTEQUAL: 						result.Add(ScriptToken.ZeroNotEqual); 						break; 					case OpcodeType.OP_SIZE: 						result.Add(ScriptToken.Size); 						break; 					case OpcodeType.OP_SWAP: 						result.Add(ScriptToken.Swap); 						break; 					case OpcodeType.OP_VERIFY: 						result.Add(ScriptToken.Verify); 						break; 					case OpcodeType.OP_HASH160: 						result.Add(ScriptToken.Hash160); 						break; 					case OpcodeType.OP_SHA256: 						result.Add(ScriptToken.Sha256); 						break; 					case OpcodeType.OP_ADD: 						result.Add(ScriptToken.Add); 						break; 					case OpcodeType.OP_0: 						result.Add(new ScriptToken.Number(0u)); 						break; 					case OpcodeType.OP_1: 						result.Add(new ScriptToken.Number(1u)); 						break; 					case OpcodeType.OP_2: 						result.Add(new ScriptToken.Number(2u)); 						break; 					case OpcodeType.OP_3: 						result.Add(new ScriptToken.Number(3u)); 						break; 					case OpcodeType.OP_4: 						result.Add(new ScriptToken.Number(4u)); 						break; 					case OpcodeType.OP_5: 						result.Add(new ScriptToken.Number(5u)); 						break; 					case OpcodeType.OP_6: 						result.Add(new ScriptToken.Number(6u)); 						break; 					case OpcodeType.OP_7: 						result.Add(new ScriptToken.Number(7u)); 						break; 					case OpcodeType.OP_8: 						result.Add(new ScriptToken.Number(8u)); 						break; 					case OpcodeType.OP_9: 						result.Add(new ScriptToken.Number(9u)); 						break; 					case OpcodeType.OP_10: 						result.Add(new ScriptToken.Number(10u)); 						break; 					case OpcodeType.OP_11: 						result.Add(new ScriptToken.Number(11u)); 						break; 					case OpcodeType.OP_12: 						result.Add(new ScriptToken.Number(12u)); 						break; 					case OpcodeType.OP_13: 						result.Add(new ScriptToken.Number(13u)); 						break; 					case OpcodeType.OP_14: 						result.Add(new ScriptToken.Number(14u)); 						break; 					case OpcodeType.OP_15: 						result.Add(new ScriptToken.Number(15u)); 						break; 					case OpcodeType.OP_16: 						result.Add(new ScriptToken.Number(16u)); 						break; 					default: 						if ((byte)0x01 <= (byte)op.Code && (byte)op.Code < (byte)0x48) 							result.Add(GetItem(op)); 						else if ((byte)0x48 <= (byte)op.Code) 							throw new ParsingException($"Miniscript does not support pushdata bigger than 33. Got {op}"); 						else 							throw new ParsingException($"Unknown Opcode to Miniscript {op.Name}"); 						break; 				}
Magic Number,NBitcoin.Scripting,ScriptExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptExtensions.cs,ToTokens,The following statement contains a magic number: switch (op.Code) 				{ 					case OpcodeType.OP_BOOLAND: 						result.Add(ScriptToken.BoolAnd); 						break; 					case OpcodeType.OP_BOOLOR: 						result.Add(ScriptToken.BoolOr); 						break; 					case OpcodeType.OP_EQUAL: 						result.Add(ScriptToken.Equal); 						break; 					case OpcodeType.OP_EQUALVERIFY: 						result.Add(ScriptToken.EqualVerify); 						break; 					case OpcodeType.OP_CHECKSIG: 						result.Add(ScriptToken.CheckSig); 						break; 					case OpcodeType.OP_CHECKSIGVERIFY: 						result.Add(ScriptToken.CheckSigVerify); 						break; 					case OpcodeType.OP_CHECKMULTISIG: 						result.Add(ScriptToken.CheckMultiSig); 						break; 					case OpcodeType.OP_CHECKMULTISIGVERIFY: 						result.Add(ScriptToken.CheckMultiSigVerify); 						break; 					case OpcodeType.OP_CHECKSEQUENCEVERIFY: 						result.Add(ScriptToken.CheckSequenceVerify); 						break; 					case OpcodeType.OP_FROMALTSTACK: 						result.Add(ScriptToken.FromAltStack); 						break; 					case OpcodeType.OP_TOALTSTACK: 						result.Add(ScriptToken.ToAltStack); 						break; 					case OpcodeType.OP_DROP: 						result.Add(ScriptToken.Drop); 						break; 					case OpcodeType.OP_DUP: 						result.Add(ScriptToken.Dup); 						break; 					case OpcodeType.OP_IF: 						result.Add(ScriptToken.If); 						break; 					case OpcodeType.OP_IFDUP: 						result.Add(ScriptToken.IfDup); 						break; 					case OpcodeType.OP_NOTIF: 						result.Add(ScriptToken.NotIf); 						break; 					case OpcodeType.OP_ELSE: 						result.Add(ScriptToken.Else); 						break; 					case OpcodeType.OP_ENDIF: 						result.Add(ScriptToken.EndIf); 						break; 					case OpcodeType.OP_0NOTEQUAL: 						result.Add(ScriptToken.ZeroNotEqual); 						break; 					case OpcodeType.OP_SIZE: 						result.Add(ScriptToken.Size); 						break; 					case OpcodeType.OP_SWAP: 						result.Add(ScriptToken.Swap); 						break; 					case OpcodeType.OP_VERIFY: 						result.Add(ScriptToken.Verify); 						break; 					case OpcodeType.OP_HASH160: 						result.Add(ScriptToken.Hash160); 						break; 					case OpcodeType.OP_SHA256: 						result.Add(ScriptToken.Sha256); 						break; 					case OpcodeType.OP_ADD: 						result.Add(ScriptToken.Add); 						break; 					case OpcodeType.OP_0: 						result.Add(new ScriptToken.Number(0u)); 						break; 					case OpcodeType.OP_1: 						result.Add(new ScriptToken.Number(1u)); 						break; 					case OpcodeType.OP_2: 						result.Add(new ScriptToken.Number(2u)); 						break; 					case OpcodeType.OP_3: 						result.Add(new ScriptToken.Number(3u)); 						break; 					case OpcodeType.OP_4: 						result.Add(new ScriptToken.Number(4u)); 						break; 					case OpcodeType.OP_5: 						result.Add(new ScriptToken.Number(5u)); 						break; 					case OpcodeType.OP_6: 						result.Add(new ScriptToken.Number(6u)); 						break; 					case OpcodeType.OP_7: 						result.Add(new ScriptToken.Number(7u)); 						break; 					case OpcodeType.OP_8: 						result.Add(new ScriptToken.Number(8u)); 						break; 					case OpcodeType.OP_9: 						result.Add(new ScriptToken.Number(9u)); 						break; 					case OpcodeType.OP_10: 						result.Add(new ScriptToken.Number(10u)); 						break; 					case OpcodeType.OP_11: 						result.Add(new ScriptToken.Number(11u)); 						break; 					case OpcodeType.OP_12: 						result.Add(new ScriptToken.Number(12u)); 						break; 					case OpcodeType.OP_13: 						result.Add(new ScriptToken.Number(13u)); 						break; 					case OpcodeType.OP_14: 						result.Add(new ScriptToken.Number(14u)); 						break; 					case OpcodeType.OP_15: 						result.Add(new ScriptToken.Number(15u)); 						break; 					case OpcodeType.OP_16: 						result.Add(new ScriptToken.Number(16u)); 						break; 					default: 						if ((byte)0x01 <= (byte)op.Code && (byte)op.Code < (byte)0x48) 							result.Add(GetItem(op)); 						else if ((byte)0x48 <= (byte)op.Code) 							throw new ParsingException($"Miniscript does not support pushdata bigger than 33. Got {op}"); 						else 							throw new ParsingException($"Unknown Opcode to Miniscript {op.Name}"); 						break; 				}
Magic Number,NBitcoin.Scripting,ScriptExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptExtensions.cs,ToTokens,The following statement contains a magic number: switch (op.Code) 				{ 					case OpcodeType.OP_BOOLAND: 						result.Add(ScriptToken.BoolAnd); 						break; 					case OpcodeType.OP_BOOLOR: 						result.Add(ScriptToken.BoolOr); 						break; 					case OpcodeType.OP_EQUAL: 						result.Add(ScriptToken.Equal); 						break; 					case OpcodeType.OP_EQUALVERIFY: 						result.Add(ScriptToken.EqualVerify); 						break; 					case OpcodeType.OP_CHECKSIG: 						result.Add(ScriptToken.CheckSig); 						break; 					case OpcodeType.OP_CHECKSIGVERIFY: 						result.Add(ScriptToken.CheckSigVerify); 						break; 					case OpcodeType.OP_CHECKMULTISIG: 						result.Add(ScriptToken.CheckMultiSig); 						break; 					case OpcodeType.OP_CHECKMULTISIGVERIFY: 						result.Add(ScriptToken.CheckMultiSigVerify); 						break; 					case OpcodeType.OP_CHECKSEQUENCEVERIFY: 						result.Add(ScriptToken.CheckSequenceVerify); 						break; 					case OpcodeType.OP_FROMALTSTACK: 						result.Add(ScriptToken.FromAltStack); 						break; 					case OpcodeType.OP_TOALTSTACK: 						result.Add(ScriptToken.ToAltStack); 						break; 					case OpcodeType.OP_DROP: 						result.Add(ScriptToken.Drop); 						break; 					case OpcodeType.OP_DUP: 						result.Add(ScriptToken.Dup); 						break; 					case OpcodeType.OP_IF: 						result.Add(ScriptToken.If); 						break; 					case OpcodeType.OP_IFDUP: 						result.Add(ScriptToken.IfDup); 						break; 					case OpcodeType.OP_NOTIF: 						result.Add(ScriptToken.NotIf); 						break; 					case OpcodeType.OP_ELSE: 						result.Add(ScriptToken.Else); 						break; 					case OpcodeType.OP_ENDIF: 						result.Add(ScriptToken.EndIf); 						break; 					case OpcodeType.OP_0NOTEQUAL: 						result.Add(ScriptToken.ZeroNotEqual); 						break; 					case OpcodeType.OP_SIZE: 						result.Add(ScriptToken.Size); 						break; 					case OpcodeType.OP_SWAP: 						result.Add(ScriptToken.Swap); 						break; 					case OpcodeType.OP_VERIFY: 						result.Add(ScriptToken.Verify); 						break; 					case OpcodeType.OP_HASH160: 						result.Add(ScriptToken.Hash160); 						break; 					case OpcodeType.OP_SHA256: 						result.Add(ScriptToken.Sha256); 						break; 					case OpcodeType.OP_ADD: 						result.Add(ScriptToken.Add); 						break; 					case OpcodeType.OP_0: 						result.Add(new ScriptToken.Number(0u)); 						break; 					case OpcodeType.OP_1: 						result.Add(new ScriptToken.Number(1u)); 						break; 					case OpcodeType.OP_2: 						result.Add(new ScriptToken.Number(2u)); 						break; 					case OpcodeType.OP_3: 						result.Add(new ScriptToken.Number(3u)); 						break; 					case OpcodeType.OP_4: 						result.Add(new ScriptToken.Number(4u)); 						break; 					case OpcodeType.OP_5: 						result.Add(new ScriptToken.Number(5u)); 						break; 					case OpcodeType.OP_6: 						result.Add(new ScriptToken.Number(6u)); 						break; 					case OpcodeType.OP_7: 						result.Add(new ScriptToken.Number(7u)); 						break; 					case OpcodeType.OP_8: 						result.Add(new ScriptToken.Number(8u)); 						break; 					case OpcodeType.OP_9: 						result.Add(new ScriptToken.Number(9u)); 						break; 					case OpcodeType.OP_10: 						result.Add(new ScriptToken.Number(10u)); 						break; 					case OpcodeType.OP_11: 						result.Add(new ScriptToken.Number(11u)); 						break; 					case OpcodeType.OP_12: 						result.Add(new ScriptToken.Number(12u)); 						break; 					case OpcodeType.OP_13: 						result.Add(new ScriptToken.Number(13u)); 						break; 					case OpcodeType.OP_14: 						result.Add(new ScriptToken.Number(14u)); 						break; 					case OpcodeType.OP_15: 						result.Add(new ScriptToken.Number(15u)); 						break; 					case OpcodeType.OP_16: 						result.Add(new ScriptToken.Number(16u)); 						break; 					default: 						if ((byte)0x01 <= (byte)op.Code && (byte)op.Code < (byte)0x48) 							result.Add(GetItem(op)); 						else if ((byte)0x48 <= (byte)op.Code) 							throw new ParsingException($"Miniscript does not support pushdata bigger than 33. Got {op}"); 						else 							throw new ParsingException($"Unknown Opcode to Miniscript {op.Name}"); 						break; 				}
Magic Number,NBitcoin.Scripting,ScriptExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptExtensions.cs,ToTokens,The following statement contains a magic number: switch (op.Code) 				{ 					case OpcodeType.OP_BOOLAND: 						result.Add(ScriptToken.BoolAnd); 						break; 					case OpcodeType.OP_BOOLOR: 						result.Add(ScriptToken.BoolOr); 						break; 					case OpcodeType.OP_EQUAL: 						result.Add(ScriptToken.Equal); 						break; 					case OpcodeType.OP_EQUALVERIFY: 						result.Add(ScriptToken.EqualVerify); 						break; 					case OpcodeType.OP_CHECKSIG: 						result.Add(ScriptToken.CheckSig); 						break; 					case OpcodeType.OP_CHECKSIGVERIFY: 						result.Add(ScriptToken.CheckSigVerify); 						break; 					case OpcodeType.OP_CHECKMULTISIG: 						result.Add(ScriptToken.CheckMultiSig); 						break; 					case OpcodeType.OP_CHECKMULTISIGVERIFY: 						result.Add(ScriptToken.CheckMultiSigVerify); 						break; 					case OpcodeType.OP_CHECKSEQUENCEVERIFY: 						result.Add(ScriptToken.CheckSequenceVerify); 						break; 					case OpcodeType.OP_FROMALTSTACK: 						result.Add(ScriptToken.FromAltStack); 						break; 					case OpcodeType.OP_TOALTSTACK: 						result.Add(ScriptToken.ToAltStack); 						break; 					case OpcodeType.OP_DROP: 						result.Add(ScriptToken.Drop); 						break; 					case OpcodeType.OP_DUP: 						result.Add(ScriptToken.Dup); 						break; 					case OpcodeType.OP_IF: 						result.Add(ScriptToken.If); 						break; 					case OpcodeType.OP_IFDUP: 						result.Add(ScriptToken.IfDup); 						break; 					case OpcodeType.OP_NOTIF: 						result.Add(ScriptToken.NotIf); 						break; 					case OpcodeType.OP_ELSE: 						result.Add(ScriptToken.Else); 						break; 					case OpcodeType.OP_ENDIF: 						result.Add(ScriptToken.EndIf); 						break; 					case OpcodeType.OP_0NOTEQUAL: 						result.Add(ScriptToken.ZeroNotEqual); 						break; 					case OpcodeType.OP_SIZE: 						result.Add(ScriptToken.Size); 						break; 					case OpcodeType.OP_SWAP: 						result.Add(ScriptToken.Swap); 						break; 					case OpcodeType.OP_VERIFY: 						result.Add(ScriptToken.Verify); 						break; 					case OpcodeType.OP_HASH160: 						result.Add(ScriptToken.Hash160); 						break; 					case OpcodeType.OP_SHA256: 						result.Add(ScriptToken.Sha256); 						break; 					case OpcodeType.OP_ADD: 						result.Add(ScriptToken.Add); 						break; 					case OpcodeType.OP_0: 						result.Add(new ScriptToken.Number(0u)); 						break; 					case OpcodeType.OP_1: 						result.Add(new ScriptToken.Number(1u)); 						break; 					case OpcodeType.OP_2: 						result.Add(new ScriptToken.Number(2u)); 						break; 					case OpcodeType.OP_3: 						result.Add(new ScriptToken.Number(3u)); 						break; 					case OpcodeType.OP_4: 						result.Add(new ScriptToken.Number(4u)); 						break; 					case OpcodeType.OP_5: 						result.Add(new ScriptToken.Number(5u)); 						break; 					case OpcodeType.OP_6: 						result.Add(new ScriptToken.Number(6u)); 						break; 					case OpcodeType.OP_7: 						result.Add(new ScriptToken.Number(7u)); 						break; 					case OpcodeType.OP_8: 						result.Add(new ScriptToken.Number(8u)); 						break; 					case OpcodeType.OP_9: 						result.Add(new ScriptToken.Number(9u)); 						break; 					case OpcodeType.OP_10: 						result.Add(new ScriptToken.Number(10u)); 						break; 					case OpcodeType.OP_11: 						result.Add(new ScriptToken.Number(11u)); 						break; 					case OpcodeType.OP_12: 						result.Add(new ScriptToken.Number(12u)); 						break; 					case OpcodeType.OP_13: 						result.Add(new ScriptToken.Number(13u)); 						break; 					case OpcodeType.OP_14: 						result.Add(new ScriptToken.Number(14u)); 						break; 					case OpcodeType.OP_15: 						result.Add(new ScriptToken.Number(15u)); 						break; 					case OpcodeType.OP_16: 						result.Add(new ScriptToken.Number(16u)); 						break; 					default: 						if ((byte)0x01 <= (byte)op.Code && (byte)op.Code < (byte)0x48) 							result.Add(GetItem(op)); 						else if ((byte)0x48 <= (byte)op.Code) 							throw new ParsingException($"Miniscript does not support pushdata bigger than 33. Got {op}"); 						else 							throw new ParsingException($"Unknown Opcode to Miniscript {op.Name}"); 						break; 				}
Magic Number,NBitcoin.Scripting,ScriptExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptExtensions.cs,ToTokens,The following statement contains a magic number: switch (op.Code) 				{ 					case OpcodeType.OP_BOOLAND: 						result.Add(ScriptToken.BoolAnd); 						break; 					case OpcodeType.OP_BOOLOR: 						result.Add(ScriptToken.BoolOr); 						break; 					case OpcodeType.OP_EQUAL: 						result.Add(ScriptToken.Equal); 						break; 					case OpcodeType.OP_EQUALVERIFY: 						result.Add(ScriptToken.EqualVerify); 						break; 					case OpcodeType.OP_CHECKSIG: 						result.Add(ScriptToken.CheckSig); 						break; 					case OpcodeType.OP_CHECKSIGVERIFY: 						result.Add(ScriptToken.CheckSigVerify); 						break; 					case OpcodeType.OP_CHECKMULTISIG: 						result.Add(ScriptToken.CheckMultiSig); 						break; 					case OpcodeType.OP_CHECKMULTISIGVERIFY: 						result.Add(ScriptToken.CheckMultiSigVerify); 						break; 					case OpcodeType.OP_CHECKSEQUENCEVERIFY: 						result.Add(ScriptToken.CheckSequenceVerify); 						break; 					case OpcodeType.OP_FROMALTSTACK: 						result.Add(ScriptToken.FromAltStack); 						break; 					case OpcodeType.OP_TOALTSTACK: 						result.Add(ScriptToken.ToAltStack); 						break; 					case OpcodeType.OP_DROP: 						result.Add(ScriptToken.Drop); 						break; 					case OpcodeType.OP_DUP: 						result.Add(ScriptToken.Dup); 						break; 					case OpcodeType.OP_IF: 						result.Add(ScriptToken.If); 						break; 					case OpcodeType.OP_IFDUP: 						result.Add(ScriptToken.IfDup); 						break; 					case OpcodeType.OP_NOTIF: 						result.Add(ScriptToken.NotIf); 						break; 					case OpcodeType.OP_ELSE: 						result.Add(ScriptToken.Else); 						break; 					case OpcodeType.OP_ENDIF: 						result.Add(ScriptToken.EndIf); 						break; 					case OpcodeType.OP_0NOTEQUAL: 						result.Add(ScriptToken.ZeroNotEqual); 						break; 					case OpcodeType.OP_SIZE: 						result.Add(ScriptToken.Size); 						break; 					case OpcodeType.OP_SWAP: 						result.Add(ScriptToken.Swap); 						break; 					case OpcodeType.OP_VERIFY: 						result.Add(ScriptToken.Verify); 						break; 					case OpcodeType.OP_HASH160: 						result.Add(ScriptToken.Hash160); 						break; 					case OpcodeType.OP_SHA256: 						result.Add(ScriptToken.Sha256); 						break; 					case OpcodeType.OP_ADD: 						result.Add(ScriptToken.Add); 						break; 					case OpcodeType.OP_0: 						result.Add(new ScriptToken.Number(0u)); 						break; 					case OpcodeType.OP_1: 						result.Add(new ScriptToken.Number(1u)); 						break; 					case OpcodeType.OP_2: 						result.Add(new ScriptToken.Number(2u)); 						break; 					case OpcodeType.OP_3: 						result.Add(new ScriptToken.Number(3u)); 						break; 					case OpcodeType.OP_4: 						result.Add(new ScriptToken.Number(4u)); 						break; 					case OpcodeType.OP_5: 						result.Add(new ScriptToken.Number(5u)); 						break; 					case OpcodeType.OP_6: 						result.Add(new ScriptToken.Number(6u)); 						break; 					case OpcodeType.OP_7: 						result.Add(new ScriptToken.Number(7u)); 						break; 					case OpcodeType.OP_8: 						result.Add(new ScriptToken.Number(8u)); 						break; 					case OpcodeType.OP_9: 						result.Add(new ScriptToken.Number(9u)); 						break; 					case OpcodeType.OP_10: 						result.Add(new ScriptToken.Number(10u)); 						break; 					case OpcodeType.OP_11: 						result.Add(new ScriptToken.Number(11u)); 						break; 					case OpcodeType.OP_12: 						result.Add(new ScriptToken.Number(12u)); 						break; 					case OpcodeType.OP_13: 						result.Add(new ScriptToken.Number(13u)); 						break; 					case OpcodeType.OP_14: 						result.Add(new ScriptToken.Number(14u)); 						break; 					case OpcodeType.OP_15: 						result.Add(new ScriptToken.Number(15u)); 						break; 					case OpcodeType.OP_16: 						result.Add(new ScriptToken.Number(16u)); 						break; 					default: 						if ((byte)0x01 <= (byte)op.Code && (byte)op.Code < (byte)0x48) 							result.Add(GetItem(op)); 						else if ((byte)0x48 <= (byte)op.Code) 							throw new ParsingException($"Miniscript does not support pushdata bigger than 33. Got {op}"); 						else 							throw new ParsingException($"Unknown Opcode to Miniscript {op.Name}"); 						break; 				}
Magic Number,NBitcoin.Scripting,ScriptExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptExtensions.cs,ToTokens,The following statement contains a magic number: switch (op.Code) 				{ 					case OpcodeType.OP_BOOLAND: 						result.Add(ScriptToken.BoolAnd); 						break; 					case OpcodeType.OP_BOOLOR: 						result.Add(ScriptToken.BoolOr); 						break; 					case OpcodeType.OP_EQUAL: 						result.Add(ScriptToken.Equal); 						break; 					case OpcodeType.OP_EQUALVERIFY: 						result.Add(ScriptToken.EqualVerify); 						break; 					case OpcodeType.OP_CHECKSIG: 						result.Add(ScriptToken.CheckSig); 						break; 					case OpcodeType.OP_CHECKSIGVERIFY: 						result.Add(ScriptToken.CheckSigVerify); 						break; 					case OpcodeType.OP_CHECKMULTISIG: 						result.Add(ScriptToken.CheckMultiSig); 						break; 					case OpcodeType.OP_CHECKMULTISIGVERIFY: 						result.Add(ScriptToken.CheckMultiSigVerify); 						break; 					case OpcodeType.OP_CHECKSEQUENCEVERIFY: 						result.Add(ScriptToken.CheckSequenceVerify); 						break; 					case OpcodeType.OP_FROMALTSTACK: 						result.Add(ScriptToken.FromAltStack); 						break; 					case OpcodeType.OP_TOALTSTACK: 						result.Add(ScriptToken.ToAltStack); 						break; 					case OpcodeType.OP_DROP: 						result.Add(ScriptToken.Drop); 						break; 					case OpcodeType.OP_DUP: 						result.Add(ScriptToken.Dup); 						break; 					case OpcodeType.OP_IF: 						result.Add(ScriptToken.If); 						break; 					case OpcodeType.OP_IFDUP: 						result.Add(ScriptToken.IfDup); 						break; 					case OpcodeType.OP_NOTIF: 						result.Add(ScriptToken.NotIf); 						break; 					case OpcodeType.OP_ELSE: 						result.Add(ScriptToken.Else); 						break; 					case OpcodeType.OP_ENDIF: 						result.Add(ScriptToken.EndIf); 						break; 					case OpcodeType.OP_0NOTEQUAL: 						result.Add(ScriptToken.ZeroNotEqual); 						break; 					case OpcodeType.OP_SIZE: 						result.Add(ScriptToken.Size); 						break; 					case OpcodeType.OP_SWAP: 						result.Add(ScriptToken.Swap); 						break; 					case OpcodeType.OP_VERIFY: 						result.Add(ScriptToken.Verify); 						break; 					case OpcodeType.OP_HASH160: 						result.Add(ScriptToken.Hash160); 						break; 					case OpcodeType.OP_SHA256: 						result.Add(ScriptToken.Sha256); 						break; 					case OpcodeType.OP_ADD: 						result.Add(ScriptToken.Add); 						break; 					case OpcodeType.OP_0: 						result.Add(new ScriptToken.Number(0u)); 						break; 					case OpcodeType.OP_1: 						result.Add(new ScriptToken.Number(1u)); 						break; 					case OpcodeType.OP_2: 						result.Add(new ScriptToken.Number(2u)); 						break; 					case OpcodeType.OP_3: 						result.Add(new ScriptToken.Number(3u)); 						break; 					case OpcodeType.OP_4: 						result.Add(new ScriptToken.Number(4u)); 						break; 					case OpcodeType.OP_5: 						result.Add(new ScriptToken.Number(5u)); 						break; 					case OpcodeType.OP_6: 						result.Add(new ScriptToken.Number(6u)); 						break; 					case OpcodeType.OP_7: 						result.Add(new ScriptToken.Number(7u)); 						break; 					case OpcodeType.OP_8: 						result.Add(new ScriptToken.Number(8u)); 						break; 					case OpcodeType.OP_9: 						result.Add(new ScriptToken.Number(9u)); 						break; 					case OpcodeType.OP_10: 						result.Add(new ScriptToken.Number(10u)); 						break; 					case OpcodeType.OP_11: 						result.Add(new ScriptToken.Number(11u)); 						break; 					case OpcodeType.OP_12: 						result.Add(new ScriptToken.Number(12u)); 						break; 					case OpcodeType.OP_13: 						result.Add(new ScriptToken.Number(13u)); 						break; 					case OpcodeType.OP_14: 						result.Add(new ScriptToken.Number(14u)); 						break; 					case OpcodeType.OP_15: 						result.Add(new ScriptToken.Number(15u)); 						break; 					case OpcodeType.OP_16: 						result.Add(new ScriptToken.Number(16u)); 						break; 					default: 						if ((byte)0x01 <= (byte)op.Code && (byte)op.Code < (byte)0x48) 							result.Add(GetItem(op)); 						else if ((byte)0x48 <= (byte)op.Code) 							throw new ParsingException($"Miniscript does not support pushdata bigger than 33. Got {op}"); 						else 							throw new ParsingException($"Unknown Opcode to Miniscript {op.Name}"); 						break; 				}
Magic Number,NBitcoin.Scripting,ScriptExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptExtensions.cs,ToTokens,The following statement contains a magic number: switch (op.Code) 				{ 					case OpcodeType.OP_BOOLAND: 						result.Add(ScriptToken.BoolAnd); 						break; 					case OpcodeType.OP_BOOLOR: 						result.Add(ScriptToken.BoolOr); 						break; 					case OpcodeType.OP_EQUAL: 						result.Add(ScriptToken.Equal); 						break; 					case OpcodeType.OP_EQUALVERIFY: 						result.Add(ScriptToken.EqualVerify); 						break; 					case OpcodeType.OP_CHECKSIG: 						result.Add(ScriptToken.CheckSig); 						break; 					case OpcodeType.OP_CHECKSIGVERIFY: 						result.Add(ScriptToken.CheckSigVerify); 						break; 					case OpcodeType.OP_CHECKMULTISIG: 						result.Add(ScriptToken.CheckMultiSig); 						break; 					case OpcodeType.OP_CHECKMULTISIGVERIFY: 						result.Add(ScriptToken.CheckMultiSigVerify); 						break; 					case OpcodeType.OP_CHECKSEQUENCEVERIFY: 						result.Add(ScriptToken.CheckSequenceVerify); 						break; 					case OpcodeType.OP_FROMALTSTACK: 						result.Add(ScriptToken.FromAltStack); 						break; 					case OpcodeType.OP_TOALTSTACK: 						result.Add(ScriptToken.ToAltStack); 						break; 					case OpcodeType.OP_DROP: 						result.Add(ScriptToken.Drop); 						break; 					case OpcodeType.OP_DUP: 						result.Add(ScriptToken.Dup); 						break; 					case OpcodeType.OP_IF: 						result.Add(ScriptToken.If); 						break; 					case OpcodeType.OP_IFDUP: 						result.Add(ScriptToken.IfDup); 						break; 					case OpcodeType.OP_NOTIF: 						result.Add(ScriptToken.NotIf); 						break; 					case OpcodeType.OP_ELSE: 						result.Add(ScriptToken.Else); 						break; 					case OpcodeType.OP_ENDIF: 						result.Add(ScriptToken.EndIf); 						break; 					case OpcodeType.OP_0NOTEQUAL: 						result.Add(ScriptToken.ZeroNotEqual); 						break; 					case OpcodeType.OP_SIZE: 						result.Add(ScriptToken.Size); 						break; 					case OpcodeType.OP_SWAP: 						result.Add(ScriptToken.Swap); 						break; 					case OpcodeType.OP_VERIFY: 						result.Add(ScriptToken.Verify); 						break; 					case OpcodeType.OP_HASH160: 						result.Add(ScriptToken.Hash160); 						break; 					case OpcodeType.OP_SHA256: 						result.Add(ScriptToken.Sha256); 						break; 					case OpcodeType.OP_ADD: 						result.Add(ScriptToken.Add); 						break; 					case OpcodeType.OP_0: 						result.Add(new ScriptToken.Number(0u)); 						break; 					case OpcodeType.OP_1: 						result.Add(new ScriptToken.Number(1u)); 						break; 					case OpcodeType.OP_2: 						result.Add(new ScriptToken.Number(2u)); 						break; 					case OpcodeType.OP_3: 						result.Add(new ScriptToken.Number(3u)); 						break; 					case OpcodeType.OP_4: 						result.Add(new ScriptToken.Number(4u)); 						break; 					case OpcodeType.OP_5: 						result.Add(new ScriptToken.Number(5u)); 						break; 					case OpcodeType.OP_6: 						result.Add(new ScriptToken.Number(6u)); 						break; 					case OpcodeType.OP_7: 						result.Add(new ScriptToken.Number(7u)); 						break; 					case OpcodeType.OP_8: 						result.Add(new ScriptToken.Number(8u)); 						break; 					case OpcodeType.OP_9: 						result.Add(new ScriptToken.Number(9u)); 						break; 					case OpcodeType.OP_10: 						result.Add(new ScriptToken.Number(10u)); 						break; 					case OpcodeType.OP_11: 						result.Add(new ScriptToken.Number(11u)); 						break; 					case OpcodeType.OP_12: 						result.Add(new ScriptToken.Number(12u)); 						break; 					case OpcodeType.OP_13: 						result.Add(new ScriptToken.Number(13u)); 						break; 					case OpcodeType.OP_14: 						result.Add(new ScriptToken.Number(14u)); 						break; 					case OpcodeType.OP_15: 						result.Add(new ScriptToken.Number(15u)); 						break; 					case OpcodeType.OP_16: 						result.Add(new ScriptToken.Number(16u)); 						break; 					default: 						if ((byte)0x01 <= (byte)op.Code && (byte)op.Code < (byte)0x48) 							result.Add(GetItem(op)); 						else if ((byte)0x48 <= (byte)op.Code) 							throw new ParsingException($"Miniscript does not support pushdata bigger than 33. Got {op}"); 						else 							throw new ParsingException($"Unknown Opcode to Miniscript {op.Name}"); 						break; 				}
Magic Number,NBitcoin.Scripting,ScriptExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptExtensions.cs,GetItem,The following statement contains a magic number: op.PushData.Length == 20
Magic Number,NBitcoin.Scripting,ScriptExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptExtensions.cs,GetItem,The following statement contains a magic number: op.PushData.Length == 32
Magic Number,NBitcoin.Scripting,ScriptExtensions,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptExtensions.cs,GetItem,The following statement contains a magic number: op.PushData.Length == 33
Magic Number,NBitcoin.Scripting,ScriptToken,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptToken.cs,GetHashCode,The following statement contains a magic number: switch (Tag) 				{ 					case 26: 						{ 							Number number = (Number)this; 							num = 26; 							return -1640531527 + ((int)number.Item + ((num << 6) + (num >> 2))); 						} 					case 27: 						{ 							Hash160Hash hash160Hash = (Hash160Hash)this; 							num = 27; 							return -1640531527 + (hash160Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 28: 						{ 							Sha256Hash sha256Hash = (Sha256Hash)this; 							num = 28; 							return -1640531527 + (sha256Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 29: 						{ 							Pk pk = (Pk)this; 							num = 29; 							return -1640531527 + (pk.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					default: 						return Tag; 				}
Magic Number,NBitcoin.Scripting,ScriptToken,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptToken.cs,GetHashCode,The following statement contains a magic number: switch (Tag) 				{ 					case 26: 						{ 							Number number = (Number)this; 							num = 26; 							return -1640531527 + ((int)number.Item + ((num << 6) + (num >> 2))); 						} 					case 27: 						{ 							Hash160Hash hash160Hash = (Hash160Hash)this; 							num = 27; 							return -1640531527 + (hash160Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 28: 						{ 							Sha256Hash sha256Hash = (Sha256Hash)this; 							num = 28; 							return -1640531527 + (sha256Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 29: 						{ 							Pk pk = (Pk)this; 							num = 29; 							return -1640531527 + (pk.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					default: 						return Tag; 				}
Magic Number,NBitcoin.Scripting,ScriptToken,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptToken.cs,GetHashCode,The following statement contains a magic number: switch (Tag) 				{ 					case 26: 						{ 							Number number = (Number)this; 							num = 26; 							return -1640531527 + ((int)number.Item + ((num << 6) + (num >> 2))); 						} 					case 27: 						{ 							Hash160Hash hash160Hash = (Hash160Hash)this; 							num = 27; 							return -1640531527 + (hash160Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 28: 						{ 							Sha256Hash sha256Hash = (Sha256Hash)this; 							num = 28; 							return -1640531527 + (sha256Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 29: 						{ 							Pk pk = (Pk)this; 							num = 29; 							return -1640531527 + (pk.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					default: 						return Tag; 				}
Magic Number,NBitcoin.Scripting,ScriptToken,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptToken.cs,GetHashCode,The following statement contains a magic number: switch (Tag) 				{ 					case 26: 						{ 							Number number = (Number)this; 							num = 26; 							return -1640531527 + ((int)number.Item + ((num << 6) + (num >> 2))); 						} 					case 27: 						{ 							Hash160Hash hash160Hash = (Hash160Hash)this; 							num = 27; 							return -1640531527 + (hash160Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 28: 						{ 							Sha256Hash sha256Hash = (Sha256Hash)this; 							num = 28; 							return -1640531527 + (sha256Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 29: 						{ 							Pk pk = (Pk)this; 							num = 29; 							return -1640531527 + (pk.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					default: 						return Tag; 				}
Magic Number,NBitcoin.Scripting,ScriptToken,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptToken.cs,GetHashCode,The following statement contains a magic number: switch (Tag) 				{ 					case 26: 						{ 							Number number = (Number)this; 							num = 26; 							return -1640531527 + ((int)number.Item + ((num << 6) + (num >> 2))); 						} 					case 27: 						{ 							Hash160Hash hash160Hash = (Hash160Hash)this; 							num = 27; 							return -1640531527 + (hash160Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 28: 						{ 							Sha256Hash sha256Hash = (Sha256Hash)this; 							num = 28; 							return -1640531527 + (sha256Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 29: 						{ 							Pk pk = (Pk)this; 							num = 29; 							return -1640531527 + (pk.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					default: 						return Tag; 				}
Magic Number,NBitcoin.Scripting,ScriptToken,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptToken.cs,GetHashCode,The following statement contains a magic number: switch (Tag) 				{ 					case 26: 						{ 							Number number = (Number)this; 							num = 26; 							return -1640531527 + ((int)number.Item + ((num << 6) + (num >> 2))); 						} 					case 27: 						{ 							Hash160Hash hash160Hash = (Hash160Hash)this; 							num = 27; 							return -1640531527 + (hash160Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 28: 						{ 							Sha256Hash sha256Hash = (Sha256Hash)this; 							num = 28; 							return -1640531527 + (sha256Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 29: 						{ 							Pk pk = (Pk)this; 							num = 29; 							return -1640531527 + (pk.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					default: 						return Tag; 				}
Magic Number,NBitcoin.Scripting,ScriptToken,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptToken.cs,GetHashCode,The following statement contains a magic number: switch (Tag) 				{ 					case 26: 						{ 							Number number = (Number)this; 							num = 26; 							return -1640531527 + ((int)number.Item + ((num << 6) + (num >> 2))); 						} 					case 27: 						{ 							Hash160Hash hash160Hash = (Hash160Hash)this; 							num = 27; 							return -1640531527 + (hash160Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 28: 						{ 							Sha256Hash sha256Hash = (Sha256Hash)this; 							num = 28; 							return -1640531527 + (sha256Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 29: 						{ 							Pk pk = (Pk)this; 							num = 29; 							return -1640531527 + (pk.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					default: 						return Tag; 				}
Magic Number,NBitcoin.Scripting,ScriptToken,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptToken.cs,GetHashCode,The following statement contains a magic number: switch (Tag) 				{ 					case 26: 						{ 							Number number = (Number)this; 							num = 26; 							return -1640531527 + ((int)number.Item + ((num << 6) + (num >> 2))); 						} 					case 27: 						{ 							Hash160Hash hash160Hash = (Hash160Hash)this; 							num = 27; 							return -1640531527 + (hash160Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 28: 						{ 							Sha256Hash sha256Hash = (Sha256Hash)this; 							num = 28; 							return -1640531527 + (sha256Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 29: 						{ 							Pk pk = (Pk)this; 							num = 29; 							return -1640531527 + (pk.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					default: 						return Tag; 				}
Magic Number,NBitcoin.Scripting,ScriptToken,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptToken.cs,GetHashCode,The following statement contains a magic number: switch (Tag) 				{ 					case 26: 						{ 							Number number = (Number)this; 							num = 26; 							return -1640531527 + ((int)number.Item + ((num << 6) + (num >> 2))); 						} 					case 27: 						{ 							Hash160Hash hash160Hash = (Hash160Hash)this; 							num = 27; 							return -1640531527 + (hash160Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 28: 						{ 							Sha256Hash sha256Hash = (Sha256Hash)this; 							num = 28; 							return -1640531527 + (sha256Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 29: 						{ 							Pk pk = (Pk)this; 							num = 29; 							return -1640531527 + (pk.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					default: 						return Tag; 				}
Magic Number,NBitcoin.Scripting,ScriptToken,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptToken.cs,GetHashCode,The following statement contains a magic number: switch (Tag) 				{ 					case 26: 						{ 							Number number = (Number)this; 							num = 26; 							return -1640531527 + ((int)number.Item + ((num << 6) + (num >> 2))); 						} 					case 27: 						{ 							Hash160Hash hash160Hash = (Hash160Hash)this; 							num = 27; 							return -1640531527 + (hash160Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 28: 						{ 							Sha256Hash sha256Hash = (Sha256Hash)this; 							num = 28; 							return -1640531527 + (sha256Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 29: 						{ 							Pk pk = (Pk)this; 							num = 29; 							return -1640531527 + (pk.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					default: 						return Tag; 				}
Magic Number,NBitcoin.Scripting,ScriptToken,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptToken.cs,GetHashCode,The following statement contains a magic number: switch (Tag) 				{ 					case 26: 						{ 							Number number = (Number)this; 							num = 26; 							return -1640531527 + ((int)number.Item + ((num << 6) + (num >> 2))); 						} 					case 27: 						{ 							Hash160Hash hash160Hash = (Hash160Hash)this; 							num = 27; 							return -1640531527 + (hash160Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 28: 						{ 							Sha256Hash sha256Hash = (Sha256Hash)this; 							num = 28; 							return -1640531527 + (sha256Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 29: 						{ 							Pk pk = (Pk)this; 							num = 29; 							return -1640531527 + (pk.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					default: 						return Tag; 				}
Magic Number,NBitcoin.Scripting,ScriptToken,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptToken.cs,GetHashCode,The following statement contains a magic number: switch (Tag) 				{ 					case 26: 						{ 							Number number = (Number)this; 							num = 26; 							return -1640531527 + ((int)number.Item + ((num << 6) + (num >> 2))); 						} 					case 27: 						{ 							Hash160Hash hash160Hash = (Hash160Hash)this; 							num = 27; 							return -1640531527 + (hash160Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 28: 						{ 							Sha256Hash sha256Hash = (Sha256Hash)this; 							num = 28; 							return -1640531527 + (sha256Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 29: 						{ 							Pk pk = (Pk)this; 							num = 29; 							return -1640531527 + (pk.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					default: 						return Tag; 				}
Magic Number,NBitcoin.Scripting,ScriptToken,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptToken.cs,GetHashCode,The following statement contains a magic number: switch (Tag) 				{ 					case 26: 						{ 							Number number = (Number)this; 							num = 26; 							return -1640531527 + ((int)number.Item + ((num << 6) + (num >> 2))); 						} 					case 27: 						{ 							Hash160Hash hash160Hash = (Hash160Hash)this; 							num = 27; 							return -1640531527 + (hash160Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 28: 						{ 							Sha256Hash sha256Hash = (Sha256Hash)this; 							num = 28; 							return -1640531527 + (sha256Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 29: 						{ 							Pk pk = (Pk)this; 							num = 29; 							return -1640531527 + (pk.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					default: 						return Tag; 				}
Magic Number,NBitcoin.Scripting,ScriptToken,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptToken.cs,GetHashCode,The following statement contains a magic number: switch (Tag) 				{ 					case 26: 						{ 							Number number = (Number)this; 							num = 26; 							return -1640531527 + ((int)number.Item + ((num << 6) + (num >> 2))); 						} 					case 27: 						{ 							Hash160Hash hash160Hash = (Hash160Hash)this; 							num = 27; 							return -1640531527 + (hash160Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 28: 						{ 							Sha256Hash sha256Hash = (Sha256Hash)this; 							num = 28; 							return -1640531527 + (sha256Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 29: 						{ 							Pk pk = (Pk)this; 							num = 29; 							return -1640531527 + (pk.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					default: 						return Tag; 				}
Magic Number,NBitcoin.Scripting,ScriptToken,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptToken.cs,GetHashCode,The following statement contains a magic number: switch (Tag) 				{ 					case 26: 						{ 							Number number = (Number)this; 							num = 26; 							return -1640531527 + ((int)number.Item + ((num << 6) + (num >> 2))); 						} 					case 27: 						{ 							Hash160Hash hash160Hash = (Hash160Hash)this; 							num = 27; 							return -1640531527 + (hash160Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 28: 						{ 							Sha256Hash sha256Hash = (Sha256Hash)this; 							num = 28; 							return -1640531527 + (sha256Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 29: 						{ 							Pk pk = (Pk)this; 							num = 29; 							return -1640531527 + (pk.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					default: 						return Tag; 				}
Magic Number,NBitcoin.Scripting,ScriptToken,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptToken.cs,GetHashCode,The following statement contains a magic number: switch (Tag) 				{ 					case 26: 						{ 							Number number = (Number)this; 							num = 26; 							return -1640531527 + ((int)number.Item + ((num << 6) + (num >> 2))); 						} 					case 27: 						{ 							Hash160Hash hash160Hash = (Hash160Hash)this; 							num = 27; 							return -1640531527 + (hash160Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 28: 						{ 							Sha256Hash sha256Hash = (Sha256Hash)this; 							num = 28; 							return -1640531527 + (sha256Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 29: 						{ 							Pk pk = (Pk)this; 							num = 29; 							return -1640531527 + (pk.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					default: 						return Tag; 				}
Magic Number,NBitcoin.Scripting,ScriptToken,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptToken.cs,GetHashCode,The following statement contains a magic number: switch (Tag) 				{ 					case 26: 						{ 							Number number = (Number)this; 							num = 26; 							return -1640531527 + ((int)number.Item + ((num << 6) + (num >> 2))); 						} 					case 27: 						{ 							Hash160Hash hash160Hash = (Hash160Hash)this; 							num = 27; 							return -1640531527 + (hash160Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 28: 						{ 							Sha256Hash sha256Hash = (Sha256Hash)this; 							num = 28; 							return -1640531527 + (sha256Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 29: 						{ 							Pk pk = (Pk)this; 							num = 29; 							return -1640531527 + (pk.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					default: 						return Tag; 				}
Magic Number,NBitcoin.Scripting,ScriptToken,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptToken.cs,GetHashCode,The following statement contains a magic number: switch (Tag) 				{ 					case 26: 						{ 							Number number = (Number)this; 							num = 26; 							return -1640531527 + ((int)number.Item + ((num << 6) + (num >> 2))); 						} 					case 27: 						{ 							Hash160Hash hash160Hash = (Hash160Hash)this; 							num = 27; 							return -1640531527 + (hash160Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 28: 						{ 							Sha256Hash sha256Hash = (Sha256Hash)this; 							num = 28; 							return -1640531527 + (sha256Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 29: 						{ 							Pk pk = (Pk)this; 							num = 29; 							return -1640531527 + (pk.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					default: 						return Tag; 				}
Magic Number,NBitcoin.Scripting,ScriptToken,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptToken.cs,GetHashCode,The following statement contains a magic number: switch (Tag) 				{ 					case 26: 						{ 							Number number = (Number)this; 							num = 26; 							return -1640531527 + ((int)number.Item + ((num << 6) + (num >> 2))); 						} 					case 27: 						{ 							Hash160Hash hash160Hash = (Hash160Hash)this; 							num = 27; 							return -1640531527 + (hash160Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 28: 						{ 							Sha256Hash sha256Hash = (Sha256Hash)this; 							num = 28; 							return -1640531527 + (sha256Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 29: 						{ 							Pk pk = (Pk)this; 							num = 29; 							return -1640531527 + (pk.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					default: 						return Tag; 				}
Magic Number,NBitcoin.Scripting,ScriptToken,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptToken.cs,GetHashCode,The following statement contains a magic number: switch (Tag) 				{ 					case 26: 						{ 							Number number = (Number)this; 							num = 26; 							return -1640531527 + ((int)number.Item + ((num << 6) + (num >> 2))); 						} 					case 27: 						{ 							Hash160Hash hash160Hash = (Hash160Hash)this; 							num = 27; 							return -1640531527 + (hash160Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 28: 						{ 							Sha256Hash sha256Hash = (Sha256Hash)this; 							num = 28; 							return -1640531527 + (sha256Hash.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					case 29: 						{ 							Pk pk = (Pk)this; 							num = 29; 							return -1640531527 + (pk.Item.GetHashCode()) + ((num << 6) + (num >> 2)); 						} 					default: 						return Tag; 				}
Magic Number,NBitcoin.Scripting,ScriptToken,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptToken.cs,Equals,The following statement contains a magic number: switch (Tag) 						{ 							case 26: 								{ 									Number number = (Number)this; 									Number number2 = (Number)obj; 									return number.Item == number2.Item; 								} 							case 27: 								{ 									Hash160Hash hash160Hash = (Hash160Hash)this; 									Hash160Hash hash160Hash2 = (Hash160Hash)obj; 									return hash160Hash.Item == hash160Hash2.Item; 								} 							case 28: 								{ 									Sha256Hash sha256Hash = (Sha256Hash)this; 									Sha256Hash sha256Hash2 = (Sha256Hash)obj; 									return sha256Hash.Item == sha256Hash2.Item; 								} 							case 29: 								{ 									Pk pk = (Pk)this; 									Pk pk2 = (Pk)obj; 									return pk.Item == pk2.Item; 								} 							default: 								return true; 						}
Magic Number,NBitcoin.Scripting,ScriptToken,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptToken.cs,Equals,The following statement contains a magic number: switch (Tag) 						{ 							case 26: 								{ 									Number number = (Number)this; 									Number number2 = (Number)obj; 									return number.Item == number2.Item; 								} 							case 27: 								{ 									Hash160Hash hash160Hash = (Hash160Hash)this; 									Hash160Hash hash160Hash2 = (Hash160Hash)obj; 									return hash160Hash.Item == hash160Hash2.Item; 								} 							case 28: 								{ 									Sha256Hash sha256Hash = (Sha256Hash)this; 									Sha256Hash sha256Hash2 = (Sha256Hash)obj; 									return sha256Hash.Item == sha256Hash2.Item; 								} 							case 29: 								{ 									Pk pk = (Pk)this; 									Pk pk2 = (Pk)obj; 									return pk.Item == pk2.Item; 								} 							default: 								return true; 						}
Magic Number,NBitcoin.Scripting,ScriptToken,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptToken.cs,Equals,The following statement contains a magic number: switch (Tag) 						{ 							case 26: 								{ 									Number number = (Number)this; 									Number number2 = (Number)obj; 									return number.Item == number2.Item; 								} 							case 27: 								{ 									Hash160Hash hash160Hash = (Hash160Hash)this; 									Hash160Hash hash160Hash2 = (Hash160Hash)obj; 									return hash160Hash.Item == hash160Hash2.Item; 								} 							case 28: 								{ 									Sha256Hash sha256Hash = (Sha256Hash)this; 									Sha256Hash sha256Hash2 = (Sha256Hash)obj; 									return sha256Hash.Item == sha256Hash2.Item; 								} 							case 29: 								{ 									Pk pk = (Pk)this; 									Pk pk2 = (Pk)obj; 									return pk.Item == pk2.Item; 								} 							default: 								return true; 						}
Magic Number,NBitcoin.Scripting,ScriptToken,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptToken.cs,Equals,The following statement contains a magic number: switch (Tag) 						{ 							case 26: 								{ 									Number number = (Number)this; 									Number number2 = (Number)obj; 									return number.Item == number2.Item; 								} 							case 27: 								{ 									Hash160Hash hash160Hash = (Hash160Hash)this; 									Hash160Hash hash160Hash2 = (Hash160Hash)obj; 									return hash160Hash.Item == hash160Hash2.Item; 								} 							case 28: 								{ 									Sha256Hash sha256Hash = (Sha256Hash)this; 									Sha256Hash sha256Hash2 = (Sha256Hash)obj; 									return sha256Hash.Item == sha256Hash2.Item; 								} 							case 29: 								{ 									Pk pk = (Pk)this; 									Pk pk2 = (Pk)obj; 									return pk.Item == pk2.Item; 								} 							default: 								return true; 						}
Magic Number,NBitcoin.Socks,SocksException,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksException.cs,GetMessageForCode,The following statement contains a magic number: switch (errorCode) 			{ 				case 0: 					return "Success"; 				case 1: 					return "general SOCKS server failure"; 				case 2: 					return "connection not allowed by ruleset"; 				case 3: 					return "Network unreachable"; 				case 4: 					return "Host unreachable"; 				case 5: 					return "Connection refused"; 				case 6: 					return "TTL expired"; 				case 7: 					return "Command not supported"; 				case 8: 					return "Address type not supported"; 				default: 					return "Unknown code"; 			}
Magic Number,NBitcoin.Socks,SocksException,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksException.cs,GetMessageForCode,The following statement contains a magic number: switch (errorCode) 			{ 				case 0: 					return "Success"; 				case 1: 					return "general SOCKS server failure"; 				case 2: 					return "connection not allowed by ruleset"; 				case 3: 					return "Network unreachable"; 				case 4: 					return "Host unreachable"; 				case 5: 					return "Connection refused"; 				case 6: 					return "TTL expired"; 				case 7: 					return "Command not supported"; 				case 8: 					return "Address type not supported"; 				default: 					return "Unknown code"; 			}
Magic Number,NBitcoin.Socks,SocksException,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksException.cs,GetMessageForCode,The following statement contains a magic number: switch (errorCode) 			{ 				case 0: 					return "Success"; 				case 1: 					return "general SOCKS server failure"; 				case 2: 					return "connection not allowed by ruleset"; 				case 3: 					return "Network unreachable"; 				case 4: 					return "Host unreachable"; 				case 5: 					return "Connection refused"; 				case 6: 					return "TTL expired"; 				case 7: 					return "Command not supported"; 				case 8: 					return "Address type not supported"; 				default: 					return "Unknown code"; 			}
Magic Number,NBitcoin.Socks,SocksException,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksException.cs,GetMessageForCode,The following statement contains a magic number: switch (errorCode) 			{ 				case 0: 					return "Success"; 				case 1: 					return "general SOCKS server failure"; 				case 2: 					return "connection not allowed by ruleset"; 				case 3: 					return "Network unreachable"; 				case 4: 					return "Host unreachable"; 				case 5: 					return "Connection refused"; 				case 6: 					return "TTL expired"; 				case 7: 					return "Command not supported"; 				case 8: 					return "Address type not supported"; 				default: 					return "Unknown code"; 			}
Magic Number,NBitcoin.Socks,SocksException,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksException.cs,GetMessageForCode,The following statement contains a magic number: switch (errorCode) 			{ 				case 0: 					return "Success"; 				case 1: 					return "general SOCKS server failure"; 				case 2: 					return "connection not allowed by ruleset"; 				case 3: 					return "Network unreachable"; 				case 4: 					return "Host unreachable"; 				case 5: 					return "Connection refused"; 				case 6: 					return "TTL expired"; 				case 7: 					return "Command not supported"; 				case 8: 					return "Address type not supported"; 				default: 					return "Unknown code"; 			}
Magic Number,NBitcoin.Socks,SocksException,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksException.cs,GetMessageForCode,The following statement contains a magic number: switch (errorCode) 			{ 				case 0: 					return "Success"; 				case 1: 					return "general SOCKS server failure"; 				case 2: 					return "connection not allowed by ruleset"; 				case 3: 					return "Network unreachable"; 				case 4: 					return "Host unreachable"; 				case 5: 					return "Connection refused"; 				case 6: 					return "TTL expired"; 				case 7: 					return "Command not supported"; 				case 8: 					return "Address type not supported"; 				default: 					return "Unknown code"; 			}
Magic Number,NBitcoin.Socks,SocksException,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksException.cs,GetMessageForCode,The following statement contains a magic number: switch (errorCode) 			{ 				case 0: 					return "Success"; 				case 1: 					return "general SOCKS server failure"; 				case 2: 					return "connection not allowed by ruleset"; 				case 3: 					return "Network unreachable"; 				case 4: 					return "Host unreachable"; 				case 5: 					return "Connection refused"; 				case 6: 					return "TTL expired"; 				case 7: 					return "Command not supported"; 				case 8: 					return "Address type not supported"; 				default: 					return "Unknown code"; 			}
Magic Number,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,CreateConnectMessage,The following statement contains a magic number: dns.Host.Length > 255
Magic Number,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,CreateConnectMessage,The following statement contains a magic number: sendBuffer = new byte[4 + 1 + dns.Host.Length + 2];
Magic Number,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,CreateConnectMessage,The following statement contains a magic number: sendBuffer = new byte[4 + 1 + dns.Host.Length + 2];
Magic Number,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,CreateConnectMessage,The following statement contains a magic number: sendBuffer[0] = 5;
Magic Number,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,CreateConnectMessage,The following statement contains a magic number: sendBuffer[2] = 0;
Magic Number,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,CreateConnectMessage,The following statement contains a magic number: sendBuffer[3] = 3;
Magic Number,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,CreateConnectMessage,The following statement contains a magic number: sendBuffer[3] = 3;
Magic Number,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,CreateConnectMessage,The following statement contains a magic number: sendBuffer[4] = (byte)dns.Host.Length;
Magic Number,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,CreateConnectMessage,The following statement contains a magic number: Encoding.ASCII.GetBytes(dns.Host' 0' dns.Host.Length' sendBuffer' 5);
Magic Number,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,CreateConnectMessage,The following statement contains a magic number: sendBuffer[sendBuffer.Length - 2] = (byte)((port & 0xff00) >> 8);
Magic Number,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,CreateConnectMessage,The following statement contains a magic number: sendBuffer[sendBuffer.Length - 2] = (byte)((port & 0xff00) >> 8);
Magic Number,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,Handshake,The following statement contains a magic number: var selectionResponse = new byte[2];
Magic Number,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,Handshake,The following statement contains a magic number: await stream.ReadAsync(selectionResponse' 0' 2).WithCancellation(cancellationToken).ConfigureAwait(false);
Magic Number,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,Handshake,The following statement contains a magic number: selectionResponse[0] != 5
Magic Number,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,Handshake,The following statement contains a magic number: uName.Length > 255
Magic Number,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,Handshake,The following statement contains a magic number: passwd.Length > 255
Magic Number,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,Handshake,The following statement contains a magic number: var userNamePasswordResponse = new byte[2];
Magic Number,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,Handshake,The following statement contains a magic number: await stream.ReadAsync(userNamePasswordResponse' 0' 2).WithCancellation(cancellationToken).ConfigureAwait(false);
Magic Number,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,Handshake,The following statement contains a magic number: selectionResponse[1] == 2
Magic Number,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,Handshake,The following statement contains a magic number: var connectResponse = new byte[10];
Magic Number,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,Handshake,The following statement contains a magic number: await stream.ReadAsync(connectResponse' 0' 10).WithCancellation(cancellationToken).ConfigureAwait(false);
Magic Number,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,Handshake,The following statement contains a magic number: connectResponse[0] != 5
Magic Number,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,Handshake,The following statement contains a magic number: connectResponse[2] != 0
Magic Number,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,Handshake,The following statement contains a magic number: connectResponse[3] != 1
Magic Number,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,Handshake,The following statement contains a magic number: i < 4 + 4
Magic Number,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,Handshake,The following statement contains a magic number: i < 4 + 4
Magic Number,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,Handshake,The following statement contains a magic number: connectResponse[8] != 0 || connectResponse[9] != 0
Magic Number,NBitcoin.Socks,SocksHelper,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Socks\SocksHelper.cs,Handshake,The following statement contains a magic number: connectResponse[8] != 0 || connectResponse[9] != 0
Magic Number,NBitcoin.Stealth,BitField,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Stealth\BitcoinStealthAddress.cs,BitField,The following statement contains a magic number: var numberBits = Math.Min(8' bitleft);
Magic Number,NBitcoin.Stealth,BitField,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Stealth\BitcoinStealthAddress.cs,GetPrefixByteLength,The following statement contains a magic number: bitcount > 32
Magic Number,NBitcoin.Stealth,BitField,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Stealth\BitcoinStealthAddress.cs,GetPrefixByteLength,The following statement contains a magic number: return Math.Min(4' bitcount / 8 + 1);
Magic Number,NBitcoin.Stealth,BitField,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Stealth\BitcoinStealthAddress.cs,GetPrefixByteLength,The following statement contains a magic number: return Math.Min(4' bitcount / 8 + 1);
Magic Number,NBitcoin.Stealth,BitField,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Stealth\BitcoinStealthAddress.cs,GetEncodedForm,The following statement contains a magic number: var encoded =  				_Rawform.Length == 4 ? _Rawform : _Rawform.Concat(new byte[4 - _Rawform.Length]).ToArray();
Magic Number,NBitcoin.Stealth,BitField,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Stealth\BitcoinStealthAddress.cs,GetEncodedForm,The following statement contains a magic number: var encoded =  				_Rawform.Length == 4 ? _Rawform : _Rawform.Concat(new byte[4 - _Rawform.Length]).ToArray();
Magic Number,NBitcoin.Stealth,BitField,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Stealth\BitcoinStealthAddress.cs,Match,The following statement contains a magic number: data.Length * 8 < _BitCount
Magic Number,NBitcoin.Stealth,BitcoinStealthAddress,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Stealth\BitcoinStealthAddress.cs,GenerateBytes,The following statement contains a magic number: ms.Write(scanKey.Compress().ToBytes()' 0' 33);
Magic Number,NBitcoin.Stealth,BitcoinStealthAddress,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Stealth\BitcoinStealthAddress.cs,GenerateBytes,The following statement contains a magic number: ms.Write(key.Compress().ToBytes()' 0' 33);
Magic Number,NBitcoin.Stealth,StealthMetadata,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Stealth\StealthMetadata.cs,StealthMetadata,The following statement contains a magic number: data.WriteByte(6);
Magic Number,NBitcoin.Stealth,StealthMetadata,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Stealth\StealthMetadata.cs,StealthMetadata,The following statement contains a magic number: data.Write(ephemKey.PubKey.Compress().ToBytes()' 0' 33);
Magic Number,NBitcoin.Stealth,StealthMetadata,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Stealth\StealthMetadata.cs,Fill,The following statement contains a magic number: data == null || data.Length != 1 + 4 + 33
Magic Number,NBitcoin.Stealth,StealthMetadata,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Stealth\StealthMetadata.cs,Fill,The following statement contains a magic number: data == null || data.Length != 1 + 4 + 33
Magic Number,NBitcoin.Stealth,StealthMetadata,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Stealth\StealthMetadata.cs,Fill,The following statement contains a magic number: output.Version != 6
Magic Number,NBitcoin.Stealth,StealthMetadata,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Stealth\StealthMetadata.cs,Fill,The following statement contains a magic number: output.Nonce = ms.ReadBytes(4);
Magic Number,NBitcoin.Stealth,StealthMetadata,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Stealth\StealthMetadata.cs,Fill,The following statement contains a magic number: output.EphemKey = new PubKey(ms.ReadBytes(33));
Magic Number,NBitcoin.Stealth,StealthMetadata,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Stealth\StealthMetadata.cs,Fill,The following statement contains a magic number: output.BitField = Utils.ToUInt32(msprefix.ReadBytes(4)' true);
Duplicate Code,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The method contains a code clone-set at the following line numbers (starting from the method definition): ((7' 38)' (41' 104))
Duplicate Code,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The method contains a code clone-set at the following line numbers (starting from the method definition): ((7' 26)' (57' 76)' (73' 92)' (41' 60))
Duplicate Code,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,Finalize,The method contains a code clone-set at the following line numbers (starting from the method definition): ((41' 75)' (57' 91))
Duplicate Code,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The method contains a code clone-set at the following line numbers (starting from the method definition): ((9' 42)' (45' 78)' (81' 114)' (117' 150))
Duplicate Code,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The method contains a code clone-set at the following line numbers (starting from the method definition): ((9' 41)' (152' 184)' (187' 251)' (45' 77)' (81' 113)' (117' 149))
Duplicate Code,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The method contains a code clone-set at the following line numbers (starting from the method definition): ((9' 28)' (203' 222)' (219' 238)' (45' 64)' (81' 100)' (117' 136)' (152' 171)' (187' 206))
Duplicate Code,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The method contains a code clone-set at the following line numbers (starting from the method definition): ((187' 221)' (203' 237))
Duplicate Code,NBitcoin.Crypto,SipHasher,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,SipHashUint256,The method contains a code clone-set at the following line numbers (starting from the method definition): ((44' 63)' (80' 99)' (116' 135))
Missing Default,NBitcoin,Bitcoin,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Bitcoin.cs,GetNetwork,The following switch statement is missing a default case: switch (networkType) 			{ 				case NetworkType.Mainnet: 					return Mainnet; 				case NetworkType.Testnet: 					return Testnet; 				case NetworkType.Regtest: 					return Regtest; 			}
Missing Default,NBitcoin,BitcoinFormatter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Money.cs,Format,The following switch statement is missing a default case: switch (unit)  			{  				case 'B':  					unitToUseInCalc = MoneyUnit.BTC;  					break;  			}
Missing Default,NBitcoin,Network,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Network.cs,GetNetwork,The following switch statement is missing a default case: switch (name)  			{  				case "main":  				case "btc-mainnet":  				case "mainnet":  					return Network.Main;  				case "testnet":  				case "btc-testnet":  				case "test":  				case "testnet3":  					return Network.TestNet;  				case "reg":  				case "btc-regtest":  				case "regtest":  				case "regnet":  					return Network.RegTest;  			}
Missing Default,NBitcoin,NetworkSetBase,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\NetworkSet.cs,GetNetwork,The following switch statement is missing a default case: switch (networkType) 			{ 				case NetworkType.Mainnet: 					return Mainnet; 				case NetworkType.Testnet: 					return Testnet; 				case NetworkType.Regtest: 					return Regtest; 			}
Missing Default,NBitcoin,ScriptCompressor,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Transaction.cs,Decompress,The following switch statement is missing a default case: switch (nSize)  			{  				case 0x00:  					return PayToPubkeyHashTemplate.Instance.GenerateScriptPubKey(new KeyId(data.SafeSubarray(0' 20)));  				case 0x01:  					return PayToScriptHashTemplate.Instance.GenerateScriptPubKey(new ScriptId(data.SafeSubarray(0' 20)));  				case 0x02:  				case 0x03:  					var keyPart = data.SafeSubarray(0' 32);  					var keyBytes = new byte[33];  					keyBytes[0] = (byte)nSize;  					Array.Copy(keyPart' 0' keyBytes' 1' 32);  					return PayToPubkeyTemplate.Instance.GenerateScriptPubKey(keyBytes);  				case 0x04:  				case 0x05:  					byte[] vch = new byte[33];  					vch[0] = (byte)(nSize - 2);  					Array.Copy(data' 0' vch' 1' 32);  					PubKey pubkey = new PubKey(vch' true);  					pubkey = pubkey.Decompress();  					return PayToPubkeyTemplate.Instance.GenerateScriptPubKey(pubkey);  			}
Missing Default,NBitcoin.BouncyCastle.Asn1,Asn1InputStream,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\asn1\Asn1InputStream.cs,CreatePrimitiveDerObject,The following switch statement is missing a default case: switch (tagNo)  			{  				case Asn1Tags.Boolean:  					throw new IOException("invalid ECDSA sig");  				case Asn1Tags.Enumerated:  					throw new IOException("invalid ECDSA sig");  				case Asn1Tags.ObjectIdentifier:  					throw new IOException("invalid ECDSA sig");  			}
Missing Default,NBitcoin.BouncyCastle.Math,BigInteger,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\BigInteger.cs,ToString,The following switch statement is missing a default case: switch (radix)  			{  				case 2:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 2));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 2)' 32);  						}  						break;  					}  				case 8:  					{  						int mask = (1 << 30) - 1;  						BigInteger u = this.Abs();  						int bits = u.BitLength;  						IList S = Platform.CreateArrayList();  						while (bits > 30)  						{  							S.Add(Convert.ToString(u.IntValue & mask' 8));  							u = u.ShiftRight(30);  							bits -= 30;  						}  						sb.Append(Convert.ToString(u.IntValue' 8));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' 10);  						}  						break;  					}  				case 16:  					{  						int pos = firstNonZero;  						sb.Append(Convert.ToString(magnitude[pos]' 16));  						while (++pos < magnitude.Length)  						{  							AppendZeroExtendedString(sb' Convert.ToString(magnitude[pos]' 16)' 8);  						}  						break;  					}  				// TODO This could work for other radices if there is an alternative to Convert.ToString method  				//default:  				case 10:  					{  						BigInteger q = this.Abs();  						if (q.BitLength < 64)  						{  							sb.Append(Convert.ToString(q.LongValue' radix));  							break;  						}    						// Based on algorithm 1a from chapter 4.4 in Seminumerical Algorithms (Knuth)    						// Work out the largest power of 'rdx' that is a positive 64-bit integer  						// TODO possibly cache power/exponent against radix?  						long limit = Int64.MaxValue / radix;  						long power = radix;  						int exponent = 1;  						while (power <= limit)  						{  							power *= radix;  							++exponent;  						}    						BigInteger bigPower = BigInteger.ValueOf(power);    						IList S = Platform.CreateArrayList();  						while (q.CompareTo(bigPower) >= 0)  						{  							BigInteger[] qr = q.DivideAndRemainder(bigPower);  							S.Add(Convert.ToString(qr[1].LongValue' radix));  							q = qr[0];  						}    						sb.Append(Convert.ToString(q.LongValue' radix));  						for (int i = S.Count - 1; i >= 0; --i)  						{  							AppendZeroExtendedString(sb' (string)S[i]' exponent);  						}  						break;  					}  			}
Missing Default,NBitcoin.BouncyCastle.Math.EC,ECCurve,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECCurve.cs,NormalizeAll,The following switch statement is missing a default case: switch (this.CoordinateSystem) 			{ 				case ECCurve.COORD_AFFINE: 				case ECCurve.COORD_LAMBDA_AFFINE: 					{ 						if (iso != null) 							throw new ArgumentException("not valid for affine coordinates"' "iso");  						return; 					} 			}
Missing Default,NBitcoin.BouncyCastle.Math.EC,FpPoint,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\ECPoint.cs,TimesPow2,The following switch statement is missing a default case: switch (coord) 				{ 					case ECCurve.COORD_HOMOGENEOUS: 						ECFieldElement Z1Sq = Z1.Square(); 						X1 = X1.Multiply(Z1); 						Y1 = Y1.Multiply(Z1Sq); 						W1 = CalculateJacobianModifiedW(Z1' Z1Sq); 						break; 					case ECCurve.COORD_JACOBIAN: 						W1 = CalculateJacobianModifiedW(Z1' null); 						break; 					case ECCurve.COORD_JACOBIAN_MODIFIED: 						W1 = GetJacobianModifiedW(); 						break; 				}
Missing Default,NBitcoin.BouncyCastle.Math.EC.Multiplier,WNafUtilities,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\ec\multiplier\WNafUtilities.cs,Precompute,The following switch statement is missing a default case: switch (c.CoordinateSystem)  								{  									case ECCurve.COORD_JACOBIAN:  									case ECCurve.COORD_JACOBIAN_CHUDNOVSKY:  									case ECCurve.COORD_JACOBIAN_MODIFIED:  										{  											iso = twiceP.GetZCoord(0);  											twiceP = c.CreatePoint(twiceP.XCoord.ToBigInteger()'  												twiceP.YCoord.ToBigInteger());    											ECFieldElement iso2 = iso.Square()' iso3 = iso2.Multiply(iso);  											last = last.ScaleX(iso2).ScaleY(iso3);    											if (iniPreCompLen == 0)  											{  												preComp[0] = last;  											}  											break;  										}  								}
Missing Default,NBitcoin.BouncyCastle.Math.Field,FiniteFields,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\BouncyCastle\math\field\FiniteFields.cs,GetPrimeField,The following switch statement is missing a default case: switch (characteristic.IntValue)  				{  					case 2:  						return GF_2;  					case 3:  						return GF_3;  				}
Missing Default,NBitcoin.Crypto,Hashes,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Crypto\Hashes.cs,MurmurHash3,The following switch statement is missing a default case: switch (chunk.Length)  					{  						case 4:  							/* Get four bytes from the input into an uint */  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16  							| chunk[3] << 24);    							/* bitmagic hash */  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;    							h1 ^= k1;  							h1 = rotl32(h1' 13);  							h1 = h1 * 5 + 0xe6546b64;  							break;  						case 3:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8  							| chunk[2] << 16);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 2:  							k1 = (uint)  							(chunk[0]  							| chunk[1] << 8);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  						case 1:  							k1 = (uint)(chunk[0]);  							k1 *= c1;  							k1 = rotl32(k1' 15);  							k1 *= c2;  							h1 ^= k1;  							break;  					}
Missing Default,NBitcoin.DataEncoders,DataEncoder,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\DataEncoders\Encoders.cs,IsSpace,The following switch statement is missing a default case: switch (c)  			{  				case ' ':  				case '\t':  				case '\n':  				case '\v':  				case '\f':  				case '\r':  					return true;  			}
Missing Default,NBitcoin.RPC,SatoshiFormatter,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\RPC\SatoshiFormatter.cs,GetScriptType,The following switch statement is missing a default case: switch (template.Type)  			{  				case TxOutType.TX_PUBKEY:  					return "pubkey";  				case TxOutType.TX_PUBKEYHASH:  					return "pubkeyhash";  				case TxOutType.TX_SCRIPTHASH:  					return "scripthash";  				case TxOutType.TX_MULTISIG:  					return "multisig";  				case TxOutType.TX_NULL_DATA:  					return "nulldata";  			}
Missing Default,NBitcoin.Scripting,ScriptToken,C:\research\architectureSmells\repos\NicolasDorier_NBitcoin\NBitcoin\Scripting\ScriptToken.cs,ToString,The following switch statement is missing a default case: switch (this.Tag) 			{ 				case Tags.BoolAnd: 					return "BoolAnd"; 				case Tags.BoolOr: 					return "BoolAnd"; 				case Tags.Add: 					return "Add"; 				case Tags.Equal: 					return "Equal"; 				case Tags.EqualVerify: 					return "EqualVerify"; 				case Tags.CheckSig: 					return "CheckSig"; 				case Tags.CheckSigVerify: 					return "CheckSigVerify"; 				case Tags.CheckMultiSig: 					return "CheckMultiSig"; 				case Tags.CheckMultiSigVerify: 					return "CheckMultiSigVerify"; 				case Tags.CheckSequenceVerify: 					return "CheckSequenceVerify"; 				case Tags.FromAltStack: 					return "FromAltStack"; 				case Tags.ToAltStack: 					return "ToAltStack"; 				case Tags.Drop: 					return "Drop"; 				case Tags.Dup: 					return "Dup"; 				case Tags.If: 					return "If"; 				case Tags.IfDup: 					return "IfDup"; 				case Tags.NotIf: 					return "NotIf"; 				case Tags.Else: 					return "Else"; 				case Tags.EndIf: 					return "EndIf"; 				case Tags.ZeroNotEqual: 					return "ZeroNotEqual"; 				case Tags.Size: 					return "Size"; 				case Tags.Swap: 					return "Swap"; 				case Tags.Verify: 					return "Verify"; 				case Tags.Hash160: 					return "Hash160"; 				case Tags.Sha256: 					return "Sha256"; 				case Tags.Number: 					var n = ((Number)this).Item; 					return $"Number({n})"; 				case Tags.Hash160Hash: 					var hash160 = ((Hash160Hash)this).Item; 					return $"Hash160Hash({hash160})"; 				case Tags.Sha256Hash: 					var sha256 = ((Sha256Hash)this).Item; 					return $"Sha256Hash({sha256})"; 				case Tags.Pk: 					var pk = ((Pk)this).Item; 					return $"Pk({pk})"; 			}
