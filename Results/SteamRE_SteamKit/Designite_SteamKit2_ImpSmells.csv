Implementation smell,Namespace,Class,File,Method,Description
Long Method,SevenZip.Compression.LZMA,Decoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaDecoder.cs,Code,The method has 114 lines of code.
Long Method,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The method has 453 lines of code.
Long Method,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The method has 160 lines of code.
Long Method,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The method has 103 lines of code.
Long Method,SevenZip.Compression.LZ,BinTree,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,The method has 125 lines of code.
Complex Method,SteamKit2,UdpConnection,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\UdpConnection.cs,NetLoop,Cyclomatic complexity of the method is 10
Complex Method,SteamKit2,CDNClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CDNClient.cs,FetchServerListAsync,Cyclomatic complexity of the method is 10
Complex Method,SteamKit2,KVTextReader,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Types\KeyValue.cs,ReadToken,Cyclomatic complexity of the method is 17
Complex Method,SteamKit2,KeyValue,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Types\KeyValue.cs,RecursiveLoadFromBuffer,Cyclomatic complexity of the method is 8
Complex Method,SteamKit2,SteamID,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Types\SteamID.cs,SetFromSteam3String,Cyclomatic complexity of the method is 9
Complex Method,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,Cyclomatic complexity of the method is 58
Complex Method,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,Cyclomatic complexity of the method is 15
Complex Method,SevenZip.Compression.LZ,BinTree,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,Cyclomatic complexity of the method is 21
Long Parameter List,SteamKit2,CDNClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CDNClient.cs,DownloadManifestAsync,The method has 5 parameters. Parameters: depotId' manifestId' host' cdnAuthToken' depotKey
Long Parameter List,SteamKit2,CDNClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CDNClient.cs,DownloadDepotChunkAsync,The method has 5 parameters. Parameters: depotId' chunk' host' cdnAuthToken' depotKey
Long Parameter List,SteamKit2,CDNClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CDNClient.cs,DoRawCommandAsync,The method has 7 parameters. Parameters: server' method' command' data' doAuth' args' authtoken
Long Parameter List,SteamKit2,CDNClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CDNClient.cs,DoCommandAsync,The method has 7 parameters. Parameters: server' method' command' data' doAuth' args' authtoken
Long Parameter List,SteamKit2,CDNClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CDNClient.cs,DownloadManifestCoreAsync,The method has 5 parameters. Parameters: depotId' manifestId' server' cdnAuthToken' depotKey
Long Parameter List,SteamKit2,CDNClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CDNClient.cs,DownloadDepotChunkCoreAsync,The method has 5 parameters. Parameters: depotId' chunk' server' cdnAuthToken' depotKey
Long Parameter List,SteamKit2,SteamUserStats,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\Handlers\SteamUserStats\Callbacks.cs,GetLeaderboardEntries,The method has 5 parameters. Parameters: appId' id' rangeStart' rangeEnd' dataRequest
Long Parameter List,SteamKit2,ChunkData,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Types\DepotManifest.cs,ChunkData,The method has 5 parameters. Parameters: id' checksum' offset' comp_length' uncomp_length
Long Parameter List,SteamKit2,FileData,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Types\DepotManifest.cs,FileData,The method has 6 parameters. Parameters: filename' flag' size' hash' encrypted' numChunks
Long Parameter List,SteamKit2,Crc32,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Crc32.cs,CalculateHash,The method has 5 parameters. Parameters: table' seed' buffer' start' size
Long Parameter List,SteamKit2,ZipUtil,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\ZipUtil.cs,WriteCentralDirectory,The method has 6 parameters. Parameters: writer' fileName' CRC' compressedSize' decompressedSize' localHeaderOffset
Long Parameter List,SteamKit2,ZipUtil,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\ZipUtil.cs,WriteLocalFile,The method has 5 parameters. Parameters: writer' fileName' CRC' decompressedSize' processedBuffer
Long Parameter List,SevenZip,ICoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\ICoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,SevenZip.Compression.LZMA,Decoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaDecoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,SevenZip.Compression.RangeCoder,BitTreeEncoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\RangeCoder\RangeCoderBitTree.cs,ReverseEncode,The method has 5 parameters. Parameters: Models' startIndex' rangeEncoder' NumBitLevels' symbol
Long Parameter List,SteamKit2.Util,NativeMethods,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Win32Helpers.cs,CreateFile,The method has 7 parameters. Parameters: lpFileName' dwDesiredAccess' dwShareMode' lpSecurityAttributes' dwCreationDisposition' dwFlagsAndAttributes' hTemplateFile
Long Parameter List,SteamKit2.Util,NativeMethods,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Win32Helpers.cs,DeviceIoControl,The method has 8 parameters. Parameters: hDevice' dwIoControlCode' lpInBuffer' nInBufferSize' lpOutBuffer' nOutBufferSize' lpBytesReturned' lpOverlapped
Long Identifier,SteamKit2.Internal,MsgClientLogon,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamLanguageInternal.cs,,The length of the parameter ProtocolVerMinorMinGameServers is 30.
Long Identifier,SteamKit2.Internal,MsgClientLogon,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamLanguageInternal.cs,,The length of the parameter ProtocolVerMinorMinForSupportingEMsgMulti is 41.
Long Identifier,SteamKit2.Internal,MsgClientLogon,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamLanguageInternal.cs,,The length of the parameter ProtocolVerMinorMinForSupportingEMsgClientEncryptPct is 52.
Long Identifier,SteamKit2.Internal,MsgClientLogon,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamLanguageInternal.cs,,The length of the parameter ProtocolVerMinorMinForExtendedMsgHdr is 36.
Long Identifier,SteamKit2.Internal,MsgClientLogon,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamLanguageInternal.cs,,The length of the parameter ProtocolVerMinorMinForSessionIDLast is 35.
Long Identifier,SteamKit2.Internal,MsgClientLogon,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamLanguageInternal.cs,,The length of the parameter ProtocolVerMinorMinForServerAvailablityMsgs is 43.
Long Identifier,SteamKit2.Internal,MsgClientLogon,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamLanguageInternal.cs,,The length of the parameter ProtocolVerMinorMinForCegApplyPESig is 35.
Long Identifier,SteamKit2.Internal,MsgClientLogon,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamLanguageInternal.cs,,The length of the parameter ProtocolVerMinorMinForMarketingMessages2 is 40.
Long Identifier,SteamKit2.Internal,MsgClientLogon,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamLanguageInternal.cs,,The length of the parameter ProtocolVerMinorMinForAnyProtoBufMessages is 41.
Long Identifier,SteamKit2.Internal,MsgClientLogon,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamLanguageInternal.cs,,The length of the parameter ProtocolVerMinorMinForProtoBufLoggedOffMessage is 46.
Long Identifier,SteamKit2.Internal,MsgClientLogon,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamLanguageInternal.cs,,The length of the parameter ProtocolVerMinorMinForProtoBufMultiMessages is 43.
Long Identifier,SteamKit2.Internal,MsgClientLogon,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamLanguageInternal.cs,,The length of the parameter ProtocolVerMinorMinForSendingProtocolToUFS is 42.
Long Identifier,SteamKit2.Internal,MsgClientLogon,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamLanguageInternal.cs,,The length of the parameter ProtocolVerMinorMinForMachineAuth is 33.
Long Identifier,SteamKit2.Internal,MsgClientLogon,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamLanguageInternal.cs,,The length of the parameter ProtocolVerMinorMinForSessionIDLastAnon is 39.
Long Identifier,SteamKit2.Internal,MsgClientLogon,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamLanguageInternal.cs,,The length of the parameter ProtocolVerMinorMinForEnhancedAppList is 37.
Long Identifier,SteamKit2.Internal,MsgClientLogon,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamLanguageInternal.cs,,The length of the parameter ProtocolVerMinorMinForSteamGuardNotificationUI is 46.
Long Identifier,SteamKit2.Internal,MsgClientLogon,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamLanguageInternal.cs,,The length of the parameter ProtocolVerMinorMinForProtoBufServiceModuleCalls is 48.
Long Identifier,SteamKit2.Internal,MsgClientLogon,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamLanguageInternal.cs,,The length of the parameter ProtocolVerMinorMinForGzipMultiMessages is 39.
Long Identifier,SteamKit2.Internal,MsgClientLogon,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamLanguageInternal.cs,,The length of the parameter ProtocolVerMinorMinForNewVoiceCallAuthorize is 43.
Long Identifier,SteamKit2.Internal,MsgClientLogon,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamLanguageInternal.cs,,The length of the parameter ProtocolVerMinorMinForClientInstanceIDs is 39.
Long Identifier,SteamKit2.Internal,EncryptedAppTicket,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamMsgAppTicket.cs,,The length of the parameter _cb_encrypted_appownershipticket is 32.
Long Identifier,SteamKit2.Internal,GamePlayed,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamMsgClientServer.cs,,The length of the parameter _primary_steam_controller_serial is 32.
Long Identifier,SteamKit2.Internal,GamePlayed,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamMsgClientServer.cs,,The length of the parameter _total_non_steam_controller_count is 33.
Long Identifier,SteamKit2.Internal,CMsgClientIsLimitedAccount,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamMsgClientServer.cs,,The length of the parameter _bis_limited_account_allowed_to_invite_friends is 46.
Long Identifier,SteamKit2.Internal,CMsgClientServersAvailable,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamMsgClientServer.cs,,The length of the parameter _server_type_for_auth_services is 30.
Long Identifier,SteamKit2.Internal,CMsgClientUCMPublishFileResponse,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamMsgClientServer2.cs,,The length of the parameter _needs_workshop_legal_agreement_acceptance is 42.
Long Identifier,SteamKit2.Internal,CMsgClientUCMUpdatePublishedFileResponse,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamMsgClientServer2.cs,,The length of the parameter _needs_workshop_legal_agreement_acceptance is 42.
Long Identifier,SteamKit2.Internal,CMsgTrading_InitiateTradeResponse,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamMsgClientServer2.cs,,The length of the parameter _default_password_reset_probation_days is 38.
Long Identifier,SteamKit2.Internal,CMsgTrading_InitiateTradeResponse,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamMsgClientServer2.cs,,The length of the parameter _password_reset_probation_days is 30.
Long Identifier,SteamKit2.Internal,CMsgTrading_InitiateTradeResponse,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamMsgClientServer2.cs,,The length of the parameter _default_email_change_probation_days is 36.
Long Identifier,SteamKit2.Internal,CMsgClientCommentNotifications,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamMsgClientServer2.cs,,The length of the parameter _count_new_comments_subscriptions is 33.
Long Identifier,SteamKit2.Internal,CMsgClientOfflineMessageNotification,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamMsgClientServer2.cs,,The length of the parameter _friends_with_offline_messages is 30.
Long Identifier,SteamKit2.Internal,CMsgClientEmailAddrInfo,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamMsgClientServer2.cs,,The length of the parameter _credential_change_requires_code is 32.
Long Identifier,SteamKit2.Internal,CMsgClientEmailAddrInfo,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamMsgClientServer2.cs,,The length of the parameter _password_or_secretqa_change_requires_code is 42.
Long Identifier,SteamKit2.Internal,CMsgClientLogon,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamMsgClientServerLogin.cs,,The length of the parameter _anon_user_target_account_name is 30.
Long Identifier,SteamKit2.Internal,CMsgClientLogon,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamMsgClientServerLogin.cs,,The length of the parameter _create_new_psn_linked_account_if_needed is 40.
Long Identifier,SteamKit2.Internal,CMsgClientLogon,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamMsgClientServerLogin.cs,,The length of the parameter _steamguard_dont_remember_computer is 34.
Long Identifier,SteamKit2.Internal,CMsgClientLogonResponse,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamMsgClientServerLogin.cs,,The length of the parameter _out_of_game_heartbeat_seconds is 30.
Long Identifier,SteamKit2.Internal,CMsgClientLogonResponse,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamMsgClientServerLogin.cs,,The length of the parameter _webapi_authenticate_user_nonce is 31.
Long Identifier,SteamKit2.Internal,CMsgClientLogonResponse,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamMsgClientServerLogin.cs,,The length of the parameter _count_loginfailures_to_migrate is 31.
Long Identifier,SteamKit2.Internal,CMsgClientRequestWebAPIAuthenticateUserNonceResponse,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamMsgClientServerLogin.cs,,The length of the parameter _webapi_authenticate_user_nonce is 31.
Long Identifier,SteamKit2.Internal,CMsgClientAccountInfo,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamMsgClientServerLogin.cs,,The length of the parameter _steamguard_notify_newmachines is 30.
Long Identifier,SteamKit2.Internal,CMsgClientAccountInfo,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamMsgClientServerLogin.cs,,The length of the parameter _steamguard_machine_name_user_chosen is 36.
Long Identifier,SteamKit2.GC.CSGO.Internal,CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\CSGO\MsgGC.cs,,The length of the parameter _ongoingmatch_account_id_sessions is 33.
Long Identifier,SteamKit2.GC.CSGO.Internal,CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\CSGO\MsgGC.cs,,The length of the parameter _failready_account_id_sessions is 30.
Long Identifier,SteamKit2.GC.CSGO.Internal,CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\CSGO\MsgGC.cs,,The length of the parameter _vacbanned_account_id_sessions is 30.
Long Identifier,SteamKit2.GC.CSGO.Internal,CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\CSGO\MsgGC.cs,,The length of the parameter _penalty_account_id_sessions_green is 34.
Long Identifier,SteamKit2.GC.CSGO.Internal,CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\CSGO\MsgGC.cs,,The length of the parameter _tournament_casters_account_ids is 31.
Long Identifier,SteamKit2.GC.CSGO.Internal,CGCMsgSQLStatsResponse,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\CSGO\SteamMsgBase.cs,,The length of the parameter _non_prepared_statements_executed is 33.
Long Identifier,SteamKit2.GC.CSGO.Internal,CGCMsgSQLStatsResponse,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\CSGO\SteamMsgBase.cs,,The length of the parameter _operations_timed_out_in_queue is 30.
Long Identifier,SteamKit2.GC.CSGO.Internal,CGCSystemMsg_GetPurchaseTrust_Response,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\CSGO\SteamMsgBase.cs,,The length of the parameter _has_no_recent_password_resets is 30.
Long Identifier,SteamKit2.GC.CSGO.Internal,CMsgUpdateItemSchema,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\CSGO\SteamMsgGC.cs,,The length of the parameter _items_game_url_DEPRECATED2013 is 30.
Long Identifier,SteamKit2.GC.CSGO.Internal,CMsgGCClientDisplayNotification,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\CSGO\SteamMsgGC.cs,,The length of the parameter _notification_title_localization_key is 36.
Long Identifier,SteamKit2.GC.CSGO.Internal,CMsgGCClientDisplayNotification,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\CSGO\SteamMsgGC.cs,,The length of the parameter _notification_body_localization_key is 35.
Long Identifier,SteamKit2.GC.CSGO.Internal,CMsgGameServerInfo,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\CSGO\SteamMsgGC.cs,,The length of the parameter _server_relay_connected_steam_id is 32.
Long Identifier,SteamKit2.GC.CSGO.Internal,CMsgAccountDetails,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\CSGO\SteamMsgGCSDK.cs,,The length of the parameter _eligible_for_community_market is 30.
Long Identifier,SteamKit2.GC.CSGO.Internal,CMsgConnectionStatus,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\CSGO\SteamMsgGCSDK.cs,,The length of the parameter _estimated_wait_seconds_remaining is 33.
Long Identifier,SteamKit2.GC.Dota.Internal,CMsgDOTAMatchHistoryFilter,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCClient.cs,,The length of the parameter _newest_match_id_at_last_query is 30.
Long Identifier,SteamKit2.GC.Dota.Internal,CMsgDOTAReportsRemainingResponse,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCClient.cs,,The length of the parameter _num_positive_reports_remaining is 31.
Long Identifier,SteamKit2.GC.Dota.Internal,CMsgDOTAReportsRemainingResponse,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCClient.cs,,The length of the parameter _num_negative_reports_remaining is 31.
Long Identifier,SteamKit2.GC.Dota.Internal,CMsgDOTAWelcome,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCClient.cs,,The length of the parameter _allow_3rd_party_match_history is 30.
Long Identifier,SteamKit2.GC.Dota.Internal,CMsgDOTAWelcome,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCClient.cs,,The length of the parameter _is_perfect_world_test_account is 30.
Long Identifier,SteamKit2.GC.Dota.Internal,CMsgMatchmakingMatchGroupInfo,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCClient.cs,,The length of the parameter _auto_region_select_ping_penalty is 32.
Long Identifier,SteamKit2.GC.Dota.Internal,CMsgDOTAMatchmakingStatsResponse,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCClient.cs,,The length of the parameter _legacy_searching_players_by_group_source2 is 42.
Long Identifier,SteamKit2.GC.Dota.Internal,CMsgDOTASetMatchHistoryAccess,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCClient.cs,,The length of the parameter _allow_3rd_party_match_history is 30.
Long Identifier,SteamKit2.GC.Dota.Internal,CMsgDOTAChatMessage,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCClientChat.cs,,The length of the parameter _fantasy_draft_owner_account_id is 31.
Long Identifier,SteamKit2.GC.Dota.Internal,CMsgDOTAChatMessage,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCClientChat.cs,,The length of the parameter _fantasy_draft_player_account_id is 32.
Long Identifier,SteamKit2.GC.Dota.Internal,CMsgPracticeLobbySetDetails,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCClientMatchMgmt.cs,,The length of the parameter _lan_host_ping_to_server_region is 31.
Long Identifier,SteamKit2.GC.Dota.Internal,CMsgPracticeLobbySetDetails,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCClientMatchMgmt.cs,,The length of the parameter _league_selection_priority_team is 31.
Long Identifier,SteamKit2.GC.Dota.Internal,CMsgPracticeLobbySetDetails,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCClientMatchMgmt.cs,,The length of the parameter _league_selection_priority_choice is 33.
Long Identifier,SteamKit2.GC.Dota.Internal,CMsgPracticeLobbySetDetails,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCClientMatchMgmt.cs,,The length of the parameter _league_non_selection_priority_choice is 37.
Long Identifier,SteamKit2.GC.Dota.Internal,CMsgPracticeLobbyListResponseEntry,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCClientMatchMgmt.cs,,The length of the parameter _lan_host_ping_to_server_region is 31.
Long Identifier,SteamKit2.GC.Dota.Internal,CMsgJoinableCustomLobbiesResponseEntry,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCClientMatchMgmt.cs,,The length of the parameter _lan_host_ping_to_server_region is 31.
Long Identifier,SteamKit2.GC.Dota.Internal,UpcomingMatch,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCClientTournament.cs,,The length of the parameter _team1_prev_match_opponent_score is 32.
Long Identifier,SteamKit2.GC.Dota.Internal,UpcomingMatch,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCClientTournament.cs,,The length of the parameter _team2_prev_match_opponent_score is 32.
Long Identifier,SteamKit2.GC.Dota.Internal,CSourceTVGameSmall,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCClientWatch.cs,,The length of the parameter _weekend_tourney_tournament_id is 30.
Long Identifier,SteamKit2.GC.Dota.Internal,CSourceTVGameSmall,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCClientWatch.cs,,The length of the parameter _weekend_tourney_bracket_round is 30.
Long Identifier,SteamKit2.GC.Dota.Internal,Tourney,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCClientWatch.cs,,The length of the parameter _weekend_tourney_tournament_id is 30.
Long Identifier,SteamKit2.GC.Dota.Internal,Tourney,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCClientWatch.cs,,The length of the parameter _weekend_tourney_season_trophy_id is 33.
Long Identifier,SteamKit2.GC.Dota.Internal,CSODOTAGameAccountClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommon.cs,,The length of the parameter _prevent_public_text_chat_until_date is 36.
Long Identifier,SteamKit2.GC.Dota.Internal,CSODOTAGameAccountClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommon.cs,,The length of the parameter _last_secondary_abandoned_game_date is 35.
Long Identifier,SteamKit2.GC.Dota.Internal,CSODOTAGameAccountClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommon.cs,,The length of the parameter _shutdownlawterminatetimestamp is 30.
Long Identifier,SteamKit2.GC.Dota.Internal,CSODOTAGameAccountClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommon.cs,,The length of the parameter _solo_calibration_games_remaining is 33.
Long Identifier,SteamKit2.GC.Dota.Internal,CSODOTAGameAccountClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommon.cs,,The length of the parameter _solo_competitive_games_played is 30.
Long Identifier,SteamKit2.GC.Dota.Internal,CSODOTAGameAccountClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommon.cs,,The length of the parameter _party_competitive_games_played is 31.
Long Identifier,SteamKit2.GC.Dota.Internal,CSODOTAGameAccountClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommon.cs,,The length of the parameter _competitive_team_games_played is 30.
Long Identifier,SteamKit2.GC.Dota.Internal,CSODOTAGameAccountClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommon.cs,,The length of the parameter _player_behavior_seq_num_last_report is 36.
Long Identifier,SteamKit2.GC.Dota.Internal,CSODOTAGameAccountClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommon.cs,,The length of the parameter _player_behavior_score_last_report is 34.
Long Identifier,SteamKit2.GC.Dota.Internal,CSODOTAGameAccountClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommon.cs,,The length of the parameter _player_behavior_report_old_data is 32.
Long Identifier,SteamKit2.GC.Dota.Internal,CSODOTAGameAccountClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommon.cs,,The length of the parameter _tourney_recent_participation_date is 34.
Long Identifier,SteamKit2.GC.Dota.Internal,CSODOTAGameAccountClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommon.cs,,The length of the parameter _ranked_matchmaking_ban_until_date is 34.
Long Identifier,SteamKit2.GC.Dota.Internal,CSODOTAGameAccountClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommon.cs,,The length of the parameter _general_seasonal_ranked_calibration_games_remaining is 52.
Long Identifier,SteamKit2.GC.Dota.Internal,CSODOTAGameAccountClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommon.cs,,The length of the parameter _general_seasonal_ranked_games_played is 37.
Long Identifier,SteamKit2.GC.Dota.Internal,CSODOTAGameAccountClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommon.cs,,The length of the parameter _general_seasonal_ranked_rank_peak is 34.
Long Identifier,SteamKit2.GC.Dota.Internal,CSODOTAGameAccountClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommon.cs,,The length of the parameter _general_seasonal_rank_transferred is 34.
Long Identifier,SteamKit2.GC.Dota.Internal,CSODOTAGameAccountClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommon.cs,,The length of the parameter _solo_seasonal_ranked_calibration_games_remaining is 49.
Long Identifier,SteamKit2.GC.Dota.Internal,CSODOTAGameAccountClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommon.cs,,The length of the parameter _solo_seasonal_ranked_games_played is 34.
Long Identifier,SteamKit2.GC.Dota.Internal,CSODOTAGameAccountClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommon.cs,,The length of the parameter _solo_seasonal_ranked_rank_peak is 31.
Long Identifier,SteamKit2.GC.Dota.Internal,CSODOTAGameAccountClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommon.cs,,The length of the parameter _solo_seasonal_rank_transferred is 31.
Long Identifier,SteamKit2.GC.Dota.Internal,AccountPoints,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommon.cs,,The length of the parameter _unlocked_chat_wheel_message_ranges is 35.
Long Identifier,SteamKit2.GC.Dota.Internal,MatchDetails,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommon.cs,,The length of the parameter _steam_broadcaster_account_ids is 30.
Long Identifier,SteamKit2.GC.Dota.Internal,CMsgDOTASeasonPredictions,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommon.cs,,The length of the parameter _in_game_prediction_count_per_game is 34.
Long Identifier,SteamKit2.GC.Dota.Internal,CMsgDOTASeasonPredictions,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommon.cs,,The length of the parameter _in_game_prediction_voting_period_minutes is 41.
Long Identifier,SteamKit2.GC.Dota.Internal,CSODOTAParty,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommonMatchMgmt.cs,,The length of the parameter _effective_started_matchmaking_time is 35.
Long Identifier,SteamKit2.GC.Dota.Internal,CSODOTAParty,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommonMatchMgmt.cs,,The length of the parameter _matchmaking_max_range_minutes is 30.
Long Identifier,SteamKit2.GC.Dota.Internal,CSODOTALobby,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommonMatchMgmt.cs,,The length of the parameter _lan_host_ping_to_server_region is 31.
Long Identifier,SteamKit2.GC.Dota.Internal,CSODOTALobby,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommonMatchMgmt.cs,,The length of the parameter _custom_game_auto_created_lobby is 31.
Long Identifier,SteamKit2.GC.Dota.Internal,CSODOTALobby,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommonMatchMgmt.cs,,The length of the parameter _custom_game_uses_account_records is 33.
Long Identifier,SteamKit2.GC.Dota.Internal,CSODOTALobby,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommonMatchMgmt.cs,,The length of the parameter _league_selection_priority_team is 31.
Long Identifier,SteamKit2.GC.Dota.Internal,CSODOTALobby,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommonMatchMgmt.cs,,The length of the parameter _league_selection_priority_choice is 33.
Long Identifier,SteamKit2.GC.Dota.Internal,CSODOTALobby,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommonMatchMgmt.cs,,The length of the parameter _league_non_selection_priority_choice is 37.
Long Identifier,SteamKit2.GC.Dota.Internal,CSODOTALobby,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCCommonMatchMgmt.cs,,The length of the parameter _weekend_tourney_bracket_round is 30.
Long Identifier,SteamKit2.GC.Dota.Internal,CMsgGameServerInfo,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCServer.cs,,The length of the parameter _server_relay_connected_steam_id is 32.
Long Identifier,SteamKit2.GC.Dota.Internal,CMsgGameMatchSignOut,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCServer.cs,,The length of the parameter _player_strange_count_adjustments is 33.
Long Identifier,SteamKit2.GC.Dota.Internal,CMsgGameMatchSignOut,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCServer.cs,,The length of the parameter _event_game_leaderboard_entries is 31.
Long Identifier,SteamKit2.GC.Dota.Internal,PlayerCommunication,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\MsgGCServer.cs,,The length of the parameter _max_teammate_pings_per_interval is 32.
Long Identifier,SteamKit2.GC.Dota.Internal,CGCMsgSQLStatsResponse,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\SteamMsgBase.cs,,The length of the parameter _non_prepared_statements_executed is 33.
Long Identifier,SteamKit2.GC.Dota.Internal,CGCMsgSQLStatsResponse,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\SteamMsgBase.cs,,The length of the parameter _operations_timed_out_in_queue is 30.
Long Identifier,SteamKit2.GC.Dota.Internal,CMsgGCGetAppFriendsList,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\SteamMsgBase.cs,,The length of the parameter _include_friendship_timestamps is 30.
Long Identifier,SteamKit2.GC.Dota.Internal,CGCSystemMsg_GetPurchaseTrust_Response,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\SteamMsgBase.cs,,The length of the parameter _has_no_recent_password_resets is 30.
Long Identifier,SteamKit2.GC.Dota.Internal,CSOEconGameAccountClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\SteamMsgGC.cs,,The length of the parameter _need_to_choose_most_helpful_friend is 35.
Long Identifier,SteamKit2.GC.Dota.Internal,CMsgGCClientDisplayNotification,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\SteamMsgGC.cs,,The length of the parameter _notification_title_localization_key is 36.
Long Identifier,SteamKit2.GC.Dota.Internal,CMsgGCClientDisplayNotification,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\SteamMsgGC.cs,,The length of the parameter _notification_body_localization_key is 35.
Long Identifier,SteamKit2.GC.Dota.Internal,CMsgClientToGCGetGiftPermissionsResponse,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\SteamMsgGCEcon.cs,,The length of the parameter _friendship_age_requirement_two_factor is 38.
Long Identifier,SteamKit2.GC.Dota.Internal,CMsgConnectionStatus,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\Dota\SteamMsgGCSDK.cs,,The length of the parameter _estimated_wait_seconds_remaining is 33.
Long Identifier,SteamKit2.GC.TF2.Internal,CMsgTFWorldStatus,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\MsgGC.cs,,The length of the parameter _beta_stress_test_event_active is 30.
Long Identifier,SteamKit2.GC.TF2.Internal,CMsgGC_GameServer_ResetIdentityResponse,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\MsgGC.cs,,The length of the parameter _game_server_identity_token_reset is 33.
Long Identifier,SteamKit2.GC.TF2.Internal,CSOTFParty,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\MsgGC.cs,,The length of the parameter _search_play_for_bragging_rights is 32.
Long Identifier,SteamKit2.GC.TF2.Internal,CSOTFParty,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\MsgGC.cs,,The length of the parameter _matchmaking_low_priority_time is 30.
Long Identifier,SteamKit2.GC.TF2.Internal,CMsgMatchmakingProgress,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\MsgGC.cs,,The length of the parameter _matching_worldwide_searching_players is 37.
Long Identifier,SteamKit2.GC.TF2.Internal,CMsgMatchmakingProgress,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\MsgGC.cs,,The length of the parameter _matching_near_you_searching_players is 36.
Long Identifier,SteamKit2.GC.TF2.Internal,CMsgMatchmakingProgress,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\MsgGC.cs,,The length of the parameter _total_worldwide_searching_players is 34.
Long Identifier,SteamKit2.GC.TF2.Internal,CMsgMatchmakingProgress,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\MsgGC.cs,,The length of the parameter _total_near_you_searching_players is 33.
Long Identifier,SteamKit2.GC.TF2.Internal,CMsgMatchmakingProgress,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\MsgGC.cs,,The length of the parameter _matching_worldwide_active_players is 34.
Long Identifier,SteamKit2.GC.TF2.Internal,CMsgMatchmakingProgress,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\MsgGC.cs,,The length of the parameter _matching_near_you_active_players is 33.
Long Identifier,SteamKit2.GC.TF2.Internal,CMsgMatchmakingProgress,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\MsgGC.cs,,The length of the parameter _total_worldwide_active_players is 31.
Long Identifier,SteamKit2.GC.TF2.Internal,CMsgMatchmakingProgress,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\MsgGC.cs,,The length of the parameter _total_near_you_active_players is 30.
Long Identifier,SteamKit2.GC.TF2.Internal,CMsgMatchmakingProgress,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\MsgGC.cs,,The length of the parameter _matching_worldwide_empty_gameservers is 37.
Long Identifier,SteamKit2.GC.TF2.Internal,CMsgMatchmakingProgress,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\MsgGC.cs,,The length of the parameter _matching_near_you_empty_gameservers is 36.
Long Identifier,SteamKit2.GC.TF2.Internal,CMsgMatchmakingProgress,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\MsgGC.cs,,The length of the parameter _total_worldwide_empty_gameservers is 34.
Long Identifier,SteamKit2.GC.TF2.Internal,CMsgMatchmakingProgress,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\MsgGC.cs,,The length of the parameter _total_near_you_empty_gameservers is 33.
Long Identifier,SteamKit2.GC.TF2.Internal,Item,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\MsgGC.cs,,The length of the parameter _squad_surplus_claimer_steam_id is 31.
Long Identifier,SteamKit2.GC.TF2.Internal,CMsgGCMatchMakerStatsResponse,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\MsgGC.cs,,The length of the parameter _matchgroup_data_center_population is 34.
Long Identifier,SteamKit2.GC.TF2.Internal,CGCMsgSQLStatsResponse,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\SteamMsgBase.cs,,The length of the parameter _non_prepared_statements_executed is 33.
Long Identifier,SteamKit2.GC.TF2.Internal,CGCMsgSQLStatsResponse,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\SteamMsgBase.cs,,The length of the parameter _operations_timed_out_in_queue is 30.
Long Identifier,SteamKit2.GC.TF2.Internal,CGCSystemMsg_GetPurchaseTrust_Response,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\SteamMsgBase.cs,,The length of the parameter _has_no_recent_password_resets is 30.
Long Identifier,SteamKit2.GC.TF2.Internal,CSOEconGameAccountClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\SteamMsgGC.cs,,The length of the parameter _need_to_choose_most_helpful_friend is 35.
Long Identifier,SteamKit2.GC.TF2.Internal,CSOEconGameAccountClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\SteamMsgGC.cs,,The length of the parameter _matchmaking_ranked_ban_expiration is 34.
Long Identifier,SteamKit2.GC.TF2.Internal,CSOEconGameAccountClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\SteamMsgGC.cs,,The length of the parameter _matchmaking_ranked_low_priority_expiration is 43.
Long Identifier,SteamKit2.GC.TF2.Internal,CSOEconGameAccountClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\SteamMsgGC.cs,,The length of the parameter _matchmaking_ranked_ban_last_duration is 37.
Long Identifier,SteamKit2.GC.TF2.Internal,CSOEconGameAccountClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\SteamMsgGC.cs,,The length of the parameter _matchmaking_ranked_low_priority_last_duration is 46.
Long Identifier,SteamKit2.GC.TF2.Internal,CSOEconGameAccountClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\SteamMsgGC.cs,,The length of the parameter _matchmaking_casual_ban_expiration is 34.
Long Identifier,SteamKit2.GC.TF2.Internal,CSOEconGameAccountClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\SteamMsgGC.cs,,The length of the parameter _matchmaking_casual_low_priority_expiration is 43.
Long Identifier,SteamKit2.GC.TF2.Internal,CSOEconGameAccountClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\SteamMsgGC.cs,,The length of the parameter _matchmaking_casual_ban_last_duration is 37.
Long Identifier,SteamKit2.GC.TF2.Internal,CSOEconGameAccountClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\SteamMsgGC.cs,,The length of the parameter _matchmaking_casual_low_priority_last_duration is 46.
Long Identifier,SteamKit2.GC.TF2.Internal,CMsgGCClientDisplayNotification,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\SteamMsgGC.cs,,The length of the parameter _notification_title_localization_key is 36.
Long Identifier,SteamKit2.GC.TF2.Internal,CMsgGCClientDisplayNotification,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\SteamMsgGC.cs,,The length of the parameter _notification_body_localization_key is 35.
Long Identifier,SteamKit2.GC.TF2.Internal,CMsgConnectionStatus,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\GC\TF2\SteamMsgGCSDK.cs,,The length of the parameter _estimated_wait_seconds_remaining is 33.
Long Identifier,SteamKit2.Unified.Internal,CCredentials_GetSteamGuardDetails_Response,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\Unified\SteamMsgCredentials.cs,,The length of the parameter _deprecated_machine_name_userchosen is 35.
Long Identifier,SteamKit2.Unified.Internal,CCredentials_GetSteamGuardDetails_Response,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\Unified\SteamMsgCredentials.cs,,The length of the parameter _deprecated_timestamp_machine_steamguard_enabled is 48.
Long Identifier,SteamKit2.Unified.Internal,CCredentials_GetSteamGuardDetails_Response,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\Unified\SteamMsgCredentials.cs,,The length of the parameter _deprecated_authentication_exists_from_geoloc_before_mintime is 60.
Long Identifier,SteamKit2.Unified.Internal,SessionData,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\Unified\SteamMsgCredentials.cs,,The length of the parameter _timestamp_machine_steamguard_enabled is 37.
Long Identifier,SteamKit2.Unified.Internal,SessionData,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\Unified\SteamMsgCredentials.cs,,The length of the parameter _authentication_exists_from_geoloc_before_mintime is 49.
Long Identifier,SteamKit2.Unified.Internal,SessionData,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\Unified\SteamMsgCredentials.cs,,The length of the parameter _authentication_exists_from_same_ip_before_mintime is 50.
Long Identifier,SteamKit2.Unified.Internal,CCredentials_LastCredentialChangeTime_Response,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\Unified\SteamMsgCredentials.cs,,The length of the parameter _timestamp_last_password_change is 31.
Long Identifier,SteamKit2.Unified.Internal,CCredentials_LastCredentialChangeTime_Response,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\Unified\SteamMsgCredentials.cs,,The length of the parameter _timestamp_last_password_reset is 30.
Long Identifier,SteamKit2.Unified.Internal,CTwoFactor_Status_Response,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\Unified\SteamMsgTwoFactor.cs,,The length of the parameter _revocation_attempts_remaining is 30.
Long Identifier,SteamKit2.Unified.Internal,CTwoFactor_RemoveAuthenticator_Request,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\Unified\SteamMsgTwoFactor.cs,,The length of the parameter _remove_all_steamguard_cookies is 30.
Long Identifier,SteamKit2.Unified.Internal,CTwoFactor_RemoveAuthenticator_Response,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\Unified\SteamMsgTwoFactor.cs,,The length of the parameter _revocation_attempts_remaining is 30.
Long Identifier,SevenZip.Compression.LZMA,Base,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaBase.cs,,The length of the parameter kNumLitPosStatesBitsEncodingMax is 31.
Long Identifier,SteamKit2.Util.MacHelpers,DiskArbitration,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\MacHelpers.cs,,The length of the parameter kDADiskDescriptionMediaUUIDKey is 30.
Long Identifier,SteamKit2.Util,NativeMethods,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Win32Helpers.cs,,The length of the parameter IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS is 36.
Long Statement,SteamKit2,ClientMsgProtobuf,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\ClientMsg.cs,Serialize,The length of the statement  "            throw new NotSupportedException( "ClientMsgProtobuf is for reading only. Use ClientMsgProtobuf<T> for serializing messages." ); " is 127.
Long Statement,SteamKit2,EnvelopeEncryptedConnection,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\EnvelopeEncryptedConnection.cs,HandleEncryptRequest,The length of the statement  "            DebugLog.WriteLine( nameof(EnvelopeEncryptedConnection)' "Got encryption request. Universe: {0} Protocol ver: {1}"' connectedUniverse' protoVersion ); " is 150.
Long Statement,SteamKit2,EnvelopeEncryptedConnection,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\EnvelopeEncryptedConnection.cs,HandleEncryptRequest,The length of the statement  "            DebugLog.Assert( protoVersion == 1' nameof(EnvelopeEncryptedConnection)' "Encryption handshake protocol version mismatch!" ); " is 125.
Long Statement,SteamKit2,EnvelopeEncryptedConnection,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\EnvelopeEncryptedConnection.cs,HandleEncryptRequest,The length of the statement  "            DebugLog.Assert( connectedUniverse == universe' nameof(EnvelopeEncryptedConnection)' FormattableString.Invariant( $"Expected universe {universe} but server reported universe {connectedUniverse}" ) ); " is 199.
Long Statement,SteamKit2,EnvelopeEncryptedConnection,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\EnvelopeEncryptedConnection.cs,HandleEncryptRequest,The length of the statement  "                DebugLog.WriteLine(nameof(EnvelopeEncryptedConnection)' "HandleEncryptRequest got request for invalid universe! Universe: {0} Protocol ver: {1}"' connectedUniverse' protoVersion ); " is 180.
Long Statement,SteamKit2,TcpConnection,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\TcpConnection.cs,TryConnect,The length of the statement  "            if ( WaitHandle.WaitAny( new WaitHandle[] { asyncResult.AsyncWaitHandle' cancellationToken.Token.WaitHandle }' timeout ) == 0 ) " is 127.
Long Statement,SteamKit2,TcpConnection,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\TcpConnection.cs,TryConnect,The length of the statement  "                    DebugLog.WriteLine( "TcpConnection"' "Socket exception while completing connection request to {0}: {1}"' destination' ex ); " is 123.
Long Statement,SteamKit2,UdpConnection,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\UdpConnection.cs,Disconnect,The length of the statement  "            if ( state != (int)State.Disconnected && Interlocked.Exchange(ref state' (int)State.Disconnecting) == (int)State.Disconnected ) " is 127.
Long Statement,SteamKit2,UdpConnection,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\UdpConnection.cs,NetLoop,The length of the statement  "                if ( Interlocked.CompareExchange(ref state' (int)State.ChallengeReqSent' (int)State.Disconnected) != (int)State.Disconnected ) " is 126.
Long Statement,SteamKit2,UdpConnection,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\UdpConnection.cs,ReceiveChallenge,The length of the statement  "            if ( Interlocked.CompareExchange( ref state' (int)State.ConnectSent' (int)State.ChallengeReqSent ) != (int)State.ChallengeReqSent ) " is 131.
Long Statement,SteamKit2,WebSocketConnection,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\WebSocketConnection.cs,Connect,The length of the statement  "                DebugLog.WriteLine(nameof(WebSocketConnection)' "Attempted to connect while already connected. Closing old connection..."); " is 123.
Long Statement,SteamKit2,WebSocketConnection,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\WebSocketConnection.cs,Send,The length of the statement  "                DebugLog.WriteLine(nameof(WebSocketConnection)' "Exception while sending data: {0} - {1}"' ex.GetType().FullName' ex.Message); " is 126.
Long Statement,SteamKit2,WebSocketContext,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\WebSocketContext.cs,RunCore,The length of the statement  "                        DebugLog.WriteLine(nameof(WebSocketContext)' "Exception connecting websocket: {0} - {1}"' ex.GetType().FullName' ex.Message); " is 125.
Long Statement,SteamKit2,WebSocketContext,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\WebSocketContext.cs,SendAsync,The length of the statement  "                    DebugLog.WriteLine(nameof(WebSocketContext)' "{0} exception when sending message: {1}"' ex.GetType().FullName' ex.Message); " is 123.
Long Statement,SteamKit2,CDNClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CDNClient.cs,FetchServerListAsync,The length of the statement  "            var serverKv = await DoCommandAsync( csServer' HttpMethod.Get' "serverlist"' args: string.Format( "{0}/{1}/"' cellId' maxServers ) ).ConfigureAwait( false ); " is 157.
Long Statement,SteamKit2,CDNClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CDNClient.cs,FetchServerListAsync,The length of the statement  "                Server.ConnectionProtocol protocol = ( httpsSupport == "optional" || httpsSupport == "mandatory" ) ? Server.ConnectionProtocol.HTTPS : Server.ConnectionProtocol.HTTP; " is 166.
Long Statement,SteamKit2,CDNClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CDNClient.cs,ConnectAsync,The length of the statement  "                data = string.Format( "sessionkey={0}&anonymoususer=1&steamid={1}"' WebHelpers.UrlEncode( cryptedSessKey )' steamClient.SteamID.ConvertToUInt64() ); " is 148.
Long Statement,SteamKit2,CDNClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CDNClient.cs,ConnectAsync,The length of the statement  "                data = string.Format( "sessionkey={0}&appticket={1}"' WebHelpers.UrlEncode( cryptedSessKey )' WebHelpers.UrlEncode( encryptedAppTicket ) ); " is 139.
Long Statement,SteamKit2,CDNClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CDNClient.cs,DownloadManifestAsync,The length of the statement  "            return await DownloadManifestCoreAsync( depotId' manifestId' connectedServer' cdnToken' depotKey ).ConfigureAwait(false); " is 121.
Long Statement,SteamKit2,CDNClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CDNClient.cs,DownloadDepotChunkAsync,The length of the statement  "            return await DownloadDepotChunkCoreAsync( depotId' chunk' connectedServer' cdnToken' depotKey ).ConfigureAwait( false ); " is 120.
Long Statement,SteamKit2,CDNClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CDNClient.cs,BuildCommand,The length of the statement  "            return string.Format( "{0}://{1}:{2}/{3}/{4}{5}"' protocol' server.VHost' server.Port' command' args' authtoken ?? "" ); " is 120.
Long Statement,SteamKit2,CDNClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CDNClient.cs,DoCommandAsync,The length of the statement  "            var resultData = await DoRawCommandAsync( server' method' command' data' doAuth' args' authtoken ).ConfigureAwait( false ); " is 123.
Long Statement,SteamKit2,CDNClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CDNClient.cs,DoCommandAsync,The length of the statement  "                    throw new InvalidDataException( "An internal error occurred while attempting to parse the response from the CS server."' ex ); " is 126.
Long Statement,SteamKit2,CDNClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CDNClient.cs,DownloadManifestCoreAsync,The length of the statement  "            var manifestData = await DoRawCommandAsync( server' HttpMethod.Get' "depot"' doAuth: true' args: string.Format( "{0}/manifest/{1}/5"' depotId' manifestId )' authtoken: cdnAuthToken ).ConfigureAwait( false ); " is 207.
Long Statement,SteamKit2,CDNClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CDNClient.cs,DownloadDepotChunkCoreAsync,The length of the statement  "            var chunkData = await DoRawCommandAsync( server' HttpMethod.Get' "depot"' doAuth: true' args: string.Format( "{0}/chunk/{1}"' depotId' chunkID )' authtoken: cdnAuthToken ).ConfigureAwait( false ); " is 196.
Long Statement,SteamKit2,CDNClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CDNClient.cs,DownloadDepotChunkCoreAsync,The length of the statement  "                DebugLog.Assert( chunkData.Length == chunk.CompressedLength' "CDNClient"' "Length mismatch after downloading depot chunk!" ); " is 125.
Long Statement,SteamKit2,DepotChunk,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CDNClient.cs,Process,The length of the statement  "                    throw new InvalidDataException( "Processed data checksum is incorrect! Downloaded depot chunk is corrupt or invalid/wrong depot key?" ); " is 136.
Long Statement,SteamKit2,SteamApps,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\Handlers\SteamApps\Callbacks.cs,PICSGetProductInfo,The length of the statement  "            return PICSGetProductInfo( apps.Select( app => new PICSRequest( app' 0' onlyPublic ) )' packages.Select( package => new PICSRequest( package ) )' metaDataOnly ); " is 161.
Long Statement,SteamKit2,SteamApps,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\Handlers\SteamApps\Callbacks.cs,PICSGetProductInfo,The length of the statement  "            return new AsyncJobMultiple<PICSProductInfoCallback>( this.Client' request.SourceJobID' callback => !callback.ResponsePending ); " is 128.
Long Statement,SteamKit2,SteamFriends,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\Handlers\SteamFriends\Callbacks.cs,RequestOfflineMessages,The length of the statement  "            var request = new ClientMsgProtobuf<CMsgClientChatGetFriendMessageHistoryForOfflineMessages>( EMsg.ClientFSGetFriendMessageHistoryForOfflineMessages ); " is 151.
Long Statement,SteamKit2,SteamFriends,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\Handlers\SteamFriends\Callbacks.cs,HandleFriendsList,The length of the statement  "            // we have to request information for all of our friends because steam only sends persona information for online friends " is 120.
Long Statement,SteamKit2,UnifiedService<TService>,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\Handlers\SteamUnifiedMessages\SteamUnifiedMessages.cs,SendMessage,The length of the statement  "                var method = typeof(SteamUnifiedMessages).GetMethod( nameof(SteamUnifiedMessages.SendMessage) ).MakeGenericMethod( message.GetType() ); " is 135.
Long Statement,SteamKit2,SteamUser,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\Handlers\SteamUser\Callbacks.cs,LogOn,The length of the statement  "            if ( string.IsNullOrEmpty( details.Username ) || ( string.IsNullOrEmpty( details.Password ) && string.IsNullOrEmpty( details.LoginKey ) ) ) " is 139.
Long Statement,SteamKit2,SteamUser,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\Handlers\SteamUser\Callbacks.cs,RequestWebAPIUserNonce,The length of the statement  "            var reqMsg = new ClientMsgProtobuf<CMsgClientRequestWebAPIAuthenticateUserNonce>( EMsg.ClientRequestWebAPIAuthenticateUserNonce ); " is 130.
Long Statement,SteamKit2,SteamWorkshop,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\Handlers\SteamWorkshop\Callbacks.cs,EnumerateUserPublishedFiles,The length of the statement  "            var enumRequest = new ClientMsgProtobuf<CMsgClientUCMEnumerateUserPublishedFiles>( EMsg.ClientUCMEnumerateUserPublishedFiles ); " is 127.
Long Statement,SteamKit2,SteamWorkshop,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\Handlers\SteamWorkshop\Callbacks.cs,EnumerateUserSubscribedFiles,The length of the statement  "            var enumRequest = new ClientMsgProtobuf<CMsgClientUCMEnumerateUserSubscribedFiles>( EMsg.ClientUCMEnumerateUserSubscribedFiles ); " is 129.
Long Statement,SteamKit2,SteamWorkshop,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\Handlers\SteamWorkshop\Callbacks.cs,EnumeratePublishedFilesByUserAction,The length of the statement  "            var enumRequest = new ClientMsgProtobuf<CMsgClientUCMEnumeratePublishedFilesByUserAction>( EMsg.ClientUCMEnumeratePublishedFilesByUserAction ); " is 143.
Long Statement,SteamKit2,AsyncJobManager,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\SteamClient\AsyncJobManager.cs,TryCompleteJob,The length of the statement  "            // pass this callback into the job so it can determine if the job is finished (in the case of multiple responses to a job) " is 122.
Long Statement,SteamKit2,AsyncJobManager,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\SteamClient\AsyncJobManager.cs,CancelTimedoutJobs,The length of the statement  "            // see: http://referencesource.microsoft.com/#mscorlib/system/Collections/Concurrent/ConcurrentDictionary.cs'fe55c11912af21d2 " is 125.
Long Statement,SteamKit2,CallbackManager,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\SteamClient\CallbackMgr\CallbackMgr.cs,Handle,The length of the statement  "                .FindAll( callback => callback.CallbackType.IsAssignableFrom( call.GetType() ) ) // find handlers interested in this callback " is 125.
Long Statement,SteamKit2,SteamClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\SteamClient\Callbacks.cs,AddHandler,The length of the statement  "                throw new InvalidOperationException( string.Format( "A handler of type \"{0}\" is already registered."' handler.GetType() ) ); " is 126.
Long Statement,SteamKit2,SteamClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\SteamClient\Callbacks.cs,OnClientMsgReceived,The length of the statement  "                    DebugLog.WriteLine( "SteamClient"' "Unhandled '{0}' exception from '{1}' handler: '{2}'"' ex.GetType().Name' key.Name' ex.Message ); " is 132.
Long Statement,SteamKit2,UFSClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\UFSClient\Callbacks.cs,NetMsgReceived,The length of the statement  "            DebugLog.WriteLine( "UFSClient"' "<- Recv'd EMsg: {0} ({1}) {2}"' packetMsg.MsgType' ( int )packetMsg.MsgType' packetMsg.IsProto ? "(Proto)" : "" ); " is 148.
Long Statement,SteamKit2,SteamDirectory,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\WebAPI\SteamDirectory.cs,LoadAsync,The length of the statement  "            }' cancellationToken' TaskContinuationOptions.NotOnCanceled | TaskContinuationOptions.NotOnFaulted' TaskScheduler.Current ); " is 124.
Long Statement,SteamKit2,AsyncInterface,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\WebAPI\WebAPI.cs,CallAsync,The length of the statement  "                    // we need to observe the exception in this OnlyOnFaulted continuation if our task throws an exception but we're not able to observe it " is 135.
Long Statement,SteamKit2,AsyncInterface,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\WebAPI\WebAPI.cs,CallAsyncCore,The length of the statement  "                            "An internal error occurred when attempting to parse the response from the WebAPI server. This can indicate a change in the VDF format."' " is 137.
Long Statement,SteamKit2,AsyncInterface,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\WebAPI\WebAPI.cs,TryInvokeMember,The length of the statement  "                    throw new InvalidOperationException( "Argument mismatch in API call. All parameters must be passed as named arguments." ); " is 122.
Long Statement,SteamKit2,AsyncInterface,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\WebAPI\WebAPI.cs,TryInvokeMember,The length of the statement  "                        "The called API function was invalid. It must be in the form of 'FunctionName###' where the optional ### represent the function version." " is 137.
Long Statement,SteamKit2,AsyncInterface,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\WebAPI\WebAPI.cs,TryInvokeMember,The length of the statement  "                        throw new ArgumentOutOfRangeException( "version"' "The function version number supplied was invalid or out of range." ); " is 120.
Long Statement,SteamKit2,DepotManifest,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Types\DepotManifest.cs,DecryptFilenames,The length of the statement  "                file.FileName = Encoding.UTF8.GetString( filename ).TrimEnd( new char[] { '\0' } ).Replace(altDirChar' Path.DirectorySeparatorChar); " is 132.
Long Statement,SteamKit2,DepotManifest,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Types\DepotManifest.cs,ParseBinaryManifest,The length of the statement  "                FileData filedata = new FileData(file_mapping.FileName' file_mapping.Flags' file_mapping.TotalSize' file_mapping.HashContent' FilenamesEncrypted' file_mapping.Chunks.Length); " is 174.
Long Statement,SteamKit2,DepotManifest,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Types\DepotManifest.cs,ParseBinaryManifest,The length of the statement  "                    filedata.Chunks.Add( new ChunkData( chunk.ChunkGID' chunk.Checksum' chunk.Offset' chunk.CompressedSize' chunk.DecompressedSize ) ); " is 131.
Long Statement,SteamKit2,DepotManifest,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Types\DepotManifest.cs,ParseProtobufManifestPayload,The length of the statement  "                FileData filedata = new FileData(file_mapping.filename' (EDepotFileFlag)file_mapping.flags' file_mapping.size' file_mapping.sha_content' FilenamesEncrypted' file_mapping.chunks.Count); " is 184.
Long Statement,SteamKit2,DepotManifest,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Types\DepotManifest.cs,ParseProtobufManifestPayload,The length of the statement  "                    filedata.Chunks.Add( new ChunkData( chunk.sha' BitConverter.GetBytes(chunk.crc)' chunk.offset' chunk.cb_compressed' chunk.cb_original ) ); " is 138.
Long Statement,SteamKit2,AsyncJob<T>,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Types\JobID.cs,AddResult,The length of the statement  "            // inform steamclient that this job wishes to be removed from tracking since we've recieved the single callback we were waiting for " is 131.
Long Statement,SteamKit2,AsyncJobMultiple<T>,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Types\JobID.cs,SetFailed,The length of the statement  "            // steamclient is informing this async job that we've either timed out or failed while waiting for an additional callback " is 121.
Long Statement,SteamKit2,KeyValue,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Types\KeyValue.cs,AsFloat,The length of the statement  "            if ( float.TryParse( this.Value' NumberStyles.Float | NumberStyles.AllowThousands' CultureInfo.InvariantCulture' out value ) == false ) " is 135.
Long Statement,SteamKit2,KeyValue,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Types\KeyValue.cs,TryReadAsBinaryCore,The length of the statement  "                            DebugLog.WriteLine( "KeyValue"' "Encountered WideString type when parsing binary KeyValue' which is unsupported. Returning false."); " is 132.
Long Statement,SteamKit2,SteamID,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Types\SteamID.cs,RenderSteam2,The length of the statement  "                    var universeDigit = ( AccountUniverse <= EUniverse.Public ) ? "0" : Enum.Format( typeof( EUniverse )' AccountUniverse' "D" ); " is 125.
Long Statement,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,SymmetricDecryptHMACIV,The length of the statement  "                throw new CryptographicException( string.Format( CultureInfo.InvariantCulture' "{0} was unable to decrypt packet: HMAC from server did not match computed HMAC."' nameof(NetFilterEncryption) ) ); " is 194.
Long Statement,SteamKit2,DefaultInfoProvider,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\HardwareUtils.cs,GetMacAddress,The length of the statement  "                .Where( i => i.NetworkInterfaceType == NetworkInterfaceType.Ethernet || i.NetworkInterfaceType == NetworkInterfaceType.Wireless80211 ) " is 134.
Long Statement,SteamKit2,OSXInfoProvider,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\HardwareUtils.cs,GetMachineGuid,The length of the statement  "            uint platformExpert = IOServiceGetMatchingService( kIOMasterPortDefault' IOServiceMatching( "IOPlatformExpertDevice" ) ); " is 121.
Long Statement,SteamKit2,OSXInfoProvider,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\HardwareUtils.cs,GetMachineGuid,The length of the statement  "                    using ( var serialNumberKey = CFStringCreateWithCString( CFTypeRef.None' kIOPlatformSerialNumberKey' CFStringEncoding.kCFStringEncodingASCII ) ) " is 144.
Long Statement,SteamKit2,OSXInfoProvider,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\HardwareUtils.cs,GetDiskId,The length of the statement  "                using ( var key = CFStringCreateWithCString( CFTypeRef.None' DiskArbitration.kDADiskDescriptionMediaUUIDKey' CFStringEncoding.kCFStringEncodingASCII ) ) " is 152.
Long Statement,SteamKit2,HardwareUtils,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\HardwareUtils.cs,GenerateMachineID,The length of the statement  "            // this was flipped off shortly after the update rolled out' likely due to linux steamclients running on distros without a way to build a machineid " is 147.
Long Statement,SteamKit2,HardwareUtils,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\HardwareUtils.cs,GenerateMachineID,The length of the statement  "            // so while a valid MO isn't currently (as of aug 25th) required' they could be in the future and we'll abide by The Valve Law now " is 130.
Long Statement,SteamKit2,Utils,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Utils.cs,GetOSType,The length of the statement  "                                    // Note: The OSVersion property reports the same version number (6.2.0.0) for both Windows 8 and Windows 8.1.- http://msdn.microsoft.com/en-us/library/system.environment.osversion(v=vs.110).aspx " is 194.
Long Statement,SteamKit2,WebHelpers,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Utils.cs,IsUrlSafeChar,The length of the statement  "            if ( ( ( ( ch >= 'a' ) && ( ch <= 'z' ) ) || ( ( ch >= 'A' ) && ( ch <= 'Z' ) ) ) || ( ( ch >= '0' ) && ( ch <= '9' ) ) ) " is 121.
Long Statement,SteamKit2,ZipUtil,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\ZipUtil.cs,Compress,The length of the statement  "                UInt32 CDRSize = WriteCentralDirectory( writer' "z"' checkSum' ( UInt32 )compressed.Length' ( UInt32 )buffer.Length' poslocal ); " is 128.
Long Statement,SteamKit2.Internal,CMClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CMClient.cs,OnClientMsgReceived,The length of the statement  "            DebugLog.WriteLine( "CMClient"' "<- Recv'd EMsg: {0} ({1}) (Proto: {2})"' packetMsg.MsgType' ( int )packetMsg.MsgType' packetMsg.IsProto ); " is 139.
Long Statement,SteamKit2.Internal,CMClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CMClient.cs,CreateConnection,The length of the statement  "            throw new ArgumentOutOfRangeException( nameof(protocol)' protocol' "Protocol bitmask has no supported protocols set." ); " is 120.
Long Statement,SteamKit2.Internal,CMClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CMClient.cs,GetPacketMsg,The length of the statement  "                DebugLog.WriteLine( nameof(CMClient)' "PacketMsg too small to contain a message' was only {0} bytes. Message: 0x{1}"' data.Length' BitConverter.ToString( data ).Replace( "-"' string.Empty ) ); " is 192.
Long Statement,SteamKit2.Internal,CMClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CMClient.cs,GetPacketMsg,The length of the statement  "                DebugLog.WriteLine( "CMClient"' "Exception deserializing emsg {0} ({1}).\n{2}"' eMsg' MsgUtil.IsProtoBuf( rawEMsg )' ex.ToString() ); " is 133.
Long Statement,SteamKit2.Internal,CMClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CMClient.cs,HandleLogOnResponse,The length of the statement  "                DebugLog.WriteLine( "CMClient"' "Got non-proto logon response' this is indicative of no logon attempt after connecting." ); " is 123.
Long Statement,SteamKit2.Internal,CMClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CMClient.cs,HandleCMList,The length of the statement  "            DebugLog.Assert( cmMsg.Body.cm_addresses.Count == cmMsg.Body.cm_ports.Count' "CMClient"' "HandleCMList received malformed message" ); " is 133.
Long Statement,SteamKit2.Internal,CMClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CMClient.cs,HandleCMList,The length of the statement  "                .Zip( cmMsg.Body.cm_ports' ( addr' port ) => ServerRecord.CreateSocketServer( new IPEndPoint( NetHelpers.GetIPAddress( addr ) ' ( int )port ) ) ); " is 146.
Long Statement,SteamKit2.Discovery,SmartCMServerList,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\Discovery\SmartCMServerList.cs,ResolveServerList,The length of the statement  "            IEnumerable<ServerRecord> serverList = await configuration.ServerListProvider.FetchServerListAsync().ConfigureAwait( false ); " is 125.
Long Statement,SteamKit2.Discovery,SmartCMServerList,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\Discovery\SmartCMServerList.cs,TryMark,The length of the statement  "                var serverInfos = servers.Where( x => x.Record.EndPoint.Equals( endPoint ) && x.Protocol.HasFlagsFast( protocolTypes ) ).ToArray(); " is 131.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1(); " is 126.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1(); " is 126.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,FillDistancesPrices,The length of the statement  "					_posSlotPrices[st + posSlot] += ((((posSlot >> 1) - 1) - Base.kNumAlignBits) << RangeCoder.BitEncoder.kNumBitPriceShiftBits); " is 125.
Long Statement,SteamKit2.Util,Win32Helpers,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Win32Helpers.cs,GetBootDiskNumber,The length of the statement  "			using ( var handle = NativeMethods.CreateFile( volumeName' 0' NativeMethods.FILE_SHARE_READ | NativeMethods.FILE_SHARE_WRITE' IntPtr.Zero' NativeMethods.OPEN_EXISTING' 0' IntPtr.Zero ) ) " is 186.
Long Statement,SteamKit2.Util,Win32Helpers,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Win32Helpers.cs,GetBootDiskNumber,The length of the statement  "					if ( !NativeMethods.DeviceIoControl( handle' NativeMethods.IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS' IntPtr.Zero' 0' pointer' (uint)bufferSize' out bytesReturned' IntPtr.Zero ) ) " is 174.
Long Statement,SteamKit2.Util,Win32Helpers,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Win32Helpers.cs,GetPhysicalDriveSerialNumber,The length of the statement  "			using (var handle = NativeMethods.CreateFile( $@"\\.\PhysicalDrive{driveNumber}"' 0' NativeMethods.FILE_SHARE_READ | NativeMethods.FILE_SHARE_WRITE' IntPtr.Zero' NativeMethods.OPEN_EXISTING' 0' IntPtr.Zero ) ) " is 209.
Long Statement,SteamKit2.Util,Win32Helpers,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Win32Helpers.cs,GetPhysicalDriveSerialNumber,The length of the statement  "						if ( !NativeMethods.DeviceIoControl( handle' NativeMethods.IOCTL_STORAGE_QUERY_PROPERTY' queryPtr' ( uint )querySize' headerPtr' ( uint )headerSize' out bytesReturned' IntPtr.Zero ) ) " is 183.
Long Statement,SteamKit2.Util,Win32Helpers,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Win32Helpers.cs,GetPhysicalDriveSerialNumber,The length of the statement  "					// 2. Call DeviceIOControl(STORAGE_PROPERTY_QUERY' STORAGE_DEVICE_DESCRIPTOR) to get a bunch of device info with a header " is 121.
Long Statement,SteamKit2.Util,Win32Helpers,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Win32Helpers.cs,GetPhysicalDriveSerialNumber,The length of the statement  "						if ( !NativeMethods.DeviceIoControl( handle' NativeMethods.IOCTL_STORAGE_QUERY_PROPERTY' queryPtr' ( uint )querySize' descriptorPtr' descriptorSize' out bytesReturned' IntPtr.Zero ) ) " is 183.
Complex Conditional,SteamKit2,WebHelpers,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Utils.cs,IsUrlSafeChar,The conditional expression  "( ( ( ch >= 'a' ) && ( ch <= 'z' ) ) || ( ( ch >= 'A' ) && ( ch <= 'Z' ) ) ) || ( ( ch >= '0' ) && ( ch <= '9' ) )"  is complex.
Complex Conditional,SteamKit2.Internal,Callback<TCall>,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\SteamClient\CallbackMgr\CallbackMgr_Internals.cs,Run,The conditional expression  "cb != null && (cb.JobID == JobID || JobID == JobID.Invalid) && OnRun != null"  is complex.
Empty Catch Block,SteamKit2,TcpConnection,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\TcpConnection.cs,Shutdown,The method has an empty catch block.
Empty Catch Block,SteamKit2,WebSocketContext,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\WebSocketContext.cs,Dispose,The method has an empty catch block.
Empty Catch Block,SteamKit2,UFSClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\UFSClient\Callbacks.cs,Send,The method has an empty catch block.
Empty Catch Block,SteamKit2,UFSClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\UFSClient\Callbacks.cs,Send,The method has an empty catch block.
Empty Catch Block,SteamKit2.Internal,CMClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CMClient.cs,Send,The method has an empty catch block.
Empty Catch Block,SteamKit2.Internal,CMClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CMClient.cs,Send,The method has an empty catch block.
Magic Number,SteamKit2,EnvelopeEncryptedConnection,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\EnvelopeEncryptedConnection.cs,HandleEncryptRequest,The following statement contains a magic number: if ( request.Payload.Length >= 16 )              {                  randomChallenge = request.Payload.ToArray();              }              else              {                  randomChallenge = null;              }
Magic Number,SteamKit2,EnvelopeEncryptedConnection,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\EnvelopeEncryptedConnection.cs,HandleEncryptRequest,The following statement contains a magic number: var tempSessionKey = CryptoHelper.GenerateRandomBlock( 32 );
Magic Number,SteamKit2,NetFilterEncryption,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\NetFilterEncryption.cs,NetFilterEncryption,The following statement contains a magic number: DebugLog.Assert( sessionKey.Length == 32' nameof(NetFilterEncryption)' "AES session key was not 32 bytes!" );
Magic Number,SteamKit2,NetFilterEncryptionWithHMAC,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\NetFilterEncryptionWithHMAC.cs,NetFilterEncryptionWithHMAC,The following statement contains a magic number: DebugLog.Assert( sessionKey.Length == 32' nameof(NetFilterEncryption)' "AES session key was not 32 bytes!" );
Magic Number,SteamKit2,NetFilterEncryptionWithHMAC,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\NetFilterEncryptionWithHMAC.cs,NetFilterEncryptionWithHMAC,The following statement contains a magic number: this.hmacSecret = new byte[ 16 ];
Magic Number,SteamKit2,TcpConnection,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\TcpConnection.cs,NetLoop,The following statement contains a magic number: const int POLL_MS = 100;
Magic Number,SteamKit2,TcpConnection,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\TcpConnection.cs,NetLoop,The following statement contains a magic number: while (!cancellationToken.IsCancellationRequested)              {                  bool canRead = false;                    try                  {                      canRead = socket.Poll(POLL_MS * 1000' SelectMode.SelectRead);                  }                  catch (SocketException ex)                  {                      DebugLog.WriteLine("TcpConnection"' "Socket exception while polling: {0}"' ex);                      break;                  }                    if (!canRead)                  {                      // nothing to read yet                      continue;                  }                    byte[] packData = null;                    try                  {                      // read the packet off the network                      packData = ReadPacket();                  }                  catch (IOException ex)                  {                      DebugLog.WriteLine("TcpConnection"' "Socket exception occurred while reading packet: {0}"' ex);                      break;                  }                    try                  {                      NetMsgReceived?.Invoke( this' new NetMsgEventArgs( packData' destination ) );                  }                  catch (Exception ex)                  {                      DebugLog.WriteLine("TcpConnection"' "Unexpected exception propogated back to NetLoop: {0}"' ex);                  }              }
Magic Number,SteamKit2,UdpConnection,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\UdpConnection.cs,Disconnect,The following statement contains a magic number: sourceConnId += 256;
Magic Number,SteamKit2,UdpConnection,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\UdpConnection.cs,NetLoop,The following statement contains a magic number: byte[] buf = new byte[2048];
Magic Number,SteamKit2,UdpConnection,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\UdpConnection.cs,NetLoop,The following statement contains a magic number: while ( state != (int)State.Disconnected )              {                  try                  {                      // Wait up to 150ms for data' if none is found and the timeout is exceeded' we're done here.                      if ( !sock.Poll(150000' SelectMode.SelectRead)                          && DateTime.Now > timeOut )                      {                          DebugLog.WriteLine("UdpConnection"' "Connection timed out");                            state = (int)State.Disconnected;                          break;                      }                        // By using a 10ms wait' we allow for multiple packets sent at the time to all be processed before moving on                      // to processing output and therefore Acks (the more we process at the same time' the fewer acks we have to send)                      while ( sock.Poll(10000' SelectMode.SelectRead) )                      {                          int length = sock.ReceiveFrom(buf' ref packetSender);                            // Ignore packets that aren't sent by the server we're connected to.                          if ( !packetSender.Equals( CurrentEndPoint ) )                              continue;                            // Data from the desired server was received; delay timeout                          timeOut = DateTime.Now.AddSeconds(TIMEOUT_DELAY);                            MemoryStream ms = new MemoryStream(buf' 0' length);                          UdpPacket packet = new UdpPacket(ms);                            ReceivePacket(packet);                      }                  }                  catch ( IOException ex )                  {                      DebugLog.WriteLine( "UdpConnection"' "Exception occurred while reading packet: {0}"' ex );                        state = ( int )State.Disconnected;                      break;                  }                  catch ( SocketException e )                  {                      DebugLog.WriteLine( "UdpConnection"' "Critical socket failure: " + e.SocketErrorCode );                        state = ( int )State.Disconnected;                      break;                  }                    // Send or resend any sequenced packets; a call to ReceivePacket can set our state to disconnected                  // so don't send anything we have queued in that case                  if ( state != ( int )State.Disconnected )                      SendPendingMessages();                    // If we received data but had no data to send back' we need to manually Ack (usually tags along with                  // outgoing data); also acks disconnections                  if ( inSeq != inSeqAcked )                      SendAck();                    // If a graceful shutdown has been requested' nothing in the outgoing queue is discarded.                  // Once it's empty' we exit' since the last packet was our disconnect notification.                  if ( state == ( int )State.Disconnecting && outPackets.Count == 0 )                  {                      DebugLog.WriteLine( "UdpConnection"' "Graceful disconnect completed" );                        state = ( int )State.Disconnected;                      userRequestedDisconnect = true;                      break;                  }              }
Magic Number,SteamKit2,UdpConnection,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\UdpConnection.cs,NetLoop,The following statement contains a magic number: while ( state != (int)State.Disconnected )              {                  try                  {                      // Wait up to 150ms for data' if none is found and the timeout is exceeded' we're done here.                      if ( !sock.Poll(150000' SelectMode.SelectRead)                          && DateTime.Now > timeOut )                      {                          DebugLog.WriteLine("UdpConnection"' "Connection timed out");                            state = (int)State.Disconnected;                          break;                      }                        // By using a 10ms wait' we allow for multiple packets sent at the time to all be processed before moving on                      // to processing output and therefore Acks (the more we process at the same time' the fewer acks we have to send)                      while ( sock.Poll(10000' SelectMode.SelectRead) )                      {                          int length = sock.ReceiveFrom(buf' ref packetSender);                            // Ignore packets that aren't sent by the server we're connected to.                          if ( !packetSender.Equals( CurrentEndPoint ) )                              continue;                            // Data from the desired server was received; delay timeout                          timeOut = DateTime.Now.AddSeconds(TIMEOUT_DELAY);                            MemoryStream ms = new MemoryStream(buf' 0' length);                          UdpPacket packet = new UdpPacket(ms);                            ReceivePacket(packet);                      }                  }                  catch ( IOException ex )                  {                      DebugLog.WriteLine( "UdpConnection"' "Exception occurred while reading packet: {0}"' ex );                        state = ( int )State.Disconnected;                      break;                  }                  catch ( SocketException e )                  {                      DebugLog.WriteLine( "UdpConnection"' "Critical socket failure: " + e.SocketErrorCode );                        state = ( int )State.Disconnected;                      break;                  }                    // Send or resend any sequenced packets; a call to ReceivePacket can set our state to disconnected                  // so don't send anything we have queued in that case                  if ( state != ( int )State.Disconnected )                      SendPendingMessages();                    // If we received data but had no data to send back' we need to manually Ack (usually tags along with                  // outgoing data); also acks disconnections                  if ( inSeq != inSeqAcked )                      SendAck();                    // If a graceful shutdown has been requested' nothing in the outgoing queue is discarded.                  // Once it's empty' we exit' since the last packet was our disconnect notification.                  if ( state == ( int )State.Disconnecting && outPackets.Count == 0 )                  {                      DebugLog.WriteLine( "UdpConnection"' "Graceful disconnect completed" );                        state = ( int )State.Disconnected;                      userRequestedDisconnect = true;                      break;                  }              }
Magic Number,SteamKit2,WebSocketContext,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\WebSocketContext.cs,ReadMessageAsync,The following statement contains a magic number: using (var ms = new MemoryStream())                  {                      var buffer = new byte[1024];                      var segment = new ArraySegment<byte>(buffer);                        WebSocketReceiveResult result;                      do                      {                          try                          {                              result = await socket.ReceiveAsync(segment' cancellationToken).ConfigureAwait(false);                          }                          catch (ObjectDisposedException)                          {                              DisconnectNonBlocking(userInitiated: cancellationToken.IsCancellationRequested);                              return null;                          }                          catch (WebSocketException)                          {                              DisconnectNonBlocking(userInitiated: false);                              return null;                          }                          catch (Win32Exception)                          {                              DisconnectNonBlocking(userInitiated: false);                              return null;                          }                            switch (result.MessageType)                          {                              case WebSocketMessageType.Binary:                                  ms.Write(buffer' 0' result.Count);                                  DebugLog.WriteLine(nameof(WebSocketContext)' "Recieved {0} bytes."' result.Count);                                  break;                                case WebSocketMessageType.Text:                                  try                                  {                                      var message = Encoding.UTF8.GetString(buffer' 0' result.Count);                                      DebugLog.WriteLine(nameof(WebSocketContext)' "Recieved websocket text message: \"{0}\""' message);                                  }                                  catch                                  {                                      var frameBytes = new byte[result.Count];                                      Array.Copy(buffer' 0' frameBytes' 0' result.Count);                                      var frameHexBytes = BitConverter.ToString(frameBytes).Replace("-"' string.Empty);                                      DebugLog.WriteLine(nameof(WebSocketContext)' "Recieved websocket text message: 0x{0}"' frameHexBytes);                                  }                                  break;                                case WebSocketMessageType.Close:                              default:                                  DisconnectNonBlocking(userInitiated: false);                                  return null;                          }                      }                      while (!result.EndOfMessage);                        return ms.ToArray();                  }
Magic Number,SteamKit2,CDNClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CDNClient.cs,FetchServerListAsync,The following statement contains a magic number: foreach ( var server in serverKv.Children )              {                  string type = server[ "type" ].AsString();                  string host = server[ "host" ].AsString();                  string vhost = server[ "vhost" ].AsString();                    string[] hostSplits = host.Split( ':' );                    int port = 80;                  if ( hostSplits.Length > 1 )                  {                      int parsedPort;                      if ( int.TryParse( hostSplits[ 1 ]' out parsedPort ) )                      {                          port = parsedPort;                      }                  }                    uint serverCell = ( uint )server[ "cell" ].AsInteger();                  int load = server[ "load" ].AsInteger();                  int weightedLoad = server[ "weightedload" ].AsInteger();                  int entries = server[ "NumEntriesInClientList" ].AsInteger( 1 );                  int useTokenAuth = server[ "usetokenauth" ].AsInteger();                  string httpsSupport = server[ "https_support" ].AsString();                    // If usetokenauth is specified' we can treat this server as a CDN and request tokens                  if ( useTokenAuth > 0 )                  {                      type = "CDN";                  }                    Server.ConnectionProtocol protocol = ( httpsSupport == "optional" || httpsSupport == "mandatory" ) ? Server.ConnectionProtocol.HTTPS : Server.ConnectionProtocol.HTTP;                    serverList.Add( new Server                  {                      Protocol = protocol'                      Host = host'                      VHost = vhost'                      Port = protocol == Server.ConnectionProtocol.HTTPS ? 443 : port'                        Type = type'                        CellID = serverCell'                        Load = load'                      WeightedLoad = weightedLoad'                      NumEntries = entries                  } );                                }
Magic Number,SteamKit2,CDNClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CDNClient.cs,FetchServerListAsync,The following statement contains a magic number: foreach ( var server in serverKv.Children )              {                  string type = server[ "type" ].AsString();                  string host = server[ "host" ].AsString();                  string vhost = server[ "vhost" ].AsString();                    string[] hostSplits = host.Split( ':' );                    int port = 80;                  if ( hostSplits.Length > 1 )                  {                      int parsedPort;                      if ( int.TryParse( hostSplits[ 1 ]' out parsedPort ) )                      {                          port = parsedPort;                      }                  }                    uint serverCell = ( uint )server[ "cell" ].AsInteger();                  int load = server[ "load" ].AsInteger();                  int weightedLoad = server[ "weightedload" ].AsInteger();                  int entries = server[ "NumEntriesInClientList" ].AsInteger( 1 );                  int useTokenAuth = server[ "usetokenauth" ].AsInteger();                  string httpsSupport = server[ "https_support" ].AsString();                    // If usetokenauth is specified' we can treat this server as a CDN and request tokens                  if ( useTokenAuth > 0 )                  {                      type = "CDN";                  }                    Server.ConnectionProtocol protocol = ( httpsSupport == "optional" || httpsSupport == "mandatory" ) ? Server.ConnectionProtocol.HTTPS : Server.ConnectionProtocol.HTTP;                    serverList.Add( new Server                  {                      Protocol = protocol'                      Host = host'                      VHost = vhost'                      Port = protocol == Server.ConnectionProtocol.HTTPS ? 443 : port'                        Type = type'                        CellID = serverCell'                        Load = load'                      WeightedLoad = weightedLoad'                      NumEntries = entries                  } );                                }
Magic Number,SteamKit2,CDNClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CDNClient.cs,ConnectAsync,The following statement contains a magic number: sessionKey = CryptoHelper.GenerateRandomBlock( 32 );
Magic Number,SteamKit2,CDNClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CDNClient.cs,DownloadManifestAsync,The following statement contains a magic number: var server = new Server              {                  Protocol = Server.ConnectionProtocol.HTTP'                  Host = host'                  VHost = host'                  Port = 80              };
Magic Number,SteamKit2,CDNClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CDNClient.cs,DownloadDepotChunkAsync,The following statement contains a magic number: var server = new Server              {                  Protocol = Server.ConnectionProtocol.HTTP'                  Host = host'                  VHost = host'                  Port = 80              };
Magic Number,SteamKit2,SteamUser,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\Handlers\SteamUser\Callbacks.cs,LogOn,The following statement contains a magic number: logon.Body.client_package_version = 1771;
Magic Number,SteamKit2,MarketingMessageCallback,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\Handlers\SteamUser\Callbacks.cs,MarketingMessageCallback,The following statement contains a magic number: using ( var ms = new MemoryStream( payload ) )                  using ( var br = new BinaryReader( ms ) )                  {                      for ( int x = 0 ; x < body.Count ; ++x )                      {                          int dataLen = br.ReadInt32() - 4; // total length includes the 4 byte length                          byte[] messageData = br.ReadBytes( dataLen );                            msgList.Add( new Message( messageData ) );                      }                  }
Magic Number,SteamKit2,SteamConfigurationBuilder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\SteamClient\Configuration\SteamConfigurationBuilder.cs,CreateDefaultState,The following statement contains a magic number: return new SteamConfigurationState              {                  AllowDirectoryFetch = true'                    ConnectionTimeout = TimeSpan.FromSeconds(5)'                    DefaultPersonaStateFlags =                      EClientPersonaStateFlag.PlayerName | EClientPersonaStateFlag.Presence |                      EClientPersonaStateFlag.SourceID | EClientPersonaStateFlag.GameExtraInfo |                      EClientPersonaStateFlag.LastSeen'                    ProtocolTypes = ProtocolTypes.Tcp'                    ServerListProvider = new NullServerListProvider()'                    Universe = EUniverse.Public'                    WebAPIBaseAddress = WebAPI.DefaultBaseAddress              };
Magic Number,SteamKit2,UFSClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\UFSClient\Callbacks.cs,UFSClient,The following statement contains a magic number: ConnectionTimeout = TimeSpan.FromSeconds( 5 );
Magic Number,SteamKit2,UFSClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\UFSClient\Callbacks.cs,UploadFile,The following statement contains a magic number: const uint MaxBytesPerChunk = 10240;
Magic Number,SteamKit2,AsyncInterface,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\WebAPI\WebAPI.cs,AsyncInterface,The following statement contains a magic number: httpClient = new HttpClient                  {                      BaseAddress = baseAddress'                      Timeout = TimeSpan.FromSeconds(100)                  };
Magic Number,SteamKit2,DepotManifest,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Types\DepotManifest.cs,Deserialize,The following statement contains a magic number: using ( var ms = new MemoryStream( data ) )              using ( var br = new BinaryReader( ms ) )              {                  while ( ( ms.Length - ms.Position ) > 0 )                  {                      uint magic = br.ReadUInt32();                        switch ( magic )                      {                          case Steam3Manifest.MAGIC:                              ms.Seek(-4' SeekOrigin.Current);                              Steam3Manifest binaryManifest = new Steam3Manifest( br );                              ParseBinaryManifest( binaryManifest );                                uint marker = br.ReadUInt32();                              if ( marker != magic )                                  throw new InvalidDataException( "Unable to find end of message marker for depot manifest" );                              break;                            case DepotManifest.PROTOBUF_PAYLOAD_MAGIC:                              uint payload_length = br.ReadUInt32();                              byte[] payload_bytes = br.ReadBytes( (int)payload_length );                              using ( var ms_payload = new MemoryStream( payload_bytes ) )                                   payload = Serializer.Deserialize<ContentManifestPayload>( ms_payload );                              break;                            case DepotManifest.PROTOBUF_METADATA_MAGIC:                              uint metadata_length = br.ReadUInt32();                              byte[] metadata_bytes = br.ReadBytes( (int)metadata_length );                              using ( var ms_metadata = new MemoryStream( metadata_bytes ) )                                  metadata = Serializer.Deserialize<ContentManifestMetadata>( ms_metadata );                              break;                            case DepotManifest.PROTOBUF_SIGNATURE_MAGIC:                              uint signature_length = br.ReadUInt32();                              byte[] signature_bytes = br.ReadBytes( (int)signature_length );                              using ( var ms_signature = new MemoryStream( signature_bytes ) )                                  signature = Serializer.Deserialize<ContentManifestSignature>( ms_signature );                              break;                            case DepotManifest.PROTOBUF_ENDOFMANIFEST_MAGIC:                              break;                            default:                              throw new NotImplementedException( string.Format( "Unrecognized magic value {0:X} in depot manifest."' magic ) );                      }                  }              }
Magic Number,SteamKit2,AsyncJob,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Types\JobID.cs,Heartbeat,The following statement contains a magic number: Timeout += TimeSpan.FromSeconds( 10 );
Magic Number,SteamKit2,KVTextReader,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Types\KeyValue.cs,ReadToken,The following statement contains a magic number: while ( !EndOfStream )              {                  next = ( char )Peek();                    if ( next == '"' || next == '{' || next == '}' )                      break;                    if ( next == '[' )                      bConditionalStart = true;                    if ( next == ']' && bConditionalStart )                      wasConditional = true;                    if ( Char.IsWhiteSpace( next ) )                      break;                    if ( count < 1023 )                  {                      ret.Append( next );                  }                  else                  {                      throw new Exception( "ReadToken overflow" );                  }                    Read();              }
Magic Number,SteamKit2,FileMapping,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Types\Manifest.cs,Deserialize,The following statement contains a magic number: HashContent = ds.ReadBytes( 20 );
Magic Number,SteamKit2,FileMapping,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Types\Manifest.cs,Deserialize,The following statement contains a magic number: HashFileName = ds.ReadBytes( 20 );
Magic Number,SteamKit2,Chunk,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Types\Manifest.cs,Deserialize,The following statement contains a magic number: ChunkGID = ds.ReadBytes( 20 );
Magic Number,SteamKit2,Chunk,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Types\Manifest.cs,Deserialize,The following statement contains a magic number: Checksum = ds.ReadBytes( 4 );
Magic Number,SteamKit2,AsnParser,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\AsnKeyParser.cs,GetLength,The following statement contains a magic number: try                  {                      byte b = GetNextOctet();                        if (b == (b & 0x7f))                      {                          return b;                      }                      int i = b & 0x7f;                        if (i > 4)                      {                          var sb = new StringBuilder("Invalid Length Encoding. ");                          sb.AppendFormat("Length uses {0} _octets"'                                          i.ToString(CultureInfo.InvariantCulture));                          throw new BerDecodeException(sb.ToString()' position);                      }                        while (0 != i--)                      {                          // shift left                          length <<= 8;                            length |= GetNextOctet();                      }                  }                  catch (ArgumentOutOfRangeException ex)                  {                      throw new BerDecodeException("Error Parsing Key"' position' ex);                  }
Magic Number,SteamKit2,AsnParser,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\AsnKeyParser.cs,GetLength,The following statement contains a magic number: try                  {                      byte b = GetNextOctet();                        if (b == (b & 0x7f))                      {                          return b;                      }                      int i = b & 0x7f;                        if (i > 4)                      {                          var sb = new StringBuilder("Invalid Length Encoding. ");                          sb.AppendFormat("Length uses {0} _octets"'                                          i.ToString(CultureInfo.InvariantCulture));                          throw new BerDecodeException(sb.ToString()' position);                      }                        while (0 != i--)                      {                          // shift left                          length <<= 8;                            length |= GetNextOctet();                      }                  }                  catch (ArgumentOutOfRangeException ex)                  {                      throw new BerDecodeException("Error Parsing Key"' position' ex);                  }
Magic Number,SteamKit2,Crc32,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Crc32.cs,InitializeTable,The following statement contains a magic number: UInt32[] createTable = new UInt32[ 256 ];
Magic Number,SteamKit2,Crc32,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Crc32.cs,InitializeTable,The following statement contains a magic number: for ( int i = 0 ; i < 256 ; i++ )              {                  UInt32 entry = ( UInt32 )i;                  for ( int j = 0 ; j < 8 ; j++ )                      if ( ( entry & 1 ) == 1 )                          entry = ( entry >> 1 ) ^ polynomial;                      else                          entry = entry >> 1;                  createTable[ i ] = entry;              }
Magic Number,SteamKit2,Crc32,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Crc32.cs,InitializeTable,The following statement contains a magic number: for ( int i = 0 ; i < 256 ; i++ )              {                  UInt32 entry = ( UInt32 )i;                  for ( int j = 0 ; j < 8 ; j++ )                      if ( ( entry & 1 ) == 1 )                          entry = ( entry >> 1 ) ^ polynomial;                      else                          entry = entry >> 1;                  createTable[ i ] = entry;              }
Magic Number,SteamKit2,Crc32,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Crc32.cs,CalculateHash,The following statement contains a magic number: for ( int i = start ; i < size ; i++ )                  unchecked                  {                      crc = ( crc >> 8 ) ^ table[ buffer[ i ] ^ crc & 0xff ];                  }
Magic Number,SteamKit2,Crc32,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Crc32.cs,UInt32ToBigEndianBytes,The following statement contains a magic number: return new byte[] {  			    (byte)((x >> 24) & 0xff)'  			    (byte)((x >> 16) & 0xff)'  			    (byte)((x >> 8) & 0xff)'  			    (byte)(x & 0xff)  		    };
Magic Number,SteamKit2,Crc32,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Crc32.cs,UInt32ToBigEndianBytes,The following statement contains a magic number: return new byte[] {  			    (byte)((x >> 24) & 0xff)'  			    (byte)((x >> 16) & 0xff)'  			    (byte)((x >> 8) & 0xff)'  			    (byte)(x & 0xff)  		    };
Magic Number,SteamKit2,Crc32,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Crc32.cs,UInt32ToBigEndianBytes,The following statement contains a magic number: return new byte[] {  			    (byte)((x >> 24) & 0xff)'  			    (byte)((x >> 16) & 0xff)'  			    (byte)((x >> 8) & 0xff)'  			    (byte)(x & 0xff)  		    };
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,AESEncrypt,The following statement contains a magic number: using ( var aes = Aes.Create() )              {                  aes.BlockSize = 128;                  aes.KeySize = 128;                    aes.Mode = CipherMode.CBC;                  aes.Padding = PaddingMode.PKCS7;                    using ( var aesTransform = aes.CreateEncryptor( key' iv ) )                  using ( var ms = new MemoryStream() )                  using ( var cs = new CryptoStream( ms' aesTransform' CryptoStreamMode.Write ) )                  {                      cs.Write( input' 0' input.Length );                      cs.FlushFinalBlock();                                            return ms.ToArray();                  }              }
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,AESEncrypt,The following statement contains a magic number: using ( var aes = Aes.Create() )              {                  aes.BlockSize = 128;                  aes.KeySize = 128;                    aes.Mode = CipherMode.CBC;                  aes.Padding = PaddingMode.PKCS7;                    using ( var aesTransform = aes.CreateEncryptor( key' iv ) )                  using ( var ms = new MemoryStream() )                  using ( var cs = new CryptoStream( ms' aesTransform' CryptoStreamMode.Write ) )                  {                      cs.Write( input' 0' input.Length );                      cs.FlushFinalBlock();                                            return ms.ToArray();                  }              }
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,AESDecrypt,The following statement contains a magic number: using ( var aes = Aes.Create() )              {                  aes.BlockSize = 128;                  aes.KeySize = 128;                    aes.Mode = CipherMode.CBC;                  aes.Padding = PaddingMode.PKCS7;                    byte[] plainText = new byte[ input.Length ];                  int outLen = 0;                    using ( var aesTransform = aes.CreateDecryptor( key' iv ) )                  using ( var ms = new MemoryStream( input ) )                  using ( var cs = new CryptoStream( ms' aesTransform' CryptoStreamMode.Read ) )                  {                      outLen = cs.Read( plainText' 0' plainText.Length );                  }                    byte[] output = new byte[ outLen ];                  Array.Copy( plainText' 0' output' 0' output.Length );                    return output;              }
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,AESDecrypt,The following statement contains a magic number: using ( var aes = Aes.Create() )              {                  aes.BlockSize = 128;                  aes.KeySize = 128;                    aes.Mode = CipherMode.CBC;                  aes.Padding = PaddingMode.PKCS7;                    byte[] plainText = new byte[ input.Length ];                  int outLen = 0;                    using ( var aesTransform = aes.CreateDecryptor( key' iv ) )                  using ( var ms = new MemoryStream( input ) )                  using ( var cs = new CryptoStream( ms' aesTransform' CryptoStreamMode.Read ) )                  {                      outLen = cs.Read( plainText' 0' plainText.Length );                  }                    byte[] output = new byte[ outLen ];                  Array.Copy( plainText' 0' output' 0' output.Length );                    return output;              }
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,SymmetricEncryptWithIV,The following statement contains a magic number: DebugLog.Assert( key.Length == 32' "CryptoHelper"' "SymmetricEncrypt used with non 32 byte key!" );
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,SymmetricEncryptWithIV,The following statement contains a magic number: using ( var aes = Aes.Create() )              {                  aes.BlockSize = 128;                  aes.KeySize = 256;                    var cryptedIv = new byte[ 16 ];                                    // encrypt iv using ECB and provided key                  aes.Mode = CipherMode.ECB;                  aes.Padding = PaddingMode.None;                    using ( var aesTransform = aes.CreateEncryptor( key' null ) )                  {                      cryptedIv = aesTransform.TransformFinalBlock( iv' 0' iv.Length );                  }                    // encrypt input plaintext with CBC using the generated (plaintext) IV and the provided key                  aes.Mode = CipherMode.CBC;                  aes.Padding = PaddingMode.PKCS7;                    using ( var aesTransform = aes.CreateEncryptor( key' iv ) )                  using ( var ms = new MemoryStream() )                  using ( var cs = new CryptoStream( ms' aesTransform' CryptoStreamMode.Write ) )                  {                      cs.Write( input' 0' input.Length );                      cs.FlushFinalBlock();                        var cipherText = ms.ToArray();                        // final output is 16 byte ecb crypted IV + cbc crypted plaintext                      var output = new byte[ cryptedIv.Length + cipherText.Length ];                        Array.Copy( cryptedIv' 0' output' 0' cryptedIv.Length );                      Array.Copy( cipherText' 0' output' cryptedIv.Length' cipherText.Length );                        return output;                  }              }
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,SymmetricEncryptWithIV,The following statement contains a magic number: using ( var aes = Aes.Create() )              {                  aes.BlockSize = 128;                  aes.KeySize = 256;                    var cryptedIv = new byte[ 16 ];                                    // encrypt iv using ECB and provided key                  aes.Mode = CipherMode.ECB;                  aes.Padding = PaddingMode.None;                    using ( var aesTransform = aes.CreateEncryptor( key' null ) )                  {                      cryptedIv = aesTransform.TransformFinalBlock( iv' 0' iv.Length );                  }                    // encrypt input plaintext with CBC using the generated (plaintext) IV and the provided key                  aes.Mode = CipherMode.CBC;                  aes.Padding = PaddingMode.PKCS7;                    using ( var aesTransform = aes.CreateEncryptor( key' iv ) )                  using ( var ms = new MemoryStream() )                  using ( var cs = new CryptoStream( ms' aesTransform' CryptoStreamMode.Write ) )                  {                      cs.Write( input' 0' input.Length );                      cs.FlushFinalBlock();                        var cipherText = ms.ToArray();                        // final output is 16 byte ecb crypted IV + cbc crypted plaintext                      var output = new byte[ cryptedIv.Length + cipherText.Length ];                        Array.Copy( cryptedIv' 0' output' 0' cryptedIv.Length );                      Array.Copy( cipherText' 0' output' cryptedIv.Length' cipherText.Length );                        return output;                  }              }
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,SymmetricEncryptWithIV,The following statement contains a magic number: using ( var aes = Aes.Create() )              {                  aes.BlockSize = 128;                  aes.KeySize = 256;                    var cryptedIv = new byte[ 16 ];                                    // encrypt iv using ECB and provided key                  aes.Mode = CipherMode.ECB;                  aes.Padding = PaddingMode.None;                    using ( var aesTransform = aes.CreateEncryptor( key' null ) )                  {                      cryptedIv = aesTransform.TransformFinalBlock( iv' 0' iv.Length );                  }                    // encrypt input plaintext with CBC using the generated (plaintext) IV and the provided key                  aes.Mode = CipherMode.CBC;                  aes.Padding = PaddingMode.PKCS7;                    using ( var aesTransform = aes.CreateEncryptor( key' iv ) )                  using ( var ms = new MemoryStream() )                  using ( var cs = new CryptoStream( ms' aesTransform' CryptoStreamMode.Write ) )                  {                      cs.Write( input' 0' input.Length );                      cs.FlushFinalBlock();                        var cipherText = ms.ToArray();                        // final output is 16 byte ecb crypted IV + cbc crypted plaintext                      var output = new byte[ cryptedIv.Length + cipherText.Length ];                        Array.Copy( cryptedIv' 0' output' 0' cryptedIv.Length );                      Array.Copy( cipherText' 0' output' cryptedIv.Length' cipherText.Length );                        return output;                  }              }
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,SymmetricEncrypt,The following statement contains a magic number: var iv = GenerateRandomBlock( 16 );
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,SymmetricEncryptWithHMACIV,The following statement contains a magic number: var iv = new byte[ 16 ];
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,SymmetricEncryptWithHMACIV,The following statement contains a magic number: var random = GenerateRandomBlock( 3 );
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,SymmetricDecryptHMACIV,The following statement contains a magic number: Debug.Assert( key.Length >= 16 );
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,SymmetricDecryptHMACIV,The following statement contains a magic number: var truncatedKeyForHmac = new byte[ 16 ];
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,SymmetricDecryptHMACIV,The following statement contains a magic number: using ( var hmac = new HMACSHA1( hmacSecret ) )              using ( var ms = new MemoryStream() )              {                  ms.Write( iv' iv.Length - 3' 3 );                  ms.Write( plaintextData' 0' plaintextData.Length );                  ms.Seek( 0' SeekOrigin.Begin );                    hmacBytes = hmac.ComputeHash( ms );              }
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,SymmetricDecryptHMACIV,The following statement contains a magic number: using ( var hmac = new HMACSHA1( hmacSecret ) )              using ( var ms = new MemoryStream() )              {                  ms.Write( iv' iv.Length - 3' 3 );                  ms.Write( plaintextData' 0' plaintextData.Length );                  ms.Seek( 0' SeekOrigin.Begin );                    hmacBytes = hmac.ComputeHash( ms );              }
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,SymmetricDecryptHMACIV,The following statement contains a magic number: if ( !hmacBytes.Take( iv.Length - 3 ).SequenceEqual( iv.Take( iv.Length - 3 ) ) )              {                  throw new CryptographicException( string.Format( CultureInfo.InvariantCulture' "{0} was unable to decrypt packet: HMAC from server did not match computed HMAC."' nameof(NetFilterEncryption) ) );              }
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,SymmetricDecryptHMACIV,The following statement contains a magic number: if ( !hmacBytes.Take( iv.Length - 3 ).SequenceEqual( iv.Take( iv.Length - 3 ) ) )              {                  throw new CryptographicException( string.Format( CultureInfo.InvariantCulture' "{0} was unable to decrypt packet: HMAC from server did not match computed HMAC."' nameof(NetFilterEncryption) ) );              }
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,SymmetricDecrypt,The following statement contains a magic number: DebugLog.Assert( key.Length == 32' "CryptoHelper"' "SymmetricDecrypt used with non 32 byte key!" );
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,SymmetricDecrypt,The following statement contains a magic number: using ( var aes = Aes.Create() )              {                  aes.BlockSize = 128;                  aes.KeySize = 256;                    // first 16 bytes of input is the ECB encrypted IV                  byte[] cryptedIv = new byte[ 16 ];                  iv = new byte[ cryptedIv.Length ];                  Array.Copy( input' 0' cryptedIv' 0' cryptedIv.Length );                    // the rest is ciphertext                  byte[] cipherText = new byte[ input.Length - cryptedIv.Length ];                  Array.Copy( input' cryptedIv.Length' cipherText' 0' cipherText.Length );                    // decrypt the IV using ECB                  aes.Mode = CipherMode.ECB;                  aes.Padding = PaddingMode.None;                    using ( var aesTransform = aes.CreateDecryptor( key' null ) )                  {                      iv = aesTransform.TransformFinalBlock( cryptedIv' 0' cryptedIv.Length );                  }                    // decrypt the remaining ciphertext in cbc with the decrypted IV                  aes.Mode = CipherMode.CBC;                  aes.Padding = PaddingMode.PKCS7;                    using ( var aesTransform = aes.CreateDecryptor( key' iv ) )                  using ( var ms = new MemoryStream( cipherText ) )                  using ( var cs = new CryptoStream( ms' aesTransform' CryptoStreamMode.Read ) )                  {                      // plaintext is never longer than ciphertext                      byte[] plaintext = new byte[ cipherText.Length ];                        int len = cs.Read( plaintext' 0' plaintext.Length );                        byte[] output = new byte[ len ];                      Array.Copy( plaintext' 0' output' 0' len );                        return output;                  }              }
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,SymmetricDecrypt,The following statement contains a magic number: using ( var aes = Aes.Create() )              {                  aes.BlockSize = 128;                  aes.KeySize = 256;                    // first 16 bytes of input is the ECB encrypted IV                  byte[] cryptedIv = new byte[ 16 ];                  iv = new byte[ cryptedIv.Length ];                  Array.Copy( input' 0' cryptedIv' 0' cryptedIv.Length );                    // the rest is ciphertext                  byte[] cipherText = new byte[ input.Length - cryptedIv.Length ];                  Array.Copy( input' cryptedIv.Length' cipherText' 0' cipherText.Length );                    // decrypt the IV using ECB                  aes.Mode = CipherMode.ECB;                  aes.Padding = PaddingMode.None;                    using ( var aesTransform = aes.CreateDecryptor( key' null ) )                  {                      iv = aesTransform.TransformFinalBlock( cryptedIv' 0' cryptedIv.Length );                  }                    // decrypt the remaining ciphertext in cbc with the decrypted IV                  aes.Mode = CipherMode.CBC;                  aes.Padding = PaddingMode.PKCS7;                    using ( var aesTransform = aes.CreateDecryptor( key' iv ) )                  using ( var ms = new MemoryStream( cipherText ) )                  using ( var cs = new CryptoStream( ms' aesTransform' CryptoStreamMode.Read ) )                  {                      // plaintext is never longer than ciphertext                      byte[] plaintext = new byte[ cipherText.Length ];                        int len = cs.Read( plaintext' 0' plaintext.Length );                        byte[] output = new byte[ len ];                      Array.Copy( plaintext' 0' output' 0' len );                        return output;                  }              }
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,SymmetricDecrypt,The following statement contains a magic number: using ( var aes = Aes.Create() )              {                  aes.BlockSize = 128;                  aes.KeySize = 256;                    // first 16 bytes of input is the ECB encrypted IV                  byte[] cryptedIv = new byte[ 16 ];                  iv = new byte[ cryptedIv.Length ];                  Array.Copy( input' 0' cryptedIv' 0' cryptedIv.Length );                    // the rest is ciphertext                  byte[] cipherText = new byte[ input.Length - cryptedIv.Length ];                  Array.Copy( input' cryptedIv.Length' cipherText' 0' cipherText.Length );                    // decrypt the IV using ECB                  aes.Mode = CipherMode.ECB;                  aes.Padding = PaddingMode.None;                    using ( var aesTransform = aes.CreateDecryptor( key' null ) )                  {                      iv = aesTransform.TransformFinalBlock( cryptedIv' 0' cryptedIv.Length );                  }                    // decrypt the remaining ciphertext in cbc with the decrypted IV                  aes.Mode = CipherMode.CBC;                  aes.Padding = PaddingMode.PKCS7;                    using ( var aesTransform = aes.CreateDecryptor( key' iv ) )                  using ( var ms = new MemoryStream( cipherText ) )                  using ( var cs = new CryptoStream( ms' aesTransform' CryptoStreamMode.Read ) )                  {                      // plaintext is never longer than ciphertext                      byte[] plaintext = new byte[ cipherText.Length ];                        int len = cs.Read( plaintext' 0' plaintext.Length );                        byte[] output = new byte[ len ];                      Array.Copy( plaintext' 0' output' 0' len );                        return output;                  }              }
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,VerifyAndDecryptPassword,The following statement contains a magic number: using( HMACSHA1 hmac = new HMACSHA1(key) )              {                  hash = hmac.ComputeHash( input' 0' 32 );              }
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,VerifyAndDecryptPassword,The following statement contains a magic number: for ( int i = 32; i < input.Length; i++ )                  if ( input[ i ] != hash[ i % 32 ] )                      return null;
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,VerifyAndDecryptPassword,The following statement contains a magic number: for ( int i = 32; i < input.Length; i++ )                  if ( input[ i ] != hash[ i % 32 ] )                      return null;
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,VerifyAndDecryptPassword,The following statement contains a magic number: byte[] encrypted = new byte[ 32 ];
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,SymmetricDecryptECB,The following statement contains a magic number: DebugLog.Assert( key.Length == 32' "CryptoHelper"' "SymmetricDecryptECB used with non 32 byte key!" );
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,SymmetricDecryptECB,The following statement contains a magic number: using ( var aes = Aes.Create() )              {                  aes.BlockSize = 128;                  aes.KeySize = 256;                  aes.Mode = CipherMode.ECB;                  aes.Padding = PaddingMode.PKCS7;                    using ( var aesTransform = aes.CreateDecryptor( key' null ) )                  {                      byte[] output = aesTransform.TransformFinalBlock( input' 0' input.Length );                        return output;                  }              }
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,SymmetricDecryptECB,The following statement contains a magic number: using ( var aes = Aes.Create() )              {                  aes.BlockSize = 128;                  aes.KeySize = 256;                  aes.Mode = CipherMode.ECB;                  aes.Padding = PaddingMode.PKCS7;                    using ( var aesTransform = aes.CreateDecryptor( key' null ) )                  {                      byte[] output = aesTransform.TransformFinalBlock( input' 0' input.Length );                        return output;                  }              }
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,AdlerHash,The following statement contains a magic number: for ( int i = 0 ; i < input.Length ; i++ )              {                  a = ( a + input[ i ] ) % 65521;                  b = ( b + a ) % 65521;              }
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,AdlerHash,The following statement contains a magic number: for ( int i = 0 ; i < input.Length ; i++ )              {                  a = ( a + input[ i ] ) % 65521;                  b = ( b + a ) % 65521;              }
Magic Number,SteamKit2,CryptoHelper,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\CryptoHelper.cs,AdlerHash,The following statement contains a magic number: return BitConverter.GetBytes( a | ( b << 16 ) );
Magic Number,SteamKit2,OSXInfoProvider,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\HardwareUtils.cs,GetMachineGuid,The following statement contains a magic number: if ( platformExpert != 0 )              {                  try                  {                      using ( var serialNumberKey = CFStringCreateWithCString( CFTypeRef.None' kIOPlatformSerialNumberKey' CFStringEncoding.kCFStringEncodingASCII ) )                      {                          var serialNumberAsString = IORegistryEntryCreateCFProperty( platformExpert' serialNumberKey' CFTypeRef.None' 0 );                          var sb = new StringBuilder( 64 );                          if ( CFStringGetCString( serialNumberAsString' sb' sb.Capacity' CFStringEncoding.kCFStringEncodingASCII ) )                          {                              return Encoding.ASCII.GetBytes( sb.ToString() );                          }                      }                  }                  finally                  {                      IOObjectRelease( platformExpert );                  }              }
Magic Number,SteamKit2,OSXInfoProvider,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\HardwareUtils.cs,GetDiskId,The following statement contains a magic number: if ( statted == 0 )              {                  using ( var session = DASessionCreate( CFTypeRef.None ) )                  using ( var disk = DADiskCreateFromBSDName( CFTypeRef.None' session' stat.f_mntfromname ) )                  using ( var properties = DADiskCopyDescription( disk ) )                  using ( var key = CFStringCreateWithCString( CFTypeRef.None' DiskArbitration.kDADiskDescriptionMediaUUIDKey' CFStringEncoding.kCFStringEncodingASCII ) )                  {                      IntPtr cfuuid = IntPtr.Zero;                      if ( CFDictionaryGetValueIfPresent( properties' key' out cfuuid ) )                      {                          using ( var uuidString = CFUUIDCreateString( CFTypeRef.None' cfuuid ) )                          {                              var stringBuilder = new StringBuilder( 64 );                              if ( CFStringGetCString( uuidString' stringBuilder' stringBuilder.Capacity' CFStringEncoding.kCFStringEncodingASCII ) )                              {                                  return Encoding.ASCII.GetBytes( stringBuilder.ToString() );                              }                          }                      }                  }              }
Magic Number,SteamKit2,HardwareUtils,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\HardwareUtils.cs,GetMachineID,The following statement contains a magic number: bool didComplete = generateTask.Wait( TimeSpan.FromSeconds( 30 ) );
Magic Number,SteamKit2,StreamHelpers,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\StreamHelpers.cs,ReadInt16,The following statement contains a magic number: stream.Read( data' 0' 2 );
Magic Number,SteamKit2,StreamHelpers,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\StreamHelpers.cs,ReadUInt16,The following statement contains a magic number: stream.Read(data' 0' 2);
Magic Number,SteamKit2,StreamHelpers,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\StreamHelpers.cs,ReadInt32,The following statement contains a magic number: stream.Read( data' 0' 4 );
Magic Number,SteamKit2,StreamHelpers,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\StreamHelpers.cs,ReadInt64,The following statement contains a magic number: stream.Read( data' 0' 8 );
Magic Number,SteamKit2,StreamHelpers,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\StreamHelpers.cs,ReadUInt32,The following statement contains a magic number: stream.Read(data' 0' 4);
Magic Number,SteamKit2,StreamHelpers,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\StreamHelpers.cs,ReadUInt64,The following statement contains a magic number: stream.Read( data' 0' 8 );
Magic Number,SteamKit2,StreamHelpers,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\StreamHelpers.cs,ReadFloat,The following statement contains a magic number: stream.Read( data' 0' 4 );
Magic Number,SteamKit2,Utils,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Utils.cs,DecodeHexString,The following statement contains a magic number: byte[] bytes = new byte[chars / 2];
Magic Number,SteamKit2,Utils,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Utils.cs,DecodeHexString,The following statement contains a magic number: for (int i = 0; i < chars; i += 2)                  bytes[i / 2] = Convert.ToByte(hex.Substring(i' 2)' 16);
Magic Number,SteamKit2,Utils,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Utils.cs,DecodeHexString,The following statement contains a magic number: for (int i = 0; i < chars; i += 2)                  bytes[i / 2] = Convert.ToByte(hex.Substring(i' 2)' 16);
Magic Number,SteamKit2,Utils,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Utils.cs,DecodeHexString,The following statement contains a magic number: for (int i = 0; i < chars; i += 2)                  bytes[i / 2] = Convert.ToByte(hex.Substring(i' 2)' 16);
Magic Number,SteamKit2,Utils,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Utils.cs,DecodeHexString,The following statement contains a magic number: for (int i = 0; i < chars; i += 2)                  bytes[i / 2] = Convert.ToByte(hex.Substring(i' 2)' 16);
Magic Number,SteamKit2,Utils,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Utils.cs,GetOSType,The following statement contains a magic number: switch ( osVer.Platform )              {                  case PlatformID.Win32Windows:                      {                          switch ( ver.Minor )                          {                              case 0:                                  return EOSType.Win95;                                case 10:                                  return EOSType.Win98;                                case 90:                                  return EOSType.WinME;                                default:                                  return EOSType.WinUnknown;                          }                      }                    case PlatformID.Win32NT:                      {                          switch ( ver.Major )                          {                              case 4:                                  return EOSType.WinNT;                                case 5:                                  switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.Win2000;                                        case 1:                                          return EOSType.WinXP;                                        case 2:                                          // Assume nobody runs Windows XP Professional x64 Edition                                          // It's an edition of Windows Server 2003 anyway.                                          return EOSType.Win2003;                                  }                                    goto default;                                case 6:                                  switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.WinVista; // Also Server 2008                                        case 1:                                          return EOSType.Windows7; // Also Server 2008 R2                                        case 2:                                          return EOSType.Windows8; // Also Server 2012                                        // Note: The OSVersion property reports the same version number (6.2.0.0) for both Windows 8 and Windows 8.1.- http://msdn.microsoft.com/en-us/library/system.environment.osversion(v=vs.110).aspx                                      // In practice' this will only get hit if the application targets Windows 8.1 in the app manifest.                                      // See http://msdn.microsoft.com/en-us/library/windows/desktop/dn481241(v=vs.85).aspx for more info.                                      case 3:                                          return EOSType.Windows81; // Also Server 2012 R2                                  }                                    goto default;                                case 10:                                  return EOSType.Windows10;                                default:                                  return EOSType.WinUnknown;                          }                      }                    case PlatformID.Unix:                      {                          if ( IsMacOS() )                          {                              switch ( ver.Major )                              {                                  case 11:                                      return EOSType.MacOS107; // "Lion"                                    case 12:                                      return EOSType.MacOS108; // "Mountain Lion"                                    case 13:                                      return EOSType.MacOS109; // "Mavericks"                                    case 14:                                     return EOSType.MacOS1010; // "Yosemite"                                    case 15:                                      return EOSType.MacOS1011; // El Capitan                                    case 16:                                      return EOSType.MacOS1012; // Sierra                                    default:                                      return EOSType.MacOSUnknown;                              }                          }                          else                          {                              return EOSType.LinuxUnknown;                          }                      }                    default:                      return EOSType.Unknown;              }
Magic Number,SteamKit2,Utils,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Utils.cs,GetOSType,The following statement contains a magic number: switch ( osVer.Platform )              {                  case PlatformID.Win32Windows:                      {                          switch ( ver.Minor )                          {                              case 0:                                  return EOSType.Win95;                                case 10:                                  return EOSType.Win98;                                case 90:                                  return EOSType.WinME;                                default:                                  return EOSType.WinUnknown;                          }                      }                    case PlatformID.Win32NT:                      {                          switch ( ver.Major )                          {                              case 4:                                  return EOSType.WinNT;                                case 5:                                  switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.Win2000;                                        case 1:                                          return EOSType.WinXP;                                        case 2:                                          // Assume nobody runs Windows XP Professional x64 Edition                                          // It's an edition of Windows Server 2003 anyway.                                          return EOSType.Win2003;                                  }                                    goto default;                                case 6:                                  switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.WinVista; // Also Server 2008                                        case 1:                                          return EOSType.Windows7; // Also Server 2008 R2                                        case 2:                                          return EOSType.Windows8; // Also Server 2012                                        // Note: The OSVersion property reports the same version number (6.2.0.0) for both Windows 8 and Windows 8.1.- http://msdn.microsoft.com/en-us/library/system.environment.osversion(v=vs.110).aspx                                      // In practice' this will only get hit if the application targets Windows 8.1 in the app manifest.                                      // See http://msdn.microsoft.com/en-us/library/windows/desktop/dn481241(v=vs.85).aspx for more info.                                      case 3:                                          return EOSType.Windows81; // Also Server 2012 R2                                  }                                    goto default;                                case 10:                                  return EOSType.Windows10;                                default:                                  return EOSType.WinUnknown;                          }                      }                    case PlatformID.Unix:                      {                          if ( IsMacOS() )                          {                              switch ( ver.Major )                              {                                  case 11:                                      return EOSType.MacOS107; // "Lion"                                    case 12:                                      return EOSType.MacOS108; // "Mountain Lion"                                    case 13:                                      return EOSType.MacOS109; // "Mavericks"                                    case 14:                                     return EOSType.MacOS1010; // "Yosemite"                                    case 15:                                      return EOSType.MacOS1011; // El Capitan                                    case 16:                                      return EOSType.MacOS1012; // Sierra                                    default:                                      return EOSType.MacOSUnknown;                              }                          }                          else                          {                              return EOSType.LinuxUnknown;                          }                      }                    default:                      return EOSType.Unknown;              }
Magic Number,SteamKit2,Utils,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Utils.cs,GetOSType,The following statement contains a magic number: switch ( osVer.Platform )              {                  case PlatformID.Win32Windows:                      {                          switch ( ver.Minor )                          {                              case 0:                                  return EOSType.Win95;                                case 10:                                  return EOSType.Win98;                                case 90:                                  return EOSType.WinME;                                default:                                  return EOSType.WinUnknown;                          }                      }                    case PlatformID.Win32NT:                      {                          switch ( ver.Major )                          {                              case 4:                                  return EOSType.WinNT;                                case 5:                                  switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.Win2000;                                        case 1:                                          return EOSType.WinXP;                                        case 2:                                          // Assume nobody runs Windows XP Professional x64 Edition                                          // It's an edition of Windows Server 2003 anyway.                                          return EOSType.Win2003;                                  }                                    goto default;                                case 6:                                  switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.WinVista; // Also Server 2008                                        case 1:                                          return EOSType.Windows7; // Also Server 2008 R2                                        case 2:                                          return EOSType.Windows8; // Also Server 2012                                        // Note: The OSVersion property reports the same version number (6.2.0.0) for both Windows 8 and Windows 8.1.- http://msdn.microsoft.com/en-us/library/system.environment.osversion(v=vs.110).aspx                                      // In practice' this will only get hit if the application targets Windows 8.1 in the app manifest.                                      // See http://msdn.microsoft.com/en-us/library/windows/desktop/dn481241(v=vs.85).aspx for more info.                                      case 3:                                          return EOSType.Windows81; // Also Server 2012 R2                                  }                                    goto default;                                case 10:                                  return EOSType.Windows10;                                default:                                  return EOSType.WinUnknown;                          }                      }                    case PlatformID.Unix:                      {                          if ( IsMacOS() )                          {                              switch ( ver.Major )                              {                                  case 11:                                      return EOSType.MacOS107; // "Lion"                                    case 12:                                      return EOSType.MacOS108; // "Mountain Lion"                                    case 13:                                      return EOSType.MacOS109; // "Mavericks"                                    case 14:                                     return EOSType.MacOS1010; // "Yosemite"                                    case 15:                                      return EOSType.MacOS1011; // El Capitan                                    case 16:                                      return EOSType.MacOS1012; // Sierra                                    default:                                      return EOSType.MacOSUnknown;                              }                          }                          else                          {                              return EOSType.LinuxUnknown;                          }                      }                    default:                      return EOSType.Unknown;              }
Magic Number,SteamKit2,Utils,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Utils.cs,GetOSType,The following statement contains a magic number: switch ( osVer.Platform )              {                  case PlatformID.Win32Windows:                      {                          switch ( ver.Minor )                          {                              case 0:                                  return EOSType.Win95;                                case 10:                                  return EOSType.Win98;                                case 90:                                  return EOSType.WinME;                                default:                                  return EOSType.WinUnknown;                          }                      }                    case PlatformID.Win32NT:                      {                          switch ( ver.Major )                          {                              case 4:                                  return EOSType.WinNT;                                case 5:                                  switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.Win2000;                                        case 1:                                          return EOSType.WinXP;                                        case 2:                                          // Assume nobody runs Windows XP Professional x64 Edition                                          // It's an edition of Windows Server 2003 anyway.                                          return EOSType.Win2003;                                  }                                    goto default;                                case 6:                                  switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.WinVista; // Also Server 2008                                        case 1:                                          return EOSType.Windows7; // Also Server 2008 R2                                        case 2:                                          return EOSType.Windows8; // Also Server 2012                                        // Note: The OSVersion property reports the same version number (6.2.0.0) for both Windows 8 and Windows 8.1.- http://msdn.microsoft.com/en-us/library/system.environment.osversion(v=vs.110).aspx                                      // In practice' this will only get hit if the application targets Windows 8.1 in the app manifest.                                      // See http://msdn.microsoft.com/en-us/library/windows/desktop/dn481241(v=vs.85).aspx for more info.                                      case 3:                                          return EOSType.Windows81; // Also Server 2012 R2                                  }                                    goto default;                                case 10:                                  return EOSType.Windows10;                                default:                                  return EOSType.WinUnknown;                          }                      }                    case PlatformID.Unix:                      {                          if ( IsMacOS() )                          {                              switch ( ver.Major )                              {                                  case 11:                                      return EOSType.MacOS107; // "Lion"                                    case 12:                                      return EOSType.MacOS108; // "Mountain Lion"                                    case 13:                                      return EOSType.MacOS109; // "Mavericks"                                    case 14:                                     return EOSType.MacOS1010; // "Yosemite"                                    case 15:                                      return EOSType.MacOS1011; // El Capitan                                    case 16:                                      return EOSType.MacOS1012; // Sierra                                    default:                                      return EOSType.MacOSUnknown;                              }                          }                          else                          {                              return EOSType.LinuxUnknown;                          }                      }                    default:                      return EOSType.Unknown;              }
Magic Number,SteamKit2,Utils,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Utils.cs,GetOSType,The following statement contains a magic number: switch ( osVer.Platform )              {                  case PlatformID.Win32Windows:                      {                          switch ( ver.Minor )                          {                              case 0:                                  return EOSType.Win95;                                case 10:                                  return EOSType.Win98;                                case 90:                                  return EOSType.WinME;                                default:                                  return EOSType.WinUnknown;                          }                      }                    case PlatformID.Win32NT:                      {                          switch ( ver.Major )                          {                              case 4:                                  return EOSType.WinNT;                                case 5:                                  switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.Win2000;                                        case 1:                                          return EOSType.WinXP;                                        case 2:                                          // Assume nobody runs Windows XP Professional x64 Edition                                          // It's an edition of Windows Server 2003 anyway.                                          return EOSType.Win2003;                                  }                                    goto default;                                case 6:                                  switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.WinVista; // Also Server 2008                                        case 1:                                          return EOSType.Windows7; // Also Server 2008 R2                                        case 2:                                          return EOSType.Windows8; // Also Server 2012                                        // Note: The OSVersion property reports the same version number (6.2.0.0) for both Windows 8 and Windows 8.1.- http://msdn.microsoft.com/en-us/library/system.environment.osversion(v=vs.110).aspx                                      // In practice' this will only get hit if the application targets Windows 8.1 in the app manifest.                                      // See http://msdn.microsoft.com/en-us/library/windows/desktop/dn481241(v=vs.85).aspx for more info.                                      case 3:                                          return EOSType.Windows81; // Also Server 2012 R2                                  }                                    goto default;                                case 10:                                  return EOSType.Windows10;                                default:                                  return EOSType.WinUnknown;                          }                      }                    case PlatformID.Unix:                      {                          if ( IsMacOS() )                          {                              switch ( ver.Major )                              {                                  case 11:                                      return EOSType.MacOS107; // "Lion"                                    case 12:                                      return EOSType.MacOS108; // "Mountain Lion"                                    case 13:                                      return EOSType.MacOS109; // "Mavericks"                                    case 14:                                     return EOSType.MacOS1010; // "Yosemite"                                    case 15:                                      return EOSType.MacOS1011; // El Capitan                                    case 16:                                      return EOSType.MacOS1012; // Sierra                                    default:                                      return EOSType.MacOSUnknown;                              }                          }                          else                          {                              return EOSType.LinuxUnknown;                          }                      }                    default:                      return EOSType.Unknown;              }
Magic Number,SteamKit2,Utils,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Utils.cs,GetOSType,The following statement contains a magic number: switch ( osVer.Platform )              {                  case PlatformID.Win32Windows:                      {                          switch ( ver.Minor )                          {                              case 0:                                  return EOSType.Win95;                                case 10:                                  return EOSType.Win98;                                case 90:                                  return EOSType.WinME;                                default:                                  return EOSType.WinUnknown;                          }                      }                    case PlatformID.Win32NT:                      {                          switch ( ver.Major )                          {                              case 4:                                  return EOSType.WinNT;                                case 5:                                  switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.Win2000;                                        case 1:                                          return EOSType.WinXP;                                        case 2:                                          // Assume nobody runs Windows XP Professional x64 Edition                                          // It's an edition of Windows Server 2003 anyway.                                          return EOSType.Win2003;                                  }                                    goto default;                                case 6:                                  switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.WinVista; // Also Server 2008                                        case 1:                                          return EOSType.Windows7; // Also Server 2008 R2                                        case 2:                                          return EOSType.Windows8; // Also Server 2012                                        // Note: The OSVersion property reports the same version number (6.2.0.0) for both Windows 8 and Windows 8.1.- http://msdn.microsoft.com/en-us/library/system.environment.osversion(v=vs.110).aspx                                      // In practice' this will only get hit if the application targets Windows 8.1 in the app manifest.                                      // See http://msdn.microsoft.com/en-us/library/windows/desktop/dn481241(v=vs.85).aspx for more info.                                      case 3:                                          return EOSType.Windows81; // Also Server 2012 R2                                  }                                    goto default;                                case 10:                                  return EOSType.Windows10;                                default:                                  return EOSType.WinUnknown;                          }                      }                    case PlatformID.Unix:                      {                          if ( IsMacOS() )                          {                              switch ( ver.Major )                              {                                  case 11:                                      return EOSType.MacOS107; // "Lion"                                    case 12:                                      return EOSType.MacOS108; // "Mountain Lion"                                    case 13:                                      return EOSType.MacOS109; // "Mavericks"                                    case 14:                                     return EOSType.MacOS1010; // "Yosemite"                                    case 15:                                      return EOSType.MacOS1011; // El Capitan                                    case 16:                                      return EOSType.MacOS1012; // Sierra                                    default:                                      return EOSType.MacOSUnknown;                              }                          }                          else                          {                              return EOSType.LinuxUnknown;                          }                      }                    default:                      return EOSType.Unknown;              }
Magic Number,SteamKit2,Utils,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Utils.cs,GetOSType,The following statement contains a magic number: switch ( osVer.Platform )              {                  case PlatformID.Win32Windows:                      {                          switch ( ver.Minor )                          {                              case 0:                                  return EOSType.Win95;                                case 10:                                  return EOSType.Win98;                                case 90:                                  return EOSType.WinME;                                default:                                  return EOSType.WinUnknown;                          }                      }                    case PlatformID.Win32NT:                      {                          switch ( ver.Major )                          {                              case 4:                                  return EOSType.WinNT;                                case 5:                                  switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.Win2000;                                        case 1:                                          return EOSType.WinXP;                                        case 2:                                          // Assume nobody runs Windows XP Professional x64 Edition                                          // It's an edition of Windows Server 2003 anyway.                                          return EOSType.Win2003;                                  }                                    goto default;                                case 6:                                  switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.WinVista; // Also Server 2008                                        case 1:                                          return EOSType.Windows7; // Also Server 2008 R2                                        case 2:                                          return EOSType.Windows8; // Also Server 2012                                        // Note: The OSVersion property reports the same version number (6.2.0.0) for both Windows 8 and Windows 8.1.- http://msdn.microsoft.com/en-us/library/system.environment.osversion(v=vs.110).aspx                                      // In practice' this will only get hit if the application targets Windows 8.1 in the app manifest.                                      // See http://msdn.microsoft.com/en-us/library/windows/desktop/dn481241(v=vs.85).aspx for more info.                                      case 3:                                          return EOSType.Windows81; // Also Server 2012 R2                                  }                                    goto default;                                case 10:                                  return EOSType.Windows10;                                default:                                  return EOSType.WinUnknown;                          }                      }                    case PlatformID.Unix:                      {                          if ( IsMacOS() )                          {                              switch ( ver.Major )                              {                                  case 11:                                      return EOSType.MacOS107; // "Lion"                                    case 12:                                      return EOSType.MacOS108; // "Mountain Lion"                                    case 13:                                      return EOSType.MacOS109; // "Mavericks"                                    case 14:                                     return EOSType.MacOS1010; // "Yosemite"                                    case 15:                                      return EOSType.MacOS1011; // El Capitan                                    case 16:                                      return EOSType.MacOS1012; // Sierra                                    default:                                      return EOSType.MacOSUnknown;                              }                          }                          else                          {                              return EOSType.LinuxUnknown;                          }                      }                    default:                      return EOSType.Unknown;              }
Magic Number,SteamKit2,Utils,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Utils.cs,GetOSType,The following statement contains a magic number: switch ( osVer.Platform )              {                  case PlatformID.Win32Windows:                      {                          switch ( ver.Minor )                          {                              case 0:                                  return EOSType.Win95;                                case 10:                                  return EOSType.Win98;                                case 90:                                  return EOSType.WinME;                                default:                                  return EOSType.WinUnknown;                          }                      }                    case PlatformID.Win32NT:                      {                          switch ( ver.Major )                          {                              case 4:                                  return EOSType.WinNT;                                case 5:                                  switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.Win2000;                                        case 1:                                          return EOSType.WinXP;                                        case 2:                                          // Assume nobody runs Windows XP Professional x64 Edition                                          // It's an edition of Windows Server 2003 anyway.                                          return EOSType.Win2003;                                  }                                    goto default;                                case 6:                                  switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.WinVista; // Also Server 2008                                        case 1:                                          return EOSType.Windows7; // Also Server 2008 R2                                        case 2:                                          return EOSType.Windows8; // Also Server 2012                                        // Note: The OSVersion property reports the same version number (6.2.0.0) for both Windows 8 and Windows 8.1.- http://msdn.microsoft.com/en-us/library/system.environment.osversion(v=vs.110).aspx                                      // In practice' this will only get hit if the application targets Windows 8.1 in the app manifest.                                      // See http://msdn.microsoft.com/en-us/library/windows/desktop/dn481241(v=vs.85).aspx for more info.                                      case 3:                                          return EOSType.Windows81; // Also Server 2012 R2                                  }                                    goto default;                                case 10:                                  return EOSType.Windows10;                                default:                                  return EOSType.WinUnknown;                          }                      }                    case PlatformID.Unix:                      {                          if ( IsMacOS() )                          {                              switch ( ver.Major )                              {                                  case 11:                                      return EOSType.MacOS107; // "Lion"                                    case 12:                                      return EOSType.MacOS108; // "Mountain Lion"                                    case 13:                                      return EOSType.MacOS109; // "Mavericks"                                    case 14:                                     return EOSType.MacOS1010; // "Yosemite"                                    case 15:                                      return EOSType.MacOS1011; // El Capitan                                    case 16:                                      return EOSType.MacOS1012; // Sierra                                    default:                                      return EOSType.MacOSUnknown;                              }                          }                          else                          {                              return EOSType.LinuxUnknown;                          }                      }                    default:                      return EOSType.Unknown;              }
Magic Number,SteamKit2,Utils,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Utils.cs,GetOSType,The following statement contains a magic number: switch ( osVer.Platform )              {                  case PlatformID.Win32Windows:                      {                          switch ( ver.Minor )                          {                              case 0:                                  return EOSType.Win95;                                case 10:                                  return EOSType.Win98;                                case 90:                                  return EOSType.WinME;                                default:                                  return EOSType.WinUnknown;                          }                      }                    case PlatformID.Win32NT:                      {                          switch ( ver.Major )                          {                              case 4:                                  return EOSType.WinNT;                                case 5:                                  switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.Win2000;                                        case 1:                                          return EOSType.WinXP;                                        case 2:                                          // Assume nobody runs Windows XP Professional x64 Edition                                          // It's an edition of Windows Server 2003 anyway.                                          return EOSType.Win2003;                                  }                                    goto default;                                case 6:                                  switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.WinVista; // Also Server 2008                                        case 1:                                          return EOSType.Windows7; // Also Server 2008 R2                                        case 2:                                          return EOSType.Windows8; // Also Server 2012                                        // Note: The OSVersion property reports the same version number (6.2.0.0) for both Windows 8 and Windows 8.1.- http://msdn.microsoft.com/en-us/library/system.environment.osversion(v=vs.110).aspx                                      // In practice' this will only get hit if the application targets Windows 8.1 in the app manifest.                                      // See http://msdn.microsoft.com/en-us/library/windows/desktop/dn481241(v=vs.85).aspx for more info.                                      case 3:                                          return EOSType.Windows81; // Also Server 2012 R2                                  }                                    goto default;                                case 10:                                  return EOSType.Windows10;                                default:                                  return EOSType.WinUnknown;                          }                      }                    case PlatformID.Unix:                      {                          if ( IsMacOS() )                          {                              switch ( ver.Major )                              {                                  case 11:                                      return EOSType.MacOS107; // "Lion"                                    case 12:                                      return EOSType.MacOS108; // "Mountain Lion"                                    case 13:                                      return EOSType.MacOS109; // "Mavericks"                                    case 14:                                     return EOSType.MacOS1010; // "Yosemite"                                    case 15:                                      return EOSType.MacOS1011; // El Capitan                                    case 16:                                      return EOSType.MacOS1012; // Sierra                                    default:                                      return EOSType.MacOSUnknown;                              }                          }                          else                          {                              return EOSType.LinuxUnknown;                          }                      }                    default:                      return EOSType.Unknown;              }
Magic Number,SteamKit2,Utils,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Utils.cs,GetOSType,The following statement contains a magic number: switch ( osVer.Platform )              {                  case PlatformID.Win32Windows:                      {                          switch ( ver.Minor )                          {                              case 0:                                  return EOSType.Win95;                                case 10:                                  return EOSType.Win98;                                case 90:                                  return EOSType.WinME;                                default:                                  return EOSType.WinUnknown;                          }                      }                    case PlatformID.Win32NT:                      {                          switch ( ver.Major )                          {                              case 4:                                  return EOSType.WinNT;                                case 5:                                  switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.Win2000;                                        case 1:                                          return EOSType.WinXP;                                        case 2:                                          // Assume nobody runs Windows XP Professional x64 Edition                                          // It's an edition of Windows Server 2003 anyway.                                          return EOSType.Win2003;                                  }                                    goto default;                                case 6:                                  switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.WinVista; // Also Server 2008                                        case 1:                                          return EOSType.Windows7; // Also Server 2008 R2                                        case 2:                                          return EOSType.Windows8; // Also Server 2012                                        // Note: The OSVersion property reports the same version number (6.2.0.0) for both Windows 8 and Windows 8.1.- http://msdn.microsoft.com/en-us/library/system.environment.osversion(v=vs.110).aspx                                      // In practice' this will only get hit if the application targets Windows 8.1 in the app manifest.                                      // See http://msdn.microsoft.com/en-us/library/windows/desktop/dn481241(v=vs.85).aspx for more info.                                      case 3:                                          return EOSType.Windows81; // Also Server 2012 R2                                  }                                    goto default;                                case 10:                                  return EOSType.Windows10;                                default:                                  return EOSType.WinUnknown;                          }                      }                    case PlatformID.Unix:                      {                          if ( IsMacOS() )                          {                              switch ( ver.Major )                              {                                  case 11:                                      return EOSType.MacOS107; // "Lion"                                    case 12:                                      return EOSType.MacOS108; // "Mountain Lion"                                    case 13:                                      return EOSType.MacOS109; // "Mavericks"                                    case 14:                                     return EOSType.MacOS1010; // "Yosemite"                                    case 15:                                      return EOSType.MacOS1011; // El Capitan                                    case 16:                                      return EOSType.MacOS1012; // Sierra                                    default:                                      return EOSType.MacOSUnknown;                              }                          }                          else                          {                              return EOSType.LinuxUnknown;                          }                      }                    default:                      return EOSType.Unknown;              }
Magic Number,SteamKit2,Utils,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Utils.cs,GetOSType,The following statement contains a magic number: switch ( osVer.Platform )              {                  case PlatformID.Win32Windows:                      {                          switch ( ver.Minor )                          {                              case 0:                                  return EOSType.Win95;                                case 10:                                  return EOSType.Win98;                                case 90:                                  return EOSType.WinME;                                default:                                  return EOSType.WinUnknown;                          }                      }                    case PlatformID.Win32NT:                      {                          switch ( ver.Major )                          {                              case 4:                                  return EOSType.WinNT;                                case 5:                                  switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.Win2000;                                        case 1:                                          return EOSType.WinXP;                                        case 2:                                          // Assume nobody runs Windows XP Professional x64 Edition                                          // It's an edition of Windows Server 2003 anyway.                                          return EOSType.Win2003;                                  }                                    goto default;                                case 6:                                  switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.WinVista; // Also Server 2008                                        case 1:                                          return EOSType.Windows7; // Also Server 2008 R2                                        case 2:                                          return EOSType.Windows8; // Also Server 2012                                        // Note: The OSVersion property reports the same version number (6.2.0.0) for both Windows 8 and Windows 8.1.- http://msdn.microsoft.com/en-us/library/system.environment.osversion(v=vs.110).aspx                                      // In practice' this will only get hit if the application targets Windows 8.1 in the app manifest.                                      // See http://msdn.microsoft.com/en-us/library/windows/desktop/dn481241(v=vs.85).aspx for more info.                                      case 3:                                          return EOSType.Windows81; // Also Server 2012 R2                                  }                                    goto default;                                case 10:                                  return EOSType.Windows10;                                default:                                  return EOSType.WinUnknown;                          }                      }                    case PlatformID.Unix:                      {                          if ( IsMacOS() )                          {                              switch ( ver.Major )                              {                                  case 11:                                      return EOSType.MacOS107; // "Lion"                                    case 12:                                      return EOSType.MacOS108; // "Mountain Lion"                                    case 13:                                      return EOSType.MacOS109; // "Mavericks"                                    case 14:                                     return EOSType.MacOS1010; // "Yosemite"                                    case 15:                                      return EOSType.MacOS1011; // El Capitan                                    case 16:                                      return EOSType.MacOS1012; // Sierra                                    default:                                      return EOSType.MacOSUnknown;                              }                          }                          else                          {                              return EOSType.LinuxUnknown;                          }                      }                    default:                      return EOSType.Unknown;              }
Magic Number,SteamKit2,Utils,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Utils.cs,GetOSType,The following statement contains a magic number: switch ( osVer.Platform )              {                  case PlatformID.Win32Windows:                      {                          switch ( ver.Minor )                          {                              case 0:                                  return EOSType.Win95;                                case 10:                                  return EOSType.Win98;                                case 90:                                  return EOSType.WinME;                                default:                                  return EOSType.WinUnknown;                          }                      }                    case PlatformID.Win32NT:                      {                          switch ( ver.Major )                          {                              case 4:                                  return EOSType.WinNT;                                case 5:                                  switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.Win2000;                                        case 1:                                          return EOSType.WinXP;                                        case 2:                                          // Assume nobody runs Windows XP Professional x64 Edition                                          // It's an edition of Windows Server 2003 anyway.                                          return EOSType.Win2003;                                  }                                    goto default;                                case 6:                                  switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.WinVista; // Also Server 2008                                        case 1:                                          return EOSType.Windows7; // Also Server 2008 R2                                        case 2:                                          return EOSType.Windows8; // Also Server 2012                                        // Note: The OSVersion property reports the same version number (6.2.0.0) for both Windows 8 and Windows 8.1.- http://msdn.microsoft.com/en-us/library/system.environment.osversion(v=vs.110).aspx                                      // In practice' this will only get hit if the application targets Windows 8.1 in the app manifest.                                      // See http://msdn.microsoft.com/en-us/library/windows/desktop/dn481241(v=vs.85).aspx for more info.                                      case 3:                                          return EOSType.Windows81; // Also Server 2012 R2                                  }                                    goto default;                                case 10:                                  return EOSType.Windows10;                                default:                                  return EOSType.WinUnknown;                          }                      }                    case PlatformID.Unix:                      {                          if ( IsMacOS() )                          {                              switch ( ver.Major )                              {                                  case 11:                                      return EOSType.MacOS107; // "Lion"                                    case 12:                                      return EOSType.MacOS108; // "Mountain Lion"                                    case 13:                                      return EOSType.MacOS109; // "Mavericks"                                    case 14:                                     return EOSType.MacOS1010; // "Yosemite"                                    case 15:                                      return EOSType.MacOS1011; // El Capitan                                    case 16:                                      return EOSType.MacOS1012; // Sierra                                    default:                                      return EOSType.MacOSUnknown;                              }                          }                          else                          {                              return EOSType.LinuxUnknown;                          }                      }                    default:                      return EOSType.Unknown;              }
Magic Number,SteamKit2,Utils,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Utils.cs,GetOSType,The following statement contains a magic number: switch ( osVer.Platform )              {                  case PlatformID.Win32Windows:                      {                          switch ( ver.Minor )                          {                              case 0:                                  return EOSType.Win95;                                case 10:                                  return EOSType.Win98;                                case 90:                                  return EOSType.WinME;                                default:                                  return EOSType.WinUnknown;                          }                      }                    case PlatformID.Win32NT:                      {                          switch ( ver.Major )                          {                              case 4:                                  return EOSType.WinNT;                                case 5:                                  switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.Win2000;                                        case 1:                                          return EOSType.WinXP;                                        case 2:                                          // Assume nobody runs Windows XP Professional x64 Edition                                          // It's an edition of Windows Server 2003 anyway.                                          return EOSType.Win2003;                                  }                                    goto default;                                case 6:                                  switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.WinVista; // Also Server 2008                                        case 1:                                          return EOSType.Windows7; // Also Server 2008 R2                                        case 2:                                          return EOSType.Windows8; // Also Server 2012                                        // Note: The OSVersion property reports the same version number (6.2.0.0) for both Windows 8 and Windows 8.1.- http://msdn.microsoft.com/en-us/library/system.environment.osversion(v=vs.110).aspx                                      // In practice' this will only get hit if the application targets Windows 8.1 in the app manifest.                                      // See http://msdn.microsoft.com/en-us/library/windows/desktop/dn481241(v=vs.85).aspx for more info.                                      case 3:                                          return EOSType.Windows81; // Also Server 2012 R2                                  }                                    goto default;                                case 10:                                  return EOSType.Windows10;                                default:                                  return EOSType.WinUnknown;                          }                      }                    case PlatformID.Unix:                      {                          if ( IsMacOS() )                          {                              switch ( ver.Major )                              {                                  case 11:                                      return EOSType.MacOS107; // "Lion"                                    case 12:                                      return EOSType.MacOS108; // "Mountain Lion"                                    case 13:                                      return EOSType.MacOS109; // "Mavericks"                                    case 14:                                     return EOSType.MacOS1010; // "Yosemite"                                    case 15:                                      return EOSType.MacOS1011; // El Capitan                                    case 16:                                      return EOSType.MacOS1012; // Sierra                                    default:                                      return EOSType.MacOSUnknown;                              }                          }                          else                          {                              return EOSType.LinuxUnknown;                          }                      }                    default:                      return EOSType.Unknown;              }
Magic Number,SteamKit2,Utils,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Utils.cs,GetOSType,The following statement contains a magic number: switch ( osVer.Platform )              {                  case PlatformID.Win32Windows:                      {                          switch ( ver.Minor )                          {                              case 0:                                  return EOSType.Win95;                                case 10:                                  return EOSType.Win98;                                case 90:                                  return EOSType.WinME;                                default:                                  return EOSType.WinUnknown;                          }                      }                    case PlatformID.Win32NT:                      {                          switch ( ver.Major )                          {                              case 4:                                  return EOSType.WinNT;                                case 5:                                  switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.Win2000;                                        case 1:                                          return EOSType.WinXP;                                        case 2:                                          // Assume nobody runs Windows XP Professional x64 Edition                                          // It's an edition of Windows Server 2003 anyway.                                          return EOSType.Win2003;                                  }                                    goto default;                                case 6:                                  switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.WinVista; // Also Server 2008                                        case 1:                                          return EOSType.Windows7; // Also Server 2008 R2                                        case 2:                                          return EOSType.Windows8; // Also Server 2012                                        // Note: The OSVersion property reports the same version number (6.2.0.0) for both Windows 8 and Windows 8.1.- http://msdn.microsoft.com/en-us/library/system.environment.osversion(v=vs.110).aspx                                      // In practice' this will only get hit if the application targets Windows 8.1 in the app manifest.                                      // See http://msdn.microsoft.com/en-us/library/windows/desktop/dn481241(v=vs.85).aspx for more info.                                      case 3:                                          return EOSType.Windows81; // Also Server 2012 R2                                  }                                    goto default;                                case 10:                                  return EOSType.Windows10;                                default:                                  return EOSType.WinUnknown;                          }                      }                    case PlatformID.Unix:                      {                          if ( IsMacOS() )                          {                              switch ( ver.Major )                              {                                  case 11:                                      return EOSType.MacOS107; // "Lion"                                    case 12:                                      return EOSType.MacOS108; // "Mountain Lion"                                    case 13:                                      return EOSType.MacOS109; // "Mavericks"                                    case 14:                                     return EOSType.MacOS1010; // "Yosemite"                                    case 15:                                      return EOSType.MacOS1011; // El Capitan                                    case 16:                                      return EOSType.MacOS1012; // Sierra                                    default:                                      return EOSType.MacOSUnknown;                              }                          }                          else                          {                              return EOSType.LinuxUnknown;                          }                      }                    default:                      return EOSType.Unknown;              }
Magic Number,SteamKit2,Utils,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Utils.cs,GetOSType,The following statement contains a magic number: switch ( osVer.Platform )              {                  case PlatformID.Win32Windows:                      {                          switch ( ver.Minor )                          {                              case 0:                                  return EOSType.Win95;                                case 10:                                  return EOSType.Win98;                                case 90:                                  return EOSType.WinME;                                default:                                  return EOSType.WinUnknown;                          }                      }                    case PlatformID.Win32NT:                      {                          switch ( ver.Major )                          {                              case 4:                                  return EOSType.WinNT;                                case 5:                                  switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.Win2000;                                        case 1:                                          return EOSType.WinXP;                                        case 2:                                          // Assume nobody runs Windows XP Professional x64 Edition                                          // It's an edition of Windows Server 2003 anyway.                                          return EOSType.Win2003;                                  }                                    goto default;                                case 6:                                  switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.WinVista; // Also Server 2008                                        case 1:                                          return EOSType.Windows7; // Also Server 2008 R2                                        case 2:                                          return EOSType.Windows8; // Also Server 2012                                        // Note: The OSVersion property reports the same version number (6.2.0.0) for both Windows 8 and Windows 8.1.- http://msdn.microsoft.com/en-us/library/system.environment.osversion(v=vs.110).aspx                                      // In practice' this will only get hit if the application targets Windows 8.1 in the app manifest.                                      // See http://msdn.microsoft.com/en-us/library/windows/desktop/dn481241(v=vs.85).aspx for more info.                                      case 3:                                          return EOSType.Windows81; // Also Server 2012 R2                                  }                                    goto default;                                case 10:                                  return EOSType.Windows10;                                default:                                  return EOSType.WinUnknown;                          }                      }                    case PlatformID.Unix:                      {                          if ( IsMacOS() )                          {                              switch ( ver.Major )                              {                                  case 11:                                      return EOSType.MacOS107; // "Lion"                                    case 12:                                      return EOSType.MacOS108; // "Mountain Lion"                                    case 13:                                      return EOSType.MacOS109; // "Mavericks"                                    case 14:                                     return EOSType.MacOS1010; // "Yosemite"                                    case 15:                                      return EOSType.MacOS1011; // El Capitan                                    case 16:                                      return EOSType.MacOS1012; // Sierra                                    default:                                      return EOSType.MacOSUnknown;                              }                          }                          else                          {                              return EOSType.LinuxUnknown;                          }                      }                    default:                      return EOSType.Unknown;              }
Magic Number,SteamKit2,DateUtils,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Utils.cs,DateTimeFromUnixTime,The following statement contains a magic number: DateTime origin = new DateTime(1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);
Magic Number,SteamKit2,DateUtils,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Utils.cs,DateTimeToUnixTime,The following statement contains a magic number: DateTime origin = new DateTime(1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);
Magic Number,SteamKit2,WebHelpers,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Utils.cs,UrlEncode,The following statement contains a magic number: StringBuilder encoded = new StringBuilder( input.Length * 2 );
Magic Number,SteamKit2,NetHelpers,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Utils.cs,TryParseIPEndPoint,The following statement contains a magic number: if (endpointParts.Length != 2)              {                  endPoint = null;                  return false;              }
Magic Number,SteamKit2,VZipUtil,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\VZipUtil.cs,Decompress,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream(buffer))              using (BinaryReader reader = new BinaryReader(ms))              {                  if (reader.ReadUInt16() != VZipHeader)                  {                      throw new Exception("Expecting VZipHeader at start of stream");                  }                    if (reader.ReadChar() != Version)                  {                      throw new Exception("Expecting VZip version 'a'");                  }                    // Sometimes this is a creation timestamp (e.g. for Steam Client VZips).                  // Sometimes this is a CRC32 (e.g. for depot chunks).                  /* uint creationTimestampOrSecondaryCRC = */ reader.ReadUInt32();                    byte[] properties = reader.ReadBytes(5);                  byte[] compressedBuffer = reader.ReadBytes((int)ms.Length - HeaderLength - FooterLength - 5);                    uint outputCRC = reader.ReadUInt32();                  uint sizeDecompressed = reader.ReadUInt32();                    if (reader.ReadUInt16() != VZipFooter)                  {                      throw new Exception("Expecting VZipFooter at end of stream");                  }                    SevenZip.Compression.LZMA.Decoder decoder = new SevenZip.Compression.LZMA.Decoder();                  decoder.SetDecoderProperties(properties);                    using (MemoryStream inputStream = new MemoryStream(compressedBuffer))                  using (MemoryStream outStream = new MemoryStream((int)sizeDecompressed))                  {                      decoder.Code(inputStream' outStream' compressedBuffer.Length' sizeDecompressed' null);                        var outData = outStream.ToArray();                      if (Crc32.Compute(outData) != outputCRC)                      {                          throw new InvalidDataException("CRC does not match decompressed data. VZip data may be corrupted.");                      }                        return outData;                  }              }
Magic Number,SteamKit2,VZipUtil,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\VZipUtil.cs,Decompress,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream(buffer))              using (BinaryReader reader = new BinaryReader(ms))              {                  if (reader.ReadUInt16() != VZipHeader)                  {                      throw new Exception("Expecting VZipHeader at start of stream");                  }                    if (reader.ReadChar() != Version)                  {                      throw new Exception("Expecting VZip version 'a'");                  }                    // Sometimes this is a creation timestamp (e.g. for Steam Client VZips).                  // Sometimes this is a CRC32 (e.g. for depot chunks).                  /* uint creationTimestampOrSecondaryCRC = */ reader.ReadUInt32();                    byte[] properties = reader.ReadBytes(5);                  byte[] compressedBuffer = reader.ReadBytes((int)ms.Length - HeaderLength - FooterLength - 5);                    uint outputCRC = reader.ReadUInt32();                  uint sizeDecompressed = reader.ReadUInt32();                    if (reader.ReadUInt16() != VZipFooter)                  {                      throw new Exception("Expecting VZipFooter at end of stream");                  }                    SevenZip.Compression.LZMA.Decoder decoder = new SevenZip.Compression.LZMA.Decoder();                  decoder.SetDecoderProperties(properties);                    using (MemoryStream inputStream = new MemoryStream(compressedBuffer))                  using (MemoryStream outStream = new MemoryStream((int)sizeDecompressed))                  {                      decoder.Code(inputStream' outStream' compressedBuffer.Length' sizeDecompressed' null);                        var outData = outStream.ToArray();                      if (Crc32.Compute(outData) != outputCRC)                      {                          throw new InvalidDataException("CRC does not match decompressed data. VZip data may be corrupted.");                      }                        return outData;                  }              }
Magic Number,SteamKit2,VZipUtil,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\VZipUtil.cs,Compress,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream())              using (BinaryWriter writer = new BinaryWriter(ms))              {                  byte[] crc = CryptoHelper.CRCHash(buffer);                    writer.Write(VZipHeader);                  writer.Write((byte)Version);                  writer.Write(crc);                    Int32 dictionary = 1 << 23;                  Int32 posStateBits = 2;                  Int32 litContextBits = 3;                  Int32 litPosBits = 0;                  Int32 algorithm = 2;                  Int32 numFastBytes = 128;                    SevenZip.CoderPropID[] propIDs =                   {                      SevenZip.CoderPropID.DictionarySize'                      SevenZip.CoderPropID.PosStateBits'                      SevenZip.CoderPropID.LitContextBits'                      SevenZip.CoderPropID.LitPosBits'                      SevenZip.CoderPropID.Algorithm'                      SevenZip.CoderPropID.NumFastBytes'                      SevenZip.CoderPropID.MatchFinder'                      SevenZip.CoderPropID.EndMarker                  };                    object[] properties =                   {                      (Int32)(dictionary)'                      (Int32)(posStateBits)'                      (Int32)(litContextBits)'                      (Int32)(litPosBits)'                      (Int32)(algorithm)'                      (Int32)(numFastBytes)'                      "bt4"'                      false                  };                    SevenZip.Compression.LZMA.Encoder encoder = new SevenZip.Compression.LZMA.Encoder();                  encoder.SetCoderProperties(propIDs' properties);                  encoder.WriteCoderProperties(ms);                    using(MemoryStream input = new MemoryStream(buffer)) {                      encoder.Code(input' ms' -1' -1' null);                  }                    writer.Write(crc);                  writer.Write((uint)buffer.Length);                  writer.Write(VZipFooter);                    return ms.ToArray();              }
Magic Number,SteamKit2,VZipUtil,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\VZipUtil.cs,Compress,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream())              using (BinaryWriter writer = new BinaryWriter(ms))              {                  byte[] crc = CryptoHelper.CRCHash(buffer);                    writer.Write(VZipHeader);                  writer.Write((byte)Version);                  writer.Write(crc);                    Int32 dictionary = 1 << 23;                  Int32 posStateBits = 2;                  Int32 litContextBits = 3;                  Int32 litPosBits = 0;                  Int32 algorithm = 2;                  Int32 numFastBytes = 128;                    SevenZip.CoderPropID[] propIDs =                   {                      SevenZip.CoderPropID.DictionarySize'                      SevenZip.CoderPropID.PosStateBits'                      SevenZip.CoderPropID.LitContextBits'                      SevenZip.CoderPropID.LitPosBits'                      SevenZip.CoderPropID.Algorithm'                      SevenZip.CoderPropID.NumFastBytes'                      SevenZip.CoderPropID.MatchFinder'                      SevenZip.CoderPropID.EndMarker                  };                    object[] properties =                   {                      (Int32)(dictionary)'                      (Int32)(posStateBits)'                      (Int32)(litContextBits)'                      (Int32)(litPosBits)'                      (Int32)(algorithm)'                      (Int32)(numFastBytes)'                      "bt4"'                      false                  };                    SevenZip.Compression.LZMA.Encoder encoder = new SevenZip.Compression.LZMA.Encoder();                  encoder.SetCoderProperties(propIDs' properties);                  encoder.WriteCoderProperties(ms);                    using(MemoryStream input = new MemoryStream(buffer)) {                      encoder.Code(input' ms' -1' -1' null);                  }                    writer.Write(crc);                  writer.Write((uint)buffer.Length);                  writer.Write(VZipFooter);                    return ms.ToArray();              }
Magic Number,SteamKit2,VZipUtil,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\VZipUtil.cs,Compress,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream())              using (BinaryWriter writer = new BinaryWriter(ms))              {                  byte[] crc = CryptoHelper.CRCHash(buffer);                    writer.Write(VZipHeader);                  writer.Write((byte)Version);                  writer.Write(crc);                    Int32 dictionary = 1 << 23;                  Int32 posStateBits = 2;                  Int32 litContextBits = 3;                  Int32 litPosBits = 0;                  Int32 algorithm = 2;                  Int32 numFastBytes = 128;                    SevenZip.CoderPropID[] propIDs =                   {                      SevenZip.CoderPropID.DictionarySize'                      SevenZip.CoderPropID.PosStateBits'                      SevenZip.CoderPropID.LitContextBits'                      SevenZip.CoderPropID.LitPosBits'                      SevenZip.CoderPropID.Algorithm'                      SevenZip.CoderPropID.NumFastBytes'                      SevenZip.CoderPropID.MatchFinder'                      SevenZip.CoderPropID.EndMarker                  };                    object[] properties =                   {                      (Int32)(dictionary)'                      (Int32)(posStateBits)'                      (Int32)(litContextBits)'                      (Int32)(litPosBits)'                      (Int32)(algorithm)'                      (Int32)(numFastBytes)'                      "bt4"'                      false                  };                    SevenZip.Compression.LZMA.Encoder encoder = new SevenZip.Compression.LZMA.Encoder();                  encoder.SetCoderProperties(propIDs' properties);                  encoder.WriteCoderProperties(ms);                    using(MemoryStream input = new MemoryStream(buffer)) {                      encoder.Code(input' ms' -1' -1' null);                  }                    writer.Write(crc);                  writer.Write((uint)buffer.Length);                  writer.Write(VZipFooter);                    return ms.ToArray();              }
Magic Number,SteamKit2,VZipUtil,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\VZipUtil.cs,Compress,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream())              using (BinaryWriter writer = new BinaryWriter(ms))              {                  byte[] crc = CryptoHelper.CRCHash(buffer);                    writer.Write(VZipHeader);                  writer.Write((byte)Version);                  writer.Write(crc);                    Int32 dictionary = 1 << 23;                  Int32 posStateBits = 2;                  Int32 litContextBits = 3;                  Int32 litPosBits = 0;                  Int32 algorithm = 2;                  Int32 numFastBytes = 128;                    SevenZip.CoderPropID[] propIDs =                   {                      SevenZip.CoderPropID.DictionarySize'                      SevenZip.CoderPropID.PosStateBits'                      SevenZip.CoderPropID.LitContextBits'                      SevenZip.CoderPropID.LitPosBits'                      SevenZip.CoderPropID.Algorithm'                      SevenZip.CoderPropID.NumFastBytes'                      SevenZip.CoderPropID.MatchFinder'                      SevenZip.CoderPropID.EndMarker                  };                    object[] properties =                   {                      (Int32)(dictionary)'                      (Int32)(posStateBits)'                      (Int32)(litContextBits)'                      (Int32)(litPosBits)'                      (Int32)(algorithm)'                      (Int32)(numFastBytes)'                      "bt4"'                      false                  };                    SevenZip.Compression.LZMA.Encoder encoder = new SevenZip.Compression.LZMA.Encoder();                  encoder.SetCoderProperties(propIDs' properties);                  encoder.WriteCoderProperties(ms);                    using(MemoryStream input = new MemoryStream(buffer)) {                      encoder.Code(input' ms' -1' -1' null);                  }                    writer.Write(crc);                  writer.Write((uint)buffer.Length);                  writer.Write(VZipFooter);                    return ms.ToArray();              }
Magic Number,SteamKit2,VZipUtil,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\VZipUtil.cs,Compress,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream())              using (BinaryWriter writer = new BinaryWriter(ms))              {                  byte[] crc = CryptoHelper.CRCHash(buffer);                    writer.Write(VZipHeader);                  writer.Write((byte)Version);                  writer.Write(crc);                    Int32 dictionary = 1 << 23;                  Int32 posStateBits = 2;                  Int32 litContextBits = 3;                  Int32 litPosBits = 0;                  Int32 algorithm = 2;                  Int32 numFastBytes = 128;                    SevenZip.CoderPropID[] propIDs =                   {                      SevenZip.CoderPropID.DictionarySize'                      SevenZip.CoderPropID.PosStateBits'                      SevenZip.CoderPropID.LitContextBits'                      SevenZip.CoderPropID.LitPosBits'                      SevenZip.CoderPropID.Algorithm'                      SevenZip.CoderPropID.NumFastBytes'                      SevenZip.CoderPropID.MatchFinder'                      SevenZip.CoderPropID.EndMarker                  };                    object[] properties =                   {                      (Int32)(dictionary)'                      (Int32)(posStateBits)'                      (Int32)(litContextBits)'                      (Int32)(litPosBits)'                      (Int32)(algorithm)'                      (Int32)(numFastBytes)'                      "bt4"'                      false                  };                    SevenZip.Compression.LZMA.Encoder encoder = new SevenZip.Compression.LZMA.Encoder();                  encoder.SetCoderProperties(propIDs' properties);                  encoder.WriteCoderProperties(ms);                    using(MemoryStream input = new MemoryStream(buffer)) {                      encoder.Code(input' ms' -1' -1' null);                  }                    writer.Write(crc);                  writer.Write((uint)buffer.Length);                  writer.Write(VZipFooter);                    return ms.ToArray();              }
Magic Number,SteamKit2,ZipUtil,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\ZipUtil.cs,WriteCentralDirectory,The following statement contains a magic number: writer.Write( ( UInt32 )32 );
Magic Number,SteamKit2,ZipUtil,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\ZipUtil.cs,WriteCentralDirectory,The following statement contains a magic number: return ( ( UInt32 )writer.BaseStream.Position - pos ) + 4;
Magic Number,SteamKit2.Internal,UdpHeader,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamLanguageInternal.cs,UdpHeader,The following statement contains a magic number: SourceConnID = 512;
Magic Number,SteamKit2.Internal,ExtendedClientMsgHdr,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamLanguageInternal.cs,ExtendedClientMsgHdr,The following statement contains a magic number: HeaderSize = 36;
Magic Number,SteamKit2.Internal,ExtendedClientMsgHdr,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamLanguageInternal.cs,ExtendedClientMsgHdr,The following statement contains a magic number: HeaderVersion = 2;
Magic Number,SteamKit2.Internal,ExtendedClientMsgHdr,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamLanguageInternal.cs,ExtendedClientMsgHdr,The following statement contains a magic number: HeaderCanary = 239;
Magic Number,SteamKit2.Internal,MsgChannelEncryptResponse,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamLanguageInternal.cs,MsgChannelEncryptResponse,The following statement contains a magic number: KeySize = 128;
Magic Number,SteamKit2.Internal,MsgClientNewLoginKey,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamLanguageInternal.cs,MsgClientNewLoginKey,The following statement contains a magic number: LoginKey = new byte[20];
Magic Number,SteamKit2.Internal,MsgClientNewLoginKey,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamLanguageInternal.cs,Deserialize,The following statement contains a magic number: LoginKey = br.ReadBytes( 20 );
Magic Number,SteamKit2.Internal,MsgClientP2PIntroducerMessage,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamLanguageInternal.cs,MsgClientP2PIntroducerMessage,The following statement contains a magic number: Data = new byte[1450];
Magic Number,SteamKit2.Internal,MsgClientP2PIntroducerMessage,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Base\Generated\SteamLanguageInternal.cs,Deserialize,The following statement contains a magic number: Data = br.ReadBytes( 1450 );
Magic Number,SteamKit2.Discovery,ServerRecord,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\Discovery\ServerRecord.cs,CreateWebSocketServer,The following statement contains a magic number: const int DefaultPort = 443;
Magic Number,SteamKit2.Discovery,SmartCMServerList,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\Discovery\SmartCMServerList.cs,SmartCMServerList,The following statement contains a magic number: BadConnectionMemoryTimeSpan = TimeSpan.FromMinutes( 5 );
Magic Number,SteamKit2.Discovery,SmartCMServerList,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\Discovery\SmartCMServerList.cs,ResolveServerList,The following statement contains a magic number: if ( endpointList.Count == 0 && configuration.AllowDirectoryFetch )              {                  DebugWrite( "Could not query SteamDirectory' falling back to cm0" );                  var cm0 = await Dns.GetHostAddressesAsync( "cm0.steampowered.com" ).ConfigureAwait( false );                    endpointList = cm0.Select( ipaddr => ServerRecord.CreateSocketServer( new IPEndPoint(ipaddr' 27015) ) ).ToList();              }
Magic Number,SevenZip,CRC,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Common\CRC.cs,CRC,The following statement contains a magic number: Table = new uint[256];
Magic Number,SevenZip,CRC,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Common\CRC.cs,CRC,The following statement contains a magic number: for (uint i = 0; i < 256; i++)  			{  				uint r = i;  				for (int j = 0; j < 8; j++)  					if ((r & 1) != 0)  						r = (r >> 1) ^ kPoly;  					else  						r >>= 1;  				Table[i] = r;  			}
Magic Number,SevenZip,CRC,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Common\CRC.cs,CRC,The following statement contains a magic number: for (uint i = 0; i < 256; i++)  			{  				uint r = i;  				for (int j = 0; j < 8; j++)  					if ((r & 1) != 0)  						r = (r >> 1) ^ kPoly;  					else  						r >>= 1;  				Table[i] = r;  			}
Magic Number,SevenZip,CRC,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Common\CRC.cs,UpdateByte,The following statement contains a magic number: _value = Table[(((byte)(_value)) ^ b)] ^ (_value >> 8);
Magic Number,SevenZip,CRC,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Common\CRC.cs,Update,The following statement contains a magic number: for (uint i = 0; i < size; i++)  				_value = Table[(((byte)(_value)) ^ data[offset + i])] ^ (_value >> 8);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaBase.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;  				else if (Index < 10) Index -= 3;  				else Index -= 6;
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaBase.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;  				else if (Index < 10) Index -= 3;  				else Index -= 6;
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaBase.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;  				else if (Index < 10) Index -= 3;  				else Index -= 6;
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaBase.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;  				else if (Index < 10) Index -= 3;  				else Index -= 6;
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaBase.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaBase.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaBase.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaBase.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaBase.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaBase.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaBase.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaBase.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaBase.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaBase.cs,IsCharState,The following statement contains a magic number: return Index < 7;
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaDecoder.cs,SetDictionarySize,The following statement contains a magic number: if (m_DictionarySize != dictionarySize)  			{  				m_DictionarySize = dictionarySize;  				m_DictionarySizeCheck = Math.Max(m_DictionarySize' 1);  				uint blockSize = Math.Max(m_DictionarySizeCheck' (1 << 12));  				m_OutWindow.Create(blockSize);  			}
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaDecoder.cs,SetLiteralProperties,The following statement contains a magic number: if (lp > 8)  				throw new InvalidParamException();
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaDecoder.cs,SetLiteralProperties,The following statement contains a magic number: if (lc > 8)  				throw new InvalidParamException();
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaDecoder.cs,Code,The following statement contains a magic number: while (nowPos64 < outSize64)  			{  				// UInt64 next = Math.Min(nowPos64 + (1 << 18)' outSize64);  					// while(nowPos64 < next)  				{  					uint posState = (uint)nowPos64 & m_PosStateMask;  					if (m_IsMatchDecoders[(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0)  					{  						byte b;  						byte prevByte = m_OutWindow.GetByte(0);  						if (!state.IsCharState())  							b = m_LiteralDecoder.DecodeWithMatchByte(m_RangeDecoder'  								(uint)nowPos64' prevByte' m_OutWindow.GetByte(rep0));  						else  							b = m_LiteralDecoder.DecodeNormal(m_RangeDecoder' (uint)nowPos64' prevByte);  						m_OutWindow.PutByte(b);  						state.UpdateChar();  						nowPos64++;  					}  					else  					{  						uint len;  						if (m_IsRepDecoders[state.Index].Decode(m_RangeDecoder) == 1)  						{  							if (m_IsRepG0Decoders[state.Index].Decode(m_RangeDecoder) == 0)  							{  								if (m_IsRep0LongDecoders[(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0)  								{  									state.UpdateShortRep();  									m_OutWindow.PutByte(m_OutWindow.GetByte(rep0));  									nowPos64++;  									continue;  								}  							}  							else  							{  								UInt32 distance;  								if (m_IsRepG1Decoders[state.Index].Decode(m_RangeDecoder) == 0)  								{  									distance = rep1;  								}  								else  								{  									if (m_IsRepG2Decoders[state.Index].Decode(m_RangeDecoder) == 0)  										distance = rep2;  									else  									{  										distance = rep3;  										rep3 = rep2;  									}  									rep2 = rep1;  								}  								rep1 = rep0;  								rep0 = distance;  							}  							len = m_RepLenDecoder.Decode(m_RangeDecoder' posState) + Base.kMatchMinLen;  							state.UpdateRep();  						}  						else  						{  							rep3 = rep2;  							rep2 = rep1;  							rep1 = rep0;  							len = Base.kMatchMinLen + m_LenDecoder.Decode(m_RangeDecoder' posState);  							state.UpdateMatch();  							uint posSlot = m_PosSlotDecoder[Base.GetLenToPosState(len)].Decode(m_RangeDecoder);  							if (posSlot >= Base.kStartPosModelIndex)  							{  								int numDirectBits = (int)((posSlot >> 1) - 1);  								rep0 = ((2 | (posSlot & 1)) << numDirectBits);  								if (posSlot < Base.kEndPosModelIndex)  									rep0 += BitTreeDecoder.ReverseDecode(m_PosDecoders'  											rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);  								else  								{  									rep0 += (m_RangeDecoder.DecodeDirectBits(  										numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);  									rep0 += m_PosAlignDecoder.ReverseDecode(m_RangeDecoder);  								}  							}  							else  								rep0 = posSlot;  						}  						if (rep0 >= m_OutWindow.TrainSize + nowPos64 || rep0 >= m_DictionarySizeCheck)  						{  							if (rep0 == 0xFFFFFFFF)  								break;  							throw new DataErrorException();  						}  						m_OutWindow.CopyBlock(rep0' len);  						nowPos64 += len;  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: if (properties.Length < 5)  				throw new InvalidParamException();
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int lc = properties[0] % 9;
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int remainder = properties[0] / 9;
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int lp = remainder % 5;
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int pb = remainder / 5;
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
Magic Number,SevenZip.Compression.LZMA,LiteralDecoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaDecoder.cs,GetState,The following statement contains a magic number: return ((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits));
Magic Number,SevenZip.Compression.LZMA,Decoder2,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaDecoder.cs,DecodeWithMatchByte,The following statement contains a magic number: do  					{  						uint matchBit = (uint)(matchByte >> 7) & 1;  						matchByte <<= 1;  						uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);  						symbol = (symbol << 1) | bit;  						if (matchBit != bit)  						{  							while (symbol < 0x100)  								symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);  							break;  						}  					}  					while (symbol < 0x100);
Magic Number,SevenZip.Compression.LZMA,Decoder2,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaDecoder.cs,DecodeWithMatchByte,The following statement contains a magic number: do  					{  						uint matchBit = (uint)(matchByte >> 7) & 1;  						matchByte <<= 1;  						uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);  						symbol = (symbol << 1) | bit;  						if (matchBit != bit)  						{  							while (symbol < 0x100)  								symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);  							break;  						}  					}  					while (symbol < 0x100);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,Encoder,The following statement contains a magic number: const Byte kFastSlots = 22;
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,Encoder,The following statement contains a magic number: int c = 2;
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,Encoder,The following statement contains a magic number: for (Byte slotFast = 2; slotFast < kFastSlots; slotFast++)  			{  				UInt32 k = ((UInt32)1 << ((slotFast >> 1) - 1));  				for (UInt32 j = 0; j < k; j++' c++)  					g_FastPos[c] = slotFast;  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 11))  				return g_FastPos[pos];
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))  				return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))  				return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))  				return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 20] + 40);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 20] + 40);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))  				return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))  				return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))  				return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))  				return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))  				return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))  				return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 26] + 52);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 26] + 52);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,Create,The following statement contains a magic number: if (_matchFinder == null)  			{  				LZ.BinTree bt = new LZ.BinTree();  				int numHashBytes = 4;  				if (_matchFinderType == EMatchFinderType.BT2)  					numHashBytes = 2;  				bt.SetType(numHashBytes);  				_matchFinder = bt;  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,Create,The following statement contains a magic number: if (_matchFinder == null)  			{  				LZ.BinTree bt = new LZ.BinTree();  				int numHashBytes = 4;  				if (_matchFinderType == EMatchFinderType.BT2)  					numHashBytes = 2;  				bt.SetType(numHashBytes);  				_matchFinder = bt;  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,ReadMatchDistances,The following statement contains a magic number: if (numDistancePairs > 0)  			{  				lenRes = _matchDistances[numDistancePairs - 2];  				if (lenRes == _numFastBytes)  					lenRes += _matchFinder.GetMatchLen((int)lenRes - 1' _matchDistances[numDistancePairs - 1]'  						Base.kMatchMaxLen - lenRes);  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPureRepPrice,The following statement contains a magic number: if (repIndex == 0)  			{  				price = _isRepG0[state.Index].GetPrice0();  				price += _isRep0Long[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  			}  			else  			{  				price = _isRepG0[state.Index].GetPrice1();  				if (repIndex == 1)  					price += _isRepG1[state.Index].GetPrice0();  				else  				{  					price += _isRepG1[state.Index].GetPrice1();  					price += _isRepG2[state.Index].GetPrice(repIndex - 2);  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (numAvailableBytes < 2)  			{  				backRes = 0xFFFFFFFF;  				return 1;  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenMain < 2 && currentByte != matchByte && repLens[repMaxIndex] < 2)  			{  				backRes = (UInt32)0xFFFFFFFF;  				return 1;  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenMain < 2 && currentByte != matchByte && repLens[repMaxIndex] < 2)  			{  				backRes = (UInt32)0xFFFFFFFF;  				return 1;  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if(lenEnd < 2)  			{  				backRes = _optimum[1].BackPrev;  				return 1;  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum[0].Backs2 = reps[2];
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum[0].Backs3 = reps[3];
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: do  				_optimum[len--].Price = kIfinityPrice;  			while (len >= 2);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < Base.kNumRepDistances; i++)  			{  				UInt32 repLen = repLens[i];  				if (repLen < 2)  					continue;  				UInt32 price = repMatchPrice + GetPureRepPrice(i' _state' posState);  				do  				{  					UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);  					Optimal optimum = _optimum[repLen];  					if (curAndLenPrice < optimum.Price)  					{  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = 0;  						optimum.BackPrev = i;  						optimum.Prev1IsChar = false;  					}  				}  				while (--repLen >= 2);  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < Base.kNumRepDistances; i++)  			{  				UInt32 repLen = repLens[i];  				if (repLen < 2)  					continue;  				UInt32 price = repMatchPrice + GetPureRepPrice(i' _state' posState);  				do  				{  					UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);  					Optimal optimum = _optimum[repLen];  					if (curAndLenPrice < optimum.Price)  					{  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = 0;  						optimum.BackPrev = i;  						optimum.Prev1IsChar = false;  					}  				}  				while (--repLen >= 2);  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < Base.kNumRepDistances; i++)  			{  				UInt32 repLen = repLens[i];  				if (repLen < 2)  					continue;  				UInt32 price = repMatchPrice + GetPureRepPrice(i' _state' posState);  				do  				{  					UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);  					Optimal optimum = _optimum[repLen];  					if (curAndLenPrice < optimum.Price)  					{  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = 0;  						optimum.BackPrev = i;  						optimum.Prev1IsChar = false;  					}  				}  				while (--repLen >= 2);  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (len <= lenMain)  			{  				UInt32 offs = 0;  				while (len > _matchDistances[offs])  					offs += 2;  				for (; ; len++)  				{  					UInt32 distance = _matchDistances[offs + 1];  					UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(distance' len' posState);  					Optimal optimum = _optimum[len];  					if (curAndLenPrice < optimum.Price)  					{  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = 0;  						optimum.BackPrev = distance + Base.kNumRepDistances;  						optimum.Prev1IsChar = false;  					}  					if (len == _matchDistances[offs])  					{  						offs += 2;  						if (offs == numDistancePairs)  							break;  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (len <= lenMain)  			{  				UInt32 offs = 0;  				while (len > _matchDistances[offs])  					offs += 2;  				for (; ; len++)  				{  					UInt32 distance = _matchDistances[offs + 1];  					UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(distance' len' posState);  					Optimal optimum = _optimum[len];  					if (curAndLenPrice < optimum.Price)  					{  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = 0;  						optimum.BackPrev = distance + Base.kNumRepDistances;  						optimum.Prev1IsChar = false;  					}  					if (len == _matchDistances[offs])  					{  						offs += 2;  						if (offs == numDistancePairs)  							break;  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,ChangePair,The following statement contains a magic number: const int kDif = 7;
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,ChangePair,The following statement contains a magic number: return (smallDist < ((UInt32)(1) << (32 - kDif)) && bigDist >= (smallDist << kDif));
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,WriteEndMarker,The following statement contains a magic number: int footerBits = 30;
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true)  			{  				UInt32 pos;  				UInt32 len = GetOptimum((UInt32)nowPos64' out pos);  				  				UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  				UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  				if (len == 1 && pos == 0xFFFFFFFF)  				{  					_isMatch[complexState].Encode(_rangeEncoder' 0);  					Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));  					LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);  					if (!_state.IsCharState())  					{  						Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));  						subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);  					}  					else  						subCoder.Encode(_rangeEncoder' curByte);  					_previousByte = curByte;  					_state.UpdateChar();  				}  				else  				{  					_isMatch[complexState].Encode(_rangeEncoder' 1);  					if (pos < Base.kNumRepDistances)  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 1);  						if (pos == 0)  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 0);  							if (len == 1)  								_isRep0Long[complexState].Encode(_rangeEncoder' 0);  							else  								_isRep0Long[complexState].Encode(_rangeEncoder' 1);  						}  						else  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 1);  							if (pos == 1)  								_isRepG1[_state.Index].Encode(_rangeEncoder' 0);  							else  							{  								_isRepG1[_state.Index].Encode(_rangeEncoder' 1);  								_isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);  							}  						}  						if (len == 1)  							_state.UpdateShortRep();  						else  						{  							_repMatchLenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  							_state.UpdateRep();  						}  						UInt32 distance = _repDistances[pos];  						if (pos != 0)  						{  							for (UInt32 i = pos; i >= 1; i--)  								_repDistances[i] = _repDistances[i - 1];  							_repDistances[0] = distance;  						}  					}  					else  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 0);  						_state.UpdateMatch();  						_lenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  						pos -= Base.kNumRepDistances;  						UInt32 posSlot = GetPosSlot(pos);  						UInt32 lenToPosState = Base.GetLenToPosState(len);  						_posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);    						if (posSlot >= Base.kStartPosModelIndex)  						{  							int footerBits = (int)((posSlot >> 1) - 1);  							UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  							UInt32 posReduced = pos - baseVal;    							if (posSlot < Base.kEndPosModelIndex)  								RangeCoder.BitTreeEncoder.ReverseEncode(_posEncoders'  										baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  							else  							{  								_rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  								_posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & Base.kAlignMask);  								_alignPriceCount++;  							}  						}  						UInt32 distance = pos;  						for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  							_repDistances[i] = _repDistances[i - 1];  						_repDistances[0] = distance;  						_matchPriceCount++;  					}  					_previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));  				}  				_additionalOffset -= len;  				nowPos64 += len;  				if (_additionalOffset == 0)  				{  					// if (!_fastMode)  					if (_matchPriceCount >= (1 << 7))  						FillDistancesPrices();  					if (_alignPriceCount >= Base.kAlignTableSize)  						FillAlignPrices();  					inSize = nowPos64;  					outSize = _rangeEncoder.GetProcessedSizeAdd();  					if (_matchFinder.GetNumAvailableBytes() == 0)  					{  						Flush((UInt32)nowPos64);  						return;  					}    					if (nowPos64 - progressPosValuePrev >= (1 << 12))  					{  						_finished = false;  						finished = false;  						return;  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true)  			{  				UInt32 pos;  				UInt32 len = GetOptimum((UInt32)nowPos64' out pos);  				  				UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  				UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  				if (len == 1 && pos == 0xFFFFFFFF)  				{  					_isMatch[complexState].Encode(_rangeEncoder' 0);  					Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));  					LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);  					if (!_state.IsCharState())  					{  						Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));  						subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);  					}  					else  						subCoder.Encode(_rangeEncoder' curByte);  					_previousByte = curByte;  					_state.UpdateChar();  				}  				else  				{  					_isMatch[complexState].Encode(_rangeEncoder' 1);  					if (pos < Base.kNumRepDistances)  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 1);  						if (pos == 0)  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 0);  							if (len == 1)  								_isRep0Long[complexState].Encode(_rangeEncoder' 0);  							else  								_isRep0Long[complexState].Encode(_rangeEncoder' 1);  						}  						else  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 1);  							if (pos == 1)  								_isRepG1[_state.Index].Encode(_rangeEncoder' 0);  							else  							{  								_isRepG1[_state.Index].Encode(_rangeEncoder' 1);  								_isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);  							}  						}  						if (len == 1)  							_state.UpdateShortRep();  						else  						{  							_repMatchLenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  							_state.UpdateRep();  						}  						UInt32 distance = _repDistances[pos];  						if (pos != 0)  						{  							for (UInt32 i = pos; i >= 1; i--)  								_repDistances[i] = _repDistances[i - 1];  							_repDistances[0] = distance;  						}  					}  					else  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 0);  						_state.UpdateMatch();  						_lenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  						pos -= Base.kNumRepDistances;  						UInt32 posSlot = GetPosSlot(pos);  						UInt32 lenToPosState = Base.GetLenToPosState(len);  						_posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);    						if (posSlot >= Base.kStartPosModelIndex)  						{  							int footerBits = (int)((posSlot >> 1) - 1);  							UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  							UInt32 posReduced = pos - baseVal;    							if (posSlot < Base.kEndPosModelIndex)  								RangeCoder.BitTreeEncoder.ReverseEncode(_posEncoders'  										baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  							else  							{  								_rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  								_posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & Base.kAlignMask);  								_alignPriceCount++;  							}  						}  						UInt32 distance = pos;  						for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  							_repDistances[i] = _repDistances[i - 1];  						_repDistances[0] = distance;  						_matchPriceCount++;  					}  					_previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));  				}  				_additionalOffset -= len;  				nowPos64 += len;  				if (_additionalOffset == 0)  				{  					// if (!_fastMode)  					if (_matchPriceCount >= (1 << 7))  						FillDistancesPrices();  					if (_alignPriceCount >= Base.kAlignTableSize)  						FillAlignPrices();  					inSize = nowPos64;  					outSize = _rangeEncoder.GetProcessedSizeAdd();  					if (_matchFinder.GetNumAvailableBytes() == 0)  					{  						Flush((UInt32)nowPos64);  						return;  					}    					if (nowPos64 - progressPosValuePrev >= (1 << 12))  					{  						_finished = false;  						finished = false;  						return;  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true)  			{  				UInt32 pos;  				UInt32 len = GetOptimum((UInt32)nowPos64' out pos);  				  				UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  				UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  				if (len == 1 && pos == 0xFFFFFFFF)  				{  					_isMatch[complexState].Encode(_rangeEncoder' 0);  					Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));  					LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);  					if (!_state.IsCharState())  					{  						Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));  						subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);  					}  					else  						subCoder.Encode(_rangeEncoder' curByte);  					_previousByte = curByte;  					_state.UpdateChar();  				}  				else  				{  					_isMatch[complexState].Encode(_rangeEncoder' 1);  					if (pos < Base.kNumRepDistances)  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 1);  						if (pos == 0)  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 0);  							if (len == 1)  								_isRep0Long[complexState].Encode(_rangeEncoder' 0);  							else  								_isRep0Long[complexState].Encode(_rangeEncoder' 1);  						}  						else  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 1);  							if (pos == 1)  								_isRepG1[_state.Index].Encode(_rangeEncoder' 0);  							else  							{  								_isRepG1[_state.Index].Encode(_rangeEncoder' 1);  								_isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);  							}  						}  						if (len == 1)  							_state.UpdateShortRep();  						else  						{  							_repMatchLenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  							_state.UpdateRep();  						}  						UInt32 distance = _repDistances[pos];  						if (pos != 0)  						{  							for (UInt32 i = pos; i >= 1; i--)  								_repDistances[i] = _repDistances[i - 1];  							_repDistances[0] = distance;  						}  					}  					else  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 0);  						_state.UpdateMatch();  						_lenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  						pos -= Base.kNumRepDistances;  						UInt32 posSlot = GetPosSlot(pos);  						UInt32 lenToPosState = Base.GetLenToPosState(len);  						_posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);    						if (posSlot >= Base.kStartPosModelIndex)  						{  							int footerBits = (int)((posSlot >> 1) - 1);  							UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  							UInt32 posReduced = pos - baseVal;    							if (posSlot < Base.kEndPosModelIndex)  								RangeCoder.BitTreeEncoder.ReverseEncode(_posEncoders'  										baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  							else  							{  								_rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  								_posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & Base.kAlignMask);  								_alignPriceCount++;  							}  						}  						UInt32 distance = pos;  						for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  							_repDistances[i] = _repDistances[i - 1];  						_repDistances[0] = distance;  						_matchPriceCount++;  					}  					_previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));  				}  				_additionalOffset -= len;  				nowPos64 += len;  				if (_additionalOffset == 0)  				{  					// if (!_fastMode)  					if (_matchPriceCount >= (1 << 7))  						FillDistancesPrices();  					if (_alignPriceCount >= Base.kAlignTableSize)  						FillAlignPrices();  					inSize = nowPos64;  					outSize = _rangeEncoder.GetProcessedSizeAdd();  					if (_matchFinder.GetNumAvailableBytes() == 0)  					{  						Flush((UInt32)nowPos64);  						return;  					}    					if (nowPos64 - progressPosValuePrev >= (1 << 12))  					{  						_finished = false;  						finished = false;  						return;  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true)  			{  				UInt32 pos;  				UInt32 len = GetOptimum((UInt32)nowPos64' out pos);  				  				UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  				UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  				if (len == 1 && pos == 0xFFFFFFFF)  				{  					_isMatch[complexState].Encode(_rangeEncoder' 0);  					Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));  					LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);  					if (!_state.IsCharState())  					{  						Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));  						subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);  					}  					else  						subCoder.Encode(_rangeEncoder' curByte);  					_previousByte = curByte;  					_state.UpdateChar();  				}  				else  				{  					_isMatch[complexState].Encode(_rangeEncoder' 1);  					if (pos < Base.kNumRepDistances)  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 1);  						if (pos == 0)  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 0);  							if (len == 1)  								_isRep0Long[complexState].Encode(_rangeEncoder' 0);  							else  								_isRep0Long[complexState].Encode(_rangeEncoder' 1);  						}  						else  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 1);  							if (pos == 1)  								_isRepG1[_state.Index].Encode(_rangeEncoder' 0);  							else  							{  								_isRepG1[_state.Index].Encode(_rangeEncoder' 1);  								_isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);  							}  						}  						if (len == 1)  							_state.UpdateShortRep();  						else  						{  							_repMatchLenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  							_state.UpdateRep();  						}  						UInt32 distance = _repDistances[pos];  						if (pos != 0)  						{  							for (UInt32 i = pos; i >= 1; i--)  								_repDistances[i] = _repDistances[i - 1];  							_repDistances[0] = distance;  						}  					}  					else  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 0);  						_state.UpdateMatch();  						_lenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  						pos -= Base.kNumRepDistances;  						UInt32 posSlot = GetPosSlot(pos);  						UInt32 lenToPosState = Base.GetLenToPosState(len);  						_posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);    						if (posSlot >= Base.kStartPosModelIndex)  						{  							int footerBits = (int)((posSlot >> 1) - 1);  							UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  							UInt32 posReduced = pos - baseVal;    							if (posSlot < Base.kEndPosModelIndex)  								RangeCoder.BitTreeEncoder.ReverseEncode(_posEncoders'  										baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  							else  							{  								_rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  								_posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & Base.kAlignMask);  								_alignPriceCount++;  							}  						}  						UInt32 distance = pos;  						for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  							_repDistances[i] = _repDistances[i - 1];  						_repDistances[0] = distance;  						_matchPriceCount++;  					}  					_previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));  				}  				_additionalOffset -= len;  				nowPos64 += len;  				if (_additionalOffset == 0)  				{  					// if (!_fastMode)  					if (_matchPriceCount >= (1 << 7))  						FillDistancesPrices();  					if (_alignPriceCount >= Base.kAlignTableSize)  						FillAlignPrices();  					inSize = nowPos64;  					outSize = _rangeEncoder.GetProcessedSizeAdd();  					if (_matchFinder.GetNumAvailableBytes() == 0)  					{  						Flush((UInt32)nowPos64);  						return;  					}    					if (nowPos64 - progressPosValuePrev >= (1 << 12))  					{  						_finished = false;  						finished = false;  						return;  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties[0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties[0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				properties[1 + i] = (Byte)((_dictionarySize >> (8 * i)) & 0xFF);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				properties[1 + i] = (Byte)((_dictionarySize >> (8 * i)) & 0xFF);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,FillDistancesPrices,The following statement contains a magic number: for (UInt32 i = Base.kStartPosModelIndex; i < Base.kNumFullDistances; i++)  			{   				UInt32 posSlot = GetPosSlot(i);  				int footerBits = (int)((posSlot >> 1) - 1);  				UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  				tempPrices[i] = BitTreeEncoder.ReverseGetPrice(_posEncoders'   					baseVal - posSlot - 1' footerBits' i - baseVal);  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++)  			{  				object prop = properties[i];  				switch (propIDs[i])  				{  					case CoderPropID.NumFastBytes:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 numFastBytes = (Int32)prop;  						if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  							throw new InvalidParamException();  						_numFastBytes = (UInt32)numFastBytes;  						break;  					}  					case CoderPropID.Algorithm:  					{  						/*  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 maximize = (Int32)prop;  						_fastMode = (maximize == 0);  						_maxMode = (maximize >= 2);  						*/  						break;  					}  					case CoderPropID.MatchFinder:  					{  						if (!(prop is String))  							throw new InvalidParamException();  						EMatchFinderType matchFinderIndexPrev = _matchFinderType;  						int m = FindMatchFinder(((string)prop).ToUpper());  						if (m < 0)  							throw new InvalidParamException();  						_matchFinderType = (EMatchFinderType)m;  						if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)  							{  							_dictionarySizePrev = 0xFFFFFFFF;  							_matchFinder = null;  							}  						break;  					}  					case CoderPropID.DictionarySize:  					{  						const int kDicLogSizeMaxCompress = 30;  						if (!(prop is Int32))  							throw new InvalidParamException(); ;  						Int32 dictionarySize = (Int32)prop;  						if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||  							dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  							throw new InvalidParamException();  						_dictionarySize = (UInt32)dictionarySize;  						int dicLogSize;  						for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  							if (dictionarySize <= ((UInt32)(1) << dicLogSize))  								break;  						_distTableSize = (UInt32)dicLogSize * 2;  						break;  					}  					case CoderPropID.PosStateBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_posStateBits = (int)v;  						_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  						break;  					}  					case CoderPropID.LitPosBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_numLiteralPosStateBits = (int)v;  						break;  					}  					case CoderPropID.LitContextBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  							throw new InvalidParamException(); ;  						_numLiteralContextBits = (int)v;  						break;  					}  					case CoderPropID.EndMarker:  					{  						if (!(prop is Boolean))  							throw new InvalidParamException();  						SetWriteEndMarkerMode((Boolean)prop);  						break;  					}  					default:  						throw new InvalidParamException();  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++)  			{  				object prop = properties[i];  				switch (propIDs[i])  				{  					case CoderPropID.NumFastBytes:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 numFastBytes = (Int32)prop;  						if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  							throw new InvalidParamException();  						_numFastBytes = (UInt32)numFastBytes;  						break;  					}  					case CoderPropID.Algorithm:  					{  						/*  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 maximize = (Int32)prop;  						_fastMode = (maximize == 0);  						_maxMode = (maximize >= 2);  						*/  						break;  					}  					case CoderPropID.MatchFinder:  					{  						if (!(prop is String))  							throw new InvalidParamException();  						EMatchFinderType matchFinderIndexPrev = _matchFinderType;  						int m = FindMatchFinder(((string)prop).ToUpper());  						if (m < 0)  							throw new InvalidParamException();  						_matchFinderType = (EMatchFinderType)m;  						if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)  							{  							_dictionarySizePrev = 0xFFFFFFFF;  							_matchFinder = null;  							}  						break;  					}  					case CoderPropID.DictionarySize:  					{  						const int kDicLogSizeMaxCompress = 30;  						if (!(prop is Int32))  							throw new InvalidParamException(); ;  						Int32 dictionarySize = (Int32)prop;  						if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||  							dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  							throw new InvalidParamException();  						_dictionarySize = (UInt32)dictionarySize;  						int dicLogSize;  						for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  							if (dictionarySize <= ((UInt32)(1) << dicLogSize))  								break;  						_distTableSize = (UInt32)dicLogSize * 2;  						break;  					}  					case CoderPropID.PosStateBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_posStateBits = (int)v;  						_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  						break;  					}  					case CoderPropID.LitPosBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_numLiteralPosStateBits = (int)v;  						break;  					}  					case CoderPropID.LitContextBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  							throw new InvalidParamException(); ;  						_numLiteralContextBits = (int)v;  						break;  					}  					case CoderPropID.EndMarker:  					{  						if (!(prop is Boolean))  							throw new InvalidParamException();  						SetWriteEndMarkerMode((Boolean)prop);  						break;  					}  					default:  						throw new InvalidParamException();  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++)  			{  				object prop = properties[i];  				switch (propIDs[i])  				{  					case CoderPropID.NumFastBytes:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 numFastBytes = (Int32)prop;  						if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  							throw new InvalidParamException();  						_numFastBytes = (UInt32)numFastBytes;  						break;  					}  					case CoderPropID.Algorithm:  					{  						/*  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 maximize = (Int32)prop;  						_fastMode = (maximize == 0);  						_maxMode = (maximize >= 2);  						*/  						break;  					}  					case CoderPropID.MatchFinder:  					{  						if (!(prop is String))  							throw new InvalidParamException();  						EMatchFinderType matchFinderIndexPrev = _matchFinderType;  						int m = FindMatchFinder(((string)prop).ToUpper());  						if (m < 0)  							throw new InvalidParamException();  						_matchFinderType = (EMatchFinderType)m;  						if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)  							{  							_dictionarySizePrev = 0xFFFFFFFF;  							_matchFinder = null;  							}  						break;  					}  					case CoderPropID.DictionarySize:  					{  						const int kDicLogSizeMaxCompress = 30;  						if (!(prop is Int32))  							throw new InvalidParamException(); ;  						Int32 dictionarySize = (Int32)prop;  						if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||  							dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  							throw new InvalidParamException();  						_dictionarySize = (UInt32)dictionarySize;  						int dicLogSize;  						for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  							if (dictionarySize <= ((UInt32)(1) << dicLogSize))  								break;  						_distTableSize = (UInt32)dicLogSize * 2;  						break;  					}  					case CoderPropID.PosStateBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_posStateBits = (int)v;  						_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  						break;  					}  					case CoderPropID.LitPosBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_numLiteralPosStateBits = (int)v;  						break;  					}  					case CoderPropID.LitContextBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  							throw new InvalidParamException(); ;  						_numLiteralContextBits = (int)v;  						break;  					}  					case CoderPropID.EndMarker:  					{  						if (!(prop is Boolean))  							throw new InvalidParamException();  						SetWriteEndMarkerMode((Boolean)prop);  						break;  					}  					default:  						throw new InvalidParamException();  				}  			}
Magic Number,SevenZip.Compression.LZMA,LiteralEncoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetSubCoder,The following statement contains a magic number: return m_Coders[((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits))];
Magic Number,SevenZip.Compression.LZMA,Encoder2,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,Encode,The following statement contains a magic number: for (int i = 7; i >= 0; i--)  					{  						uint bit = (uint)((symbol >> i) & 1);  						m_Encoders[context].Encode(rangeEncoder' bit);  						context = (context << 1) | bit;  					}
Magic Number,SevenZip.Compression.LZMA,Encoder2,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,EncodeMatched,The following statement contains a magic number: for (int i = 7; i >= 0; i--)  					{  						uint bit = (uint)((symbol >> i) & 1);  						uint state = context;  						if (same)  						{  							uint matchBit = (uint)((matchByte >> i) & 1);  							state += ((1 + matchBit) << 8);  							same = (matchBit == bit);  						}  						m_Encoders[state].Encode(rangeEncoder' bit);  						context = (context << 1) | bit;  					}
Magic Number,SevenZip.Compression.LZMA,Encoder2,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,EncodeMatched,The following statement contains a magic number: for (int i = 7; i >= 0; i--)  					{  						uint bit = (uint)((symbol >> i) & 1);  						uint state = context;  						if (same)  						{  							uint matchBit = (uint)((matchByte >> i) & 1);  							state += ((1 + matchBit) << 8);  							same = (matchBit == bit);  						}  						m_Encoders[state].Encode(rangeEncoder' bit);  						context = (context << 1) | bit;  					}
Magic Number,SevenZip.Compression.LZMA,Encoder2,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPrice,The following statement contains a magic number: int i = 7;
Magic Number,SevenZip.Compression.LZMA,Encoder2,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPrice,The following statement contains a magic number: if (matchMode)  					{  						for (; i >= 0; i--)  						{  							uint matchBit = (uint)(matchByte >> i) & 1;  							uint bit = (uint)(symbol >> i) & 1;  							price += m_Encoders[((1 + matchBit) << 8) + context].GetPrice(bit);  							context = (context << 1) | bit;  							if (matchBit != bit)  							{  								i--;  								break;  							}  						}  					}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: HASH_ARRAY = (numHashBytes > 2);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY)  			{  				kNumHashDirectBytes = 0;  				kMinMatchCheck = 4;  				kFixHashSize = kHash2Size + kHash3Size;  			}  			else  			{  				kNumHashDirectBytes = 2;  				kMinMatchCheck = 2 + 1;  				kFixHashSize = 0;  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY)  			{  				kNumHashDirectBytes = 0;  				kMinMatchCheck = 4;  				kFixHashSize = kHash2Size + kHash3Size;  			}  			else  			{  				kNumHashDirectBytes = 2;  				kMinMatchCheck = 2 + 1;  				kFixHashSize = 0;  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY)  			{  				kNumHashDirectBytes = 0;  				kMinMatchCheck = 4;  				kFixHashSize = kHash2Size + kHash3Size;  			}  			else  			{  				kNumHashDirectBytes = 2;  				kMinMatchCheck = 2 + 1;  				kFixHashSize = 0;  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (historySize > kMaxValForNormalize - 256)  				throw new Exception();
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: _cutValue = 16 + (matchMaxLen >> 1);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: UInt32 windowReservSize = (historySize + keepAddBufferBefore +  					matchMaxLen + keepAddBufferAfter) / 2 + 256;
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: UInt32 windowReservSize = (historySize + keepAddBufferBefore +  					matchMaxLen + keepAddBufferAfter) / 2 + 256;
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (_cyclicBufferSize != cyclicBufferSize)  				_son = new UInt32[(_cyclicBufferSize = cyclicBufferSize) * 2];
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)  			{  				hs = historySize - 1;  				hs |= (hs >> 1);  				hs |= (hs >> 2);  				hs |= (hs >> 4);  				hs |= (hs >> 8);  				hs >>= 1;  				hs |= 0xFFFF;  				if (hs > (1 << 24))  					hs >>= 1;  				_hashMask = hs;  				hs++;  				hs += kFixHashSize;  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)  			{  				hs = historySize - 1;  				hs |= (hs >> 1);  				hs |= (hs >> 2);  				hs |= (hs >> 4);  				hs |= (hs >> 8);  				hs >>= 1;  				hs |= 0xFFFF;  				if (hs > (1 << 24))  					hs >>= 1;  				_hashMask = hs;  				hs++;  				hs += kFixHashSize;  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)  			{  				hs = historySize - 1;  				hs |= (hs >> 1);  				hs |= (hs >> 2);  				hs |= (hs >> 4);  				hs |= (hs >> 8);  				hs >>= 1;  				hs |= 0xFFFF;  				if (hs > (1 << 24))  					hs >>= 1;  				_hashMask = hs;  				hs++;  				hs += kFixHashSize;  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)  			{  				hs = historySize - 1;  				hs |= (hs >> 1);  				hs |= (hs >> 2);  				hs |= (hs >> 4);  				hs |= (hs >> 8);  				hs >>= 1;  				hs |= 0xFFFF;  				if (hs > (1 << 24))  					hs >>= 1;  				_hashMask = hs;  				hs++;  				hs += kFixHashSize;  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  				hash2Value = temp & (kHash2Size - 1);  				temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  				hash3Value = temp & (kHash3Size - 1);  				hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  			}  			else  				hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  				hash2Value = temp & (kHash2Size - 1);  				temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  				hash3Value = temp & (kHash3Size - 1);  				hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  			}  			else  				hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  				hash2Value = temp & (kHash2Size - 1);  				temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  				hash3Value = temp & (kHash3Size - 1);  				hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  			}  			else  				hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  				hash2Value = temp & (kHash2Size - 1);  				temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  				hash3Value = temp & (kHash3Size - 1);  				hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  			}  			else  				hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  				hash2Value = temp & (kHash2Size - 1);  				temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  				hash3Value = temp & (kHash3Size - 1);  				hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  			}  			else  				hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 curMatch2 = _hash[hash2Value];  				UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];  				_hash[hash2Value] = _pos;  				_hash[kHash3Offset + hash3Value] = _pos;  				if (curMatch2 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])  					{  						distances[offset++] = maxLen = 2;  						distances[offset++] = _pos - curMatch2 - 1;  					}  				if (curMatch3 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])  					{  						if (curMatch3 == curMatch2)  							offset -= 2;  						distances[offset++] = maxLen = 3;  						distances[offset++] = _pos - curMatch3 - 1;  						curMatch2 = curMatch3;  					}  				if (offset != 0 && curMatch2 == curMatch)  				{  					offset -= 2;  					maxLen = kStartMaxLen;  				}  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 curMatch2 = _hash[hash2Value];  				UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];  				_hash[hash2Value] = _pos;  				_hash[kHash3Offset + hash3Value] = _pos;  				if (curMatch2 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])  					{  						distances[offset++] = maxLen = 2;  						distances[offset++] = _pos - curMatch2 - 1;  					}  				if (curMatch3 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])  					{  						if (curMatch3 == curMatch2)  							offset -= 2;  						distances[offset++] = maxLen = 3;  						distances[offset++] = _pos - curMatch3 - 1;  						curMatch2 = curMatch3;  					}  				if (offset != 0 && curMatch2 == curMatch)  				{  					offset -= 2;  					maxLen = kStartMaxLen;  				}  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 curMatch2 = _hash[hash2Value];  				UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];  				_hash[hash2Value] = _pos;  				_hash[kHash3Offset + hash3Value] = _pos;  				if (curMatch2 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])  					{  						distances[offset++] = maxLen = 2;  						distances[offset++] = _pos - curMatch2 - 1;  					}  				if (curMatch3 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])  					{  						if (curMatch3 == curMatch2)  							offset -= 2;  						distances[offset++] = maxLen = 3;  						distances[offset++] = _pos - curMatch3 - 1;  						curMatch2 = curMatch3;  					}  				if (offset != 0 && curMatch2 == curMatch)  				{  					offset -= 2;  					maxLen = kStartMaxLen;  				}  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 curMatch2 = _hash[hash2Value];  				UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];  				_hash[hash2Value] = _pos;  				_hash[kHash3Offset + hash3Value] = _pos;  				if (curMatch2 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])  					{  						distances[offset++] = maxLen = 2;  						distances[offset++] = _pos - curMatch2 - 1;  					}  				if (curMatch3 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])  					{  						if (curMatch3 == curMatch2)  							offset -= 2;  						distances[offset++] = maxLen = 3;  						distances[offset++] = _pos - curMatch3 - 1;  						curMatch2 = curMatch3;  					}  				if (offset != 0 && curMatch2 == curMatch)  				{  					offset -= 2;  					maxLen = kStartMaxLen;  				}  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do  			{  				UInt32 lenLimit;  				if (_pos + _matchMaxLen <= _streamPos)  					lenLimit = _matchMaxLen;  				else  				{  					lenLimit = _streamPos - _pos;  					if (lenLimit < kMinMatchCheck)  					{  						MovePos();  						continue;  					}  				}    				UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  				UInt32 cur = _bufferOffset + _pos;    				UInt32 hashValue;    				if (HASH_ARRAY)  				{  					UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  					UInt32 hash2Value = temp & (kHash2Size - 1);  					_hash[hash2Value] = _pos;  					temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  					UInt32 hash3Value = temp & (kHash3Size - 1);  					_hash[kHash3Offset + hash3Value] = _pos;  					hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  				}  				else  					hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);    				UInt32 curMatch = _hash[kFixHashSize + hashValue];  				_hash[kFixHashSize + hashValue] = _pos;    				UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  				UInt32 ptr1 = (_cyclicBufferPos << 1);    				UInt32 len0' len1;  				len0 = len1 = kNumHashDirectBytes;    				UInt32 count = _cutValue;  				while (true)  				{  					if (curMatch <= matchMinPos || count-- == 0)  					{  						_son[ptr0] = _son[ptr1] = kEmptyHashValue;  						break;  					}    					UInt32 delta = _pos - curMatch;  					UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?  								(_cyclicBufferPos - delta) :  								(_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;    					UInt32 pby1 = _bufferOffset + curMatch;  					UInt32 len = Math.Min(len0' len1);  					if (_bufferBase[pby1 + len] == _bufferBase[cur + len])  					{  						while (++len != lenLimit)  							if (_bufferBase[pby1 + len] != _bufferBase[cur + len])  								break;  						if (len == lenLimit)  						{  							_son[ptr1] = _son[cyclicPos];  							_son[ptr0] = _son[cyclicPos + 1];  							break;  						}  					}  					if (_bufferBase[pby1 + len] < _bufferBase[cur + len])  					{  						_son[ptr1] = curMatch;  						ptr1 = cyclicPos + 1;  						curMatch = _son[ptr1];  						len1 = len;  					}  					else  					{  						_son[ptr0] = curMatch;  						ptr0 = cyclicPos;  						curMatch = _son[ptr0];  						len0 = len;  					}  				}  				MovePos();  			}  			while (--num != 0);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do  			{  				UInt32 lenLimit;  				if (_pos + _matchMaxLen <= _streamPos)  					lenLimit = _matchMaxLen;  				else  				{  					lenLimit = _streamPos - _pos;  					if (lenLimit < kMinMatchCheck)  					{  						MovePos();  						continue;  					}  				}    				UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  				UInt32 cur = _bufferOffset + _pos;    				UInt32 hashValue;    				if (HASH_ARRAY)  				{  					UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  					UInt32 hash2Value = temp & (kHash2Size - 1);  					_hash[hash2Value] = _pos;  					temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  					UInt32 hash3Value = temp & (kHash3Size - 1);  					_hash[kHash3Offset + hash3Value] = _pos;  					hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  				}  				else  					hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);    				UInt32 curMatch = _hash[kFixHashSize + hashValue];  				_hash[kFixHashSize + hashValue] = _pos;    				UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  				UInt32 ptr1 = (_cyclicBufferPos << 1);    				UInt32 len0' len1;  				len0 = len1 = kNumHashDirectBytes;    				UInt32 count = _cutValue;  				while (true)  				{  					if (curMatch <= matchMinPos || count-- == 0)  					{  						_son[ptr0] = _son[ptr1] = kEmptyHashValue;  						break;  					}    					UInt32 delta = _pos - curMatch;  					UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?  								(_cyclicBufferPos - delta) :  								(_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;    					UInt32 pby1 = _bufferOffset + curMatch;  					UInt32 len = Math.Min(len0' len1);  					if (_bufferBase[pby1 + len] == _bufferBase[cur + len])  					{  						while (++len != lenLimit)  							if (_bufferBase[pby1 + len] != _bufferBase[cur + len])  								break;  						if (len == lenLimit)  						{  							_son[ptr1] = _son[cyclicPos];  							_son[ptr0] = _son[cyclicPos + 1];  							break;  						}  					}  					if (_bufferBase[pby1 + len] < _bufferBase[cur + len])  					{  						_son[ptr1] = curMatch;  						ptr1 = cyclicPos + 1;  						curMatch = _son[ptr1];  						len1 = len;  					}  					else  					{  						_son[ptr0] = curMatch;  						ptr0 = cyclicPos;  						curMatch = _son[ptr0];  						len0 = len;  					}  				}  				MovePos();  			}  			while (--num != 0);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do  			{  				UInt32 lenLimit;  				if (_pos + _matchMaxLen <= _streamPos)  					lenLimit = _matchMaxLen;  				else  				{  					lenLimit = _streamPos - _pos;  					if (lenLimit < kMinMatchCheck)  					{  						MovePos();  						continue;  					}  				}    				UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  				UInt32 cur = _bufferOffset + _pos;    				UInt32 hashValue;    				if (HASH_ARRAY)  				{  					UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  					UInt32 hash2Value = temp & (kHash2Size - 1);  					_hash[hash2Value] = _pos;  					temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  					UInt32 hash3Value = temp & (kHash3Size - 1);  					_hash[kHash3Offset + hash3Value] = _pos;  					hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  				}  				else  					hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);    				UInt32 curMatch = _hash[kFixHashSize + hashValue];  				_hash[kFixHashSize + hashValue] = _pos;    				UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  				UInt32 ptr1 = (_cyclicBufferPos << 1);    				UInt32 len0' len1;  				len0 = len1 = kNumHashDirectBytes;    				UInt32 count = _cutValue;  				while (true)  				{  					if (curMatch <= matchMinPos || count-- == 0)  					{  						_son[ptr0] = _son[ptr1] = kEmptyHashValue;  						break;  					}    					UInt32 delta = _pos - curMatch;  					UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?  								(_cyclicBufferPos - delta) :  								(_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;    					UInt32 pby1 = _bufferOffset + curMatch;  					UInt32 len = Math.Min(len0' len1);  					if (_bufferBase[pby1 + len] == _bufferBase[cur + len])  					{  						while (++len != lenLimit)  							if (_bufferBase[pby1 + len] != _bufferBase[cur + len])  								break;  						if (len == lenLimit)  						{  							_son[ptr1] = _son[cyclicPos];  							_son[ptr0] = _son[cyclicPos + 1];  							break;  						}  					}  					if (_bufferBase[pby1 + len] < _bufferBase[cur + len])  					{  						_son[ptr1] = curMatch;  						ptr1 = cyclicPos + 1;  						curMatch = _son[ptr1];  						len1 = len;  					}  					else  					{  						_son[ptr0] = curMatch;  						ptr0 = cyclicPos;  						curMatch = _son[ptr0];  						len0 = len;  					}  				}  				MovePos();  			}  			while (--num != 0);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do  			{  				UInt32 lenLimit;  				if (_pos + _matchMaxLen <= _streamPos)  					lenLimit = _matchMaxLen;  				else  				{  					lenLimit = _streamPos - _pos;  					if (lenLimit < kMinMatchCheck)  					{  						MovePos();  						continue;  					}  				}    				UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  				UInt32 cur = _bufferOffset + _pos;    				UInt32 hashValue;    				if (HASH_ARRAY)  				{  					UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  					UInt32 hash2Value = temp & (kHash2Size - 1);  					_hash[hash2Value] = _pos;  					temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  					UInt32 hash3Value = temp & (kHash3Size - 1);  					_hash[kHash3Offset + hash3Value] = _pos;  					hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  				}  				else  					hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);    				UInt32 curMatch = _hash[kFixHashSize + hashValue];  				_hash[kFixHashSize + hashValue] = _pos;    				UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  				UInt32 ptr1 = (_cyclicBufferPos << 1);    				UInt32 len0' len1;  				len0 = len1 = kNumHashDirectBytes;    				UInt32 count = _cutValue;  				while (true)  				{  					if (curMatch <= matchMinPos || count-- == 0)  					{  						_son[ptr0] = _son[ptr1] = kEmptyHashValue;  						break;  					}    					UInt32 delta = _pos - curMatch;  					UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?  								(_cyclicBufferPos - delta) :  								(_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;    					UInt32 pby1 = _bufferOffset + curMatch;  					UInt32 len = Math.Min(len0' len1);  					if (_bufferBase[pby1 + len] == _bufferBase[cur + len])  					{  						while (++len != lenLimit)  							if (_bufferBase[pby1 + len] != _bufferBase[cur + len])  								break;  						if (len == lenLimit)  						{  							_son[ptr1] = _son[cyclicPos];  							_son[ptr0] = _son[cyclicPos + 1];  							break;  						}  					}  					if (_bufferBase[pby1 + len] < _bufferBase[cur + len])  					{  						_son[ptr1] = curMatch;  						ptr1 = cyclicPos + 1;  						curMatch = _son[ptr1];  						len1 = len;  					}  					else  					{  						_son[ptr0] = curMatch;  						ptr0 = cyclicPos;  						curMatch = _son[ptr0];  						len0 = len;  					}  				}  				MovePos();  			}  			while (--num != 0);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do  			{  				UInt32 lenLimit;  				if (_pos + _matchMaxLen <= _streamPos)  					lenLimit = _matchMaxLen;  				else  				{  					lenLimit = _streamPos - _pos;  					if (lenLimit < kMinMatchCheck)  					{  						MovePos();  						continue;  					}  				}    				UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  				UInt32 cur = _bufferOffset + _pos;    				UInt32 hashValue;    				if (HASH_ARRAY)  				{  					UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  					UInt32 hash2Value = temp & (kHash2Size - 1);  					_hash[hash2Value] = _pos;  					temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  					UInt32 hash3Value = temp & (kHash3Size - 1);  					_hash[kHash3Offset + hash3Value] = _pos;  					hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  				}  				else  					hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);    				UInt32 curMatch = _hash[kFixHashSize + hashValue];  				_hash[kFixHashSize + hashValue] = _pos;    				UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  				UInt32 ptr1 = (_cyclicBufferPos << 1);    				UInt32 len0' len1;  				len0 = len1 = kNumHashDirectBytes;    				UInt32 count = _cutValue;  				while (true)  				{  					if (curMatch <= matchMinPos || count-- == 0)  					{  						_son[ptr0] = _son[ptr1] = kEmptyHashValue;  						break;  					}    					UInt32 delta = _pos - curMatch;  					UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?  								(_cyclicBufferPos - delta) :  								(_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;    					UInt32 pby1 = _bufferOffset + curMatch;  					UInt32 len = Math.Min(len0' len1);  					if (_bufferBase[pby1 + len] == _bufferBase[cur + len])  					{  						while (++len != lenLimit)  							if (_bufferBase[pby1 + len] != _bufferBase[cur + len])  								break;  						if (len == lenLimit)  						{  							_son[ptr1] = _son[cyclicPos];  							_son[ptr0] = _son[cyclicPos + 1];  							break;  						}  					}  					if (_bufferBase[pby1 + len] < _bufferBase[cur + len])  					{  						_son[ptr1] = curMatch;  						ptr1 = cyclicPos + 1;  						curMatch = _son[ptr1];  						len1 = len;  					}  					else  					{  						_son[ptr0] = curMatch;  						ptr0 = cyclicPos;  						curMatch = _son[ptr0];  						len0 = len;  					}  				}  				MovePos();  			}  			while (--num != 0);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\LZ\LzBinTree.cs,Normalize,The following statement contains a magic number: NormalizeLinks(_son' _cyclicBufferSize * 2' subValue);
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\RangeCoder\RangeCoder.cs,FlushData,The following statement contains a magic number: for (int i = 0; i < 5; i++)  				ShiftLow();
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\RangeCoder\RangeCoder.cs,Encode,The following statement contains a magic number: while (Range < kTopValue)  			{  				Range <<= 8;  				ShiftLow();  			}
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1)  			{  				byte temp = _cache;  				do  				{  					Stream.WriteByte((byte)(temp + (Low >> 32)));  					temp = 0xFF;  				}  				while (--_cacheSize != 0);  				_cache = (byte)(((uint)Low) >> 24);  			}
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1)  			{  				byte temp = _cache;  				do  				{  					Stream.WriteByte((byte)(temp + (Low >> 32)));  					temp = 0xFF;  				}  				while (--_cacheSize != 0);  				_cache = (byte)(((uint)Low) >> 24);  			}
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1)  			{  				byte temp = _cache;  				do  				{  					Stream.WriteByte((byte)(temp + (Low >> 32)));  					temp = 0xFF;  				}  				while (--_cacheSize != 0);  				_cache = (byte)(((uint)Low) >> 24);  			}
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: Low = ((uint)Low) << 8;
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\RangeCoder\RangeCoder.cs,EncodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits - 1; i >= 0; i--)  			{  				Range >>= 1;  				if (((v >> i) & 1) == 1)  					Low += Range;  				if (Range < kTopValue)  				{  					Range <<= 8;  					ShiftLow();  				}  			}
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\RangeCoder\RangeCoder.cs,EncodeBit,The following statement contains a magic number: while (Range < kTopValue)  			{  				Range <<= 8;  				ShiftLow();  			}
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\RangeCoder\RangeCoder.cs,GetProcessedSizeAdd,The following statement contains a magic number: return _cacheSize +  				Stream.Position - StartPosition + 4;
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\RangeCoder\RangeCoder.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)  				Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\RangeCoder\RangeCoder.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)  				Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue)  			{  				Code = (Code << 8) | (byte)Stream.ReadByte();  				Range <<= 8;  			}
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue)  			{  				Code = (Code << 8) | (byte)Stream.ReadByte();  				Range <<= 8;  			}
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: if (Range < kTopValue)  			{  				Code = (Code << 8) | (byte)Stream.ReadByte();  				Range <<= 8;  			}
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: if (Range < kTopValue)  			{  				Code = (Code << 8) | (byte)Stream.ReadByte();  				Range <<= 8;  			}
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--)  			{  				range >>= 1;  				/*  				result <<= 1;  				if (code >= range)  				{  					code -= range;  					result |= 1;  				}  				*/  				uint t = (code - range) >> 31;  				code -= range & (t - 1);  				result = (result << 1) | (1 - t);    				if (range < kTopValue)  				{  					code = (code << 8) | (byte)Stream.ReadByte();  					range <<= 8;  				}  			}
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--)  			{  				range >>= 1;  				/*  				result <<= 1;  				if (code >= range)  				{  					code -= range;  					result |= 1;  				}  				*/  				uint t = (code - range) >> 31;  				code -= range & (t - 1);  				result = (result << 1) | (1 - t);    				if (range < kTopValue)  				{  					code = (code << 8) | (byte)Stream.ReadByte();  					range <<= 8;  				}  			}
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--)  			{  				range >>= 1;  				/*  				result <<= 1;  				if (code >= range)  				{  					code -= range;  					result |= 1;  				}  				*/  				uint t = (code - range) >> 31;  				code -= range & (t - 1);  				result = (result << 1) | (1 - t);    				if (range < kTopValue)  				{  					code = (code << 8) | (byte)Stream.ReadByte();  					range <<= 8;  				}  			}
Magic Number,SevenZip.Compression.RangeCoder,BitEncoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\RangeCoder\RangeCoderBit.cs,Encode,The following statement contains a magic number: if (encoder.Range < Encoder.kTopValue)  			{  				encoder.Range <<= 8;  				encoder.ShiftLow();  			}
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)  			{  				rangeDecoder.Range = newBound;  				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 0;  			}  			else  			{  				rangeDecoder.Range -= newBound;  				rangeDecoder.Code -= newBound;  				Prob -= (Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 1;  			}
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)  			{  				rangeDecoder.Range = newBound;  				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 0;  			}  			else  			{  				rangeDecoder.Range -= newBound;  				rangeDecoder.Code -= newBound;  				Prob -= (Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 1;  			}
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)  			{  				rangeDecoder.Range = newBound;  				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 0;  			}  			else  			{  				rangeDecoder.Range -= newBound;  				rangeDecoder.Code -= newBound;  				Prob -= (Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 1;  			}
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\LZMA\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)  			{  				rangeDecoder.Range = newBound;  				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 0;  			}  			else  			{  				rangeDecoder.Range -= newBound;  				rangeDecoder.Code -= newBound;  				Prob -= (Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 1;  			}
Missing Default,SteamKit2,EnvelopeEncryptedConnection,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\EnvelopeEncryptedConnection.cs,OnNetMsgReceived,The following switch statement is missing a default case: switch ( packetMsg.MsgType )              {                  case EMsg.ChannelEncryptRequest:                      HandleEncryptRequest( packetMsg );                      break;                    case EMsg.ChannelEncryptResult:                      HandleEncryptResult( packetMsg );                      break;              }
Missing Default,SteamKit2,WebSocketContext,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\WebSocketContext.cs,GetHostAndPort,The following switch statement is missing a default case: switch (endPoint)                  {                      case IPEndPoint ipep:                          switch (ipep.AddressFamily)                          {                              case AddressFamily.InterNetwork:                                  return FormattableString.Invariant($"{ipep.Address}:{ipep.Port}");                                case AddressFamily.InterNetworkV6:                                  // RFC 2732                                  return FormattableString.Invariant($"[{ipep.ToString()}]:{ipep.Port}");                          }                            break;                        case DnsEndPoint dns:                          return FormattableString.Invariant($"{dns.Host}:{dns.Port}");                  }
Missing Default,SteamKit2,WebSocketContext,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Networking\Steam3\WebSocketContext.cs,GetHostAndPort,The following switch statement is missing a default case: switch (ipep.AddressFamily)                          {                              case AddressFamily.InterNetwork:                                  return FormattableString.Invariant($"{ipep.Address}:{ipep.Port}");                                case AddressFamily.InterNetworkV6:                                  // RFC 2732                                  return FormattableString.Invariant($"[{ipep.ToString()}]:{ipep.Port}");                          }
Missing Default,SteamKit2,ChatMemberInfoCallback,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\Handlers\SteamFriends\Callbacks.cs,ChatMemberInfoCallback,The following switch statement is missing a default case: switch ( Type )                  {                      case EChatInfoType.StateChange:                          StateChangeInfo = new StateChangeDetails( payload );                          break;                        // todo: handle more types                      // based off disassembly                      //   - for InfoUpdate' a ChatMemberInfo object is present                      //   - for MemberLimitChange' looks like an ignored uint64 (probably steamid) followed                      //     by an int which likely represents the member limit                  }
Missing Default,SteamKit2,UnifiedService<TService>,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\Handlers\SteamUnifiedMessages\SteamUnifiedMessages.cs,ExtractMethodCallExpression,The following switch statement is missing a default case: switch ( expression.NodeType )                  {                      // Older code/tests/whatever were compiled down to just a single MethodCallExpression.                      case ExpressionType.Call:                          return ( MethodCallExpression )expression.Body;                        // Newer code/tests/whatever are now compiled by wrapping the MethodCallExpression in a LambdaExpression.                      case ExpressionType.Lambda:                          if ( expression.Body.NodeType == ExpressionType.Call )                          {                              var lambda = ( LambdaExpression )expression;                              return ( MethodCallExpression )lambda.Body;                          }                          break;                  }
Missing Default,SteamKit2,SteamID,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Types\SteamID.cs,RenderSteam3,The following switch statement is missing a default case: switch ( AccountType )              {                  case EAccountType.AnonGameServer:                  case EAccountType.Multiseat:                      renderInstance = true;                      break;                    case EAccountType.Individual:                      renderInstance = (AccountInstance != DesktopInstance);                      break;              }
Missing Default,SteamKit2,MachineInfoProvider,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\HardwareUtils.cs,GetProvider,The following switch statement is missing a default case: switch ( Environment.OSVersion.Platform )              {                  case PlatformID.Win32NT:                  case PlatformID.Win32Windows:                      return new WindowsInfoProvider();                    case PlatformID.Unix:                      if ( Utils.IsMacOS() )                      {                          return new OSXInfoProvider();                      }                      else                      {                          return new LinuxInfoProvider();                      }              }
Missing Default,SteamKit2,Utils,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Utils.cs,GetOSType,The following switch statement is missing a default case: switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.Win2000;                                        case 1:                                          return EOSType.WinXP;                                        case 2:                                          // Assume nobody runs Windows XP Professional x64 Edition                                          // It's an edition of Windows Server 2003 anyway.                                          return EOSType.Win2003;                                  }
Missing Default,SteamKit2,Utils,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Utils.cs,GetOSType,The following switch statement is missing a default case: switch ( ver.Minor )                                  {                                      case 0:                                          return EOSType.WinVista; // Also Server 2008                                        case 1:                                          return EOSType.Windows7; // Also Server 2008 R2                                        case 2:                                          return EOSType.Windows8; // Also Server 2012                                        // Note: The OSVersion property reports the same version number (6.2.0.0) for both Windows 8 and Windows 8.1.- http://msdn.microsoft.com/en-us/library/system.environment.osversion(v=vs.110).aspx                                      // In practice' this will only get hit if the application targets Windows 8.1 in the app manifest.                                      // See http://msdn.microsoft.com/en-us/library/windows/desktop/dn481241(v=vs.85).aspx for more info.                                      case 3:                                          return EOSType.Windows81; // Also Server 2012 R2                                  }
Missing Default,SteamKit2,WebHelpers,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Util\Utils.cs,IsUrlSafeChar,The following switch statement is missing a default case: switch ( ch )              {                  case '-':                  case '.':                  case '_':                      return true;              }
Missing Default,SteamKit2.Internal,CMClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CMClient.cs,OnClientMsgReceived,The following switch statement is missing a default case: switch ( packetMsg.MsgType )              {                  case EMsg.Multi:                      HandleMulti( packetMsg );                      break;                    case EMsg.ClientLogOnResponse: // we handle this to get the SteamID/SessionID and to setup heartbeating                      HandleLogOnResponse( packetMsg );                      break;                    case EMsg.ClientLoggedOff: // to stop heartbeating when we get logged off                      HandleLoggedOff( packetMsg );                      break;                    case EMsg.ClientServerList: // Steam server list                      HandleServerList( packetMsg );                      break;                    case EMsg.ClientCMList:                      HandleCMList( packetMsg );                      break;                    case EMsg.ClientSessionToken: // am session token                      HandleSessionToken( packetMsg );                      break;              }
Missing Default,SteamKit2.Internal,CMClient,C:\repos\SteamRE_SteamKit\SteamKit2\SteamKit2\Steam\CMClient.cs,GetPacketMsg,The following switch statement is missing a default case: switch ( eMsg )              {                  // certain message types are always MsgHdr                  case EMsg.ChannelEncryptRequest:                  case EMsg.ChannelEncryptResponse:                  case EMsg.ChannelEncryptResult:                      return new PacketMsg( eMsg' data );              }
