Implementation smell,Namespace,Class,File,Method,Description
Complex Method,SD.Tools.Algorithmia.Graphs,DepthFirstSearchCrawler<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\DepthFirstSearchCrawler.cs,Crawl,Cyclomatic complexity of the method is 9
Complex Method,SD.Tools.Algorithmia.Graphs,DepthFirstSearchCrawler<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\DepthFirstSearchCrawler.cs,Visit,Cyclomatic complexity of the method is 10
Complex Method,SD.Tools.Algorithmia.Heaps,BinaryHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\BinaryHeap.cs,FindIndexOfElement,Cyclomatic complexity of the method is 11
Complex Method,SD.Tools.Algorithmia.Sorting,SortingExtensionMethods,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Sorting\SortingExtensionMethods.cs,Sort,Cyclomatic complexity of the method is 8
Long Parameter List,SD.Tools.Algorithmia.Sorting,ISortAlgorithm,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Sorting\ISortAlgorithm.cs,Sort,The method has 5 parameters. Parameters: toSort' direction' startIndex' endIndex' compareFunc
Long Parameter List,SD.Tools.Algorithmia.Sorting,QuickSorter,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Sorting\QuickSorter.cs,Sort,The method has 5 parameters. Parameters: toSort' direction' startIndex' endIndex' compareFunc
Long Parameter List,SD.Tools.Algorithmia.Sorting,QuickSorter,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Sorting\QuickSorter.cs,Partition,The method has 5 parameters. Parameters: toSort' left' right' pivotIndex' valueComparerTest
Long Parameter List,SD.Tools.Algorithmia.Sorting,SelectionSorter,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Sorting\SelectionSorter.cs,Sort,The method has 5 parameters. Parameters: toSort' direction' startIndex' endIndex' compareFunc
Long Parameter List,SD.Tools.Algorithmia.Sorting,ShellSorter,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Sorting\ShellSorter.cs,Sort,The method has 5 parameters. Parameters: toSort' direction' startIndex' endIndex' compareFunc
Long Parameter List,SD.Tools.Algorithmia.Sorting,SortingExtensionMethods,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Sorting\SortingExtensionMethods.cs,Sort,The method has 5 parameters. Parameters: toSort' algorithm' direction' startIndex' endIndex
Long Parameter List,SD.Tools.Algorithmia.Sorting,SortingExtensionMethods,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Sorting\SortingExtensionMethods.cs,Sort,The method has 6 parameters. Parameters: toSort' algorithm' direction' startIndex' endIndex' comparer
Long Parameter List,SD.Tools.Algorithmia.Sorting,SortingExtensionMethods,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Sorting\SortingExtensionMethods.cs,Sort,The method has 6 parameters. Parameters: toSort' algorithm' direction' startIndex' endIndex' compareFunc
Long Identifier,SD.Tools.Algorithmia.Commands,CommandQueueManager,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Commands\CommandQueueManager.cs,,The length of the parameter _threadActiveCommandQueueStackId is 32.
Long Identifier,SD.Tools.Algorithmia.Commands,UndoablePeriodCommand,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Commands\UndoablePeriodCommand.cs,,The length of the parameter _originalIsInUndoablePeriodFlagValue is 36.
Long Identifier,SD.Tools.Algorithmia.Graphs.Algorithms,DisconnectedGraphsFinder<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\Algorithms\DisconnectedGraphsFinder.cs,FindDisconnectedGraphs,The length of the parameter onlyDisconnectedGraphOfStartVertex is 34.
Long Statement,SD.Tools.Algorithmia.Commands,Command<TState>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Commands\Command.cs,Do,The length of the statement  "				// has state retrieval function so obtain the original state using that func. This state is then used in the undo action as the state to restore " is 144.
Long Statement,SD.Tools.Algorithmia.Commands,Command<TState>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Commands\Command.cs,Undo,The length of the statement  "			// first undo commands in own command queue from back to front' that is: from the active command in the own command queue  " is 121.
Long Statement,SD.Tools.Algorithmia.Commands,Command<TState>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Commands\Command.cs,Undo,The length of the statement  "					// undo ourselves' by setting the original state back using the undoFunc0. This func is responsible for the original state to set back. " is 135.
Long Statement,SD.Tools.Algorithmia.Commands,CommandQueue,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Commands\CommandQueue.cs,EnqueueCommand,The length of the statement  "				// ignore' all commands are already there in this mode and this command therefore already is either there or is not important " is 125.
Long Statement,SD.Tools.Algorithmia.Commands,CommandQueue,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Commands\CommandQueue.cs,EnqueueCommand,The length of the statement  "					// can't add new commands to a queue of a command which executed an undoFunc. This happens through bugs in the using code so we have to  " is 135.
Long Statement,SD.Tools.Algorithmia.Commands,CommandQueueManager,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Commands\CommandQueueManager.cs,PerformUndoablePeriod,The length of the statement  "			// reset before/after do action as BeginUndoablePeriod will execute the command (which is empty) but will still perform the before/after actions " is 144.
Long Statement,SD.Tools.Algorithmia.Commands,CommandQueueManager,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Commands\CommandQueueManager.cs,UndoLastCommand,The length of the statement  "				// set the flag that an undo action is in progress to prevent new commands being added to the top command queue on the active stack. We do this here  " is 148.
Long Statement,SD.Tools.Algorithmia.Commands,CommandQueueManager,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Commands\CommandQueueManager.cs,UndoLastCommand,The length of the statement  "				// as commands which are added through code which is called (indirectly) by the undoFunc of a command undone by this routine (directly or indirectly)'  " is 150.
Long Statement,SD.Tools.Algorithmia.GeneralDataStructures,CallLimiter,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\GeneralDataStructures\CallLimiter.cs,_timer_Elapsed,The length of the statement  "				// if a synchronization object was specified' this event handler is called on the UI thread' otherwise this event handler " is 121.
Long Statement,SD.Tools.Algorithmia.GeneralDataStructures,ChangeAwareKeyedCommandifiedList<T;TKeyValue;TChangeType>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\GeneralDataStructures\ChangeAwareKeyedCommandifiedList.cs,item_DetailedElementChanged,The length of the statement  "			this.DetailedElementInListChanged.RaiseEvent(this' new ElementInListChangedEventArgs<TChangeType' T>(e.TypeOfChange' e.InvolvedElement)); " is 137.
Long Statement,SD.Tools.Algorithmia.GeneralDataStructures,CommandifiedList<T>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\GeneralDataStructures\CommandifiedList.cs,ClearItems,The length of the statement  "			Command<Collection<T>> clearCmd = new Command<Collection<T>>(() => this.PerformClearItems()' () => this.GetCurrentState()' c=>this.SetCurrentState(c)' "Clear this instance"); " is 174.
Long Statement,SD.Tools.Algorithmia.GeneralDataStructures,CommandifiedList<T>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\GeneralDataStructures\CommandifiedList.cs,InsertItem,The length of the statement  "				// create a command which simply inserts the item at the given index and as undo function removes the item at the index specified. " is 130.
Long Statement,SD.Tools.Algorithmia.GeneralDataStructures,CommandifiedList<T>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\GeneralDataStructures\CommandifiedList.cs,RemoveItem,The length of the statement  "			// create a command which simply removes the item at the given index and as undo function it re-inserts the item at the index specified. " is 136.
Long Statement,SD.Tools.Algorithmia.GeneralDataStructures,CommandifiedList<T>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\GeneralDataStructures\CommandifiedList.cs,RemoveItem,The length of the statement  "			// The command created passes the current item at the index specified' but it's not really used' as there's no state to set. The command however has to " is 151.
Long Statement,SD.Tools.Algorithmia.GeneralDataStructures,CommandifiedList<T>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\GeneralDataStructures\CommandifiedList.cs,RemoveItem,The length of the statement  "			Command<T> removeCmd = new Command<T>(() => this.PerformRemoveItem(index)' () => this[index]' i => this.PerformInsertItem(index' i)' "Remove an item"); " is 151.
Long Statement,SD.Tools.Algorithmia.GeneralDataStructures,CommandifiedList<T>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\GeneralDataStructures\CommandifiedList.cs,SetItem,The length of the statement  "			Command<T> setCmd = new Command<T>(() => this.PerformSetItem(index' item)' () => this[index]' i => this.PerformSetItem(index' i)' "Set an item at a given index"); " is 162.
Long Statement,SD.Tools.Algorithmia.GeneralDataStructures,CommandifiedList<T>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\GeneralDataStructures\CommandifiedList.cs,VerifyIndex,The length of the statement  "				throw new ArgumentOutOfRangeException(nameof(index)' string.Format("index is out of range: the value '{0}' isn't in the range of valid values."' index)); " is 153.
Long Statement,SD.Tools.Algorithmia.GeneralDataStructures,CommandifiedMember<TValue;TChangeType>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\GeneralDataStructures\CommandifiedMember.cs,SetMemberValue,The length of the statement  "				this.ValueChanged.RaiseEvent(this' new MemberChangedEventArgs<TChangeType' TValue>(_changeTypeValueToUse' originalValue' _memberValue)); " is 136.
Long Statement,SD.Tools.Algorithmia.GeneralDataStructures,CommandifiedMember<TValue;TChangeType>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\GeneralDataStructures\CommandifiedMember.cs,_memberValue_ElementChanged,The length of the statement  "			this.ValueChanged.RaiseEvent(this' new MemberChangedEventArgs<TChangeType' TValue>(_changeTypeValueToUse' _memberValue' _memberValue)); " is 135.
Long Statement,SD.Tools.Algorithmia.GeneralDataStructures,EventThrottler<TElement;TEventArgs>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\GeneralDataStructures\EventThrottler.cs,_timer_Elapsed,The length of the statement  "					// process the entire queue from back to front' skipping any action we've already done. Any action resulting from an action " is 123.
Long Statement,SD.Tools.Algorithmia.GeneralDataStructures,Pair<TVal1;TVal2>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\GeneralDataStructures\Pair.cs,Equals,The length of the statement  "			return (GeneralUtils.ValuesAreEqual(this.Value1' toCompareWith.Value1) && GeneralUtils.ValuesAreEqual(this.Value2' toCompareWith.Value2)); " is 138.
Long Statement,SD.Tools.Algorithmia.Graphs.Algorithms,TopologicalSorter<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\Algorithms\TopologicalSorter.cs,CycleDetected,The length of the statement  "				string.Format("Cycle detected. Topological sorting can't be applied on a directed graph with one or more cycles. Related vertex (which was reached from one of the vertices already visited): {0}. Edge(s) followed (and vertices visited) to reach this related vertex: {1}"'  " is 270.
Long Statement,SD.Tools.Algorithmia.Graphs,DepthFirstSearchCrawler<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\DepthFirstSearchCrawler.cs,Crawl,The length of the statement  "			TVertex vertexToStart = GeneralUtils.PerformSyncedAction(()=>_graphToCrawl.Vertices.FirstOrDefault()' _graphToCrawl.SyncRoot' _graphToCrawl.IsSynchronized); " is 156.
Long Statement,SD.Tools.Algorithmia.Graphs,DepthFirstSearchCrawler<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\DepthFirstSearchCrawler.cs,Crawl,The length of the statement  "				// create safe copy to work with. This can be a bit of a problem regarding performance with massive graphs' but toArray is in general rather quick.  " is 147.
Long Statement,SD.Tools.Algorithmia.Graphs,DepthFirstSearchCrawler<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\DepthFirstSearchCrawler.cs,Crawl,The length of the statement  "				toEnumerate = GeneralUtils.PerformSyncedAction(()=> _graphToCrawl.Vertices.ToArray()' _graphToCrawl.SyncRoot' _graphToCrawl.IsSynchronized); " is 140.
Long Statement,SD.Tools.Algorithmia.Graphs,DepthFirstSearchCrawler<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\DepthFirstSearchCrawler.cs,Crawl,The length of the statement  "					// simply use the vertexToStart. As it's being processed right away' any subsequential occurence later on will be a no-op as the vertex has " is 139.
Long Statement,SD.Tools.Algorithmia.Graphs,DepthFirstSearchCrawler<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\DepthFirstSearchCrawler.cs,Crawl,The length of the statement  "				// we only get back to this level for tree roots if it's a non-directed graph. If it's a directed graph' we can end up here as well if we moved " is 143.
Long Statement,SD.Tools.Algorithmia.Graphs,DepthFirstSearchCrawler<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\DepthFirstSearchCrawler.cs,Visit,The length of the statement  "						// cycle detected' as we're reaching a vertex (via recursion) which is still in progress. It depends on the CycleDetected routine if we may " is 139.
Long Statement,SD.Tools.Algorithmia.Graphs,DepthFirstSearchCrawler<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\DepthFirstSearchCrawler.cs,Visit,The length of the statement  "					// as the crawler visits vertices over all the edges at once' in an undirected graph there is no such situation where the visited vertex " is 136.
Long Statement,SD.Tools.Algorithmia.Graphs,DepthFirstSearchCrawler<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\DepthFirstSearchCrawler.cs,Visit,The length of the statement  "			var adjacencyList = GeneralUtils.PerformSyncedAction(()=>_graphToCrawl.GetAdjacencyListForVertex(vertex)' _graphToCrawl.SyncRoot' _graphToCrawl.IsSynchronized); " is 160.
Long Statement,SD.Tools.Algorithmia.Graphs,DepthFirstSearchCrawler<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\DepthFirstSearchCrawler.cs,Visit,The length of the statement  "				// recurse to the related vertex' over the edges in the list of edges. We simply pass the whole hashset as it doesn't matter which edge is picked " is 145.
Long Statement,SD.Tools.Algorithmia.Graphs,DepthFirstSearchCrawler<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\DepthFirstSearchCrawler.cs,Visit,The length of the statement  "				// to crawl the graph' but an algorithm might want to know which edges to pick from' so it's better to pass them as a whole than to pass them one by " is 148.
Long Statement,SD.Tools.Algorithmia.Graphs,DirectedGraph<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\DirectedGraph.cs,TransitiveClosure,The length of the statement  "				throw new InvalidOperationException("To be able to produce a Transitive Closure of this graph' the graph has to have its EdgeProducerFunc set to produce new edges. It's currently not set (null)."); " is 197.
Long Statement,SD.Tools.Algorithmia.Graphs,GraphBase<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\GraphBase.cs,Add,The length of the statement  "				CommandQueueManagerSingleton.GetInstance().EnqueueAndRunCommand(new Command<GraphBase<TVertex' TEdge>>(() => PerformAddGraph(graph)' null' " is 138.
Long Statement,SD.Tools.Algorithmia.Graphs,GraphBase<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\GraphBase.cs,Add,The length of the statement  "				CommandQueueManagerSingleton.GetInstance().EnqueueAndRunCommand(new Command<TEdge>(() => PerformAddEdge(edge)' null' _cachedCommandDescriptions[GraphCommandType.AddEdge])); " is 172.
Long Statement,SD.Tools.Algorithmia.Graphs,GraphBase<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\GraphBase.cs,Add,The length of the statement  "					CommandQueueManagerSingleton.GetInstance().EnqueueAndRunCommand(new Command<TEdge>(() => PerformAddVertex(vertex)' null' " is 120.
Long Statement,SD.Tools.Algorithmia.Graphs,GraphBase<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\GraphBase.cs,Remove,The length of the statement  "				CommandQueueManagerSingleton.GetInstance().EnqueueAndRunCommand(new Command<GraphBase<TVertex' TEdge>>(() => PerformRemoveGraph(graph' edgesOnly)' null' " is 152.
Long Statement,SD.Tools.Algorithmia.Graphs,GraphBase<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\GraphBase.cs,Remove,The length of the statement  "				CommandQueueManagerSingleton.GetInstance().EnqueueAndRunCommand(new Command<TEdge>(() => PerformRemoveEdge(edge)' null' _cachedCommandDescriptions[GraphCommandType.RemoveEdge])); " is 178.
Long Statement,SD.Tools.Algorithmia.Graphs,GraphBase<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\GraphBase.cs,Remove,The length of the statement  "				CommandQueueManagerSingleton.GetInstance().EnqueueAndRunCommand(new Command<TVertex>(() => PerformRemoveVertex(vertex)' null'  " is 125.
Long Statement,SD.Tools.Algorithmia.Graphs,GraphBase<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\GraphBase.cs,Disconnect,The length of the statement  "				CommandQueueManagerSingleton.GetInstance().EnqueueAndRunCommand(new Command<TVertex>(() => PerformDisconnect(startVertex' endVertex' bothSides)'  " is 144.
Long Statement,SD.Tools.Algorithmia.Graphs,GraphBase<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\GraphBase.cs,Contains,The length of the statement  "			// true if there's an edge between start vertex and end vertex (which automatically returns false if the vertices aren't part of this graph etc.) " is 145.
Long Statement,SD.Tools.Algorithmia.Graphs,GraphBase<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\GraphBase.cs,Contains,The length of the statement  "			return (ContainsEdge(edge.StartVertex' edge.EndVertex) && PerformSyncedAction(()=>_graph[edge.StartVertex][edge.EndVertex].Contains(edge))); " is 140.
Long Statement,SD.Tools.Algorithmia.Graphs,GraphBase<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\GraphBase.cs,GetEdges,The length of the statement  "			return this.ContainsEdge(startVertex' endVertex) ? PerformSyncedAction(() => (_graph[startVertex][endVertex]).ToHashSet()) : new HashSet<TEdge>(); " is 146.
Long Statement,SD.Tools.Algorithmia.Graphs,GraphBase<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\GraphBase.cs,GetOrphanedVertices,The length of the statement  "			// do an Except query between the list of vertices and the list of vertices in the adjacency lists. As a vertex in an adjancency list is always " is 143.
Long Statement,SD.Tools.Algorithmia.Graphs,GraphBase<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\GraphBase.cs,IsConnected,The length of the statement  "			// Use the DepthFirstCrawler to detect the number of roots of this graph. If the number of roots is higher than 1' the graph isn't connected.  " is 141.
Long Statement,SD.Tools.Algorithmia.Graphs,GraphBase<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\GraphBase.cs,GetAsNonDirectedCopy,The length of the statement  "			NonDirectedGraph<TVertex' NonDirectedEdge<TVertex>> toReturn = new NonDirectedGraph<TVertex' NonDirectedEdge<TVertex>>(); " is 121.
Long Statement,SD.Tools.Algorithmia.Graphs,GraphBase<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\GraphBase.cs,BuildCachedCommandDescriptions,The length of the statement  "			_cachedCommandDescriptions.Add(GraphCommandType.RemoveVertexFromAdjacencyList' "Remove a vertex physically from an adjacencylist"); " is 131.
Long Statement,SD.Tools.Algorithmia.Graphs,GraphBase<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\GraphBase.cs,CheckEdge,The length of the statement  "				throw new ArgumentException(string.Format("The edge isn't compatible with this graph: The graph's IsDirected flag is {0}' while the edge's IsDirected flag is {1}"' _isDirected' edge.IsDirected)); " is 195.
Long Statement,SD.Tools.Algorithmia.Graphs,GraphBase<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\GraphBase.cs,PerformRemoveVertex,The length of the statement  "			// First collect all edges and remove these first. Code observing this graph will get notified and the vertex is still there.  " is 125.
Long Statement,SD.Tools.Algorithmia.Graphs,GraphBase<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\GraphBase.cs,PerformRemoveVertex,The length of the statement  "					// an undirected edge is added to both sides' but as there's just 1 edge instance' the startvertex is the same for both sides. " is 126.
Long Statement,SD.Tools.Algorithmia.Graphs,SubGraphView<TVertex;TEdge>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Graphs\SubGraphView.cs,RemoveEdgesWithVertex,The length of the statement  "									var edgesToRemove = _edges.Where(e=>(e.EndVertex != null && e.EndVertex.Equals(vertex)) || (e.StartVertex != null && e.StartVertex.Equals(vertex))).ToList(); " is 157.
Long Statement,SD.Tools.Algorithmia.Heaps,BinaryHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\BinaryHeap.cs,Merge,The length of the statement  "				// walk the heap to merge by simply extract the root till there are no elements left. toMerge will be empty after this operation. " is 129.
Long Statement,SD.Tools.Algorithmia.Heaps,BinaryHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\BinaryHeap.cs,FindIndexOfElement,The length of the statement  "						// has left child. Check if the left child would be a parent of this element. If not' skip it' otherwise' dig into that tree. " is 125.
Long Statement,SD.Tools.Algorithmia.Heaps,BinaryHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\BinaryHeap.cs,FindIndexOfElement,The length of the statement  "								// has right child. Check if the right child would be a parent of this element. If not' skip it' otherwise' dig into that tree. " is 127.
Long Statement,SD.Tools.Algorithmia.Heaps,BinaryHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\BinaryHeap.cs,Downheap,The length of the statement  "			// by default pick the left child (as it is always there IF there are children). If there is a right child' we check which one of the two would be " is 146.
Long Statement,SD.Tools.Algorithmia.Heaps,BinaryHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\BinaryHeap.cs,Downheap,The length of the statement  "				// there is a right child' check which of the two children would be the parent of one another. We'll check if the right one would be the parent. " is 144.
Long Statement,SD.Tools.Algorithmia.Heaps,BinaryHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\BinaryHeap.cs,Downheap,The length of the statement  "			// we now have two indexes. We've to check if the passed in index is correctly the parent of the indexToCompareWith element. If not' swap and proceed " is 149.
Long Statement,SD.Tools.Algorithmia.Heaps,BinaryHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\BinaryHeap.cs,RemoveAt,The length of the statement  "			// replace element to remove with last element in the heap' then remove last element from the list of elements and then downheap the element at index " is 149.
Long Statement,SD.Tools.Algorithmia.Heaps,BinaryHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\BinaryHeap.cs,RemoveAt,The length of the statement  "					// now simply downheap the element at index specified. Downheap will take care of the rest. We need a downheap because the element " is 130.
Long Statement,SD.Tools.Algorithmia.Heaps,BinaryHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\BinaryHeap.cs,RemoveAt,The length of the statement  "					// we swapped into the 'index' location is always a child of the elements which are potentially higher up the tree. We now only have " is 132.
Long Statement,SD.Tools.Algorithmia.Heaps,BinaryHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\BinaryHeap.cs,RemoveAt,The length of the statement  "					// to take care of the fact if the element now located at 'index' is at the right place or should be a child of one of its new children'  " is 136.
Long Statement,SD.Tools.Algorithmia.Heaps,FibonacciHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\FibonacciHeap.cs,ExtractRoot,The length of the statement  "			// Consolidate trees so there's at most 1 tree per tree degree. During this process a new heap root (the min/max) is found. " is 123.
Long Statement,SD.Tools.Algorithmia.Heaps,FibonacciHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\FibonacciHeap.cs,UpdateKey,The length of the statement  "				// As this heap can be a maxheap as well' and the action can make the root of the heap be violating the heap' we simply remove the element " is 138.
Long Statement,SD.Tools.Algorithmia.Heaps,FibonacciHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\FibonacciHeap.cs,UpdateKey,The length of the statement  "					// Place the tree with the elementNode as root as a separate tree in the list of trees of this heap and first preserve the " is 122.
Long Statement,SD.Tools.Algorithmia.Heaps,FibonacciHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\FibonacciHeap.cs,UpdateKey,The length of the statement  "						// marked nodes are nodes where modifications take place' and these are bumped up to the root level of the trees sooner or later " is 128.
Long Statement,SD.Tools.Algorithmia.Heaps,FibonacciHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\FibonacciHeap.cs,Merge,The length of the statement  "			// obtain the data structures of the heap to merge' and merge them together. Do this by simply linking the two linked lists together' as " is 136.
Long Statement,SD.Tools.Algorithmia.Heaps,FibonacciHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\FibonacciHeap.cs,Merge,The length of the statement  "			// that's all that has to be done besides updating the root. All essential work is postponed till the trees have to be collided together. " is 137.
Long Statement,SD.Tools.Algorithmia.Heaps,FibonacciHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\FibonacciHeap.cs,Merge,The length of the statement  "			// add their element to node mappings to our list of mappings. We don't merge the dictionaries as that would cause this merge operation to become " is 145.
Long Statement,SD.Tools.Algorithmia.Heaps,FibonacciHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\FibonacciHeap.cs,Merge,The length of the statement  "			// an O(n) operation. With the addition of the list of mappings' our search routine has to check m mappings' where m is the # of merge operations  " is 145.
Long Statement,SD.Tools.Algorithmia.Heaps,FibonacciHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\FibonacciHeap.cs,Remove,The length of the statement  "				// normal node which isn't the heap root' use shortcut to internal remove routine so we don't have to collide the trees.  " is 120.
Long Statement,SD.Tools.Algorithmia.Heaps,FibonacciHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\FibonacciHeap.cs,ConsolidateTrees,The length of the statement  "			Dictionary<int' ListBucket<FibonacciHeapNode<TElement>>> treeNodePerDegree = new Dictionary<int' ListBucket<FibonacciHeapNode<TElement>>>(); " is 140.
Long Statement,SD.Tools.Algorithmia.Heaps,FibonacciHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\FibonacciHeap.cs,ConsolidateTrees,The length of the statement  "			// traverse the trees and if there's no tree with such a degree' add it to the list' otherwise merge the tree with the one already with that " is 140.
Long Statement,SD.Tools.Algorithmia.Heaps,FibonacciHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\FibonacciHeap.cs,ConsolidateTrees,The length of the statement  "					// there's a tree with the same node. Merge this tree with that tree till there's no tree with the same degree for this current tree " is 132.
Long Statement,SD.Tools.Algorithmia.Heaps,FibonacciHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\FibonacciHeap.cs,AddElementNodeMapping,The length of the statement  "			// add to first mapping dictionary. It can be there are more' every merge operation adds new mappings' however for adding new nodes' we add " is 139.
Long Statement,SD.Tools.Algorithmia.Heaps,FibonacciHeapNode<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\FibonacciHeap.cs,CutChild,The length of the statement  "				// mark ourselves. This is an essential part of the algorithm: if a child is cut from a node' the node has to be marked. " is 120.
Long Statement,SD.Tools.Algorithmia.PriorityQueues,SimplePriorityQueue<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\PriorityQueues\SimplePriorityQueue.cs,Peek,The length of the statement  "				// with the highest priority when it's added' however removing the element from the queue (which is the typical behavior where Peek is used for) " is 144.
Long Statement,SD.Tools.Algorithmia.PriorityQueues,SimplePriorityQueue<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\PriorityQueues\SimplePriorityQueue.cs,Peek,The length of the statement  "				// again will require to find the then highest priority' which in short means that the optimization is mitigated by the fact that the search for " is 144.
Long Statement,SD.Tools.Algorithmia.PriorityQueues,SortedPriorityQueue<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\PriorityQueues\SortedPriorityQueue.cs,Add,The length of the statement  "			// use binary search to find the spot where to insert the element' then insert the element using List<T>'s Insert() method which uses " is 133.
Long Statement,SD.Tools.Algorithmia.PriorityQueues,SortedPriorityQueue<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\PriorityQueues\SortedPriorityQueue.cs,Add,The length of the statement  "			// native block-copy code internally for performance. We'll use .NET's binarySearch implementation with our own comparer. " is 121.
Long Statement,SD.Tools.Algorithmia.PriorityQueues,SortedPriorityQueue<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\PriorityQueues\SortedPriorityQueue.cs,Add,The length of the statement  "			ComparisonBasedComparer<TElement> comparer = new ComparisonBasedComparer<TElement>(this.PriorityComparison) { FlipCompareResult = true }; " is 137.
Long Statement,SD.Tools.Algorithmia.Sorting,SelectionSorter,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Sorting\SelectionSorter.cs,Sort,The length of the statement  "			// create a lambda which will produce the proper boolean value to use in our if statement based on the direction specified. " is 123.
Long Statement,SD.Tools.Algorithmia.Sorting,ShellSorter,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Sorting\ShellSorter.cs,Sort,The length of the statement  "			// create a lambda which will produce the proper boolean value to use in our if statement based on the direction specified. " is 123.
Long Statement,SD.Tools.Algorithmia.Sorting,SortingExtensionMethods,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Sorting\SortingExtensionMethods.cs,Sort,The length of the statement  "				throw new IndexOutOfRangeException(string.Format("startIndex's value {0} is outside the list to sort' which has {1} values."' startIndexToUse' toSort.Count)); " is 158.
Long Statement,SD.Tools.Algorithmia.Sorting,SortingExtensionMethods,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Sorting\SortingExtensionMethods.cs,Sort,The length of the statement  "				throw new IndexOutOfRangeException(string.Format("endIndex's value {0} is outside the list to sort' which has {1} values."' endIndexToUse' toSort.Count)); " is 154.
Long Statement,SD.Tools.Algorithmia.UtilityClasses,GeneralUtils,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\UtilityClasses\GeneralUtils.cs,ValuesAreEqual,The length of the statement  "			if(value1 == null)		// test on value1' if value1 is null at this spot' value2 also has to be null' otherwise we'd have been caught by the previous expression. " is 158.
Long Statement,SD.Tools.Algorithmia.UtilityClasses,GeneralUtils,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\UtilityClasses\GeneralUtils.cs,CheckArraysAreEqual,The length of the statement  "			if(arr1 == null)	// test on arr1' if arr1 is null at this spot' arr2 also has to be null' otherwise we'd have been caught by the previous expression. " is 149.
Complex Conditional,SD.Tools.Algorithmia.UtilityClasses,GeneralUtils,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\UtilityClasses\GeneralUtils.cs,ValuesAreEqual,The conditional expression  "((value1 == null) && (value2 != null)) || ((value1 != null) && (value2 == null))"  is complex.
Complex Conditional,SD.Tools.Algorithmia.UtilityClasses,GeneralUtils,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\UtilityClasses\GeneralUtils.cs,CheckArraysAreEqual,The conditional expression  "((arr1 == null) && (arr2 != null)) || ((arr1 != null) && (arr2 == null))"  is complex.
Empty Catch Block,SD.Tools.Algorithmia.GeneralDataStructures,MultiValueDictionary<TKey;TValue>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\GeneralDataStructures\MultiValueDictionary.cs,MultiValueDictionary,The method has an empty catch block.
Magic Number,SD.Tools.Algorithmia.GeneralDataStructures,CallLimiter,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\GeneralDataStructures\CallLimiter.cs,Call,The following statement contains a magic number: return Call(toCall' 500.0' null);
Magic Number,SD.Tools.Algorithmia.GeneralDataStructures,CallLimiter,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\GeneralDataStructures\CallLimiter.cs,Call,The following statement contains a magic number: _timer.Interval = Math.Max(100.0' intervalMS);
Magic Number,SD.Tools.Algorithmia.GeneralDataStructures,EventThrottler<TElement;TEventArgs>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\GeneralDataStructures\EventThrottler.cs,EventThrottler,The following statement contains a magic number: intervalToUse = 500.0;
Magic Number,SD.Tools.Algorithmia.GeneralDataStructures,EventThrottler<TElement;TEventArgs>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\GeneralDataStructures\EventThrottler.cs,EventThrottler,The following statement contains a magic number: intervalToUse<100.0
Magic Number,SD.Tools.Algorithmia.Heaps,BinaryHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\BinaryHeap.cs,FindIndexOfElement,The following statement contains a magic number: int indexLeftChild = (2 * index) + 1;
Magic Number,SD.Tools.Algorithmia.Heaps,BinaryHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\BinaryHeap.cs,FindIndexOfElement,The following statement contains a magic number: int indexRightChild = (2 * index) + 2;
Magic Number,SD.Tools.Algorithmia.Heaps,BinaryHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\BinaryHeap.cs,FindIndexOfElement,The following statement contains a magic number: int indexRightChild = (2 * index) + 2;
Magic Number,SD.Tools.Algorithmia.Heaps,BinaryHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\BinaryHeap.cs,Upheap,The following statement contains a magic number: int parentIndex = (index - 1) / 2;
Magic Number,SD.Tools.Algorithmia.Heaps,BinaryHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\BinaryHeap.cs,Downheap,The following statement contains a magic number: int indexLeftChild = (2 * index) + 1;
Magic Number,SD.Tools.Algorithmia.Heaps,BinaryHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\BinaryHeap.cs,Downheap,The following statement contains a magic number: int indexRightChild = (2 * index) + 2;
Magic Number,SD.Tools.Algorithmia.Heaps,BinaryHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\BinaryHeap.cs,Downheap,The following statement contains a magic number: int indexRightChild = (2 * index) + 2;
Magic Number,SD.Tools.Algorithmia.Heaps,BinaryHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\BinaryHeap.cs,RemoveAt,The following statement contains a magic number: switch(_elements.Count)  			{  				case 0:  					return;  				case 1:  				case 2:  					// simply remove the element  					_elements.RemoveAt(index);  					return;  				default:  					// swap element at index and last element' then remove last element (which is the element to remove)  					_elements.SwapValues(index' _elements.Count - 1);  					_elements.RemoveAt(_elements.Count - 1);  					// now simply downheap the element at index specified. Downheap will take care of the rest. We need a downheap because the element  					// we swapped into the 'index' location is always a child of the elements which are potentially higher up the tree. We now only have  					// to take care of the fact if the element now located at 'index' is at the right place or should be a child of one of its new children'   					// something which is been taken care of by Downheap(index).  					Downheap(index);  					break;  			}
Magic Number,SD.Tools.Algorithmia.Heaps,FibonacciHeap<TElement>,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Heaps\FibonacciHeap.cs,ConsolidateTrees,The following statement contains a magic number: _trees.Count < 2
Magic Number,SD.Tools.Algorithmia.Sorting,ShellSorter,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Sorting\ShellSorter.cs,Sort,The following statement contains a magic number: int[] increments = new[]{ 1391376' 463792' 198768' 86961' 33936' 13776' 4592' 1968' 861' 336'	112' 48' 21' 7' 3' 1 };
Magic Number,SD.Tools.Algorithmia.Sorting,ShellSorter,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Sorting\ShellSorter.cs,Sort,The following statement contains a magic number: int[] increments = new[]{ 1391376' 463792' 198768' 86961' 33936' 13776' 4592' 1968' 861' 336'	112' 48' 21' 7' 3' 1 };
Magic Number,SD.Tools.Algorithmia.Sorting,ShellSorter,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Sorting\ShellSorter.cs,Sort,The following statement contains a magic number: int[] increments = new[]{ 1391376' 463792' 198768' 86961' 33936' 13776' 4592' 1968' 861' 336'	112' 48' 21' 7' 3' 1 };
Magic Number,SD.Tools.Algorithmia.Sorting,ShellSorter,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Sorting\ShellSorter.cs,Sort,The following statement contains a magic number: int[] increments = new[]{ 1391376' 463792' 198768' 86961' 33936' 13776' 4592' 1968' 861' 336'	112' 48' 21' 7' 3' 1 };
Magic Number,SD.Tools.Algorithmia.Sorting,ShellSorter,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Sorting\ShellSorter.cs,Sort,The following statement contains a magic number: int[] increments = new[]{ 1391376' 463792' 198768' 86961' 33936' 13776' 4592' 1968' 861' 336'	112' 48' 21' 7' 3' 1 };
Magic Number,SD.Tools.Algorithmia.Sorting,ShellSorter,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Sorting\ShellSorter.cs,Sort,The following statement contains a magic number: int[] increments = new[]{ 1391376' 463792' 198768' 86961' 33936' 13776' 4592' 1968' 861' 336'	112' 48' 21' 7' 3' 1 };
Magic Number,SD.Tools.Algorithmia.Sorting,ShellSorter,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Sorting\ShellSorter.cs,Sort,The following statement contains a magic number: int[] increments = new[]{ 1391376' 463792' 198768' 86961' 33936' 13776' 4592' 1968' 861' 336'	112' 48' 21' 7' 3' 1 };
Magic Number,SD.Tools.Algorithmia.Sorting,ShellSorter,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Sorting\ShellSorter.cs,Sort,The following statement contains a magic number: int[] increments = new[]{ 1391376' 463792' 198768' 86961' 33936' 13776' 4592' 1968' 861' 336'	112' 48' 21' 7' 3' 1 };
Magic Number,SD.Tools.Algorithmia.Sorting,ShellSorter,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Sorting\ShellSorter.cs,Sort,The following statement contains a magic number: int[] increments = new[]{ 1391376' 463792' 198768' 86961' 33936' 13776' 4592' 1968' 861' 336'	112' 48' 21' 7' 3' 1 };
Magic Number,SD.Tools.Algorithmia.Sorting,ShellSorter,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Sorting\ShellSorter.cs,Sort,The following statement contains a magic number: int[] increments = new[]{ 1391376' 463792' 198768' 86961' 33936' 13776' 4592' 1968' 861' 336'	112' 48' 21' 7' 3' 1 };
Magic Number,SD.Tools.Algorithmia.Sorting,ShellSorter,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Sorting\ShellSorter.cs,Sort,The following statement contains a magic number: int[] increments = new[]{ 1391376' 463792' 198768' 86961' 33936' 13776' 4592' 1968' 861' 336'	112' 48' 21' 7' 3' 1 };
Magic Number,SD.Tools.Algorithmia.Sorting,ShellSorter,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Sorting\ShellSorter.cs,Sort,The following statement contains a magic number: int[] increments = new[]{ 1391376' 463792' 198768' 86961' 33936' 13776' 4592' 1968' 861' 336'	112' 48' 21' 7' 3' 1 };
Magic Number,SD.Tools.Algorithmia.Sorting,ShellSorter,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Sorting\ShellSorter.cs,Sort,The following statement contains a magic number: int[] increments = new[]{ 1391376' 463792' 198768' 86961' 33936' 13776' 4592' 1968' 861' 336'	112' 48' 21' 7' 3' 1 };
Magic Number,SD.Tools.Algorithmia.Sorting,ShellSorter,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Sorting\ShellSorter.cs,Sort,The following statement contains a magic number: int[] increments = new[]{ 1391376' 463792' 198768' 86961' 33936' 13776' 4592' 1968' 861' 336'	112' 48' 21' 7' 3' 1 };
Magic Number,SD.Tools.Algorithmia.Sorting,ShellSorter,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Sorting\ShellSorter.cs,Sort,The following statement contains a magic number: int[] increments = new[]{ 1391376' 463792' 198768' 86961' 33936' 13776' 4592' 1968' 861' 336'	112' 48' 21' 7' 3' 1 };
Missing Default,SD.Tools.Algorithmia.Sorting,SortAlgorithmFactory,D:\research\architectureSmells\repos1\SolutionsDesign_Algorithmia\SD.Tools.Algorithmia\Sorting\SortAlgorithmFactory.cs,CreateSortAlgorithmImplementation,The following switch statement is missing a default case: switch(algorithm)  			{  				case SortAlgorithm.SelectionSort:  					toReturn = new SelectionSorter();  					break;  				case SortAlgorithm.ShellSort:  					toReturn = new ShellSorter();  					break;  				case SortAlgorithm.QuickSort:  					toReturn = new QuickSorter();  					break;  			}
