Implementation smell,Namespace,Class,File,Method,Description
Long Method,DelegateDecompiler,Processor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\Processor.cs,Process,The method has 641 lines of code.
Long Method,DelegateDecompiler,Processor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\Processor.cs,BuildMethodCallExpression,The method has 108 lines of code.
Complex Method,DelegateDecompiler,OptimizeExpressionVisitor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\OptimizeExpressionVisitor.cs,VisitConditional,Cyclomatic complexity of the method is 15
Complex Method,DelegateDecompiler,OptimizeExpressionVisitor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\OptimizeExpressionVisitor.cs,TryConvert,Cyclomatic complexity of the method is 8
Complex Method,DelegateDecompiler,OptimizeExpressionVisitor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\OptimizeExpressionVisitor.cs,VisitBinary,Cyclomatic complexity of the method is 10
Complex Method,DelegateDecompiler,Processor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\Processor.cs,Process,Cyclomatic complexity of the method is 116
Complex Method,DelegateDecompiler,Processor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\Processor.cs,AdjustType,Cyclomatic complexity of the method is 15
Complex Method,DelegateDecompiler,Processor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\Processor.cs,BuildMethodCallExpression,Cyclomatic complexity of the method is 22
Complex Method,DelegateDecompiler,Processor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\Processor.cs,TryParseOperator,Cyclomatic complexity of the method is 24
Long Parameter List,DelegateDecompiler,OptimizeExpressionVisitor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\OptimizeExpressionVisitor.cs,TryConvert,The method has 5 parameters. Parameters: constant' left' right' result' isLeft
Long Parameter List,DelegateDecompiler,ProcessorState,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\Processor.cs,ProcessorState,The method has 6 parameters. Parameters: stack' locals' args' instruction' last' delegates
Long Identifier,DelegateDecompiler,DecompiledQueryProvider,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\DecompiledQueryProvider.cs,CreateQuery,The length of the parameter closedGenericCreateQueryMethod is 30.
Long Identifier,DelegateDecompiler,Processor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\Processor.cs,,The length of the parameter cachedAnonymousMethodDelegateRoslyn is 35.
Long Statement,DelegateDecompiler,Configuration,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\Configuration.cs,RegisterDecompileableMember,The length of the statement  "            throw new NotImplementedException("The method RegisterDecompileableMember of Configuration is not implemented. Please implement it in your custom configuration class."); " is 169.
Long Statement,DelegateDecompiler,DecompileExpressionVisitor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\DecompileExpressionVisitor.cs,VisitMethodCall,The length of the statement  "            if (node.Method.IsGenericMethod && node.Method.GetGenericMethodDefinition() == typeof (ComputedExtension).GetMethod("Computed"' BindingFlags.Static | BindingFlags.Public)) " is 171.
Long Statement,DelegateDecompiler,OptimizeExpressionVisitor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\OptimizeExpressionVisitor.cs,TryConvertOrElse,The length of the statement  "            if (hasValue.NodeType == ExpressionType.Not && TryConvert1(((UnaryExpression) hasValue).Operand' getValueOrDefault' out result)) " is 128.
Long Statement,DelegateDecompiler,OptimizeExpressionVisitor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\OptimizeExpressionVisitor.cs,TryConvert1,The length of the statement  "                result = Expression.MakeBinary(getValueOrDefault.NodeType' ConvertToNullable(expression)' ConvertToNullable(getValueOrDefault.Right)); " is 134.
Long Statement,DelegateDecompiler,OptimizeExpressionVisitor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\OptimizeExpressionVisitor.cs,TryConvert1,The length of the statement  "                result = Expression.MakeBinary(getValueOrDefault.NodeType' ConvertToNullable(getValueOrDefault.Left)' ConvertToNullable(expression)); " is 133.
Long Statement,DelegateDecompiler,OptimizeExpressionVisitor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\OptimizeExpressionVisitor.cs,IsHasValue,The length of the statement  "            return property != null && property.Member.Name == "HasValue" && property.Expression != null && IsNullable(property.Expression.Type); " is 133.
Long Statement,DelegateDecompiler,Processor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\Processor.cs,Process,The length of the statement  "                    else if (state.Instruction.OpCode == OpCodes.Ldarg_S || state.Instruction.OpCode == OpCodes.Ldarg || state.Instruction.OpCode == OpCodes.Ldarga || state.Instruction.OpCode == OpCodes.Ldarga_S) " is 192.
Long Statement,DelegateDecompiler,Processor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\Processor.cs,Process,The length of the statement  "                            state.Instruction = ConditionalBranch(state' val => val.Type == typeof(bool) ? val : Expression.NotEqual(val' ExpressionHelper.Default(val.Type))); " is 147.
Long Statement,DelegateDecompiler,Processor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\Processor.cs,IsCachedAnonymousMethodDelegate,The length of the statement  "            return field.Name.StartsWith(cachedAnonymousMethodDelegate) && Attribute.IsDefined(field' typeof (CompilerGeneratedAttribute)' false) || " is 136.
Long Statement,DelegateDecompiler,Processor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\Processor.cs,IsCachedAnonymousMethodDelegate,The length of the statement  "                   field.Name.StartsWith(cachedAnonymousMethodDelegateRoslyn) && field.DeclaringType != null && Attribute.IsDefined(field.DeclaringType' typeof (CompilerGeneratedAttribute)' false); " is 178.
Long Statement,DelegateDecompiler,Processor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\Processor.cs,AdjustType,The length of the statement  "            if (!type.IsAssignableFrom(expression.Type) && expression.Type.IsEnum && expression.Type.GetEnumUnderlyingType() == type) " is 121.
Complex Conditional,DelegateDecompiler,OptimizeExpressionVisitor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\OptimizeExpressionVisitor.cs,TryConvert,The conditional expression  "left.NodeType == ExpressionType.Equal ||                          left.NodeType == ExpressionType.NotEqual ||                          left.NodeType == ExpressionType.GreaterThan ||                          left.NodeType == ExpressionType.GreaterThanOrEqual ||                          left.NodeType == ExpressionType.LessThan ||                          left.NodeType == ExpressionType.LessThanOrEqual"  is complex.
Complex Conditional,DelegateDecompiler,OptimizeExpressionVisitor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\OptimizeExpressionVisitor.cs,VisitBinary,The conditional expression  "rightConstant.Value as int? == 0 &&                      left is MethodCallExpression expression &&                      expression.Method.Name == "Compare" &&                      expression.Method.IsStatic &&                      expression.Method.DeclaringType == typeof(decimal)"  is complex.
Complex Conditional,DelegateDecompiler,Processor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\Processor.cs,Process,The conditional expression  "state.Instruction.OpCode == OpCodes.Ldarg_S || state.Instruction.OpCode == OpCodes.Ldarg || state.Instruction.OpCode == OpCodes.Ldarga || state.Instruction.OpCode == OpCodes.Ldarga_S"  is complex.
Complex Conditional,DelegateDecompiler,Processor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\Processor.cs,Process,The conditional expression  "state.Instruction.OpCode == OpCodes.Ldelem ||                               state.Instruction.OpCode == OpCodes.Ldelem_I ||                               state.Instruction.OpCode == OpCodes.Ldelem_I1 ||                               state.Instruction.OpCode == OpCodes.Ldelem_I2 ||                               state.Instruction.OpCode == OpCodes.Ldelem_I4 ||                               state.Instruction.OpCode == OpCodes.Ldelem_I8 ||                               state.Instruction.OpCode == OpCodes.Ldelem_U1 ||                               state.Instruction.OpCode == OpCodes.Ldelem_U2 ||                               state.Instruction.OpCode == OpCodes.Ldelem_U4 ||                               state.Instruction.OpCode == OpCodes.Ldelem_R4 ||                               state.Instruction.OpCode == OpCodes.Ldelem_R8 ||                               state.Instruction.OpCode == OpCodes.Ldelem_Ref"  is complex.
Complex Conditional,DelegateDecompiler,Processor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\Processor.cs,Process,The conditional expression  "state.Instruction.OpCode == OpCodes.Stelem ||                               state.Instruction.OpCode == OpCodes.Stelem_I ||                               state.Instruction.OpCode == OpCodes.Stelem_I1 ||                               state.Instruction.OpCode == OpCodes.Stelem_I2 ||                               state.Instruction.OpCode == OpCodes.Stelem_I4 ||                               state.Instruction.OpCode == OpCodes.Stelem_I8 ||                               state.Instruction.OpCode == OpCodes.Stelem_R4 ||                               state.Instruction.OpCode == OpCodes.Stelem_R8 ||                               state.Instruction.OpCode == OpCodes.Stelem_Ref"  is complex.
Complex Conditional,DelegateDecompiler,Processor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\Processor.cs,Process,The conditional expression  "state.Instruction.OpCode == OpCodes.Ldloc ||                               state.Instruction.OpCode == OpCodes.Ldloc_S ||                               state.Instruction.OpCode == OpCodes.Ldloca ||                                state.Instruction.OpCode == OpCodes.Ldloca_S"  is complex.
Complex Conditional,DelegateDecompiler,Processor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\Processor.cs,Process,The conditional expression  "state.Instruction.OpCode == OpCodes.Bgt ||                               state.Instruction.OpCode == OpCodes.Bgt_S ||                               state.Instruction.OpCode == OpCodes.Bgt_Un ||                               state.Instruction.OpCode == OpCodes.Bgt_Un_S"  is complex.
Complex Conditional,DelegateDecompiler,Processor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\Processor.cs,Process,The conditional expression  "state.Instruction.OpCode == OpCodes.Bge ||                               state.Instruction.OpCode == OpCodes.Bge_S ||                               state.Instruction.OpCode == OpCodes.Bge_Un ||                               state.Instruction.OpCode == OpCodes.Bge_Un_S"  is complex.
Complex Conditional,DelegateDecompiler,Processor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\Processor.cs,Process,The conditional expression  "state.Instruction.OpCode == OpCodes.Blt ||                               state.Instruction.OpCode == OpCodes.Blt_S ||                               state.Instruction.OpCode == OpCodes.Blt_Un ||                               state.Instruction.OpCode == OpCodes.Blt_Un_S"  is complex.
Complex Conditional,DelegateDecompiler,Processor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\Processor.cs,Process,The conditional expression  "state.Instruction.OpCode == OpCodes.Ble ||                               state.Instruction.OpCode == OpCodes.Ble_S ||                               state.Instruction.OpCode == OpCodes.Ble_Un ||                               state.Instruction.OpCode == OpCodes.Ble_Un_S"  is complex.
Complex Conditional,DelegateDecompiler,Processor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\Processor.cs,Process,The conditional expression  "state.Instruction.Next != null && state.Instruction.Next.OpCode == OpCodes.Ldnull &&                              state.Instruction.Next.Next != null && state.Instruction.Next.Next.OpCode == OpCodes.Cgt_Un"  is complex.
Complex Conditional,DelegateDecompiler,TransparentIdentifierRemovingExpressionVisitor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\TransparentIdentifierRemovingExpressionVisitor.cs,Match,The conditional expression  "propertyInfo != null && methodInfo != null && propertyInfo.CanRead && methodInfo == propertyInfo.GetGetMethod()"  is complex.
Magic Number,DelegateDecompiler,Processor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\Processor.cs,BuildMethodCallExpression,The following statement contains a magic number: switch (arguments.Length)                          {                              case 1:                                  return Expression.MakeUnary(type' arguments[0]' arguments[0].Type);                              case 2:                                  return Expression.MakeBinary(type' arguments[0]' arguments[1]);                          }
Magic Number,DelegateDecompiler,Processor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\Processor.cs,TryParseOperator,The following statement contains a magic number: return Enum.TryParse(m.Name.Substring(3)' out type);
Missing Default,DelegateDecompiler,OptimizeExpressionVisitor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\OptimizeExpressionVisitor.cs,VisitBinary,The following switch statement is missing a default case: switch (node.NodeType)                      {                          case ExpressionType.Equal:                              if (left is BinaryExpression binaryExpression && Invert(ref binaryExpression))                                  return binaryExpression;                              return Expression.Not(left);                          case ExpressionType.NotEqual:                              return left;                      }
Missing Default,DelegateDecompiler,OptimizeExpressionVisitor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\OptimizeExpressionVisitor.cs,Invert,The following switch statement is missing a default case: switch (expression.NodeType)              {                  case ExpressionType.Equal:                  {                      expression = Expression.NotEqual(expression.Left' expression.Right);                      return true;                  }                  case ExpressionType.NotEqual:                  {                      expression = Expression.Equal(expression.Left' expression.Right);                      return true;                  }                  case ExpressionType.LessThan:                  {                      expression = Expression.GreaterThanOrEqual(expression.Left' expression.Right);                      return true;                  }                  case ExpressionType.LessThanOrEqual:                  {                      expression = Expression.GreaterThan(expression.Left' expression.Right);                      return true;                  }                  case ExpressionType.GreaterThan:                  {                      expression = Expression.LessThanOrEqual(expression.Left' expression.Right);                      return true;                  }                  case ExpressionType.GreaterThanOrEqual:                  {                      expression = Expression.LessThan(expression.Left' expression.Right);                      return true;                  }              }
Missing Default,DelegateDecompiler,Processor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\Processor.cs,BuildMethodCallExpression,The following switch statement is missing a default case: switch (arguments.Length)                          {                              case 1:                                  return Expression.MakeUnary(type' arguments[0]' arguments[0].Type);                              case 2:                                  return Expression.MakeBinary(type' arguments[0]' arguments[1]);                          }
Missing Default,DelegateDecompiler,Processor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\Processor.cs,BuildMethodCallExpression,The following switch statement is missing a default case: switch (m.Name)                          {                              case "op_Increment":                                  return Expression.Add(arguments[0]' Expression.Constant(Convert.ChangeType(1' arguments[0].Type)));                              case "op_Decrement":                                  return Expression.Subtract(arguments[0]' Expression.Constant(Convert.ChangeType(1' arguments[0].Type)));                              case "op_Implicit":                                  return Expression.Convert(arguments[0]' m.ReturnType' m);                          }
Missing Default,DelegateDecompiler,Processor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\Processor.cs,BuildMethodCallExpression,The following switch statement is missing a default case: switch (m.Name)                  {                      case "Add":                          return Expression.MakeBinary(ExpressionType.Add' arguments[0]' arguments[1]);                      case "Subtract":                          return Expression.MakeBinary(ExpressionType.Subtract' arguments[0]' arguments[1]);                      case "Multiply":                          return Expression.MakeBinary(ExpressionType.Multiply' arguments[0]' arguments[1]);                      case "Divide":                          return Expression.MakeBinary(ExpressionType.Divide' arguments[0]' arguments[1]);                  }
Missing Default,DelegateDecompiler,Processor,D:\research\architectureSmells\repos\hazzik_DelegateDecompiler\src\DelegateDecompiler\Processor.cs,TryParseOperator,The following switch statement is missing a default case: switch (m.Name)              {                  /* The complete set of binary operator function names used is as follows:                    * op_Addition' op_Subtraction' op_Multiply' op_Division' op_Modulus'                    * op_BitwiseAnd' op_BitwiseOr' op_ExclusiveOr' op_LeftShift' op_RightShift'                    * op_Equality' op_Inequality' op_LessThan' op_LessThanOrEqual' op_GreaterThan'                    * and op_GreaterThanOrEqual.                   */                   case "op_Addition":                      type = ExpressionType.Add;                      return true;                    case "op_Subtraction":                      type = ExpressionType.Subtract;                      return true;                    case "op_Multiply":                      type = ExpressionType.Multiply;                      return true;                    case "op_Division":                      type = ExpressionType.Divide;                      return true;                    case "op_Modulus":                      type = ExpressionType.Modulo;                      return true;                    case "op_BitwiseAnd":                      type = ExpressionType.And;                      return true;                    case "op_BitwiseOr":                      type = ExpressionType.Or;                      return true;                                    case "op_ExclusiveOr":                      type = ExpressionType.ExclusiveOr;                      return true;                    case "op_LeftShift":                      type = ExpressionType.LeftShift;                      return true;                    case "op_RightShift":                      type = ExpressionType.RightShift;                      return true;                                    case "op_Equality":                      type = ExpressionType.Equal;                      return true;                                    case "op_Inequality":                      type = ExpressionType.NotEqual;                      return true;                    case "op_LessThan":                      type = ExpressionType.LessThan;                      return true;                    case "op_LessThanOrEqual":                      type = ExpressionType.LessThanOrEqual;                      return true;                    case "op_GreaterThan":                      type = ExpressionType.GreaterThan;                      return true;                    case "op_GreaterThanOrEqual":                      type = ExpressionType.GreaterThanOrEqual;                      return true;                    /*                   * The complete set of unary operator function names used is as follows:                    * op_UnaryPlus' op_UnaryNegation' op_LogicalNot' op_OnesComplement' op_Increment' op_Decrement' op_True' and op_False.                   */                  case "op_UnaryPlus":                      type = ExpressionType.UnaryPlus;                      return true;                    case "op_UnaryNegation":                      type = ExpressionType.Negate;                      return true;                    case "op_LogicalNot":                      type = ExpressionType.Not;                      return true;                    case "op_OnesComplement":                      type = ExpressionType.OnesComplement;                      return true;                    case "op_Increment":                      type = default(ExpressionType);                      return false;                    case "op_Decrement":                      type = default(ExpressionType);                      return false;                    case "op_True":                      type = default(ExpressionType);                      return false;                    case "op_False":                      type = default(ExpressionType);                      return false;              }
